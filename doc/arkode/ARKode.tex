% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}

\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\floatname{literal-block}{Listing }


\usepackage{amsfonts}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MANUALLY ADDED/EDITED
\newcommand{\disclaimer}{%
\thispagestyle{empty}% no number of this page
\vglue5\baselineskip
\begin{center}
{\bf DISCLAIMER}
\end{center}
\noindent
This document was prepared as an account of work sponsored by an agency of 
the United States government. Neither the United States government nor 
Lawrence Livermore National Security, LLC, nor Southern Methodist
University, nor any of their employees makes any warranty, expressed
or implied, or assumes any legal liability or responsibility for the
accuracy, completeness, or usefulness of any information, apparatus,
product, or process disclosed, or represents that its use would not
infringe privately owned rights.  Reference herein to any specific
commercial product, process, or service by trade name, trademark,
manufacturer, or otherwise does not necessarily constitute or imply
its endorsement, recommendation, or favoring by the United States
government, Lawrence Livermore National Security, LLC, or Southern
Methodist University. The views and opinions of authors expressed
herein do not necessarily state or reflect those of the United States
government, Lawrence Livermore National Security, LLC, or Southern
Methodist University, and shall not be used for advertising or product
endorsement purposes.

\vskip2\baselineskip
\vfill
\begin{center}
Approved for public release; further dissemination unlimited
\end{center}
\clearpage
}

\title{User Documentation for ARKode v2.1.2\\
       (SUNDIALS v3.1.2)}
\author{
  Daniel R. Reynolds$^1$, David J. Gardner$^2$, \\
  Alan C. Hindmarsh$^2$, Carol S. Woodward$^2$ \\
  and Jean M. Sexton$^1$, \\\\
  {\em $^1$Department of Mathematics}\\
  {\em Southern Methodist University} \\\\
  {\em $^2$Center for Applied Scientific Computing}\\
  {\em Lawrence Livermore National Laboratory}
}
\date{
  \today
  \vfill
  {\centerline{\includegraphics[width=0.45\textwidth]{doc_logo_blue.pdf}}}
  \vfill
  {\centerline{LLNL-SM-668082}}
}

\newcommand{\sphinxlogo}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% MANUALLY ADDED/EDITED
\disclaimer
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\phantomsection\label{index::doc}


This is the documentation for ARKode, an adaptive step time
integration package for stiff, nonstiff and mixed stiff/nonstiff
systems of ordinary differential equations (ODEs).
The ARKode solver is a component of the \href{https://computation.llnl.gov/casc/sundials/main.html}{SUNDIALS} suite of
nonlinear and differential/algebraic equation solvers. It is designed
to have a similar user experience to the \href{https://computation.llnl.gov/casc/sundials/description/description.html\#descr\_cvode}{CVODE}
solver, including user modes to allow adaptive integration to specified
output times, return after each internal step and root-finding
capabilities, and for calculations in serial and using either
shared-memory parallelism (via OpenMP or Pthreads) or
distributed-memory parallelism (via MPI). The default integration and
solver options should apply to most users, though complete control
over all internal parameters and time adaptivity algorithms is enabled
through optional interface routines.

ARKode is written in C, with C++ and Fortran interfaces.

Due to its similarities in both function and design with the CVODE
package, this documentation is highly similar with the corresponding
CVODE user guide \phantomsection\label{index:id1}{\hyperref[References:hs2017]{\emph{{[}HS2017{]}}}}.

ARKode is developed by \href{http://www.smu.edu}{Southern Methodist University}, with support by the \href{http://www.doe.gov}{US Department of Energy} through the \href{http://www.fastmath-scidac.org/}{FASTMath} SciDAC Institute, under subcontract
B598130 from \href{http://www.llnl.gov}{Lawrence Livermore National Laboratory}.


\chapter{Introduction}
\label{Introduction:introduction}\label{Introduction:id1}\label{Introduction::doc}\label{Introduction:arkode-documentation}
The ARKode solver library provides an adaptive-step time integration
package for stiff, nonstiff and mixed stiff/nonstiff systems of
ordinary differential equations (ODEs) given in explicit form
\phantomsection\label{Introduction:equation-ODE}\begin{gather}
\begin{split}M \dot{y} = f_E(t,y) + f_I(t,y),  \qquad y(t_0) = y_0,\end{split}\label{Introduction-ODE}
\end{gather}
where \(t\) is the independent variable, \(y\) is the set of
dependent variables (in \(\mathbb{R}^N\)), \(M\) is a
user-specified, nonsingular operator from \(\mathbb{R}^N\) to
\(\mathbb{R}^N\) (possibly time dependent, but independent of
\(y\)), and the right-hand side function is partitioned into two
components:
\begin{itemize}
\item {} 
\(f_E(t,y)\) contains the ``slow'' time scale components to be
integrated explicitly, and

\item {} 
\(f_I(t,y)\)  contains the ``fast'' time scale components to be
integrated implicitly.

\end{itemize}

Either of these operators may be disabled, allowing for fully
explicit, fully implicit, or combination implicit-explicit (ImEx) time
integration.

The methods used in ARKode are adaptive-step additive Runge Kutta
methods. Such methods are defined through combining two complementary
Runge-Kutta methods: one explicit (ERK) and the other diagonally
implicit (DIRK). Through appropriately partitioning the ODE system
into explicit and implicit components \eqref{Introduction-ODE}, such methods have the
potential to enable accurate and efficient time integration of mixed
stiff/nonstiff systems of ordinary differential equations.  A key
feature allowing for high efficiency of these methods is that only the
components in \(f_I(t,y)\) must be solved implicitly, allowing for
splittings tuned for use with optimal implicit solvers.

This framework allows for significant freedom over the constitutive
methods used for each component, and ARKode is packaged with a wide
array of built-in methods for use.  These built-in Butcher tables
include adaptive explicit methods of orders 2-8, adaptive implicit
methods of orders 2-5, and adaptive ImEx methods of orders 3-5.

For problems that include nonzero implicit term \(f_I(t,y)\), the
resulting implicit system (assumed nonlinear, unless specified
otherwise) is solved approximately at each integration step, using a
Newton method, modified Newton method, an Inexact Newton method, or an
accelerated fixed-point solver.  For the Newton-based methods and the
serial or threaded NVECTOR modules in SUNDIALS, ARKode may use a
variety of linear solvers provided with SUNDIALS, including both
direct (dense, band, or sparse) and preconditioned Krylov iterative
(GMRES \phantomsection\label{Introduction:id2}{\hyperref[References:ss1986]{\emph{{[}SS1986{]}}}}, BiCGStab \phantomsection\label{Introduction:id3}{\hyperref[References:v1992]{\emph{{[}V1992{]}}}}, TFQMR \phantomsection\label{Introduction:id4}{\hyperref[References:f1993]{\emph{{[}F1993{]}}}}, FGMRES \phantomsection\label{Introduction:id5}{\hyperref[References:s1993]{\emph{{[}S1993{]}}}},
or PCG \phantomsection\label{Introduction:id6}{\hyperref[References:hs1952]{\emph{{[}HS1952{]}}}}) linear solvers.  When used with one of the
distributed parallel NVECTOR modules, including PETSc and \emph{hypre}
vectors, or a user-provided vector data structure, only the Krylov
solvers are available, although a user may supply their own linear
solver for any data structures if desired.  For the serial or threaded
vector structures, there is a banded preconditioner module called
ARKBANDPRE for use with the Krylov solvers, while for the distributed
memory parallel vector structure there is a preconditioner module
called ARKBBDPRE which provides a band-block-diagonal preconditioner.
Additionally, a user may supply more optimal, problem-specific
preconditioner routines.


\section{Changes from previous versions}
\label{Introduction:changes-from-previous-versions}

\subsection{Changes in v2.1.2}
\label{Introduction:changes-in-v2-1-2}

Fixed Windows specific problem where sunindextype was not correctly 
defined when using 64-bit integers for the SUNDIALS index type. On Windows
sunindextype is now defined as the MSVC basic type \texttt{\_\_int64}.

Changed LICENSE install path to \texttt{instdir/include/sundials}.

Updated the minimum required version of CMake to 2.8.12 and enabled
using rpath by default to locate shared libraries on OSX.

Added sparse SUNMatrix ``Reallocate'' routine to allow specification of
the nonzero storage.

Updated the KLU SUNLinearSolver module to set constants for the two
reinitialization types, and fixed a bug in the full reinitialization
approach where the sparse SUNMatrix pointer would go out of scope on
some architectures.


Updated the ``ScaleAdd'' and ``ScaleAddI'' implementations in the
sparse SUNMatrix module to more optimally handle the case where the
target matrix contained sufficient storage for the sum, but had the
wrong sparsity pattern.  The sum now occurs in-place, by performing
the sum backwards in the existing storage.  However, it is still more
efficient if the user-supplied Jacobian routine allocates storage for
the sum $I+\gamma J$ or $M+\gamma J$ manually (with zero entries if
needed).


\subsection{Changes in v2.1.1}
\label{Introduction:changes-in-v2-1-1}
Fixed a potential memory leak in the SPGMR and SPFGMR linear solvers:
if ``Initialize'' was called multiple times then the solver memory was
reallocated (without being freed).

Fixed a minor bug in the ARKReInit routine, where a flag was
incorrectly set to indicate that the problem had been resized (instead
of just re-initialized).

Fixed C++11 compiler errors/warnings about incompatible use of string
literals. 

Updated KLU SUNLinearSolver module to use a \texttt{typedef} for the
precision-specific solve function to be used (to avoid compiler 
warnings).  

Added missing typecasts for some \texttt{(void*)} pointers (again, to
avoid compiler warnings). 

Bugfix in \texttt{sunmatrix\_sparse.c} where we had used \texttt{int}
instead of \texttt{sunindextype} in one location.

Added missing \texttt{\#include <stdio.h>} in NVECTOR and SUNMATRIX
header files.

Added missing prototype for \texttt{ARKSpilsGetNumMTSetups}.

Fixed an indexing bug in the CUDA NVECTOR implementation of
\code{N\_VWrmsNormMask} and revised the RAJA NVECTOR implementation of
\code{N\_VWrmsNormMask} to work with mask arrays using values other than zero or
one. Replaced \code{double} with \code{realtype} in the RAJA vector test functions.

Fixed compilation issue with GCC 7.3.0 and Fortran programs that do
not require a SUNMatrix or SUNLinearSolver module (e.g. iterative
linear solvers, explicit methods, fixed point solver, etc.).

\subsection{Changes in v2.1.0}
\label{Introduction:changes-in-v2-1-0}

Added NVECTOR print functions that write vector data to a specified
file (e.g. \code{N\_VPrintFile\_Serial}).

Added \code{make test} and \code{make test\_install} options to the build
system for testing SUNDIALS after building with \code{make} and
installing with \code{make install} respectively.

\subsection{Changes in v2.0.0}
\label{Introduction:changes-in-v2-0-0}
All interfaces to matrix structures and linear solvers have been
reworked, and all example programs have been updated.  The goal of the
redesign of these interfaces was to provide more encapsulation and
ease in interfacing custom linear solvers and interoperability with
linear solver libraries.

Specific changes include:
\begin{itemize}
\item {} 
Added generic SUNMATRIX module with three provided implementations:
dense, banded and sparse.  These replicate previous SUNDIALS Dls and
Sls matrix structures in a single object-oriented API.

\item {} 
Added example problems demonstrating use of generic SUNMATRIX modules.

\item {} 
Added generic SUNLINEARSOLVER module with eleven provided
implementations: dense, banded, LAPACK dense, LAPACK band, KLU,
SuperLU\_MT, SPGMR, SPBCGS, SPTFQMR, SPFGMR, PCG.  These replicate
previous SUNDIALS generic linear solvers in a single object-oriented
API.

\item {} 
Added example problems demonstrating use of generic SUNLINEARSOLVER modules.

\item {} 
Expanded package-provided direct linear solver (Dls) interfaces and
scaled, preconditioned, iterative linear solver (Spils) interfaces
to utilize generic SUNMATRIX and SUNLINEARSOLVER objects.

\item {} 
Removed package-specific, linear solver-specific, solver modules
(e.g. CVDENSE, KINBAND, IDAKLU, ARKSPGMR) since their functionality
is entirely replicated by the generic Dls/Spils interfaces and
SUNLINEARSOLVER/SUNMATRIX modules.  The exception is CVDIAG, a
diagonal approximate Jacobian solver available to CVODE and CVODES.

\item {} 
Converted all SUNDIALS example problems to utilize new generic
SUNMATRIX and SUNLINEARSOLVER objects, along with updated Dls and
Spils linear solver interfaces.

\item {} 
Added Spils interface routines to ARKode, CVODE, CVODES, IDA and
IDAS to allow specification of a user-provided ``JTSetup'' routine.
This change supports users who wish to set up data structures for
the user-provided Jacobian-times-vector (``JTimes'') routine, and
where the cost of one JTSetup setup per Newton iteration can be
amortized between multiple JTimes calls.

\end{itemize}

Two additional NVECTOR implementations were added -- one for CUDA and
one for RAJA vectors.  These vectors are supplied to provide very
basic support for running on GPU architectures.  Users are advised
that these vectors both move all data to the GPU device upon
construction, and speedup will only be realized if the user also
conducts the right-hand-side function evaluation on the device. In
addition, these vectors assume the problem fits on one GPU. Further
information about RAJA, users are referred to th web site,
\href{https://software.llnl.gov/RAJA/}{https://software.llnl.gov/RAJA/}.
These additions are accompanied by additions to various interface
functions and to user documentation.

All indices for data structures were updated to a new \code{sunindextype}
that can be configured to be a 32- or 64-bit integer data index type.
\code{sunindextype} is defined to be \code{int32\_t} or \code{int64\_t} when
portable types are supported, otherwise it is defined as \code{int} or
\code{long int}. The Fortran interfaces continue to use \code{long int} for
indices, except for their sparse matrix interface that now uses the
new \code{sunindextype}.  This new flexible capability for index types
includes interfaces to PETSc, \emph{hypre}, SuperLU\_MT, and KLU with either
32-bit or 64-bit capabilities depending how the user configures
SUNDIALS.

To avoid potential namespace conflicts, the macros defining
\code{booleantype} values \code{TRUE} and \code{FALSE} have been changed to
\code{SUNTRUE} and \code{SUNFALSE} respectively.

Temporary vectors were removed from preconditioner setup and solve
routines for all packages.  It is assumed that all necessary data
for user-provided preconditioner operations will be allocated and
stored in user-provided data structures.

The file \code{include/sundials\_fconfig.h} was added.  This file contains
SUNDIALS type information for use in Fortran programs.

Added functions SUNDIALSGetVersion and SUNDIALSGetVersionNumber to get
SUNDIALS release version information at runtime.

The build system was expanded to support many of the xSDK-compliant keys.
The xSDK is a movement in scientific software to provide a foundation for the
rapid and efficient production of high-quality,
sustainable extreme-scale scientific applications.  More information can
be found at, \href{https://xsdk.info}{https://xsdk.info}.

In addition, numerous changes were made to the build system.
These include the addition of separate \code{BLAS\_ENABLE} and \code{BLAS\_LIBRARIES}
CMake variables, additional error checking during CMake configuration,
minor bug fixes, and renaming CMake options to enable/disable examples
for greater clarity and an added option to enable/disable Fortran 77 examples.
These changes included changing \code{ENABLE\_EXAMPLES} to \code{ENABLE\_EXAMPLES\_C},
changing \code{CXX\_ENABLE} to \code{EXAMPLES\_ENABLE\_CXX}, changing \code{F90\_ENABLE} to
\code{EXAMPLES\_ENABLE\_F90}, and adding an \code{EXAMPLES\_ENABLE\_F77} option.

Corrections and additions were made to the examples, to
installation-related files, and to the user documentation.


\subsection{Changes in v1.1.0}
\label{Introduction:changes-in-v1-1-0}
We have included numerous bugfixes and enhancements since the
v1.0.2 release.

The bugfixes include:
\begin{itemize}
\item {} 
For each linear solver, the various solver performance counters are
now initialized to 0 in both the solver specification function and
in the solver's \code{linit} function.  This ensures that these solver
counters are initialized upon linear solver instantiation as well as
at the beginning of the problem solution.

\item {} 
The choice of the method vs embedding the Billington and TRBDF2
explicit Runge-Kutta methods were swapped, since in those the
lower-order coefficients result in an A-stable method, while the
higher-order coefficients do not.  This change results in
significantly improved robustness when using those methods.

\item {} 
A bug was fixed for the situation where a user supplies a vector of
absolute tolerances, and also uses the vector Resize() functionality.

\item {} 
A bug was fixed wherein a user-supplied Butcher table without an
embedding is supplied, and the user is running with either fixed
time steps (or they do adaptivity manually); previously this had
resulted in an error since the embedding order was below 1.

\item {} 
Numerous aspects of the documentation were fixed and/or clarified.

\end{itemize}

The feature changes/enhancements include:
\begin{itemize}
\item {} 
Two additional NVECTOR implementations were added -- one for Hypre
(parallel) ParVector vectors, and one for PETSc vectors.  These
additions are accompanied by additions to various interface
functions and to user documentation.

\item {} 
Each NVECTOR module now includes a function, \code{N\_VGetVectorID},
that returns the NVECTOR module name.

\item {} 
A memory leak was fixed in the banded preconditioner and
banded-block-diagonal preconditioner interfaces.  In addition,
updates were done to return integers from linear solver and
preconditioner `free' routines.

\item {} 
The Krylov linear solver Bi-CGstab was enhanced by removing a
redundant dot product.  Various additions and corrections were made
to the interfaces to the sparse solvers KLU and SuperLU\_MT,
including support for CSR format when using KLU.

\item {} 
The ARKode implicit predictor algorithms were updated: methods 2 and
3 were improved slightly, a new predictor approach was added, and
the default choice was modified.

\item {} 
The underlying sparse matrix structure was enhanced to allow both
CSR and CSC matrices, with CSR supported by the KLU linear solver
interface.  ARKode interfaces to the KLU solver from both C and
Fortran were updated to enable selection of sparse matrix type, and a
Fortran-90 CSR example program was added.

\item {} 
The missing {\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMtimesEvals]{\emph{\code{ARKSpilsGetNumMtimesEvals()}}}} function was added
-- this had been included in the previous documentation but had not
been implemented.

\item {} 
The handling of integer codes for specifying built-in ARKode Butcher
tables was enhanced.  While a global numbering system is still used,
methods now have \#defined names to simplify the user interface and to
streamline incorporation of new Butcher tables into ARKode.

\item {} 
The maximum number of Butcher table stages was increased from 8 to
15 to accommodate very high order methods, and an 8th-order adaptive
ERK method was added.

\item {} 
Support was added for the explicit and implicit methods in an
additive Runge-Kutta method to utilize different stage times,
solution and embedding coefficients, to support new SSP-ARK
methods.

\item {} 
The FARKODE interface was extended to include a routine to set
scalar/array-valued residual tolerances, to support Fortran
applications with non-identity mass-matrices.

\end{itemize}


\section{Reading this User Guide}
\label{Introduction:reading-this-user-guide}
This user guide is a combination of general usage instructions and
specific example programs.  We expect that some readers will want to
concentrate on teh general instructions, while others will refer
mostly to the examples, and the organization is intended to
accommodate both styles.

The structure of this document is as follows:
\begin{itemize}
\item {} 
In the next section we provide a thorough presentation of the
underlying {\hyperref[Mathematics:mathematics]{\emph{\DUspan{}{mathematics}}}} that relate these
algorithms together.

\item {} 
We follow this with overview of how the source code for ARKode is
{\hyperref[Organization:organization]{\emph{\DUspan{}{organized}}}}.

\item {} 
The largest section follows, providing a full account of the ARKode
user interface, including a description of all user-accessible
functions and outlines for ARKode usage for serial and parallel
applications. Since ARKode is written in C, we first present
{\hyperref[c_interface/index:cinterface]{\emph{\DUspan{}{the C and C++ interface}}}}, followed with a
separate section on {\hyperref[f_interface/index:fortraninterface]{\emph{\DUspan{}{using ARKode within Fortran applications}}}}.

\item {} 
The following sections discuss shared features between ARKode
and the rest of the SUNDIALS library:
{\hyperref[nvectors/index:nvectors]{\emph{\DUspan{}{vector data structures}}}},
{\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{matrix data structures}}}},
{\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{linear solver data structures}}}}, and the
{\hyperref[Install:installation]{\emph{\DUspan{}{installation procedure}}}}.

\item {} 
The final sections catalog the full set of {\hyperref[Constants:constants]{\emph{\DUspan{}{ARKode constants}}}}, that are used for both input specifications and return
codes, and the full set of {\hyperref[Butcher:butcher]{\emph{\DUspan{}{Butcher tables}}}} that are
packaged with ARKode.

\end{itemize}


\section{SUNDIALS Release License}
\label{Introduction:sundials-release-license}
The SUNDIALS packages are released open source, under a BSD license.
The only requirements of the BSD license are preservation of copyright
and a standard disclaimer of liability. Our Copyright notice is below
along with the license.

\textbf{PLEASE NOTE}  If you are using SUNDIALS with any third party
libraries linked in (e.g., LAPACK, KLU, SuperLU\_MT, PETSc, or
\emph{hypre}), be sure to review the respective license of the package as
that license may have more restrictive terms than the SUNDIALS
license.  For example, if someone builds SUNDIALS with a statically
linked KLU, the build is subject to terms of the LGPL license (which
is what KLU is released with) and \emph{not} the SUNDIALS BSD license anymore.


\subsection{Copyright Notices}
\label{Introduction:copyright-notices}
All SUNDIALS packages except ARKode are subject to the following Copyright
notice.


\subsubsection{SUNDIALS Copyright}
\label{Introduction:sundials-copyright}
Copyright (c) 2002-2016, Lawrence Livermore National Security.
Produced at the Lawrence Livermore National Laboratory.
Written by A.C. Hindmarsh, D.R. Reynolds, R. Serban, C.S. Woodward,
S.D. Cohen, A.G. Taylor, S. Peles, L.E. Banks, and D. Shumaker.

UCRL-CODE-155951    (CVODE)

UCRL-CODE-155950    (CVODES)

UCRL-CODE-155952    (IDA)

UCRL-CODE-237203    (IDAS)

LLNL-CODE-665877    (KINSOL)

All rights reserved.


\subsubsection{ARKode Copyright}
\label{Introduction:arkode-copyright}
ARKode is subject to the following joint Copyright notice.
Copyright (c) 2015-2017, Southern Methodist University and
Lawrence Livermore National Security
Written by D.R. Reynolds, D.J. Gardner, A.C. Hindmarsh, C.S. Woodward,
and J.M. Sexton.

LLNL-CODE-667205    (ARKODE)

All rights reserved.


\subsection{BSD License}
\label{Introduction:bsd-license}
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
\begin{enumerate}
\item {} 
Redistributions of source code must retain the above copyright
notice, this list of conditions and the disclaimer below.

\item {} 
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the disclaimer (as noted below)
in the documentation and/or other materials provided with the
distribution.

\item {} 
Neither the name of the LLNS/LLNL nor the names of its contributors
may be used to endorse or promote products derived from this
software without specific prior written permission.

\end{enumerate}

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE
LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Additional BSD Notice
\begin{itemize}
\item {} 
This notice is required to be provided under our contract with the
U.S. Department of Energy (DOE). This work was produced at Lawrence
Livermore National Laboratory under Contract No. DE-AC52-07NA27344
with the DOE.

\item {} 
Neither the United States Government nor Lawrence Livermore National
Security, LLC nor any of their employees, makes any warranty,
express or implied, or assumes any liability or responsibility for
the accuracy, completeness, or usefulness of any information,
apparatus, product, or process disclosed, or represents that its use
would not infringe privately-owned rights.

\item {} 
Also, reference herein to any specific commercial products, process,
or services by trade name, trademark, manufacturer or otherwise does
not necessarily constitute or imply its endorsement, recommendation,
or favoring by the United States Government or Lawrence Livermore
National Security, LLC. The views and opinions of authors expressed
herein do not necessarily state or reflect those of the United
States Government or Lawrence Livermore National Security, LLC, and
shall not be used for advertising or product endorsement purposes.

\end{itemize}


\chapter{Mathematical Considerations}
\label{Mathematics:mathematics}\label{Mathematics::doc}\label{Mathematics:mathematical-considerations}
ARKode solves ODE initial value problems (IVPs) in \(\mathbb{R}^N\).
These problems should be posed in explicit form, as
\phantomsection\label{Mathematics:equation-IVP}\begin{gather}
\begin{split}M\dot{y} = f_E(t,y) + f_I(t,y), \qquad y(t_0) = y_0.\end{split}\label{Mathematics-IVP}
\end{gather}
Here, \(t\) is the independent variable (e.g. time), and the
dependent variables are given by \(y \in \mathbb{R}^N\), where we
use the notation \(\dot{y}\) to denote \(\frac{dy}{dt}\).

\(M\) is a user-specified nonsingular operator from
\(\mathbb{R}^N \to \mathbb{R}^N\).  This operator may depend on
\(t\) but is currently assumed to be independent of \(y\).
For standard systems of ordinary differential equations and for
problems arising from the spatial semi-discretization of partial
differential equations using finite difference or finite volume
methods, \(M\) is typically the identity matrix, \(I\).  For
PDEs using a finite-element spatial semi-discretization \(M\) is
typically a well-conditioned mass matrix.

The two right-hand side functions may be described as:
\begin{itemize}
\item {} 
\(f_E(t,y)\) contains the ``slow'' time scale components of the
system.  This will be integrated using explicit methods.

\item {} 
\(f_I(t,y)\) contains the ``fast'' time scale components of the
system.  This will be integrated using implicit methods.

\end{itemize}

ARKode may be used to solve stiff, nonstiff and mixed stiff/nonstiff
problems.  Roughly speaking, stiffness is characterized by the
presence of at least one rapidly damped mode, whose time constant is
small compared to the time scale of the solution itself.  In the
implicit/explicit (ImEx) splitting above, these stiff components
should be included in the right-hand side function \(f_I(t,y)\).

In the sub-sections that follow, we elaborate on the numerical
methods that comprise the ARKode solvers.  We first discuss the
general {\hyperref[Mathematics:mathematics-ark]{\emph{\DUspan{}{formulation of additive Runge-Kutta methods}}}}, including the resulting implicit systems that must
be solved at each stage.  We then discuss the solver strategies that
ARKode uses in solving these systems: {\hyperref[Mathematics:mathematics-nonlinear]{\emph{\DUspan{}{nonlinear solvers}}}}, {\hyperref[Mathematics:mathematics-linear]{\emph{\DUspan{}{linear solvers}}}}
and {\hyperref[Mathematics:mathematics-preconditioning]{\emph{\DUspan{}{preconditioners}}}}.  We then
describe our approaches for {\hyperref[Mathematics:mathematics-error]{\emph{\DUspan{}{error control}}}}
within the iterative nonlinear and linear solvers, including
discussion on our choice of norms used within ARKode for measuring
errors within various components of the solver.  We then discuss
specific enhancements available in ARKode, including an array of
{\hyperref[Mathematics:mathematics-predictors]{\emph{\DUspan{}{prediction algorithms}}}} for the solution
at each stage, {\hyperref[Mathematics:mathematics-adaptivity]{\emph{\DUspan{}{adaptive error controllers}}}}, {\hyperref[Mathematics:mathematics-masssolve]{\emph{\DUspan{}{mass-matrix handling}}}}, and {\hyperref[Mathematics:mathematics-rootfinding]{\emph{\DUspan{}{rootfinding capabilities}}}}.


\section{Additive Runge-Kutta methods}
\label{Mathematics:mathematics-ark}\label{Mathematics:additive-runge-kutta-methods}
The methods used in ARKode are variable-step, embedded,
\index{additive Runge-Kutta methods}additive Runge-Kutta methods (ARK), based on formulas of the
form
\phantomsection\label{Mathematics:equation-ARK}\begin{gather}
\begin{split}M z_i &= M y_{n-1} + h_n \sum_{j=1}^{i-1} A^E_{i,j} f_E(t^E_{n,j}, z_j)
              + h_n \sum_{j=1}^{i}   A^I_{i,j} f_I(t^I_{n,j}, z_j),
\quad i=1,\ldots,s, \\
M y_n &= M y_{n-1} + h_n \sum_{i=1}^{s} \left(b^E_i f_E(t^E_{n,i}, z_i)
              + b^I_i f_I(t^I_{n,i}, z_i)\right), \\
M \tilde{y}_n &= M y_{n-1} + h_n \sum_{i=1}^{s} \left(
               \tilde{b}^E_i f_E(t^E_{n,i}, z_i) +
               \tilde{b}^I_i f_I(t^I_{n,i}, z_i)\right).\end{split}\label{Mathematics-ARK}
\end{gather}
Here the \(y_n\) are computed approximations to \(y(t_n)\),
\(\tilde{y}_n\) are {[}typically{]} lower-order embedded solutions
(used in error estimation), and \(h_n \equiv t_n - t_{n-1}\) is
the step size. The internal stage times are abbreviated using the
notation \(t^E_{n,j} = t_{n-1} + c^E_j h_n\) and \(t^I_{n,j}
= t_{n-1} + c^I_j h_n\).  The ARK method is primarily defined through
the coefficients \(A^E \in \mathbb{R}^{s\times s}\),
\(A^I \in \mathbb{R}^{s\times s}\), \(b^E \in \mathbb{R}^{s}\),
\(b^I \in \mathbb{R}^{s}\), \(c^E \in \mathbb{R}^{s}\) and
\(c^I \in \mathbb{R}^{s}\), that correspond with the explicit and
implicit Butcher tables.  Additional coefficients
\(\tilde{b}^E \in \mathbb{R}^{s}\) and
\(\tilde{b}^I \in \mathbb{R}^{s}\) may be used to enable an
\emph{embedded solution} that is used to estimate error for adaptive
time-stepping.  We note that ARKode currently enforces the constraint
that these tables must share the same number of stages \(s\)
between the explicit and implicit methods in an ARK pair.

The user of ARKode must choose appropriately between one of three
classes of methods: \emph{ImEx}, \emph{explicit} and \emph{implicit}.  All of
ARKode's available Butcher tables encoding the coefficients
\(c^E\), \(c^I\), \(A^E\), \(A^I\), \(b^E\),
\(b^I\), \(\tilde{b}^E\) and \(\tilde{b}^I\) are further
described in the {\hyperref[Butcher:butcher]{\emph{\DUspan{}{Appendix: Butcher tables}}}}.

For mixed stiff/nonstiff problems, a user should provide both of the
functions \(f_E\) and \(f_I\) that define the IVP system.  For
such problems, ARKode currently implements the ARK methods proposed in
\phantomsection\label{Mathematics:id1}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}, allowing for methods having order \(q = \{3,4,5\}\).
The tables for these methods are given in the section
{\hyperref[Butcher:butcher-additive]{\emph{\DUspan{}{Additive Butcher tables}}}}.

For nonstiff problems, a user may specify that \(f_I = 0\),
i.e. the equation \eqref{Mathematics-IVP} reduces to the non-split IVP
\phantomsection\label{Mathematics:equation-IVP_explicit}\begin{gather}
\begin{split}M\dot{y} = f_E(t,y), \qquad y(t_0) = y_0.\end{split}\label{Mathematics-IVP_explicit}
\end{gather}
In this scenario, the coefficients \(A^I=0\), \(c^I=0\),
\(b^I=0\) and \(\tilde{b}^I=0\) in \eqref{Mathematics-ARK}, and the ARK
methods reduce to classical \index{explicit Runge-Kutta methods}explicit Runge-Kutta methods
(ERK).  For these classes of methods, ARKode allows orders of accuracy
\(q = \{2,3,4,5,6,8\}\), with embeddings of orders \(p
= \{1,2,3,4,5,7\}\).  These default to the {\hyperref[Butcher:butcher-heun-euler]{\emph{\DUspan{}{Heun-Euler-2-1-2}}}},
{\hyperref[Butcher:butcher-bogacki-shampine]{\emph{\DUspan{}{Bogacki-Shampine-4-2-3}}}}, {\hyperref[Butcher:butcher-zonneveld]{\emph{\DUspan{}{Zonneveld-5-3-4}}}},
{\hyperref[Butcher:butcher-cash-karp]{\emph{\DUspan{}{Cash-Karp-6-4-5}}}}, {\hyperref[Butcher:butcher-verner-6-5]{\emph{\DUspan{}{Verner-8-5-6}}}} and
{\hyperref[Butcher:butcher-fehlberg-8-7]{\emph{\DUspan{}{Fehlberg-13-7-8}}}} methods, respectively.

Finally, for stiff problems the user may specify that \(f_E = 0\),
so the equation \eqref{Mathematics-IVP} reduces to the non-split IVP
\phantomsection\label{Mathematics:equation-IVP_implicit}\begin{gather}
\begin{split}M\dot{y} = f_I(t,y), \qquad y(t_0) = y_0.\end{split}\label{Mathematics-IVP_implicit}
\end{gather}
Similarly to ERK methods, in this scenario the coefficients
\(A^E=0\), \(c^E=0\), \(b^E=0\) and \(\tilde{b}^E=0\)
in \eqref{Mathematics-ARK}, and the ARK methods reduce to classical
\index{diagonally-implicit Runge-Kutta methods}diagonally-implicit Runge-Kutta methods (DIRK).  For these
classes of methods, ARKode allows orders of accuracy \(q =
\{2,3,4,5\}\), with embeddings of orders \(p = \{1,2,3,4\}\).
These default to the {\hyperref[Butcher:butcher-sdirk-2-1]{\emph{\DUspan{}{SDIRK-2-1-2}}}},
{\hyperref[Butcher:butcher-ark-4-2-3-i]{\emph{\DUspan{}{ARK-4-2-3 (implicit)}}}}, {\hyperref[Butcher:butcher-sdirk-5-4]{\emph{\DUspan{}{SDIRK-5-3-4}}}} and
{\hyperref[Butcher:butcher-ark-8-4-5-i]{\emph{\DUspan{}{ARK-8-4-5 (implicit)}}}} methods, respectively.


\section{Nonlinear solver methods}
\label{Mathematics:nonlinear-solver-methods}\label{Mathematics:mathematics-nonlinear}
For both the DIRK and ARK methods corresponding to \eqref{Mathematics-IVP} and
\eqref{Mathematics-IVP_implicit}, an implicit system
\phantomsection\label{Mathematics:equation-Residual}\begin{gather}
\begin{split}G(z_i) \equiv M z_i - h_n A^I_{i,i} f_I(t^I_{n,i}, z_i) - a_i = 0\end{split}\label{Mathematics-Residual}
\end{gather}
must be solved for each stage \(z_i, i=1,\ldots,s\), where we have
the data
\begin{gather}
\begin{split}a_i \equiv M y_{n-1} + h_n \sum_{j=1}^{i-1} \left[
   A^E_{i,j} f_E(t^E_{n,j}, z_j) +
   A^I_{i,j} f_I(t^I_{n,j}, z_j) \right]\end{split}\notag
\end{gather}
for the ARK methods, or
\begin{gather}
\begin{split}a_i \equiv M y_{n-1} + h_n \sum_{j=1}^{i-1}
   A^I_{i,j} f_I(t^I_{n,j}, z_j)\end{split}\notag
\end{gather}
for the DIRK methods.  Here, if \(f_I(t,y)\) depends nonlinearly
on \(y\) then \eqref{Mathematics-Residual} corresponds to a nonlinear system of
equations; if \(f_I(t,y)\) depends linearly on \(y\) then this
is a linear system of equations.

For systems of either type, ARKode allows a choice of solution
strategy. The default solver choice is a variant of \index{Newton's
method}Newton's
method,
\phantomsection\label{Mathematics:equation-Newton_iteration}\begin{gather}
\begin{split}z_i^{(m+1)} = z_i^{(m)} + \delta^{(m+1)},\end{split}\label{Mathematics-Newton_iteration}
\end{gather}
where \(m\) is the Newton iteration index, and the \index{Newton
update}Newton
update \(\delta^{(m+1)}\) in turn requires the solution of the
linear \index{Newton system}Newton system
\phantomsection\label{Mathematics:equation-Newton_system}\begin{gather}
\begin{split}{\mathcal A}\left(z_i^{(m)}\right) \delta^{(m+1)} = -G\left(z_i^{(m)}\right),\end{split}\label{Mathematics-Newton_system}
\end{gather}
in which
\phantomsection\label{Mathematics:equation-NewtonMatrix}\begin{gather}
\begin{split}{\mathcal A} \approx M - \gamma J, \quad J = \frac{\partial f_I}{\partial y},
\quad\text{and}\quad \gamma = h_n A^I_{i,i}.\end{split}\label{Mathematics-NewtonMatrix}
\end{gather}
As an alternate to Newton's method, ARKode may solve for each stage
\(z_i, i=1,\ldots,s\) using an \index{Anderson-accelerated fixed
point iteration}Anderson-accelerated fixed
point iteration
\phantomsection\label{Mathematics:equation-AAFP_iteration}\begin{gather}
\begin{split}z_i^{(m+1)} = g(z_i^{(m)}), \quad m=0,1,\ldots\end{split}\label{Mathematics-AAFP_iteration}
\end{gather}
Unlike with Newton's method, this method \emph{does not} require the
solution of a linear system at each iteration, instead opting for
solution of a low-dimensional least-squares solution to construct the
nonlinear update.  For details on how this iteration is performed, we
refer the reader to the reference \phantomsection\label{Mathematics:id2}{\hyperref[References:wn2011]{\emph{{[}WN2011{]}}}}.

Finally, if the user specifies that \(f_I(t,y)\) depends linearly
on \(y\) (via a call to {\hyperref[c_interface/User_callable:c.ARKodeSetLinear]{\emph{\code{ARKodeSetLinear()}}}} in C/C++, or
the \emph{LINEAR} argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran), and if
the Newton-based nonlinear solver is chosen, then the problem
\eqref{Mathematics-Residual} will be solved using only a single Newton iteration.
In this case, an additional argument to the respective function
denotes whether this Jacobian is time-dependent or not, indicating
whether the Jacobian or preconditioner needs to be recomputed at each
step.

The optimal solver (Newton vs fixed-point) is highly
problem-dependent.  Since fixed-point solvers do not require
the solution of any linear systems, each iteration may be
significantly less costly than their Newton counterparts.  However,
this can come at the cost of slower convergence (or even divergence)
in comparison with Newton-like methods.  However, these fixed-point
solvers do allow for user specification of the Anderson-accelerated
subspace size, \(m_k\).  While the required amount of solver
memory grows proportionately to \(m_k N\), larger values of
\(m_k\) may result in faster convergence.  In our experience, this
improvement may be significant even for ``small'' values,
e.g. \(1\le m_k\le 5\), and that convergence may not improve (or
even deteriorate) for larger values of \(m_k\).

While ARKode uses a Newton-based iteration as its default solver due
to its increased robustness on very stiff problems, it is highly
recommended that users also consider the fixed-point solver for their
when attempting a new problem.

For either the Newton or fixed-point solvers, it is well-known that
both the efficiency and robustness of the algorithm intimately depends
on the choice of a good initial guess.  In ARKode, the initial guess
for either nonlinear solution method is a predicted value
\(z_i^{(0)}\) that is computed explicitly from the
previously-computed data (e.g. \(y_{n-2}\), \(y_{n-1}\), and
\(z_j\) where \(j<i\)).  Additional information on the
specific predictor algorithms implemented in ARKode is provided in the
following section, {\hyperref[Mathematics:mathematics-predictors]{\emph{\DUspan{}{Implicit predictors}}}}.


\section{Linear solver methods}
\label{Mathematics:linear-solver-methods}\label{Mathematics:mathematics-linear}
When a Newton-based method is chosen for solving each nonlinear
system, a linear system of equations must be solved at each nonlinear
iteration.  For this solve ARKode provides several choices, including
the option of a user-supplied linear solver module.  The linear solver
modules distributed with SUNDIALS are organized into two families: a
\emph{direct} family comprising direct linear solvers for dense, banded or
sparse matrices, and a \emph{spils} family comprising scaled, preconditioned,
iterative (Krylov) linear solvers.  The methods offered through these
modules are as follows:
\begin{itemize}
\item {} 
dense direct solvers, using either an internal SUNDIALS
implementation or a BLAS/LAPACK implementation (serial version
only),

\item {} 
band direct solvers, using either an internal SUNDIALS
implementation or a BLAS/LAPACK implementation (serial version
only),

\item {} 
sparse direct solvers, using either the KLU sparse matrix library
\phantomsection\label{Mathematics:id3}{\hyperref[References:klu]{\emph{{[}KLU{]}}}}, or the OpenMP or PThreads-enabled SuperLU\_MT sparse matrix
library \phantomsection\label{Mathematics:id4}{\hyperref[References:superlumt]{\emph{{[}SuperLUMT{]}}}} (serial or threaded vector modules only) {[}Note
that users will need to download and install the KLU or SuperLU\_MT
packages independent of ARKode{]},

\item {} 
SPGMR, a scaled, preconditioned GMRES (Generalized Minimal Residual)
solver,

\item {} 
SPFGMR, a scaled, preconditioned Flexible GMRES (Generalized Minimal
Residual) solver,

\item {} 
SPBCGS, a scaled, preconditioned Bi-CGStab (Bi-Conjugate Gradient
Stable) solver,

\item {} 
SPTFQMR, a scaled, preconditioned TFQMR (Transpose-free
Quasi-Minimal Residual) solver, or

\item {} 
PCG, a preconditioned CG (Conjugate Gradient method) solver for
symmetric linear systems.

\end{itemize}

For large stiff systems where direct methods are infeasible, the
combination of an implicit integrator and a preconditioned
Krylov method can yield a powerful tool because it combines
established methods for stiff integration, nonlinear solver iteration,
and Krylov (linear) iteration with a problem-specific treatment of the
dominant sources of stiffness, in the form of a user-supplied
preconditioner matrix \phantomsection\label{Mathematics:id5}{\hyperref[References:bh1989]{\emph{{[}BH1989{]}}}}.  We note that the direct linear
solvers provided by SUNDIALS (dense, band and sparse), as well as the
direct linear solvers accessible through LAPACK, can only be used with
the serial and threaded vector representations.

\index{modified Newton iteration}
In the case that a direct linear solver is used, ARKode utilizes
either a Newton or a \emph{modified Newton iteration}.  The difference
between these is that in a modified Newton method, the matrix
\({\mathcal A}\) is held fixed for multiple Newton iterations.
More precisely, each Newton iteration is computed from the modified
equation
\phantomsection\label{Mathematics:equation-modified_Newton_system}\begin{gather}
\begin{split}\tilde{\mathcal A}\left(z_i^{(m)}\right) \delta^{(m+1)} = -G\left(z_i^{(m)}\right),\end{split}\label{Mathematics-modified_Newton_system}
\end{gather}
in which
\phantomsection\label{Mathematics:equation-modified_NewtonMatrix}\begin{gather}
\begin{split}\tilde{\mathcal A} \approx M - \tilde{\gamma} \tilde{J}, \quad \tilde{J} =
\frac{\partial f_I}{\partial y}(\tilde y), \quad\text{and}\quad
\tilde{\gamma} = \tilde{h} A^I_{i,i}.\end{split}\label{Mathematics-modified_NewtonMatrix}
\end{gather}
Here, the solution \(\tilde{y}\) and step size \(\tilde{h}\)
upon which the modified Jacobian rely, are merely values of the
solution and step size from a previous iteration.  In other words, the
matrix \(\tilde{\mathcal A}\) is only computed rarely, and reused for
repeated stage solves.  The frequency at which  \(\tilde{\mathcal
A}\) is recomputed, and hence the choice between normal and modified
Newton iterations, is determined by the input parameter \emph{msbp} to the
input function {\hyperref[c_interface/User_callable:c.ARKodeSetMaxStepsBetweenLSet]{\emph{\code{ARKodeSetMaxStepsBetweenLSet()}}}} in C/C++, or
with the \emph{LSETUP\_MSBP} argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran.

When using the direct and band solvers for the linear systems
\eqref{Mathematics-modified_Newton_system}, the Jacobian may be supplied by a user
routine or approximated by finite-differences.  In the case of
differencing, we use the standard approximation
\begin{gather}
\begin{split}J_{i,j}(t,y) = \frac{f_{I,i}(t,y+\sigma_j e_j) - f_{I,i}(t,y)}{\sigma_j},\end{split}\notag
\end{gather}
where \(e_j\) is the jth unit vector, and the increments
\(\sigma_j\) are given by
\begin{gather}
\begin{split}\sigma_j = \max\left\{ \sqrt{U}\, |y_j|, \frac{\sigma_0}{w_j} \right\}.\end{split}\notag
\end{gather}
Here \(U\) is the unit roundoff, \(\sigma_0\) is a
dimensionless value, and \(w_j\) is the error weight defined in
\eqref{Mathematics-EWT}.  In the dense case, this approach requires \(N\)
evaluations of \(f_I\), one for each column of \(J\).  In the
band case, the columns of \(J\) are computed in groups, using the
Curtis-Powell-Reid algorithm, with the number of \(f_I\)
evaluations equal to the bandwidth.

We note that with the sparse direct solvers, the Jacobian \emph{must}
be supplied by a user routine.

\index{inexact Newton iteration}
In the case that an iterative linear solver is chosen, ARKode utilizes a
Newton method variant called an \emph{Inexact Newton iteration}.  Here, the
matrix \({\mathcal A}\) is not itself constructed since the
algorithms only require the product of this matrix with a given
vector.  Additionally, each Newton system \eqref{Mathematics-Newton_system} is not
solved completely, since these linear solvers are iterative (hence the
``inexact'' in the name). Resultingly. for these linear solvers
\({\mathcal A}\) is applied in a matrix-free manner,
\begin{gather}
\begin{split}{\mathcal A}v = Mv - \gamma Jv.\end{split}\notag
\end{gather}
The matrix-vector products \(Jv\) are obtained by either calling
an optional user-supplied routine, or through directional differencing
using the formula
\begin{gather}
\begin{split}Jv = \frac{f_I(t,y+\sigma v) - f_I(t,y)}{\sigma},\end{split}\notag
\end{gather}
where the increment \(\sigma = 1/\|v\|\) to ensure that
\(\|\sigma v\| = 1\).

As with the modified Newton method that reused \({\mathcal A}\)
between solves, ARKode's inexact Newton iteration may also recompute the
preconditioner matrix \(P\) infrequently to balance the high costs
of matrix construction and factorization against the reduced
convergence rate that may result from a stale preconditioner.

Alternately, for some preconditioning algorithms that do not rely on
costly matrix construction and factorization operations (e.g. when
using an iterative multigrid method as preconditioner), a user may
specify that \({\mathcal A}\) and/or \(P\) should be
recomputed at every Newton iteration, since the increased rate of
convergence may more than account for the additional cost of
Jacobian/preconditioner construction.  To indicate this, a user need
only supply a negative value for the \emph{msbp} argument to
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxStepsBetweenLSet]{\emph{\code{ARKodeSetMaxStepsBetweenLSet()}}}} in C/C++, or the
\emph{LSETUP\_MSBP} argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran.

However, in cases where recomputation of the Newton matrix
\(\tilde{\mathcal A}\) or preconditioner matrix \(P\) is
lagged, ARKode will force recomputation of these structures only in
the following circumstances:
\begin{itemize}
\item {} 
when starting the problem,

\item {} 
when more than 20 steps have been taken since the last update (this
value may be changed via the \emph{msbp} argument to
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxStepsBetweenLSet]{\emph{\code{ARKodeSetMaxStepsBetweenLSet()}}}} in C/C++, or the
\emph{LSETUP\_MSBP} argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran),

\item {} 
when the value \(\bar{\gamma}\) of \(\gamma\) at the last
update satisfies \(\left|\gamma/\bar{\gamma} - 1\right| > 0.2\)
(this tolerance may be changed via the \emph{dgmax} argument to
{\hyperref[c_interface/User_callable:c.ARKodeSetDeltaGammaMax]{\emph{\code{ARKodeSetDeltaGammaMax()}}}} in C/C++, or the \emph{LSETUP\_DGMAX}
argument to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran),

\item {} 
when a non-fatal convergence failure just occurred,

\item {} 
when an error test failure just occurred, or

\item {} 
if the problem is linearly implicit and \(\gamma\) has
changed by a factor larger than 100 times machine epsilon.

\end{itemize}

When an update is forced due to a convergence failure, an update of
\(\tilde{\mathcal A}\) or \(P\) may or may not involve a reevaluation of
\(J\) (in \(\tilde{\mathcal A}\)) or of Jacobian data (in \(P\)),
depending on whether errors in the Jacobian were the likely cause of the
failure.  More generally, the decision is made to reevaluate \(J\)
(or instruct the user to reevaluate Jacobian data in \(P\)) when:
\begin{itemize}
\item {} 
starting the problem,

\item {} 
more than 50 steps have been taken since the last evaluation,

\item {} 
a convergence failure occurred with an outdated matrix, and the
value \(\bar{\gamma}\) of \(\gamma\) at the last update
satisfies \(\left|\gamma/\bar{\gamma} - 1\right| > 0.2\),

\item {} 
a convergence failure occurred that forced a step size reduction, or

\item {} 
if the problem is linearly implicit and \(\gamma\) has
changed by a factor larger than 100 times machine epsilon.

\end{itemize}

As will be further discussed in the section
{\hyperref[Mathematics:mathematics-preconditioning]{\emph{\DUspan{}{Preconditioning}}}}, in the case of a Krylov method,
preconditioning may be applied on the left, right, or on both sides of
\({\mathcal A}\), with user-supplied routines for the preconditioner setup
and solve operations.


\section{Iteration Error Control}
\label{Mathematics:mathematics-error}\label{Mathematics:iteration-error-control}

\subsection{Choice of norm}
\label{Mathematics:choice-of-norm}\label{Mathematics:mathematics-error-norm}
In the process of controlling errors at various levels (time
integration, nonlinear solution, linear solution), ARKode uses a
\index{weighted root-mean-square norm}weighted root-mean-square norm, denoted
\(\|\cdot\|_\text{WRMS}\), for all error-like quantities,
\phantomsection\label{Mathematics:equation-WRMS_NORM}\begin{gather}
\begin{split}\|v\|_\text{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N \left(v_i\,
w_i\right)^2\right)^{1/2}.\end{split}\label{Mathematics-WRMS_NORM}
\end{gather}
The power of this choice of norm arises in the specification of the
weighting vector \(w\), that combines the units of the problem
with the user-supplied measure of ``acceptable'' error.  To this end,
ARKode constructs and \index{error weight vector}error weight vector using the
most-recent step solution and the relative and absolute tolerances
input by the user, namely
\phantomsection\label{Mathematics:equation-EWT}\begin{gather}
\begin{split}w_i = \frac{1}{RTOL\cdot |y_i| + ATOL_i}.\end{split}\label{Mathematics-EWT}
\end{gather}
Since \(1/w_i\) represents a tolerance in the component
\(y_i\), a vector whose WRMS norm is 1 is regarded as ``small.'' For
brevity, we will typically drop the subscript WRMS on norms in the
remainder of this section.

Additionally, for problems involving a non-identity mass matrix,
\(M\ne I\), the units of equation \eqref{Mathematics-IVP} may differ from the
units of the solution \(y\).  In this case, ARKode may also
construct a \index{residual weight vector}residual weight vector,
\phantomsection\label{Mathematics:equation-RWT}\begin{gather}
\begin{split}w_i = \frac{1}{RTOL\cdot |My_i| + ATOL'_i},\end{split}\label{Mathematics-RWT}
\end{gather}
where the user may specify a separate absolute residual tolerance
value or array, \(ATOL'_i\).  The choice of weighting vector used
in any given norm is determined by the quantity being measured: values
having solution units use \eqref{Mathematics-EWT}, whereas values having equation
units use \eqref{Mathematics-RWT}.  Obviously, for problems with \(M=I\), the
weighting vectors are identical.


\subsection{Nonlinear iteration error control}
\label{Mathematics:nonlinear-iteration-error-control}\label{Mathematics:mathematics-error-nonlinear}
The stopping test for all of ARKode's nonlinear solvers is related to
the subsequent local error test, with the goal of keeping the
nonlinear iteration errors from interfering with local error control.
Denoting the final computed value of each stage solution as
\(z_i^{(m)}\), and the true stage solution solving \eqref{Mathematics-Residual}
as \(z_i\), we want to ensure that the iteration error
\(z_i - z_i^{(m)}\) is ``small'' (recall that a norm less than 1 is
already considered within an acceptable tolerance).

To this end, we first estimate the linear convergence rate \(R_i\)
of the nonlinear iteration.  We initialize \(R_i=1\), and reset it
to this value whenever \(\tilde{\mathcal A}\) or \(P\) are
updated.  After computing a nonlinear correction \(\delta^{(m)} =
z_i^{(m)} - z_i^{(m-1)}\), if \(m>0\) we update \(R_i\) as
\begin{gather}
\begin{split}R_i \leftarrow \max\{ 0.3 R_i, \left\|\delta^{(m)}\right\| / \left\|\delta^{(m-1)}\right\| \}.\end{split}\notag
\end{gather}
where the factor 0.3 is user-modifiable as the \emph{crdown} input to the
the function {\hyperref[c_interface/User_callable:c.ARKodeSetNonlinCRDown]{\emph{\code{ARKodeSetNonlinCRDown()}}}} in C/C++, or the
\emph{NONLIN\_CRDOWN} argument to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran.

Denoting the true time step solution as \(y(t_n)\), and the computed
time step solution (computed using the stage solutions
\(z_i^{(m)}\)) as \(y_n\), we use the estimate
\begin{gather}
\begin{split}\left\| y(t_n) - y_n \right\| \approx
\max_i \left\| z_i^{(m+1)} - z_i^{(m)} \right\| \approx
\max_i R_i \left\| z_i^{(m)} - z_i^{(m-1)} \right\| =
\max_i R_i \left\| \delta^{(m)} \right\|.\end{split}\notag
\end{gather}
Therefore our convergence (stopping) test for the nonlinear iteration
for each stage is
\phantomsection\label{Mathematics:equation-NonlinearTolerance}\begin{gather}
\begin{split}R_i \left\|\delta^{(m)} \right\| < \epsilon,\end{split}\label{Mathematics-NonlinearTolerance}
\end{gather}
where the factor \(\epsilon\) has default value 0.1, and is
user-modifiable as the \emph{nlscoef} input to the the function
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinConvCoef]{\emph{\code{ARKodeSetNonlinConvCoef()}}}} in C/C++, or the \emph{NLCONV\_COEF}
input to the function {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran.  We allow at
most 3 nonlinear iterations (modifiable through
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxNonlinIters]{\emph{\code{ARKodeSetMaxNonlinIters()}}}} in C/C++, or as the \emph{MAX\_NSTEPS}
argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran).  We also declare the
nonlinear iteration to be divergent if any of the ratios
\(\|\delta^{(m)}\| / \|\delta^{(m-1)}\| > 2.3\) with \(m>0\)
(the value 2.3 may be modified as the \emph{rdiv} input to
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinRDiv]{\emph{\code{ARKodeSetNonlinRDiv()}}}} in C/C++, or the \emph{NONLIN\_RDIV} input
to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran).  If convergence fails in the
fixed point iteration, or in the Newton iteration with \(J\) or
\({\mathcal A}\) current, we must then reduce the step size by a
factor of 0.25 (modifiable via the \emph{etacf} input to the
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxCFailGrowth]{\emph{\code{ARKodeSetMaxCFailGrowth()}}}} function in C/C++, or the
\emph{ADAPT\_ETACF} input to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran).  The
integration is halted after 10 convergence failures (modifiable via the
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxConvFails]{\emph{\code{ARKodeSetMaxConvFails()}}}} function in C/C++, or the
\emph{MAX\_CONVFAIL} argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran).


\subsection{Linear iteration error control}
\label{Mathematics:linear-iteration-error-control}\label{Mathematics:mathematics-error-linear}
When a Krylov method is used to solve the linear systems
\eqref{Mathematics-Newton_system}, its errors must also be controlled.  To this end,
we approximate the linear iteration error in the solution vector
\(\delta^{(m)}\) using the preconditioned residual vector,
e.g. \(r = P{\mathcal A}\delta^{(m)} + PG\) for the case of left
preconditioning (the role of the preconditioner is further elaborated
on in the next section).  In an attempt to ensure that the linear
iteration errors do not interfere with the nonlinear solution error
and local time integration error controls, we require that the norm of
the preconditioned linear residual satisfies
\phantomsection\label{Mathematics:equation-LinearTolerance}\begin{gather}
\begin{split}\|r\| \le \frac{\epsilon_L \epsilon}{10}.\end{split}\label{Mathematics-LinearTolerance}
\end{gather}
Here \(\epsilon\) is the same value as that used above for the
nonlinear error control.  The factor of 10 is used to ensure that the
linear solver error does not adversely affect the nonlinear solver
convergence.  Smaller values for the parameter \(\epsilon_L\) are
typically useful for strongly nonlinear and stiff ODE systems, while
easier ODE systems may benefit from a value closer to 1; by default
\(\epsilon_L = 0.05\), which may be modified by the user through
the {\hyperref[c_interface/User_callable:c.ARKSpilsSetEpsLin]{\emph{\code{ARKSpilsSetEpsLin()}}}} function in C/C++, or through the
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETEPSLIN]{\emph{\code{FARKSPILSSETEPSLIN()}}}} in Fortran.  We note that for linearly
implicit problems the same tolerance \eqref{Mathematics-LinearTolerance} is used for
the single Newton iteration.


\section{Preconditioning}
\label{Mathematics:mathematics-preconditioning}\label{Mathematics:preconditioning}
When using an inexact Newton method to solve the nonlinear system
\eqref{Mathematics-Residual}, ARKode makes repeated use of a linear solver to solve
linear systems of the form \({\mathcal A}x = b\), where \(x\) is a
correction vector and \(b\) is a residual vector.  If this linear
system solve is done with one of the scaled preconditioned iterative
linear solvers, the efficiency of such solvers may benefit
tremendously from preconditioning. A system \({\mathcal A}x=b\) can be
preconditioned as one of:
\begin{gather}
\begin{split}(P^{-1}{\mathcal A})x = P^{-1}b & \qquad\text{[left preconditioning]}, \\
({\mathcal A}P^{-1})Px = b  & \qquad\text{[right preconditioning]}, \\
(P_L^{-1} {\mathcal A} P_R^{-1}) P_R x = P_L^{-1}b & \qquad\text{[left and right
preconditioning]}.\end{split}\notag
\end{gather}
The Krylov method is then applied to a system with the
matrix \(P^{-1}{\mathcal A}\), \({\mathcal A}P^{-1}\), or
\(P_L^{-1} {\mathcal A} P_R^{-1}\), instead of \({\mathcal
A}\).  In order to improve the convergence of the Krylov iteration, the
preconditioner matrix \(P\), or the product \(P_L P_R\) in the
third case, should in some sense approximate the system matrix
\({\mathcal A}\).  Yet at the same time, in order to be
cost-effective the matrix \(P\) (or matrices \(P_L\) and
\(P_R\)) should be reasonably efficient to evaluate and solve.
Finding an optimal point in this tradeoff between rapid
convergence and low cost can be quite challenging.  Good choices are
often problem-dependent (for example, see \phantomsection\label{Mathematics:id6}{\hyperref[References:bh1989]{\emph{{[}BH1989{]}}}} for an
extensive study of preconditioners for reaction-transport systems).

Most of the iterative linear solvers supplied with SUNDIALS allow for
preconditioning either side, or on both sides, although for
non-symmetric matrices \({\mathcal A}\) we know of few situations
where preconditioning on both sides is superior to preconditioning on
one side only (with the product \(P = P_L P_R\)).  Moreover, for a
given preconditioner matrix, the merits of left vs. right
preconditioning are unclear in general, and the user should
experiment with both choices.  Performance will differ between these
choices because the inverse of the left preconditioner is included in
the linear system residual whose norm is being tested in the Krylov
algorithm.  As a rule, however, if the preconditioner is the product
of two matrices, we recommend that preconditioning be done either on
the left only or the right only, rather than using one factor on each
side.  An exception to this rule is the PCG solver, that itself
assumes a symmetric matrix \({\mathcal A}\), since the PCG
algorithm in fact applies the single preconditioner matrix \(P\)
in both left/right fashion as \(P^{-1/2} {\mathcal A} P^{-1/2}\).

Typical preconditioners used with ARKode are based on approximations
to the system Jacobian, \(J = \partial f_I / \partial y\).  Since
the Newton iteration matrix involved is \({\mathcal A} = M - \gamma J\), any
approximation \(\bar{J}\) to \(J\) yields a matrix that is of
potential use as a preconditioner, namely \(P = M - \gamma
\bar{J}\). Because the Krylov iteration occurs within a Newton
iteration and further also within a time integration, and since each
of these iterations has its own test for convergence, the
preconditioner may use a very crude approximation, as long as it
captures the dominant numerical feature(s) of the system.  We have
found that the combination of a preconditioner with the Newton-Krylov
iteration, using even a relatively poor approximation to the Jacobian,
can be surprisingly superior to using the same matrix without Krylov
acceleration (i.e., a modified Newton iteration), as well as to using
the Newton-Krylov method with no preconditioning.


\section{Implicit predictors}
\label{Mathematics:implicit-predictors}\label{Mathematics:mathematics-predictors}
For problems with implicit components, ARKode will employ a prediction
algorithm for constructing the initial guesses for each Runge-Kutta
stage, \(z_i^{(0)}\).  As is well-known with nonlinear solvers,
the selection of a good initial guess can have dramatic effects on both
the speed and robustness of the nonlinear solve, enabling the
difference between rapid quadratic convergence versus divergence of
the iteration.  To this end, ARKode implements a variety of prediction
algorithms that may be selected by the user.  In each case, the stage
guesses \(z_i^{(0)}\) are constructed explicitly using
readily-available information, including the previous step solutions
\(y_{n-1}\) and \(y_{n-2}\), as well as any previous stage
solutions \(z_j, \quad j<i\).  In most cases, prediction is
performed by constructing an interpolating polynomial through
existing data, which is then evaluated at the subsequent stage times
to provide an inexpensive but (hopefully) reasonable prediction of the
subsequent solution value.  Specifically, for most Runge-Kutta
methods each stage solution satisfies
\begin{gather}
\begin{split}z_i \approx y(t^I_{n,i}),\end{split}\notag
\end{gather}
so by constructing an interpolating polynomial \(p_q(t)\) through
a set of existing data, the initial guess at stage solutions may be
approximated as
\begin{gather}
\begin{split}z_i^{(0)} = p_q(t^I_{n,i}).\end{split}\notag
\end{gather}
Denoting \([a,b]\) as the interval containing the data used to
construct \(p_q(t)\), and assuming forward integration from
\(a\to b\), it is typically the case that \(t^I_{n,j} > b\).
The dangers of using a polynomial interpolant to extrapolate values
outside the interpolation interval are well-known, with higher-order
polynomials and predictions further outside the interval resulting in
the greatest potential inaccuracies.

The various prediction algorithms therefore construct different types of
interpolant \(p_q(t)\), as described below.


\subsection{Trivial predictor}
\label{Mathematics:trivial-predictor}\label{Mathematics:mathematics-predictors-trivial}
The so-called ``trivial predictor'' is given by the formula
\begin{gather}
\begin{split}p_0(\tau) = y_{n-1}.\end{split}\notag
\end{gather}
While this piecewise-constant interpolant is clearly not a highly
accurate candidate for problems with time-varying solutions, it is
often the most robust approach for either highly stiff problems, or
problems with implicit constraints whose violation may cause illegal
solution values (e.g. a negative density or temperature).


\subsection{Maximum order predictor}
\label{Mathematics:maximum-order-predictor}\label{Mathematics:mathematics-predictors-max}
At the opposite end of the spectrum, ARKode can construct an
interpolant \(p_q(t)\) of polynomial order up to \(q=3\).
Here, the function \(p_q(t)\) is identical to the one used for
interpolation of output solution values between time steps, i.e. for
``\index{dense output}dense output'' of \(y(t)\) for \(t_{n-1} < t < t_n\).
The order of this polynomial, \(q\), may be specified by the user
with the function {\hyperref[c_interface/User_callable:c.ARKodeSetDenseOrder]{\emph{\code{ARKodeSetDenseOrder()}}}} in C/C++, or with the
\emph{DENSE\_ORDER} argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran.

The interpolants generated are either of Lagrange or Hermite form, and
use the data \(\left\{ y_{n-2}, f_{n-2}, y_{n-1}, f_{n-1}
\right\}\), where we use \(f_{k}\) to denote \(M^{-1}
\left(f_E(t_k,y_k) + f_I(t_k,y_k)\right)\).  Defining a scaled and
shifted ``time'' variable \(\tau\) for the interval \([t_{n-2},
t_{n-1}]\) as
\begin{gather}
\begin{split}\tau(t) = (t-t_{n-1})/h_{n-1},\end{split}\notag
\end{gather}
we may denote the predicted stage times in the subsequent time
interval \([t_{n-1}, t_{n}]\) as
\begin{gather}
\begin{split}\tau_i = c^I_i \frac{h_n}{h_{n-1}}.\end{split}\notag
\end{gather}
We then construct the interpolants \(p(t)\) as follows:
\begin{itemize}
\item {} 
\(q=0\): constant interpolant
\begin{gather}
\begin{split}p_0(\tau) = \frac{y_{n-2} + y_{n-1}}{2}.\end{split}\notag
\end{gather}
\item {} 
\(q=1\): linear Lagrange interpolant
\begin{gather}
\begin{split}p_1(\tau) = -\tau\, y_{n-2} + (1+\tau)\, y_{n-1}.\end{split}\notag
\end{gather}
\item {} 
\(q=2\): quadratic Hermite interpolant
\begin{gather}
\begin{split}p_2(\tau) =  \tau^2\,y_{n-2} + (1-\tau^2)\,y_{n-1} + h(\tau+\tau^2)\,f_{n-1}.\end{split}\notag
\end{gather}
\item {} 
\(q=3\): cubic Hermite interpolant
\begin{gather}
\begin{split}p_3(\tau) =  (3\tau^2 + 2\tau^3)\,y_{n-2} +
(1-3\tau^2-2\tau^3)\,y_{n-1} + h(\tau^2+\tau^3)\,f_{n-2} +
h(\tau+2\tau^2+\tau^3)\,f_{n-1}.\end{split}\notag
\end{gather}
\end{itemize}

These higher-order predictors may be useful when using lower-order
methods in which \(h_n\) is not too large.  We further note that
although interpolants of order \(> 3\) are possible, these are not
implemented due to their increased computing and storage costs, along
with their diminishing returns due to increased extrapolation error.


\subsection{Variable order predictor}
\label{Mathematics:variable-order-predictor}\label{Mathematics:mathematics-predictors-decreasing}
This predictor attempts to use higher-order interpolations
\(p_q(t)\) for predicting earlier stages in the subsequent time
interval, and lower-order interpolants for later stages.  It uses the
same formulas as described above, but chooses \(q\) adaptively
based on the stage index \(i\), under the (rather tenuous)
assumption that the stage times are increasing, i.e. \(c^I_j < c^I_k\)
for \(j<k\):
\begin{gather}
\begin{split}q = \max\{ q_\text{max} - i,\; 1 \}.\end{split}\notag
\end{gather}

\subsection{Cutoff order predictor}
\label{Mathematics:cutoff-order-predictor}\label{Mathematics:mathematics-predictors-cutoff}
This predictor follows a similar idea as the previous algorithm, but
monitors the actual stage times to determine the polynomial
interpolant to use for prediction:
\begin{gather}
\begin{split}q = \begin{cases}
   q_\text{max}, & \text{if}\quad \tau < \tfrac12,\\
   1, & \text{otherwise}.
\end{cases}\end{split}\notag
\end{gather}

\subsection{Bootstrap predictor}
\label{Mathematics:mathematics-predictors-bootstrap}\label{Mathematics:bootstrap-predictor}
This predictor does not use any information from within the preceding
step, instead using information only within the current step
\([t_{n-1},t_n]\) (including \(y_{n-1}\) and
\(f_{n-1}\)).  Instead, this approach uses the right-hand side
from a previously computed stage solution in the same step,
\(f(t_{n-1}+c^I_j h,z_j)\) to construct a quadratic Hermite
interpolant for the prediction.  If we define the constants
\(\tilde{h} = c^I_j h\) and \(\tau = c^I_i h\), the predictor
is given by
\begin{gather}
\begin{split}z_i^{(0)} = y_{n-1} + \left(\tau - \frac{\tau^2}{2\tilde{h}}\right)
   f(t_{n-1},y_{n-1}) + \frac{\tau^2}{2\tilde{h}} f(t_{n-1}+\tilde{h},z_j).\end{split}\notag
\end{gather}
For stages in which \(c^I_j=0\) for all previous stages
\(j = 0,\ldots,i-1\), and for the first stage of any time step
\((i=0)\), this method reduces to using the trivial predictor
\(z_i^{(0)} = y_{n-1}\).  For stages having multiple precdding
nonzero \(c^I_j\), we choose the stage having largest \(c^I_j\)
value, to minimize the amount of extrapolation induced through the
prediction.

We note that in general, each stage solution \(z_j\) has
signicantly worse accuracy than the time step solutions
\(y_{n-1}\), due to the difference between the \emph{stage order} and
the \emph{method order} in typical Runge-Kutta methods.  As a result, the
accuracy of this predictor will generally be rather limited, but it is
provided for problems in which this increased stage error is better
than the effects of extrapolation far outside of the previous time
step interval \([t_{n-2},t_{n-1}]\).

We further note that although this method could be used with
non-identity mass matrix \(M\ne I\), support for that mode is not
currently implemented, so selection of this predictor in the case that
\(M\ne I\) will result in use of the {\hyperref[Mathematics:mathematics-predictors-trivial]{\emph{\DUspan{}{Trivial predictor}}}}.


\subsection{Minimum correction predictor}
\label{Mathematics:minimum-correction-predictor}\label{Mathematics:mathematics-predictors-minimumcorrection}
This predictor is not interpolation based; instead it utilizes all
existing stage information from the current step to create a predictor
containing all but the current stage solution.  Specifically, as
discussed in equations \eqref{Mathematics-ARK} and \eqref{Mathematics-Residual}, each stage solves
a nonlinear equation
\begin{gather}
\begin{split}z_i &= y_{n-1} + h_n \sum_{j=1}^{i-1} A^E_{i,j} f_E(t^E_{n,j}, z_j)
              + h_n \sum_{j=1}^{i}   A^I_{i,j} f_I(t^I_{n,j}, z_j), \\
\Leftrightarrow \quad & \\
G(z_i) &\equiv z_i - h_n A^I_{i,i} f_I(t^I_{n,i}, z_i) - a_i = 0.\end{split}\notag
\end{gather}
This prediction method merely computes the predictor \(z_i\) as
\begin{gather}
\begin{split}z_i &= y_{n-1} + h_n \sum_{j=1}^{i-1} A^E_{i,j} f_E(t^E_{n,j}, z_j)
              + h_n \sum_{j=1}^{i-1}  A^I_{i,j} f_I(t^I_{n,j}, z_j), \\
\Leftrightarrow \quad & \\
z_i &= a_i.\end{split}\notag
\end{gather}
We note that although this method could be also used with non-identity
mass matrix \(M\ne I\), support for that mode is not currently
implemented, so selection of this predictor in the case that
\(M\ne I\) will result in use of the {\hyperref[Mathematics:mathematics-predictors-trivial]{\emph{\DUspan{}{Trivial predictor}}}}.


\section{Time step adaptivity}
\label{Mathematics:time-step-adaptivity}\label{Mathematics:mathematics-adaptivity}
A critical component of ARKode, making it an IVP ``solver'' rather than
just an integrator, is its adaptive control of local truncation error.
At every step, we estimate the local error, and ensure that it
satisfies tolerance conditions.  If this local error test fails, then
the step is recomputed with a reduced step size.  To this end, every
Runge-Kutta method packaged within ARKode admit an embedded solution
\(\tilde{y}_n\), as shown in equation \eqref{Mathematics-ARK}. Generally, these
embedded solutions attain a lower order of accuracy than the computed
solution \(y_n\).  Denoting these orders of accuracy as \(p\)
and \(q\), where \(p\) corresponds to the embedding and
\(q\) corresponds to the method, for the majority of embedded
methods \(p = q-1\).  These values of \(p\) and \(q\)
correspond to the global order of accuracy for the method and
embedding, hence each admit local errors satisfying \phantomsection\label{Mathematics:id7}{\hyperref[References:hw1993]{\emph{{[}HW1993{]}}}}
\phantomsection\label{Mathematics:equation-AsymptoticErrors}\begin{gather}
\begin{split}\| y_n - y(t_n) \| = C h_n^{q+1} + \mathcal O(h_n^{q+2}), \\
\| \tilde{y}_n - y(t_n) \| = D h_n^{p+1} + \mathcal O(h_n^{p+2}),\end{split}\label{Mathematics-AsymptoticErrors}
\end{gather}
where \(C\) and \(D\) are constants independent of \(h\),
and where we have assumed exact initial conditions for the step,
\(y_{n-1} = y(t_{n-1})\). Combining these estimates, we have
\begin{gather}
\begin{split}\| y_n - \tilde{y}_n \| = \| y_n - y(t_n) - \tilde{y}_n + y(t_n) \|
\le \| y_n - y(t_n) \| + \| \tilde{y}_n - y(t_n) \|
\le D h_n^{p+1} + \mathcal O(h_n^{p+2}).\end{split}\notag
\end{gather}
We therefore use this difference norm as an estimate for the local
truncation error at the step \(n\),
\phantomsection\label{Mathematics:equation-LTE}\begin{gather}
\begin{split}T_n = \beta \left(y_n - \tilde{y}_n\right) =
\beta h_n M^{-1} \sum_{i=1}^{s} \left[
\left(b^E_i - \tilde{b}^E_i\right) f_E(t^E_{n,i}, z_i) +
\left(b^I_i - \tilde{b}^I_i\right) f_I(t^I_{n,i}, z_i) \right].\end{split}\label{Mathematics-LTE}
\end{gather}
Here, \(\beta>0\) is an error \emph{bias} to help account for the error
constant \(D\); the default value of this is \(\beta = 1.5\),
and may be modified by the user through the function
{\hyperref[c_interface/User_callable:c.ARKodeSetErrorBias]{\emph{\code{ARKodeSetErrorBias()}}}} in C/C++, or through the input
\emph{ADAPT\_BIAS} to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran.

With this LTE estimate, the local error test is simply \(\|T_n\|
< 1\), where we remind that this norm includes the user-specified
relative and absolute tolerances.  If this error test passes, the step
is considered successful, and the estimate is subsequently used to
estimate the next step size, as will be described below in the section
{\hyperref[Mathematics:mathematics-adaptivity-errorcontrol]{\emph{\DUspan{}{Asymptotic error control}}}}.  If the error test fails,
the step is rejected and a new step size \(h'\) is then computed
using the error control algorithms described in
{\hyperref[Mathematics:mathematics-adaptivity-errorcontrol]{\emph{\DUspan{}{Asymptotic error control}}}}.  A new attempt at the step
is made, and the error test is repeated.  If it fails multiple times
(as specified through the \emph{small\_nef} input to
{\hyperref[c_interface/User_callable:c.ARKodeSetSmallNumEFails]{\emph{\code{ARKodeSetSmallNumEFails()}}}} in C/C++, or the \emph{ADAPT\_SMALL\_NEF}
argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran, which defaults to 2),
then \(h'/h\) is limited above to 0.3 (this is modifiable via the
\emph{etamxf} argument to {\hyperref[c_interface/User_callable:c.ARKodeSetMaxEFailGrowth]{\emph{\code{ARKodeSetMaxEFailGrowth()}}}} in C/C++, or
the \emph{ADAPT\_ETAMXF} argument to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran), and
limited below to 0.1 after an additional step failure.  After
seven error test failures (modifiable via the function
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxErrTestFails]{\emph{\code{ARKodeSetMaxErrTestFails()}}}} in C/C++, or the \emph{MAX\_ERRFAIL}
argument to {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} in Fortran), ARKode returns to the
user with a give-up message.

We define the step size ratio between a prospective step \(h'\)
and a completed step \(h\) as \(\eta\), i.e.
\begin{gather}
\begin{split}\eta = h' / h.\end{split}\notag
\end{gather}
This is bounded above by \(\eta_\text{max}\) to ensure that step size
adjustments are not overly aggressive.  This value is modified
according to the step and history,
\begin{gather}
\begin{split}\eta_\text{max} = \begin{cases}
  \text{etamx1}, & \quad\text{on the first step (default is 10000)}, \\
  \text{growth}, & \quad\text{on general steps (default is 20)}, \\
  1, & \quad\text{if the previous step had an error test failure}.
\end{cases}\end{split}\notag
\end{gather}
Here, the values of \emph{etamx1} and \emph{growth} may be modified by the user
in the functions {\hyperref[c_interface/User_callable:c.ARKodeSetMaxFirstGrowth]{\emph{\code{ARKodeSetMaxFirstGrowth()}}}} and
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxGrowth]{\emph{\code{ARKodeSetMaxGrowth()}}}} in C/C++, respectively, or through the
inputs \emph{ADAPT\_ETAMX1} and \emph{ADAPT\_GROWTH} to the function
{\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran.

A flowchart detailing how the time steps are modified at each
iteration to ensure solver convergence and successful steps is given
in the figure below.  Here, all norms correspond to the WRMS norm, and
the error adaptivity function \textbf{arkAdapt} is supplied by one of the
error control algorithms discussed in the subsections below.
\begin{figure}[htbp]
\centering

\scalebox{0.400000}{\includegraphics{time_adaptivity.png}}
\label{Mathematics:adaptivity-figure}\end{figure}

For some problems it may be preferrable to avoid small step size
adjustments.  This can be especially true for problems that construct
and factor the Newton Jacobian matrix \({\mathcal A}\) from
equation \eqref{Mathematics-NewtonMatrix} for either a direct solve, or as a
preconditioner for an iterative solve, where this construction is
computationally expensive, and where Newton convergence can be
seriously hindered through use of a somewhat incorrect
\({\mathcal A}\).  In these scenarios, the step is not changed
when \(\eta \in [\eta_L, \eta_U]\).  The default values for these
parameters are \(\eta_L = 1\) and \(\eta_U = 1.5\), though
these are modifiable through the function
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStepBounds]{\emph{\code{ARKodeSetFixedStepBounds()}}}} in C/C++, or through the input
\emph{ADAPT\_BOUNDS} to the function {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran.

The user may supply external bounds on the step sizes within ARKode,
through defining the values \(h_\text{min}\) and \(h_\text{max}\) with
the functions {\hyperref[c_interface/User_callable:c.ARKodeSetMinStep]{\emph{\code{ARKodeSetMinStep()}}}} and
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxStep]{\emph{\code{ARKodeSetMaxStep()}}}} in C/C++, or through the inputs
\emph{MIN\_STEP} and \emph{MAX\_STEP} to the function {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in
Fortran, respectively.  These default to \(h_\text{min}=0\) and
\(h_\text{max}=\infty\).

Normally, ARKode takes steps until a user-defined output value
\(t = t_\text{out}\) is overtaken, and then it computes
\(y(t_\text{out})\) by interpolation (using the same dense output
routines described in the section
{\hyperref[Mathematics:mathematics-predictors-max]{\emph{\DUspan{}{Maximum order predictor}}}}). However, a ``one step'' mode option
is available, where control returns to the calling program after each
step. There are also options to force ARKode not to integrate past a
given stopping point \(t = t_\text{stop}\), through the function
{\hyperref[c_interface/User_callable:c.ARKodeSetStopTime]{\emph{\code{ARKodeSetStopTime()}}}} in C/C++, or through the input
\emph{STOP\_TIME} to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran.


\subsection{Asymptotic error control}
\label{Mathematics:asymptotic-error-control}\label{Mathematics:mathematics-adaptivity-errorcontrol}
As mentioned above, ARKode adapts the step size in order to attain
local errors within desired tolerances of the true solution.  These
adaptivity algorithms estimate the prospective step size \(h'\)
based on the asymptotic local error estimates \eqref{Mathematics-AsymptoticErrors}.
We define the values \(\varepsilon_n\), \(\varepsilon_{n-1}\)
and \(\varepsilon_{n-2}\) as
\begin{gather}
\begin{split}\varepsilon_k &\ \equiv \ \|T_k\|
   \ = \ \beta \|y_k - \tilde{y}_k\|,\end{split}\notag
\end{gather}
corresponding to the local error estimates for three consecutive
steps, \(t_{n-3} \to t_{n-2} \to t_{n-1} \to t_n\).  These local
error history values are all initialized to 1.0 upon program
initialization, to accomodate the few initial time steps of a
calculation where some of these error estimates are undefined.  With
these estimates, ARKode implements a variety of error control
algorithms, as specified in the subsections below.


\subsubsection{PID controller}
\label{Mathematics:mathematics-adaptivity-errorcontrol-pid}\label{Mathematics:pid-controller}
This is the default time adaptivity controller used by ARKode.  It
derives from those found in \phantomsection\label{Mathematics:id8}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}, \phantomsection\label{Mathematics:id9}{\hyperref[References:s1998]{\emph{{[}S1998{]}}}}, \phantomsection\label{Mathematics:id10}{\hyperref[References:s2003]{\emph{{[}S2003{]}}}} and
\phantomsection\label{Mathematics:id11}{\hyperref[References:s2006]{\emph{{[}S2006{]}}}}.  It uses all three of the local error estimates
\(\varepsilon_n\), \(\varepsilon_{n-1}\) and
\(\varepsilon_{n-2}\) in determination of a prospective step size,
\begin{gather}
\begin{split}h' \;=\; h_n\; \varepsilon_n^{-k_1/p}\; \varepsilon_{n-1}^{k_2/p}\;
     \varepsilon_{n-2}^{-k_3/p},\end{split}\notag
\end{gather}
where the constants \(k_1\), \(k_2\) and \(k_3\) default
to 0.58, 0.21 and 0.1, respectively, though each may be changed via a
call to the C/C++ function {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}} in
C/C++, or to the Fortran function {\hyperref[f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD]{\emph{\code{FARKSETADAPTIVITYMETHOD()}}}}
in Fortran.  In this estimate, a floor of \(\varepsilon >
10^{-10}\) is enforced to avoid division-by-zero errors.


\subsubsection{PI controller}
\label{Mathematics:pi-controller}\label{Mathematics:mathematics-adaptivity-errorcontrol-pi}
Like with the previous method, the PI controller derives from those
found in \phantomsection\label{Mathematics:id12}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}, \phantomsection\label{Mathematics:id13}{\hyperref[References:s1998]{\emph{{[}S1998{]}}}}, \phantomsection\label{Mathematics:id14}{\hyperref[References:s2003]{\emph{{[}S2003{]}}}} and \phantomsection\label{Mathematics:id15}{\hyperref[References:s2006]{\emph{{[}S2006{]}}}}, but it differs in
that it only uses the two most recent step sizes in its adaptivity
algorithm,
\begin{gather}
\begin{split}h' \;=\; h_n\; \varepsilon_n^{-k_1/p}\; \varepsilon_{n-1}^{k_2/p}.\end{split}\notag
\end{gather}
Here, the default values of \(k_1\) and \(k_2\) default
to 0.8 and 0.31, respectively, though they may be changed via a
call to {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}} in C/C++, or
{\hyperref[f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD]{\emph{\code{FARKSETADAPTIVITYMETHOD()}}}} in Fortran.  As with the previous
controller, at initialization \(k_1 = k_2 = 1.0\) and the floor of
\(10^{-10}\) is enforced on the local error estimates.


\subsubsection{I controller}
\label{Mathematics:i-controller}\label{Mathematics:mathematics-adaptivity-errorcontrol-i}
The so-called I controller is the standard time adaptivity control
algorithm in use by most available ODE solvers.  It bases the
prospective time step estimate entirely off of the current local error
estimate,
\begin{gather}
\begin{split}h' \;=\; h_n\; \varepsilon_n^{-k_1/p}.\end{split}\notag
\end{gather}
By default, \(k_1=1\), but that may be overridden by the user with
the function {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}} in C/C++, or the
function {\hyperref[f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD]{\emph{\code{FARKSETADAPTIVITYMETHOD()}}}} in Fortran.


\subsubsection{Explicit Gustafsson controller}
\label{Mathematics:explicit-gustafsson-controller}\label{Mathematics:mathematics-adaptivity-errorcontrol-egus}
This step adaptivity algorithm was proposed in \phantomsection\label{Mathematics:id16}{\hyperref[References:g1991]{\emph{{[}G1991{]}}}}, and
is primarily useful in combination with explicit Runge-Kutta methods.
Using the notation of our earlier controllers, it has the form
\phantomsection\label{Mathematics:equation-expGus}\begin{gather}
\begin{split}h' \;=\; \begin{cases}
   h_1\; \varepsilon_1^{-1/p}, &\quad\text{on the first step}, \\
   h_n\; \varepsilon_n^{-k_1/p}\;
     \left(\varepsilon_n/\varepsilon_{n-1}\right)^{k_2/p}, &
   \quad\text{on subsequent steps}.
\end{cases}\end{split}\label{Mathematics-expGus}
\end{gather}
The default values of \(k_1\) and \(k_2\) are 0.367 and 0.268,
respectively, which may be changed by calling either
{\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}} in C/C++, or
{\hyperref[f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD]{\emph{\code{FARKSETADAPTIVITYMETHOD()}}}} in Fortran.


\subsubsection{Implicit Gustafsson controller}
\label{Mathematics:mathematics-adaptivity-errorcontrol-igus}\label{Mathematics:implicit-gustafsson-controller}
A version of the above controller suitable for implicit Runge-Kutta
methods was introduced in \phantomsection\label{Mathematics:id17}{\hyperref[References:g1994]{\emph{{[}G1994{]}}}}, and has the form
\phantomsection\label{Mathematics:equation-impGus}\begin{gather}
\begin{split}h' = \begin{cases}
   h_1 \varepsilon_1^{-1/p}, &\quad\text{on the first step}, \\
   h_n \left(h_n / h_{n-1}\right) \varepsilon_n^{-k_1/p}
     \left(\varepsilon_n/\varepsilon_{n-1}\right)^{-k_2/p}, &
   \quad\text{on subsequent steps}.
\end{cases}\end{split}\label{Mathematics-impGus}
\end{gather}
The algorithm parameters default to \(k_1 = 0.98\) and
\(k_2 = 0.95\), but may be modified by the user with
{\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}} in C/C++, or
{\hyperref[f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD]{\emph{\code{FARKSETADAPTIVITYMETHOD()}}}} in Fortran.


\subsubsection{ImEx Gustafsson controller}
\label{Mathematics:imex-gustafsson-controller}\label{Mathematics:mathematics-adaptivity-errorcontrol-iegus}
An ImEx version of these two preceding controllers is available in
ARKode.  This approach computes the estimates \(h'_1\) arising from
equation \eqref{Mathematics-expGus} and the estimate \(h'_2\) arising from
equation \eqref{Mathematics-impGus}, and selects
\begin{gather}
\begin{split}h' = \frac{h}{|h|}\min\left\{|h'_1|, |h'_2|\right\}.\end{split}\notag
\end{gather}
Here, equation \eqref{Mathematics-expGus} uses \(k_1\) and
\(k_2\) with default values of 0.367 and 0.268, while equation
\eqref{Mathematics-impGus} sets both parameters to the input \(k_3\) that
defaults to 0.95.  All three of these parameters may be modified with
the C/C++ function {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}} in C/C++, or
the Fortran function {\hyperref[f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD]{\emph{\code{FARKSETADAPTIVITYMETHOD()}}}} in Fortran.


\subsubsection{User-supplied controller}
\label{Mathematics:mathematics-adaptivity-errorcontrol-user}\label{Mathematics:user-supplied-controller}
Finally, ARKode allows the user to define their own time step
adaptivity function,
\begin{gather}
\begin{split}h' = H(y, t, h_n, h_{n-1}, h_{n-2}, \varepsilon_n, \varepsilon_{n-1}, \varepsilon_{n-2}, q, p),\end{split}\notag
\end{gather}
via a call to the C/C++ routine {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityFn]{\emph{\code{ARKodeSetAdaptivityFn()}}}} or
the Fortran routine {\hyperref[f_interface/Usage:f/_/FARKADAPTSET]{\emph{\code{FARKADAPTSET()}}}}.


\section{Explicit stability}
\label{Mathematics:mathematics-stability}\label{Mathematics:explicit-stability}
For problems that involve a nonzero explicit component,
\(f_E(t,y) \ne 0\), explicit and ImEx Runge-Kutta methods may
benefit from addition user-supplied information regarding the explicit
stability region.  All ARKode adaptivity methods utilize estimates of
the local error.  It is often the case that such local error control
will be sufficient for method stability, since unstable steps will
typically exceed the error control tolerances.  However, for problems
in which \(f_E(t,y)\) includes even moderately stiff components,
and especially for higher-order integration methods, it may occur that
a significant number of attempted steps will exceed the error
tolerances.  While these steps will automatically be recomputed, such
trial-and-error may be costlier than desired.  In these scenarios, a
stability-based time step controller may also be useful.

Since the explicit stability region for any method depends on the
problem under consideration, as it results from the eigenvalues of the
linearized operator \(\frac{\partial f_E}{\partial y}\),
information on the maximum stable step size is not computed internally
within ARKode.  However, for many problems such information is
readily available.  For example, in an advection-diffusion calculation,
\(f_I\) may contain the stiff diffusive components and
\(f_E\) may contain the comparably nonstiff advection terms.  In
this scenario, an explicitly stable step \(h_\text{exp}\) would be
predicted as one satisfying the Courant-Friedrichs-Lewy (CFL)
stability condition,
\begin{gather}
\begin{split}|h_\text{exp}| < \frac{\Delta x}{|\lambda|}\end{split}\notag
\end{gather}
where \(\Delta x\) is the spatial mesh size and \(\lambda\) is
the fastest advective wave speed.

In these scenarios, a user may supply a routine to predict this
maximum explicitly stable step size, \(|h_\text{exp}|\), by calling the
C/C++ function {\hyperref[c_interface/User_callable:c.ARKodeSetStabilityFn]{\emph{\code{ARKodeSetStabilityFn()}}}} or the Fortran
function {\hyperref[f_interface/Usage:f/_/FARKEXPSTABSET]{\emph{\code{FARKEXPSTABSET()}}}}.  If a value for
\(|h_\text{exp}|\) is supplied, it is compared against the value
resulting from the local error controller, \(|h_\text{acc}|\), and
the step used by ARKode will satisfy
\begin{gather}
\begin{split}h' = \frac{h}{|h|}\min\{c\, |h_\text{exp}|,\, |h_\text{acc}|\}.\end{split}\notag
\end{gather}
Here the explicit stability step factor (often called the ``CFL
factor'') \(c>0\) may be modified through the function
{\hyperref[c_interface/User_callable:c.ARKodeSetCFLFraction]{\emph{\code{ARKodeSetCFLFraction()}}}} in C/C++, or through the input
\emph{ADAPT\_CFL} to the function {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} in Fortran, and has
a default value of \(1/2\).


\subsection{Fixed time stepping}
\label{Mathematics:mathematics-fixedstep}\label{Mathematics:fixed-time-stepping}
While ARKode is designed for time step adaptivity, it may additionally
be called in ``fixed-step'' mode, typically used for debugging purposes
or for verification against hand-coded Runge-Kutta methods.  In this
mode, all time step adaptivity is disabled:
\begin{itemize}
\item {} 
temporal error control is disabled,

\item {} 
nonlinear or linear solver non-convergence results in an error
(instead of a step size adjustment),

\item {} 
no check against an explicit stability condition is performed.

\end{itemize}

Additional information on this mode is provided in the section
{\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}}.


\section{Mass matrix solver}
\label{Mathematics:mass-matrix-solver}\label{Mathematics:mathematics-masssolve}
Within the algorithms described above, there are three locations where a
linear solve of the form
\begin{gather}
\begin{split}M x = b\end{split}\notag
\end{gather}
is required: (a) in constructing the time-evolved solution
\(y_n\), (b) in estimating the local temporal truncation error,
and (c) in constructing predictors for the implicit solver iteration
(see section {\hyperref[Mathematics:mathematics-predictors-max]{\emph{\DUspan{}{Maximum order predictor}}}}).  Specifically, to
construct the time-evolved solution \(y_n\) from equation
\eqref{Mathematics-ARK} we must solve
\begin{gather}
\begin{split}&M y_n \ = \ M y_{n-1} + h_n \sum_{i=1}^{s} \left( b^E_i f_E(t^E_{n,i}, z_i)
              + b^I_i f_I(t^I_{n,i}, z_i)\right), \\
\Leftrightarrow \qquad & \\
&M (y_n -y_{n-1}) \ = \ h_n \sum_{i=1}^{s} \left(b^E_i f_E(t^E_{n,i}, z_i)
              + b^I_i f_I(t^I_{n,i}, z_i)\right), \\
\Leftrightarrow \qquad & \\
&M \nu \ = \ h_n \sum_{i=1}^{s} \left(b^E_i f_E(t^E_{n,i}, z_i)
              + b^I_i f_I(t^I_{n,i}, z_i)\right),\end{split}\notag
\end{gather}
for the update \(\nu = y_n - y_{n-1}\).  Similarly, in computing
the local temporal error estimate \(T_n\) from equation \eqref{Mathematics-LTE}
we must solve systems of the form
\begin{gather}
\begin{split}M\, T_n = h \sum_{i=1}^{s} \left[
\left(b^E_i - \tilde{b}^E_i\right) f_E(t^E_{n,i}, z_i) +
\left(b^I_i - \tilde{b}^I_i\right) f_I(t^I_{n,i}, z_i) \right].\end{split}\notag
\end{gather}
Lastly, in constructing dense output and implicit predictors of order
2 or higher (as in the section {\hyperref[Mathematics:mathematics-predictors-max]{\emph{\DUspan{}{Maximum order predictor}}}} above),
we must compute the derivative information \(f_k\) from the equation
\begin{gather}
\begin{split}M f_k = f_E(t_k, y_k) + f_I(t_k, y_k).\end{split}\notag
\end{gather}
Of course, for problems in which \(M=I\) these solves are not
required; however for problems with non-identity \(M\), ARKode may
use either an iterative linear solver or a direct linear solver, in the
same manner as described in the section {\hyperref[Mathematics:mathematics-linear]{\emph{\DUspan{}{Linear solver methods}}}} for solving
the linear Newton systems.  We note that at present, the matrix
\(M\) may depend on time \(t\) but must be independent of the
solution \(y\), since we assume that each of the above systems are
linear.

At present, for DIRK and ARK problems using a direct solver for
the Newton nonlinear iterations, the type of matrix (dense, band or
sparse) for the Newton systems \({\mathcal A}\delta = -G\) must
match the type of linear solver used for these mass-matrix systems,
since \(M\) is included inside \({\mathcal A}\).  When direct
methods are employed, the user must supply a routine to compute
\(M\) in either dense, band or sparse form to match the
structure of \({\mathcal A}\), with a user-supplied routine of type
{\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}.

When iterative methods are used, a routine must be supplied to perform
the mass-matrix-vector product, \(Mv\), through a call to the
routine {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{\code{ARKSpilsMassTimesVecFn()}}}}.  As with iterative solvers
for the Newton systems, preconditioning may be applied to aid in
solution of the mass matrix systems \(Mx=b\).  When using an
iterative mass matrix linear solver, we require that the norm of the
preconditioned linear residual satisfies
\phantomsection\label{Mathematics:equation-MassLinearTolerance}\begin{gather}
\begin{split}\|r\| \le \epsilon_L \epsilon,\end{split}\label{Mathematics-MassLinearTolerance}
\end{gather}
where again, \(\epsilon\) is the nonlinear solver tolerance
parameter from \eqref{Mathematics-NonlinearTolerance}.  When using iterative system
and mass matrix linear solvers, \(\epsilon_L\) may be specified
separately for both tolerances \eqref{Mathematics-LinearTolerance} and
\eqref{Mathematics-MassLinearTolerance}; the mass matrix linear solver value of
\(\epsilon_L\) may be modified using
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassEpsLin]{\emph{\code{ARKSpilsSetMassEpsLin()}}}} in C/C++, or
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASSEPSLIN]{\emph{\code{FARKSPILSSETMASSEPSLIN()}}}} in Fortran.


\section{Rootfinding}
\label{Mathematics:mathematics-rootfinding}\label{Mathematics:rootfinding}
The ARKode solver has been augmented to include a rootfinding
feature. This means that, while integrating the IVP \eqref{Mathematics-IVP}, ARKode
can also find the roots of a set of user-defined functions
\(g_i(t,y)\) that depend on \(t\) and the solution vector
\(y = y(t)\). The number of these root functions is arbitrary, and
if more than one \(g_i\) is found to have a root in any given
interval, the various root locations are found and reported in the
order that they occur on the \(t\) axis, in the direction of
integration.

Generally, this rootfinding feature finds only roots of odd
multiplicity, corresponding to changes in sign of \(g_i(t,
y(t))\), denoted \(g_i(t)\) for short. If a user root function has
a root of even multiplicity (no sign change), it will probably be
missed by ARKode. If such a root is desired, the user should
reformulate the root function so that it changes sign at the desired
root.

The basic scheme used is to check for sign changes of any
\(g_i(t)\) over each time step taken, and then (when a sign change
is found) to home in on the root (or roots) with a modified secant
method \phantomsection\label{Mathematics:id18}{\hyperref[References:hs1980]{\emph{{[}HS1980{]}}}}.  In addition, each time \(g\) is
computed, ARKode checks to see if \(g_i(t) = 0\) exactly, and if
so it reports this as a root. However, if an exact zero of any
\(g_i\) is found at a point \(t\), ARKode computes
\(g(t+\delta)\) for a small increment \(\delta\), slightly
further in the direction of integration, and if any
\(g_i(t+\delta) = 0\) also, ARKode stops and reports an
error. This way, each time ARKode takes a time step, it is guaranteed
that the values of all \(g_i\) are nonzero at some past value of
\(t\), beyond which a search for roots is to be done.

At any given time in the course of the time-stepping, after suitable
checking and adjusting has been done, ARKode has an interval
\((t_\text{lo}, t_\text{hi}]\) in which roots of the \(g_i(t)\) are to
be sought, such that \(t_\text{hi}\) is further ahead in the direction
of integration, and all \(g_i(t_\text{lo}) \ne 0\). The endpoint
\(t_\text{hi}\) is either \(t_n\), the end of the time step last
taken, or the next requested output time \(t_\text{out}\) if this comes
sooner. The endpoint \(t_\text{lo}\) is either \(t_{n-1}\), or the
last output time \(t_\text{out}\) (if this occurred within the last
step), or the last root location (if a root was just located within
this step), possibly adjusted slightly toward \(t_n\) if an exact
zero was found. The algorithm checks \(g(t_\text{hi})\) for zeros, and
it checks for sign changes in \((t_\text{lo}, t_\text{hi})\). If no sign
changes are found, then either a root is reported (if some
\(g_i(t_\text{hi}) = 0\)) or we proceed to the next time interval
(starting at \(t_\text{hi}\)). If one or more sign changes were found,
then a loop is entered to locate the root to within a rather tight
tolerance, given by
\begin{gather}
\begin{split}\tau = 100\, U\, (|t_n| + |h|)\qquad (\text{where}\; U = \text{unit roundoff}).\end{split}\notag
\end{gather}
Whenever sign changes are seen in two or more root functions, the one
deemed most likely to have its root occur first is the one with the
largest value of
\(\left|g_i(t_\text{hi})\right| / \left| g_i(t_\text{hi}) - g_i(t_\text{lo})\right|\),
corresponding to the closest to \(t_\text{lo}\) of the secant method
values. At each pass through the loop, a new value \(t_\text{mid}\) is
set, strictly within the search interval, and the values of
\(g_i(t_\text{mid})\) are checked. Then either \(t_\text{lo}\) or
\(t_\text{hi}\) is reset to \(t_\text{mid}\) according to which
subinterval is found to have the sign change. If there is none in
\((t_\text{lo}, t_\text{mid})\) but some \(g_i(t_\text{mid}) = 0\), then that
root is reported. The loop continues until \(\left|t_\text{hi} -
t_\text{lo} \right| < \tau\), and then the reported root location is
\(t_\text{hi}\).  In the loop to locate the root of \(g_i(t)\), the
formula for \(t_\text{mid}\) is
\begin{gather}
\begin{split}t_\text{mid} = t_\text{hi} -
\frac{g_i(t_\text{hi}) (t_\text{hi} - t_\text{lo})}{g_i(t_\text{hi}) - \alpha g_i(t_\text{lo})} ,\end{split}\notag
\end{gather}
where \(\alpha\) is a weight parameter. On the first two passes
through the loop, \(\alpha\) is set to 1, making \(t_\text{mid}\)
the secant method value. Thereafter, \(\alpha\) is reset according
to the side of the subinterval (low vs high, i.e. toward
\(t_\text{lo}\) vs toward \(t_\text{hi}\)) in which the sign change was
found in the previous two passes. If the two sides were opposite,
\(\alpha\) is set to 1. If the two sides were the same, \(\alpha\)
is halved (if on the low side) or doubled (if on the high side). The
value of \(t_\text{mid}\) is closer to \(t_\text{lo}\) when
\(\alpha < 1\) and closer to \(t_\text{hi}\) when \(\alpha > 1\).
If the above value of \(t_\text{mid}\) is within \(\tau /2\) of
\(t_\text{lo}\) or \(t_\text{hi}\), it is adjusted inward, such that its
fractional distance from the endpoint (relative to the interval size)
is between 0.1 and 0.5 (with 0.5 being the midpoint), and the actual
distance from the endpoint is at least \(\tau/2\).

Finally, we note that when running in parallel, the ARKode rootfinding
module assumes that the entire set of root defining functions
\(g_i(t,y)\) is replicated on every MPI task.  Since in these
cases the vector \(y\) is distributed across tasks, it is the
user's responsibility to perform any necessary inter-task
communication to ensure that \(g_i(t,y)\) is identical on each task.


\chapter{Code Organization}
\label{Organization:organization}\label{Organization::doc}\label{Organization:code-organization}
The family of solvers referred to as SUNDIALS consists of the solvers
CVODE and ARKode (for ODE systems), KINSOL (for nonlinear algebraic
systems), and IDA (for differential-algebraic systems).  In addition,
SUNDIALS also includes variants of CVODE and IDA with sensitivity analysis
capabilities (using either forward or adjoint methods), called CVODES and
IDAS, respectively.

The various solvers of this family share many subordinate modules.
For this reason, it is organized as a family, with a directory
structure that exploits that sharing (see the following Figures
{\hyperref[Organization:sunorg1]{\emph{\DUspan{}{SUNDIALS organization}}}}, {\hyperref[Organization:sunorg2]{\emph{\DUspan{}{SUNDIALS tree}}}}, and {\hyperref[Organization:sunorg3]{\emph{\DUspan{}{SUNDIALS examples}}}}).  The following is a list of the solver packages presently
available, and the basic functionality of each:
\begin{itemize}
\item {} 
CVODE, a linear multistep solver for stiff and nonstiff ODE systems
\(\dot{y} = f(t,y)\) based on Adams and BDF methods;

\item {} 
CVODES, a linear multistep solver for stiff and nonstiff ODEs with
sensitivity analysis capabilities;

\item {} 
ARKode, a solver for ODE systems \(M \dot{y} = f_E(t,y) + f_I(t,y)\)
based on additive Runge-Kutta methods;

\item {} 
IDA, a linear multistep solver for differential-algebraic systems
\(F(t,y,\dot{y}) = 0\) based on BDF methods;

\item {} 
IDAS, a linear multistep solver for differential-algebraic systems with sensitivity
analysis capabilities;

\item {} 
KINSOL, a solver for nonlinear algebraic systems \(F(u) = 0\).

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.750000}{\includegraphics{sunorg1.png}}
\caption{\emph{SUNDIALS organization}: High-level diagram of the SUNDIALS structure}\label{Organization:sunorg1}\end{figure}
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.750000}{\includegraphics{sunorg2.png}}
\caption{\emph{SUNDIALS tree}: Directory structure of the source tree.}\label{Organization:sunorg2}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.750000}{\includegraphics{sunorg3.png}}
\caption{\emph{SUNDIALS examples}: Directory structure of the examples.}\label{Organization:sunorg3}\end{figure}


\section{ARKode organization}
\label{Organization:arkode-organization}
The ARKode package is written in the ANSI C language.  The
following summarizes the basic structure of the package, although
knowledge of this structure is not necessary for its use.

The overall organization of the ARKode package is shown in Figure
{\hyperref[Organization:arkorg]{\emph{\DUspan{}{ARKode organization}}}}.  The central integration module,
implemented in the files \code{arkode.h}, \code{arkode\_impl.h} and
\code{arkode.c}, deals with the evaluation of integration stages, the
nonlinear solver \((\text{if}\; f_I(t,y)\ne 0)\), estimation of
the local truncation error, selection of step size, and interpolation
to user output points, among other issues.  ARKode currently supports
modified Newton, inexact Newton, and accelerated fixed-point solvers
for these implicit problems.  However, when using the Newton-based
iterations, or when using a non-identity mass matrix \(M\ne I\),
ARKode has flexibility in the choice of method used to solve the
linear sub-systems that arise.  Therefore, for any user problem
invoking the Newton solvers, or any user problem with \(M\ne I\),
one (or more) of the linear system solver modules should be specified
by the user, which is then invoked as needed during the integration
process.
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{arkorg.png}
\caption{\emph{ARKode organization}: Overall structure of the ARKode package.
Modules specific to ARKode begin with ``ARK'' (ARKDLS, ARKSPILS,
ARKBBDPRE), all other items correspond to generic solver and
auxiliary modules.  Note also that the LAPACK, KLU and SuperLU\_MT
support is through interfaces to external packages.  Users will
need to download and compile those packages independently.}\label{Organization:arkorg}\end{figure}

For solving these linear systems, ARKode presently includes two linear
solver interfaces.  The \emph{direct} linear solver interface, ARKDLS,
supports SUNLINSOL implementations with type \code{SUNLINSOL\_DIRECT} (see
{\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}).  These linear solvers utilize direct methods for
the solution of linear systems stored using one of the SUNDIALS generic
SUNMATRIX implementations (dense, banded or sparse; see
{\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}}).  It is assumed that the dominant cost for such
solvers occurs in factorization of the linear system matrix \(A\),
so ARKode utilizes these solvers within its modified Newton nonlinear solve.
The \emph{iterative} linear solver interface, ARKSPILS, supports SUNLINSOL
implementations with type \code{SUNLINSOL\_ITERATIVE} (see
{\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}).  These linear solvers utilize scaled preconditioned
iterative methods.  It is assumed that these methods are implemented
in a ``matrix-free'' manner, wherein only the action of the
matrix-vector product \(Av\) is required.  Since ARKode can
operate on any valid SUNLINSOL implementation of \code{SUNLINSOL\_DIRECT}
or \code{SUNLINSOL\_ITERATIVE} types, the set of linear solver modules
available to ARKode will expand as new SUNLINSOL modules are developed.

Within the ARKDLS interface, the package includes algorithms for the
approximation of dense or banded Jacobians through difference
quotients, but the user also has the option of supplying the Jacobian
(or an approximation to it) directly.  This user-supplied
routine is required when using sparse Jacobian matrices, since
standard difference quotient approximations do not leverage the
inherent sparsity of the problem.  Additionally, when solving problems
with non-identity mass matrices using the ARKDLS interface, a
user-supplied routine is required for providing the mass matrix.

Within the ARKSPILS interface, the package includes an algorithm for
the approximation by difference quotients of the product
\(Av\). Again, the user has the option of providing routines for
this operation, in two phases: setup (preprocessing of Jacobian data)
and multiplication.  When using ARKSPILS to solve problems with
non-identity mass matrices, corresponding user-supplied routines for
computing the product \(Mv\) are required.  For preconditioned
iterative methods for either the system or mass matrix solves, the
preconditioning must be supplied by the user, again in two phases:
setup and solve.  While there is no default choice of preconditioner
analogous to the difference-quotient approximation in the direct case,
the references \phantomsection\label{Organization:id1}{\hyperref[References:bh1989]{\emph{{[}BH1989{]}}}} and \phantomsection\label{Organization:id2}{\hyperref[References:b1992]{\emph{{[}B1992{]}}}}, together with the example and
demonstration programs included with ARKode and CVODE, offer
considerable assistance in building simple preconditioners.

Each ARKode linear solver interface consists of four primary phases,
devoted to
\begin{enumerate}
\item {} 
memory allocation and initialization,

\item {} 
setup of the matrix/preconditioner data involved,

\item {} 
solution of the system, and

\item {} 
freeing of memory.

\end{enumerate}

The setup and solution phases are separate because the evaluation of
Jacobians and preconditioners is done only periodically during the
integration process, and only as required to achieve convergence.

ARKode also provides two rudimentary preconditioner modules, for
use with any of the Krylov iterative linear solvers.  The first,
ARKBANDPRE is intended to be used with the serial or threaded vector
data structures (NVECTOR\_SERIAL, NVECTOR\_OPENMP and NVECTOR\_PTHREADS),
and provides a banded difference-quotient approximation to the
Jacobian as the preconditioner, with corresponding setup and solve
routines.  The second preconditioner module, ARKBBDPRE, is intended to
work with the parallel vector data structure, NVECTOR\_PARALLEL, and
generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix owned by a single processor.

All state information used by ARKode to solve a given problem is
saved in a single opaque memory structure, and a pointer to that
structure is returned to the user.  For C and C++ applications there
is no global data in the ARKode package, and so in this respect it is
reentrant.  State information specific to the linear solver is saved
in a separate data structure, a pointer to which resides in the ARKode
memory structure.  We note that the ARKode Fortran interface, however,
currently uses global variables.


\chapter{Using ARKode for C and C++ Applications}
\label{c_interface/index::doc}\label{c_interface/index:using-arkode-for-c-and-c-applications}\label{c_interface/index:cinterface}
This chapter is concerned with the use of ARKode for the solution
of initial value problems (IVPs) in a C or C++ language setting.  The
following sections treat the header files and the layout of the user's
main program, and provide descriptions of the ARKode user-callable
functions and user-supplied functions.

The example programs described in the companion document \phantomsection\label{c_interface/index:id1}{\hyperref[References:r2013]{\emph{{[}R2013{]}}}} may
be helpful. Those codes may be used as templates for new codes and are
included in the ARKode package \code{examples} subdirectory.

Users with applications written in Fortran should see the chapter
{\hyperref[f_interface/index:fortraninterface]{\emph{\DUspan{}{FARKODE, an Interface Module for FORTRAN Applications}}}}, which describes the Fortran/C interface
module, and may look to the Fortran example programs also described in
the companion document \phantomsection\label{c_interface/index:id2}{\hyperref[References:r2013]{\emph{{[}R2013{]}}}}.  These codes are also located in the
ARKode package \code{examples} directory.

The user should be aware that not all SUNLINSOL, SUNMATRIX
preconditioning modules are compatible with all NVECTOR
implementations.  Details on compatability are given in the
documentation for each SUNMATRIX (see {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}}) and each
SUNLINSOL module (see {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}). For example, NVECTOR\_PARALLEL
is not compatible with the dense, banded, or sparse SUNMATRIX types,
or with the corresponding dense, banded, or sparse SUNLINSOL modules.
Please check the sections {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}} and {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}} to
verify compatability between these modules.  In addition to that
documentation, we note that the ARKBANDPRE preconditioning module is
only compatible with the NVECTOR\_SERIAL, NVECTOR\_OPENMP or
NVECTOR\_PTHREADS vector implementations, and the preconditioner module
ARKBBDPRE can only be used with NVECTOR\_PARALLEL.

ARKode uses various constants for both input and output. These are
defined as needed in this chapter, but for convenience the full list
is provided separately in the section {\hyperref[Constants:constants]{\emph{\DUspan{}{Appendix: ARKode Constants}}}}.

The relevant information on using ARKode's C and C++ interfaces is
detailed in the following sub-sections:


\section{Access to library and header files}
\label{c_interface/General:access-to-library-and-header-files}\label{c_interface/General:cinterface-headers}\label{c_interface/General::doc}
At this point, it is assumed that the installation of ARKode,
following the procedure described in the section {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}},
has been completed successfully.

Regardless of where the user's application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
ARKode. The relevant library files are
\begin{itemize}
\item {} 
\code{libdir/libsundials\_arkode.lib},

\item {} 
\code{libdir/libsundials\_nvec*.lib} (one or two files),

\end{itemize}

where the file extension \code{.lib} is typically \code{.so} for shared
libraries and \code{.a} for static libraries.  The relevant header files
are located in the subdirectories
\begin{itemize}
\item {} 
\code{incdir/include/arkode}

\item {} 
\code{incdir/include/sundials}

\item {} 
\code{incdir/include/nvector}

\item {} 
\code{incdir/include/sunmatrix}

\item {} 
\code{incdir/include/sunlinsol}

\end{itemize}

The directories \code{libdir} and \code{incdir} are the installation library
and include directories, respectively.  For a default installation,
these are \code{instdir/lib} and \code{instdir/include}, respectively, where
\code{instdir} is the directory where SUNDIALS was installed (see the
section {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}} for further details).


\section{Data Types}
\label{c_interface/General:cinterface-datatypes}\label{c_interface/General:data-types}
The \code{sundials\_types.h} file contains the definition of the variable
type \code{realtype}, which is used by the SUNDIALS solvers for all
floating-point data, the definition of the integer type
\code{sunindextype}, which is used for vector and matrix indices, and
\code{booleantype}, which is used for certain logic operations within
SUNDIALS.


\subsection{Floating point types}
\label{c_interface/General:floating-point-types}
The type ``\index{realtype}realtype'' can be set to
\code{float}, \code{double}, or \code{long double}, depending on how SUNDIALS
was installed (with the default being \code{double}). The user can change
the precision of the SUNDIALS solvers' floating-point arithmetic at the
configuration stage (see the section {\hyperref[Install:installation-cmake-options]{\emph{\DUspan{}{Configuration options (Unix/Linux)}}}}).

Additionally, based on the current precision, \code{sundials\_types.h}
defines the values \index{BIG\_REAL}BIG\_REAL to be the largest value
representable as a \code{realtype}, \index{SMALL\_REAL}SMALL\_REAL to be the
smallest positive value representable as a \code{realtype}, and
\index{UNIT\_ROUNDOFF}UNIT\_ROUNDOFF to be the smallest realtype number,
\(\varepsilon\), such that \(1.0 + \varepsilon \ne 1.0\).

Within SUNDIALS, real constants may be set to have the appropriate
precision by way of a macro called \index{RCONST}RCONST.  It is this macro
that needs the ability to branch on the definition \code{realtype}.  In
ANSI C, a floating-point constant with no suffix is stored as a
\code{double}. Placing the suffix ``F'' at the end of a floating point
constant makes it a \code{float}, whereas using the suffix ``L'' makes it a
\code{long double}. For example,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define A 1.0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define B 1.0F}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define C 1.0L}
\end{Verbatim}

defines \code{A} to be a \code{double} constant equal to 1.0, \code{B} to be a
\code{float} constant equal to 1.0, and \code{C} to be a \code{long double} constant
equal to 1.0.  The macro call \code{RCONST(1.0)} automatically expands to
1.0 if \code{realtype} is \code{double}, to \code{1.0F} if \code{realtype} is \code{float}, or
to \code{1.0L} if \code{realtype} is \code{long double}. SUNDIALS uses the \code{RCONST}
macro internally to declare all of its floating-point constants.

A user program which uses the type \code{realtype} and the \code{RCONST} macro
to handle floating-point constants is precision-independent, except for
any calls to precision-specific standard math library functions.
Users can, however, use the types \code{double}, \code{float}, or \code{long
double} in their code (assuming that this usage is consistent with
the size of \code{realtype} values that are passed to and from SUNDIALS).
Thus, a previously existing piece of ANSI C code can use SUNDIALS
without modifying the code to use \code{realtype}, so long as the
SUNDIALS libraries have been compiled using the same precision (for
details see the section {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}}).


\subsection{Integer types used for vector and matrix indices}
\label{c_interface/General:integer-types-used-for-vector-and-matrix-indices}
The type \code{sunindextype} can be either a 32- or 64-bit \emph{signed} integer.
The default is the portable \code{int64\_t} type, and the user can change it
to \code{int32\_t} at the configuration stage. The configuration system
will detect if the compiler does not support portable types, and will
replace \code{int32\_t} and \code{int64\_t} with \code{int} and \code{long int},
respectively, to ensure use of the desired sizes on Linux, Mac OS X, and Windows
platforms. SUNDIALS currently does not support \emph{unsigned} integer types
for vector and matrix indices, although these could be added in the future if there
is sufficient demand.

A user program which uses \code{sunindextype} to handle vector and matrix indices
will work with both index storage types except for any calls to index storage-specific
external libraries. (Our \code{C} and \code{C++} example programs use \code{sunindextype}.)
Users can, however, use any one of \code{int}, \code{long int}, \code{int32\_t}, \code{int64\_t} or
\code{long long int} in their code, assuming that this usage is consistent with the typedef
for \code{sunindextype} on their architecture). Thus, a previously existing piece of ANSI
C code can use SUNDIALS without modifying the code to use \code{sunindextype},
so long as the SUNDIALS libraries use the appropriate index storage type (for details
see the section {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}}).


\section{Header Files}
\label{c_interface/General:header-files}
The calling program must include several header files so that various
macros and data types can be used. The header file that is always
required is:
\begin{itemize}
\item {} 
\code{arkode/arkode.h}, the main header file for ARKode, which defines the
several types and various constants, and includes function
prototypes.

\end{itemize}

Note that \code{arkode.h} includes \code{sundials\_types.h} directly, which
defines the types \code{realtype},  \code{sunindextype} and \code{booleantype}
and the constants \code{SUNFALSE} and \code{SUNTRUE}, so a user program does
not need to include \code{sundials\_types.h} directly.

The calling program must also include an NVECTOR implementation
header file, of the form \code{nvector/nvector\_***.h}.  See the section
{\hyperref[nvectors/index:nvectors]{\emph{\DUspan{}{Vector Data Structures}}}} for details for the appropriate name.  This file in
turn includes the header file \code{sundials\_nvector.h} which defines the
abstract \code{N\_Vector} data type.

If the user includes a non-trivial implicit component to their
ODE system, then each time step will require a nonlinear solver for
the resulting systems of equations.  ARKode allows an accelerated
fixed point iteration and Newton-based iterations for this solver; if
a Newton method is used then a linear solver module header file may
also be required.  Similarly, if the ODE system
\begin{gather}
\begin{split}M y' = f_I(t,y) + f_E(t,y)\end{split}\notag
\end{gather}
involves a non-identity mass matrix \(M\ne I\), then each time
step will require a linear solver for systems of the form
\(Mx=b\).  The header files corresponding to the various linear
solver interfaces and linear solver modules available for use with
ARKode for either the Newton solver or for mass-matrix solves, are:
\begin{itemize}
\item {} 
\code{arkode/arkode\_direct.h}, which is used with the ARKDLS direct
linear solver interface to access direct solvers with the following
header files:
\begin{itemize}
\item {} 
\code{sunlinsol/sunlinsol\_dense.h},
which is used with the dense linear solver module,
SUNLINSOL\_DENSE;

\item {} 
\code{sunlinsol/sunlinsol\_band.h},
which is used with the banded linear solver module,
SUNLINSOL\_BAND;

\item {} 
\code{sunlinsol/sunlinsol\_lapackdense.h},
which is used with the LAPACK dense linear solver interface module,
SUNLINSOL\_LAPACKDENSE;

\item {} 
\code{sunlinsol/sunlinsol\_lapackband.h},
which is used with the LAPACK banded linear solver interface module,
SUNLINSOL\_LAPACKBAND;

\item {} 
\code{sunlinsol/sunlinsol\_klu.h},
which is used with the \{klu\} sparse linear solver interface module,
SUNLINSOL\_KLU;

\item {} 
\code{sunlinsol/sunlinsol\_superlumt.h},
which is used with the SuperLU\_MT sparse linear solver interface
module, SUNLINSOL\_SUPERLUMT;

\end{itemize}

\item {} 
\code{arkode/arkode\_spils.h}, which is used with the ARKSPILS iterative
linear solver interface to access iterative solvers with the
following header files:
\begin{itemize}
\item {} 
\code{sunlinsol/sunlinsol\_spgmr.h},
which is used with the scaled, preconditioned GMRES Krylov linear
solver module, SUNLINSOL\_SPGMR;

\item {} 
\code{sunlinsol/sunlinsol\_spfgmr.h},
which is used with the scaled, preconditioned FGMRES Krylov linear
solver module, SUNLINSOL\_SPFGMR;

\item {} 
\code{sunlinsol/sunlinsol\_spbcgs.h},
which is used with the scaled, preconditioned Bi-CGStab Krylov
linear solver module, SUNLINSOL\_SPBCGS;

\item {} 
\code{sunlinsol/sunlinsol\_sptfqmr.h},
which is used with the scaled, preconditioned TFQMR Krylov linear
solver module, SUNLINSOL\_SPTFQMR;

\item {} 
\code{sunlinsol/sunlinsol\_pcg.h},
which is used with the scaled, preconditioned CG Krylov linear
solver module, SUNLINSOL\_PCG;

\end{itemize}

\end{itemize}

The header files for the SUNLINSOL\_DENSE and SUNLINSOL\_LAPACKDENSE
linear solver modules include the file
\code{sunmatrix/sunmatrix\_dense.h}, which defines the SUNMATRIX\_DENSE
matrix module, as well as various functions and macros for acting on
such matrices.

The header files for the SUNLINSOL\_BAND and SUNLINSOL\_LAPACKBAND
linear solver modules include the file \code{sunmatrix/sunmatrix\_band.h},
which defines the SUNMATRIX\_BAND matrix module, as well as various
functions and macros for acting on such matrices.

The header files for the SUNLINSOL\_KLU and SUNLINSOL\_SUPERLUMT linear
solver modules include the file \code{sunmatrix/sunmatrix\_sparse.h},
which defines the SUNMATRIX\_SPARSE matrix module, as well as various
functions and macros for acting on such matrices.

The header files for the Krylov iterative solvers include the file
\code{sundials/sundials\_iterative.h}, which enumerates the
preconditioning type and (for the SPGMR and SPFGMR solvers) the
choices for the Gram-Schmidt orthogonalization process.

Other headers may be needed, according to the choice of
preconditioner, etc.  For example, if preconditioning for an iterative
linear solver were performed using a block-diagonal
matrix, the header \code{sundials/sundials\_dense.h} may need to be
included for access to the underlying generic dense matrix arithmetic
routines used in the preconditioner solve.


\section{A skeleton of the user's main program}
\label{c_interface/Skeleton::doc}\label{c_interface/Skeleton:a-skeleton-of-the-user-s-main-program}\label{c_interface/Skeleton:cinterface-skeleton}
The following is a skeleton of the user's main program (or calling
program) for the integration of an ODE IVP.  Most of the steps are
independent of the NVECTOR, SUNMATRIX, and SUNLINSOL implementations
used.  For the steps that are not, refer to the sections
{\hyperref[nvectors/index:nvectors]{\emph{\DUspan{}{Vector Data Structures}}}}, {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}}  and {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}} for the
specific name of the function to be called or macro to be referenced.

\index{User main program}\begin{enumerate}
\item {} 
Initialize parallel or multi-threaded environment, if appropriate.

For example, call \code{MPI\_Init} to initialize MPI if used, or set
\code{num\_threads}, the number of threads to use within the threaded
vector functions, if used.

\item {} 
Set problem dimensions, etc.

This generally includes the problem size, \code{N}, and may include
the local vector length \code{Nlocal}.

\begin{notice}{note}{Note:}
The variables \code{N} and \code{Nlocal} should be of type
\code{sunindextype}.
\end{notice}

\item {} 
Set vector of initial values

To set the vector \code{y0} of initial values, use the appropriate
functions defined by the particular NVECTOR implementation.

For native SUNDIALS vector implementations (except the CUDA and
RAJA based ones), use a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{ydata}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

if the \code{realtype} array \code{ydata} containing the initial values of
\(y\) already exists.  Otherwise, create a new vector by making
a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VNew\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and then set its elements by accessing the underlying data where it
is located with a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ydata} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{y0}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

See the sections {\hyperref[nvectors/NVector_Serial:nvectors-nvserial]{\emph{\DUspan{}{The NVECTOR\_SERIAL Module}}}} through
{\hyperref[nvectors/NVector_Pthreads:nvectors-pthreads]{\emph{\DUspan{}{The NVECTOR\_PTHREADS Module}}}} for details.

For the HYPRE and PETSc vector wrappers, first create and initialize
the underlying vector, and then create the NVECTOR wrapper with a call
of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{yvec}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

where \code{yvec} is a HYPRE or PETSc vector.  Note that calls like
\code{N\_VNew\_***(...)} and \code{N\_VGetArrayPointer\_***(...)} are not
available for these vector wrappers.  See the sections
{\hyperref[nvectors/NVector_ParHyp:nvectors-parhyp]{\emph{\DUspan{}{The NVECTOR\_PARHYP Module}}}} and {\hyperref[nvectors/NVector_PETSc:nvectors-nvpetsc]{\emph{\DUspan{}{The NVECTOR\_PETSC Module}}}} for details.

If using either the CUDA- or RAJA-based vector implementations use
a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{y0} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMake\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{,} \PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

where \code{c} is a pointer to a \code{suncudavec} or \code{sunrajavec}
vector class if this class already exists.  Otherwise, create a new
vector by making a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VGetDeviceArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\end{Verbatim}

or

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VGetHostArrayPointer\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}
\end{Verbatim}

Note that the vector class will allocate memory on both the host
and device when instantiated.  See the sections
{\hyperref[nvectors/NVector_CUDA:nvectors-cuda]{\emph{\DUspan{}{The NVECTOR\_CUDA Module}}}} and {\hyperref[nvectors/NVector_RAJA:nvectors-raja]{\emph{\DUspan{}{The NVECTOR\_RAJA Module}}}} for details.

\item {} 
Create ARKode object

Call \code{arkode\_mem = ARKodeCreate()} to create the ARKode memory
block. {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}} returns a pointer to the ARKode memory
structure. See the section {\hyperref[c_interface/User_callable:cinterface-initialization]{\emph{\DUspan{}{ARKode initialization and deallocation functions}}}} for
details.

\item {} 
Initialize ARKode solver

Call {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}} to provide required problem specifications,
allocate internal memory for ARKode, and initialize
ARKode. {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}} returns a flag, the value of which indicates
either success or an illegal argument value. See the section
{\hyperref[c_interface/User_callable:cinterface-initialization]{\emph{\DUspan{}{ARKode initialization and deallocation functions}}}} for details.

\item {} 
Specify integration tolerances

Call {\hyperref[c_interface/User_callable:c.ARKodeSStolerances]{\emph{\code{ARKodeSStolerances()}}}} or {\hyperref[c_interface/User_callable:c.ARKodeSVtolerances]{\emph{\code{ARKodeSVtolerances()}}}} to
specify either a scalar relative tolerance and scalar absolute
tolerance, or a scalar relative tolerance and a vector of absolute
tolerances, respectively. Alternatively, call {\hyperref[c_interface/User_callable:c.ARKodeWFtolerances]{\emph{\code{ARKodeWFtolerances()}}}}
to specify a function which sets directly the weights used in
evaluating WRMS vector norms. See the section
{\hyperref[c_interface/User_callable:cinterface-tolerances]{\emph{\DUspan{}{ARKode tolerance specification functions}}}} for details.

If a problem with non-identity mass matrix is used, and the
solution units differ considerably from the equation units,
absolute tolerances for the equation residuals (nonlinear and
linear) may be specified separately through calls to
{\hyperref[c_interface/User_callable:c.ARKodeResStolerance]{\emph{\code{ARKodeResStolerance()}}}}, {\hyperref[c_interface/User_callable:c.ARKodeResVtolerance]{\emph{\code{ARKodeResVtolerance()}}}} or
{\hyperref[c_interface/User_callable:c.ARKodeResFtolerance]{\emph{\code{ARKodeResFtolerance()}}}}.

\item {} 
Set optional inputs

Call \code{ARKodeSet*} functions to change any optional inputs that
control the behavior of ARKode from their default values. See
the section {\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}} for details.

\item {} 
Create matrix object

If a direct linear solver is to be used within a Newton iteration
or for solving non-identity mass matrix systems, then a template
Jacobian and/or mass matrix must be created by using the
appropriate functions defined by the particular SUNMATRIX
implementation.

NOTE: The dense, banded, and sparse matrix objects are usable only in a
serial or threaded environment.

\item {} 
Create linear solver object

If a Newton iteration is chosen, or if the problem involves a
non-identity mass matrix, then the desired linear solver object(s)
must be created by using the appropriate functions defined by the
particular SUNLINSOL implementation.

\item {} 
Set linear solver optional inputs

Call \code{*Set*} functions from the selected linear solver module to
change optional inputs specific to that linear solver.  See the
documentation for each SUNLINSOL module in the section
{\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}} for details.

\item {} 
Attach linear solver module

If a Newton iteration is chosen for implicit or ImEx methods,
initialize the ARKDLS or ARKSPILS linear solver interface by
attaching the linear solver object (and Jacobian matrix object, if
applicable) with one of the following calls (for details see the
section {\hyperref[c_interface/User_callable:cinterface-linearsolvers]{\emph{\DUspan{}{Linear solver interface functions}}}}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKDlsSetLinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKSpilsSetLinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Similarly, if the problem involves a non-identity mass matrix,
initialize the ARKDLS or ARKSPILS mass matrix linear solver
interface by attaching the mass linear solver object (and mass
matrix object, if applicable) with one of the following calls (for
details see the section {\hyperref[c_interface/User_callable:cinterface-linearsolvers]{\emph{\DUspan{}{Linear solver interface functions}}}}):

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKDlsSetMassLinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKSpilsSetMassLinearSolver}\PYG{p}{(}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\item {} 
Set linear solver interface optional inputs

Call \code{ARKDlsSet*} or \code{ARKSpilsSet*} functions to change
optional inputs specific to that linear solver interface. See the
section {\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}} for details.

\item {} 
Specify rootfinding problem

Optionally, call {\hyperref[c_interface/User_callable:c.ARKodeRootInit]{\emph{\code{ARKodeRootInit()}}}} to initialize a rootfinding
problem to be solved during the integration of the ODE system. See
the section {\hyperref[c_interface/User_callable:cinterface-rootfinding]{\emph{\DUspan{}{Rootfinding initialization function}}}} for general details, and
the section {\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}} for relevant optional
input calls.

\item {} 
Advance solution in time

For each point at which output is desired, call

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{ARKode}\PYG{p}{(}\PYG{n}{arkode\PYGZus{}mem}\PYG{p}{,} \PYG{n}{tout}\PYG{p}{,} \PYG{n}{yout}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{tret}\PYG{p}{,} \PYG{n}{itask}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

Here, \code{itask} specifies the return mode. The vector \code{yout}
(which can be the same as the vector \code{y0} above) will contain
\(y(t_\text{out})\). See the section
{\hyperref[c_interface/User_callable:cinterface-integration]{\emph{\DUspan{}{ARKode solver function}}}} for details.

\item {} 
Get optional outputs

Call \code{ARK*Get*} functions to obtain optional output. See
the section {\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}} for details.

\item {} 
Deallocate memory for solution vector

Upon completion of the integration, deallocate memory for the
vector \code{y} (or \code{yout}) by calling the destructor function
defined by the NVECTOR implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDestroy\PYGZus{}}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\item {} 
Free solver memory

Call \code{ARKodeFree(\&arkode\_mem)} to free the memory allocated for ARKode.

\item {} 
Free linear solver and matrix memory

Call {\hyperref[sunlinsol/SUNLinSol_Operations:c.SUNLinSolFree]{\emph{\code{SUNLinSolFree()}}}} and (possibly)
{\hyperref[sunmatrix/SUNMatrix_Operations:c.SUNMatDestroy]{\emph{\code{SUNMatDestroy()}}}} to free any memory allocated for the
linear solver and matrix objects created above.

\item {} 
Finalize MPI, if used

Call \code{MPI\_Finalize} to terminate MPI.

\end{enumerate}

SUNDIALS provides some linear solvers only as a means for users to get
problems running and not as highly efficient solvers.  For example, if
solving a dense system, we suggest using the LAPACK solvers if the
size of the linear system is \(> 50,000\) (thanks to A. Nicolai
for his testing and recommendation).  The table below shows the
linear solver interfaces available as \code{SUNLinearSolver}
modules and the vector implementations required for use.  As an
example, one cannot use the dense direct solver interfaces with the
MPI-based vector implementation.  However, as discussed in section
{\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}} the SUNDIALS packages operate on generic
\code{SUNLinearSolver} objects, allowing a user to develop
their own solvers should they so desire.


\subsection{SUNDIALS linear solver interfaces and vector implementations that can be used for each}
\label{c_interface/Skeleton:cinterface-solver-vector}\label{c_interface/Skeleton:sundials-linear-solver-interfaces-and-vector-implementations-that-can-be-used-for-each}
\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|L|L|}
\hline
\textsf{\relax 
Linear Solver
Interface
} & \textsf{\relax 
Serial
} & \textsf{\relax 
Parallel
(MPI)
} & \textsf{\relax 
OpenMP
} & \textsf{\relax 
pThreads
} & \textsf{\relax 
\emph{hypre}
Vec.
} & \textsf{\relax 
PETSc
Vec.
} & \textsf{\relax 
CUDA
} & \textsf{\relax 
RAJA
} & \textsf{\relax 
User
Suppl.
}\\
\hline
Dense
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
Band
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
LapackDense
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
LapackBand
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
KLU
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
SuperLU\_MT
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
SPGMR
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline
SPFGMR
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline
SPBCGS
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline
SPTFQMR
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline
PCG
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline
User supplied
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline\end{tabulary}



\section{User-callable functions}
\label{c_interface/User_callable::doc}\label{c_interface/User_callable:user-callable-functions}\label{c_interface/User_callable:cinterface-usercallable}
This section describes the ARKode functions that are called by the
user to setup and then solve an IVP. Some of these are
required. However, starting with the section
{\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs may be
skipped for a casual use of ARKode. In any
case, refer to the preceding section, {\hyperref[c_interface/Skeleton:cinterface-skeleton]{\emph{\DUspan{}{A skeleton of the user's main program}}}}, for
the correct order of these calls.

On an error, each user-callable function returns a negative value and
sends an error message to the error handler routine, which prints the
message on \code{stderr} by default. However, the user can set a file as
error output or can provide her own error handler function
(see the section {\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}} for details).


\subsection{ARKode initialization and deallocation functions}
\label{c_interface/User_callable:arkode-initialization-and-deallocation-functions}\label{c_interface/User_callable:cinterface-initialization}\index{ARKodeCreate (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeCreate}\pysiglinewithargsret{void* \bfcode{ARKodeCreate}}{}{}
This function creates an internal memory block for a problem to be
solved by ARKode.

\textbf{Arguments:}  None

\textbf{Return value:}  If successful, a pointer to initialized problem memory
of type \code{void*}, to be passed to {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}.
If unsuccessful, a \code{NULL} pointer will be returned, and an error
message will be printed to \code{stderr}.

\end{fulllineitems}

\index{ARKodeInit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeInit}\pysiglinewithargsret{int \bfcode{ARKodeInit}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{ARKRhsFn}}}\emph{ fe}, {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{ARKRhsFn}}}\emph{ fi}, realtype\emph{ t0}, N\_Vector\emph{ y0}}{}
This function allocates and initializes memory for a problem to
be solved by ARKode.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block
(that was returned by {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}})

\item {} 
\emph{fe} -- the name of the C function (of type {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn()}}}})
defining the explicit portion of the right-hand side function in
\(\dot{y} = f_E(t,y) + f_I(t,y)\)

\item {} 
\emph{fi} -- the name of the C function (of type {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn()}}}})
defining the implicit portion of the right-hand side function in
\(\dot{y} = f_E(t,y) + f_I(t,y)\)

\item {} 
\emph{t0} -- the initial value of \(t\)

\item {} 
\emph{y0} -- the initial condition vector \(y(t_0)\)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeFree (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeFree}\pysiglinewithargsret{void \bfcode{ARKodeFree}}{void*\emph{ arkode\_mem}}{}
This function frees the problem memory \emph{arkode\_mem} created by
{\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}} and allocated by {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\end{description}

\textbf{Return value:}  None

\end{fulllineitems}



\subsection{ARKode tolerance specification functions}
\label{c_interface/User_callable:arkode-tolerance-specification-functions}\label{c_interface/User_callable:cinterface-tolerances}
These functions specify the integration tolerances. One of them
\textbf{should} be called before the first call to {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}; otherwise
default values of \code{reltol = 1e-4} and \code{abstol = 1e-9} will be
used, which may be entirely incorrect for a specific problem.

The integration tolerances \code{reltol} and \code{abstol} define a vector
of error weights, \code{ewt}.  In the case of
{\hyperref[c_interface/User_callable:c.ARKodeSStolerances]{\emph{\code{ARKodeSStolerances()}}}}, this vector has components

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

whereas in the case of {\hyperref[c_interface/User_callable:c.ARKodeSVtolerances]{\emph{\code{ARKodeSVtolerances()}}}} the vector components
are given by

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ewt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{abstol}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

This vector is used in all error and convergence tests, which use a
weighted RMS norm on all error-like vectors v:
\begin{gather}
\begin{split}\|v\|_{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N (v_i\; ewt_i)^2 \right)^{1/2},\end{split}\notag
\end{gather}
where \(N\) is the problem dimension.

Alternatively, the user may supply a custom function to supply the
\code{ewt} vector, through a call to {\hyperref[c_interface/User_callable:c.ARKodeWFtolerances]{\emph{\code{ARKodeWFtolerances()}}}}.
\index{ARKodeSStolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSStolerances}\pysiglinewithargsret{int \bfcode{ARKodeSStolerances}}{void*\emph{ arkode\_mem}, realtype\emph{ reltol}, realtype\emph{ abstol}}{}
This function specifies scalar relative and absolute tolerances.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{reltol} -- scalar relative tolerance

\item {} 
\emph{abstol} -- scalar absolute tolerance

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_NO\_MALLOC}  if the ARKode memory was not allocated by {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeSVtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSVtolerances}\pysiglinewithargsret{int \bfcode{ARKodeSVtolerances}}{void*\emph{ arkode\_mem}, realtype\emph{ reltol}, N\_Vector\emph{ abstol}}{}
This function specifies a scalar relative tolerance and a vector
absolute tolerance (a potentially different absolute tolerance for
each vector component).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{reltol} -- scalar relative tolerance

\item {} 
\emph{abstol} -- vector containing the absolute tolerances for each
solution component

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_NO\_MALLOC}  if the ARKode memory was not allocated by {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeWFtolerances (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeWFtolerances}\pysiglinewithargsret{int \bfcode{ARKodeWFtolerances}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKEwtFn]{\emph{ARKEwtFn}}}\emph{ efun}}{}
This function specifies a user-supplied function \emph{efun} to compute
the error weight vector \code{ewt}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{efun} -- the name of the function (of type {\hyperref[c_interface/User_supplied:c.ARKEwtFn]{\emph{\code{ARKEwtFn()}}}})
that implements the error weight vector computation.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_NO\_MALLOC}  if the ARKode memory was not allocated by {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}

\end{itemize}

\end{description}

\end{fulllineitems}


Moreover, for problems involving a non-identity mass matrix
\(M\ne I\), the units of the solution vector \(y\) may differ
from the units of the IVP, posed for the vector \(My\).  When this
occurs, iterative solvers for the Newton linear systems and the mass
matrix linear systems may require a different set of tolerances.
Since the relative tolerance is dimensionless, but the absolute
tolerance encodes a measure of what is ``small'' in the units of the
respective quantity, a user may optionally define absolute tolerances
in the equation units.  In this case, ARKode defines a vector of residual
weights, \code{rwt} for measuring convergence of these iterative solvers.
In the case of {\hyperref[c_interface/User_callable:c.ARKodeResStolerance]{\emph{\code{ARKodeResStolerance()}}}}, this vector has components

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rwt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{My}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rabstol}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

whereas in the case of {\hyperref[c_interface/User_callable:c.ARKodeResVtolerance]{\emph{\code{ARKodeResVtolerance()}}}} the vector components
are given by

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rwt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{reltol}\PYG{o}{*}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{My}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)} \PYG{o}{+} \PYG{n}{rabstol}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

This residual weight vector is used in all iterative solver
convergence tests, which similarly use a weighted RMS norm on all
residual-like vectors v:
\begin{gather}
\begin{split}\|v\|_{WRMS} = \left( \frac{1}{N} \sum_{i=1}^N (v_i\; rwt_i)^2 \right)^{1/2},\end{split}\notag
\end{gather}
where \(N\) is the problem dimension.

As with the error weight vector, the user may supply a custom function
to supply the \code{rwt} vector, through a call to
{\hyperref[c_interface/User_callable:c.ARKodeResFtolerance]{\emph{\code{ARKodeResFtolerance()}}}}.  Further information on all three of
these functions is provided below.
\index{ARKodeResStolerance (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeResStolerance}\pysiglinewithargsret{int \bfcode{ARKodeResStolerance}}{void*\emph{ arkode\_mem}, realtype\emph{ abstol}}{}
This function specifies a scalar absolute residual tolerance.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{rabstol} -- scalar absolute residual tolerance

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_NO\_MALLOC}  if the ARKode memory was not allocated by {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeResVtolerance (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeResVtolerance}\pysiglinewithargsret{int \bfcode{ARKodeResVtolerance}}{void*\emph{ arkode\_mem}, N\_Vector\emph{ rabstol}}{}
This function specifies a vector of absolute residual tolerances.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{rabstol} -- vector containing the absolute residual
tolerances for each solution component

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_NO\_MALLOC}  if the ARKode memory was not allocated by {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value (e.g. a negative tolerance).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeResFtolerance (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeResFtolerance}\pysiglinewithargsret{int \bfcode{ARKodeResFtolerance}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKRwtFn]{\emph{ARKRwtFn}}}\emph{ rfun}}{}
This function specifies a user-supplied function \emph{rfun} to compute
the residual weight vector \code{rwt}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{rfun} -- the name of the function (of type {\hyperref[c_interface/User_supplied:c.ARKRwtFn]{\emph{\code{ARKRwtFn()}}}})
that implements the residual weight vector computation.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_NO\_MALLOC}  if the ARKode memory was not allocated by {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{General advice on the choice of tolerances}
\label{c_interface/User_callable:general-advice-on-the-choice-of-tolerances}
For many users, the appropriate choices for tolerance values in
\code{reltol}, \code{abstol} and \code{rabstol} are a concern. The following pieces
of advice are relevant.
\begin{enumerate}
\item {} 
The scalar relative tolerance \code{reltol} is to be set to control
relative errors. So a value of \(10^{-4}\) means that errors
are controlled to .01\%. We do not recommend using \code{reltol} larger
than \(10^{-3}\). On the other hand, \code{reltol} should not be so
small that it is comparable to the unit roundoff of the machine
arithmetic (generally around \(10^{-15}\) for double-precision).

\item {} 
The absolute tolerances \code{abstol} (whether scalar or vector) need
to be set to control absolute errors when any components of the
solution vector \(y\) may be so small that pure relative error
control is meaningless.  For example, if \(y_i\) starts at some
nonzero value, but in time decays to zero, then pure relative
error control on \(y_i\) makes no sense (and is overly costly)
after \(y_i\) is below some noise level. Then \code{abstol} (if
scalar) or \code{abstol{[}i{]}} (if a vector) needs to be set to that
noise level. If the different components have different noise
levels, then \code{abstol} should be a vector.  For example, see the
example problem \code{ark\_robertson.c}, and the discussion
of it in the ARKode Examples Documentation \phantomsection\label{c_interface/User_callable:id1}{\hyperref[References:r2013]{\emph{{[}R2013{]}}}}.  In that
problem, the three components vary betwen 0 and 1, and have
different noise levels; hence the \code{atols} vector therein. It is
impossible to give any general advice on \code{abstol} values,
because the appropriate noise levels are completely
problem-dependent. The user or modeler hopefully has some idea as
to what those noise levels are.

\item {} 
The residual absolute tolerances \code{rabstol} (whether scalar or
vector) follow a similar explanation as for \code{abstol}, except
that these should be set to the noise level of the equation
components, i.e. the noise level of \(My\).  For problems in
which \(M=I\), it is recommended that \code{rabstol} be left
unset, which will default to the already-supplied \code{abstol}
values.

\item {} 
Finally, it is important to pick all the tolerance values
conservatively, because they control the error committed on each
individual step. The final (global) errors are an accumulation of
those per-step errors, where that accumulation factor is
problem-dependent.  A general rule of thumb is to reduce the
tolerances by a factor of 10 from the actual desired limits on
errors.  I.e. if you want .01\% relative accuracy (globally), a good
choice for \code{reltol} is \(10^{-5}\).  But in any case, it is
a good idea to do a few experiments with the tolerances to see how
the computed solution values vary as tolerances are reduced.

\end{enumerate}


\subsubsection{Advice on controlling unphysical negative values}
\label{c_interface/User_callable:advice-on-controlling-unphysical-negative-values}
In many applications, some components in the true solution are always
positive or non-negative, though at times very small.  In the
numerical solution, however, small negative (unphysical) values
can then occur. In most cases, these values are harmless, and simply
need to be controlled, not eliminated, but in other cases any value
that violates a constraint may cause a simulation to halt. For both of
these scenarios the following pieces of advice are relevant.
\begin{enumerate}
\item {} 
The best way to control the size of unwanted negative computed
values is with tighter absolute tolerances.  Again this requires
some knowledge of the noise level of these components, which may
or may not be different for different components. Some
experimentation may be needed.

\item {} 
If output plots or tables are being generated, and it is important
to avoid having negative numbers appear there (for the sake of
avoiding a long explanation of them, if nothing else), then
eliminate them, but only in the context of the output medium. Then
the internal values carried by the solver are unaffected. Remember
that a small negative value in \(y\) returned by ARKode, with
magnitude comparable to \code{abstol} or less, is equivalent to zero
as far as the computation is concerned.

\item {} 
The user's right-hand side routines \(f_E\) and \(f_I\)
should never change a negative value in the solution vector \(y\)
to a non-negative value in attempt to ``fix'' this problem,
since this can lead to numerical instability.  If the \(f_E\)
or \(f_I\) routines cannot tolerate a zero or negative value
(e.g. because there is a square root or log), then the offending
value should be changed to zero or a tiny positive number in a
temporary variable (not in the input \(y\) vector) for the
purposes of computing \(f_E(t, y)\) or \(f_I(t, y)\).

\item {} 
Positivity and non-negativity constraints on components can be
enforced by use of the recoverable error return feature in the
user-supplied right-hand side functions, \(f_E\) and
\(f_I\). When a recoverable error is encountered, ARKode will
retry the step with a smaller step size, which typically
alleviates the problem.  However, because this option involves
some additional overhead cost, it should only be exercised if the
use of absolute tolerances to control the computed values is
unsuccessful.

\end{enumerate}


\subsection{Linear solver interface functions}
\label{c_interface/User_callable:cinterface-linearsolvers}\label{c_interface/User_callable:linear-solver-interface-functions}
As previously explained, the Newton iterations used in solving
implicit systems within ARKode requires the solution of linear
systems of the form
\begin{gather}
\begin{split}{\mathcal A}\left(z_i^{(m)}\right) \delta^{(m+1)} = -G\left(z_i^{(m)}\right)\end{split}\notag
\end{gather}
where
\begin{gather}
\begin{split}{\mathcal A} \approx M - \gamma J, \qquad J = \frac{\partial f_I}{\partial y}.\end{split}\notag
\end{gather}
There are two ARKode linear solver interfaces currently available for this
task: ARKDLS and ARKSPILS.

The first corresponds to the use of Direct Linear Solvers, and
utilizes \code{SUNMatrix} objects to store the approximate Jacobian
\(J\), the Newton matrix \({\mathcal A}\), the mass matrix
\(M\), and factorizations used throughout the solution process.

The second corresponds to the use of Scaled, Preconditioned, Iterative
Linear Solvers, utilizing matrix-free Krylov methods to solve the
Newton systems of equations.  With most of these methods,
preconditioning can be done on the left only, on the right only, on
both the left and the right, or not at all.  The exceptions to this
rule are SPFGMR that supports right preconditioning only and PCG
that performs symmetric preconditioning.  For the specification
of a preconditioner, see the iterative linear solver portions of the
sections {\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}} and
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

If preconditioning is done, user-supplied functions should be used to
define left and right preconditioner matrices \(P_1\) and
\(P_2\) (either of which could be the identity matrix), such that
the product \(P_{1}P_{2}\) approximates the Newton matrix
\({\mathcal A} = M - \gamma J\).

To specify a generic linear solver for ARKode to use for the Newton
systems, after the call to {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}} but before any
calls to {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}, the user's program must create the
appropriate \code{SUNLinearSolver} object and call either of the
functions {\hyperref[c_interface/User_callable:c.ARKDlsSetLinearSolver]{\emph{\code{ARKDlsSetLinearSolver()}}}} or
{\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}}, as documented below.  The first
argument passed to these functions is the ARKode memory pointer
returned by {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}}; the second argument passed to
these functions is the desired \code{SUNLinearSolver} object to use
for solving Newton systems.  A call to one of these functions initializes the
appropriate ARKode linear solver interface, linking this to the main
ARKode integrator, and allows the user to specify parameters which are
specific to a particular solver interface.

The use of each of the generic linear solvers involves certain
constants and possibly some macros, that are likely to be needed in
the user code.  These are available in the corresponding header file
associated with the specific \code{SUNMatrix} or
\code{SUNLinearSolver} module in question, as described in the
sections {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}} and {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.
\index{ARKDlsSetLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsSetLinearSolver}\pysiglinewithargsret{int \bfcode{ARKDlsSetLinearSolver}}{void*\emph{ arkode\_mem}, SUNLinearSolver\emph{ LS}, SUNMatrix\emph{ J}}{}
This function specifies the direct \code{SUNLinearSolver} object
that ARKode should use, as well as a template Jacobian
\code{SUNMatrix} object.  Its use requires inclusion of the
header file  \code{arkode/arkode\_direct.h}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{LS} -- the \code{SUNLinearSolver} object to use.

\item {} 
\emph{J} -- the template Jacobian \code{SUNMatrix} object to use.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS}   if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\emph{ARKDLS\_ILL\_INPUT} if ARKDLS is incompatible with the
provided \emph{LS} or \emph{J} input objects, or the current
\code{N\_Vector} module.

\end{itemize}

\end{description}

\textbf{Notes:}  The template Jacobian matrix \emph{J} will be used in the
solve process, so if additional storage is required within the
\code{SUNMatrix} object (e.g. for factorization of a banded
matrix), ensure that the input object is allocated with sufficient
size.

The ARKDLS linear solver interface is not compatible
with all implementations of the \code{SUNLinearSolver} and
\code{N\_Vector} modules.  Specifically, ARKDLS requires use of a
\emph{direct} \code{SUNLinearSolver} object and a serial or threaded
\code{N\_Vector} module.  Additional compatibility limitations
for each \code{SUNLinearSolver} object (i.e. \code{SUNMatrix}
and \code{N\_Vector} object compatibility) are described in the
section {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.

\end{fulllineitems}

\index{ARKSpilsSetLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetLinearSolver}\pysiglinewithargsret{int \bfcode{ARKSpilsSetLinearSolver}}{void*\emph{ arkode\_mem}, SUNLinearSolver\emph{ LS}}{}
This function specifies the iterative \code{SUNLinearSolver} object
that ARKode should use, initializing the ARKSPILS scaled,
preconditioned, iterative linear solver interface.  Its use
requires inclusion of the header file  \code{arkode/arkode\_spils.h}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{LS} -- the \code{SUNLinearSolver} object to use.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS}   if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if ARKSPILS is incompatible with the
provided \emph{LS} input objects, or the current \code{N\_Vector}
module.

\end{itemize}

\end{description}

\textbf{Notes:}  The ARKSPILS linear solver interface is not compatible
with all implementations of the \code{SUNLinearSolver} and
\code{N\_Vector} modules.  Specifically, ARKSPILS requires use of an
\emph{iterative} \code{SUNLinearSolver} object, and a minimum
required set of vector operations must be provided by the current
\code{N\_Vector} module.  Additional compatibility limitations
for each \code{SUNLinearSolver} object (i.e. required
\code{N\_Vector} routines) are described in the
section {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.

\end{fulllineitems}



\subsection{Mass matrix solver specification functions}
\label{c_interface/User_callable:cinterface-massmatrixsolvers}\label{c_interface/User_callable:mass-matrix-solver-specification-functions}
As discussed in section {\hyperref[Mathematics:mathematics-masssolve]{\emph{\DUspan{}{Mass matrix solver}}}}, if the ODE
system involves a non-identity mass matrix \(M\ne I\), then ARKode
must solve linear systems of the form
\begin{gather}
\begin{split}M x = b.\end{split}\notag
\end{gather}
The same solver interfaces listed above in the section
{\hyperref[c_interface/User_callable:cinterface-linearsolvers]{\emph{\DUspan{}{Linear solver interface functions}}}} may be used for this purpose: ARKDLS
and ARKSPILS.  With the ARKSPILS interface preconditioning can be
applied.  For the specification of a preconditioner, see the iterative
linear solver portions of the sections
{\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}} and {\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.
If preconditioning is to be performed, user-supplied functions should
be used to define left and right preconditioner matrices \(P_1\) and
\(P_2\) (either of which could be the identity matrix), such that
the product \(P_{1}P_{2}\) approximates the mass matrix \(M\).

To specify a generic linear solver for ARKode to use for mass matrix
systems, after the call to {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}} but before any
calls to {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}, the user's program must create the
appropriate \code{SUNLinearSolver} object and call either of the
functions {\hyperref[c_interface/User_callable:c.ARKDlsSetMassLinearSolver]{\emph{\code{ARKDlsSetMassLinearSolver()}}}} or
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}}, as documented below.  The
first argument passed to these functions is the ARKode memory pointer
returned by {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}}; the second argument passed to
these functions is the desired \code{SUNLinearSolver} object to use
for solving mass matrix systems.  A call to one of these functions
initializes the appropriate ARKode mass matrix linear solver
interface, linking this to the main ARKode integrator, and allows the
user to specify parameters which are specific to a particular solver
interface.

The use of each of the generic linear solvers involves certain
constants and possibly some macros, that are likely to be needed in
the user code.  These are available in the corresponding header file
associated with the specific \code{SUNMatrix} or
\code{SUNLinearSolver} module in question, as described in the
sections {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}} and {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.

Note: if the user program includes linear solvers for \emph{both} the
Newton and mass matrix systems, these must have the same type:
\begin{itemize}
\item {} 
If both are \emph{direct}, then they must utilize the same
\code{SUNMatrix} type.  In this case, both the Newton and mass
matrix linear solver interfaces can use the same
\code{SUNLinearSolver} object, although different objects
(e.g. with different solver parameters) are also allowed.

\item {} 
If both are \emph{iterative}, then the Newton and mass matrix
\code{SUNLinearSolver} objects must be different.  These may even
use different solver algorithms (SPGMR, SPBCGS, etc.), if desired.
For example, if the mass matrix is symmetric but the Jacobian is not,
then PCG may be used for the mass matrix systems and SPGMR for the
Newton systems.

\end{itemize}

As with the Newton system solvers, the mass matrix linear system
solvers listed below are all built on top of generic SUNDIALS solver
modules.
\index{ARKDlsSetMassLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsSetMassLinearSolver}\pysiglinewithargsret{int \bfcode{ARKDlsSetMassLinearSolver}}{void*\emph{ arkode\_mem}, SUNLinearSolver\emph{ LS}, SUNMatrix\emph{ M}, booleantype\emph{ time\_dep}}{}
This function specifies the direct \code{SUNLinearSolver} object
that ARKode should use for mass matrix systems, as well as a
template \code{SUNMatrix} object.  Its use requires inclusion of the
header file  \code{arkode/arkode\_direct.h}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{LS} -- the \code{SUNLinearSolver} object to use.

\item {} 
\emph{M} -- the template mass \code{SUNMatrix} object to use.

\item {} 
\emph{time\_dep} -- flag denoting whether the mass matrix depends on
the independent variable (\(M = M(t)\)) or not (\(M
\ne M(t)\)).  Use \code{SUNTRUE} to indicate time-dependence of the
mass matrix.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS}   if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\emph{ARKDLS\_ILL\_INPUT} if ARKDLS is incompatible with the
provided \emph{LS} or \emph{M} input objects, or the current
\code{N\_Vector} module.

\end{itemize}

\end{description}

\textbf{Notes:}  The template mass matrix \emph{M} will be used in the
solve process, so if additional storage is required within the
\code{SUNMatrix} object (e.g. for factorization of a banded
matrix), ensure that the input object is allocated with sufficient
size.

If called with \emph{time\_dep} set to \code{SUNFALSE}, then the mass matrix is
only computed and factored once, with the results reused throughout
the entire ARKode simulation.

Unlike the system Jacobian, the system mass matrix cannot be
approximated using finite-differences of any functions provided to
ARKode.  Hence, use of the ARKDLS mass matrix solver interface
requires the user to provide a mass-matrix constructor routine
(see {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn}}}} and {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}}).

The ARKDLS linear solver interface is not compatible
with all implementations of the \code{SUNLinearSolver} and
\code{N\_Vector} modules.  Specifically, ARKDLS requires use of a
\emph{direct} \code{SUNLinearSolver} object and a serial or threaded
\code{N\_Vector} module.  Additional compatibility limitations
for each \code{SUNLinearSolver} object (i.e. \code{SUNMatrix}
and \code{N\_Vector} object compatibility) are described in the
section {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.

\end{fulllineitems}

\index{ARKSpilsSetMassLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetMassLinearSolver}\pysiglinewithargsret{int \bfcode{ARKSpilsSetMassLinearSolver}}{void*\emph{ arkode\_mem}, SUNLinearSolver\emph{ LS}, booleantype\emph{ time\_dep}}{}
This function specifies the iterative \code{SUNLinearSolver} object
that ARKode should use for mass matrix systems, initializing the
ARKSPILS scaled, preconditioned, iterative mass matrix linear
solver interface.  Its use requires inclusion of the header file
\code{arkode/arkode\_spils.h}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{LS} -- the \code{SUNLinearSolver} object to use.

\item {} 
\emph{time\_dep} -- flag denoting whether the mass matrix depends on
the independent variable (\(M = M(t)\)) or not (\(M
\ne M(t)\)).  Use \code{SUNTRUE} to indicate time-dependence of the
mass matrix.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS}   if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if ARKSPILS is incompatible with the
provided \emph{LS} input objects, or the current \code{N\_Vector}
module.

\end{itemize}

\end{description}

\textbf{Notes:}  If called with \emph{time\_dep} set to \code{SUNFALSE}, then the
mass matrix-vector-product (if supplied) is only set up once, and
the mass matrix preconditioner (if supplied) is only set up once,
with the results reused throughout the entire ARKode simulation.

Unlike the system Jacobian, the system mass matrix-vector-product
cannot be approximated using finite-differences of any functions
provided to ARKode.  Hence, use of the ARKSPILS mass matrix solver
interface requires the user to provide a mass-matrix-times-vector
product routine (see {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{\code{ARKSpilsMassTimesVecFn}}}} and
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassTimes]{\emph{\code{ARKSpilsSetMassTimes()}}}}).

The ARKSPILS linear solver interface is not compatible
with all implementations of the \code{SUNLinearSolver} and
\code{N\_Vector} modules.  Specifically, ARKSPILS requires use of an
\emph{iterative} \code{SUNLinearSolver} object, and a minimum
required set of vector operations must be provided by the current
\code{N\_Vector} module.  Additional compatibility limitations
for each \code{SUNLinearSolver} object (i.e. required
\code{N\_Vector} routines) are described in the section {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.

\end{fulllineitems}



\subsection{Rootfinding initialization function}
\label{c_interface/User_callable:cinterface-rootfinding}\label{c_interface/User_callable:rootfinding-initialization-function}
As described in the section {\hyperref[Mathematics:mathematics-rootfinding]{\emph{\DUspan{}{Rootfinding}}}}, while
solving the IVP ARKode has the capability to find the roots of a set
of user-defined functions.  To activate the root-finding algorithm,
call the following function.  This is normally called only once, prior
to the first call to {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}, but if the rootfinding
problem is to be changed during the solution,
{\hyperref[c_interface/User_callable:c.ARKodeRootInit]{\emph{\code{ARKodeRootInit()}}}} can also be called prior to a continuation
call to {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}.
\index{ARKodeRootInit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeRootInit}\pysiglinewithargsret{int \bfcode{ARKodeRootInit}}{void*\emph{ arkode\_mem}, int\emph{ nrtfn}, {\hyperref[c_interface/User_supplied:c.ARKRootFn]{\emph{ARKRootFn}}}\emph{ g}}{}
Initializes a rootfinding problem to be solved during the
integration of the ODE system.  It must be called after
{\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}}, and before {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nrtfn} -- number of functions \(g_i\), an integer \(\ge\) 0.

\item {} 
\emph{g} -- name of user-supplied function, of type {\hyperref[c_interface/User_supplied:c.ARKRootFn]{\emph{\code{ARKRootFn()}}}},
defining the functions \(g_i\) whose roots are sought.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_MEM\_FAIL}  if there was a memory allocation failure

\item {} 
\emph{ARK\_ILL\_INPUT} if \emph{nrtfn} is greater than zero but \emph{g} = \code{NULL}.

\end{itemize}

\end{description}

\textbf{Notes:} To disable the rootfinding feature after it has already
been initialized, or to free memory associated with ARKode's
rootfinding module, call \emph{ARKodeRootInit} with \emph{nrtfn = 0}.

Similarly, if a new IVP is to be solved with a call to
{\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}}, where the new IVP has no rootfinding
problem but the prior one did, then call \emph{ARKodeRootInit} with
\emph{nrtfn = 0}.

\end{fulllineitems}



\subsection{ARKode solver function}
\label{c_interface/User_callable:arkode-solver-function}\label{c_interface/User_callable:cinterface-integration}
This is the central step in the solution process -- the call to perform
the integration of the IVP.  One of the input arguments (\emph{itask})
specifies one of two modes as to where ARKode is to return a
solution.  These modes are modified if the user has set a stop time
(with a call to the optional input function {\hyperref[c_interface/User_callable:c.ARKodeSetStopTime]{\emph{\code{ARKodeSetStopTime()}}}}) or
has requested rootfinding.
\index{ARKode (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKode}\pysiglinewithargsret{int \bfcode{ARKode}}{void*\emph{ arkode\_mem}, realtype\emph{ tout}, N\_Vector\emph{ yout}, realtype\emph{ *tret}, int\emph{ itask}}{}
Integrates the ODE over an interval in \(t\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{tout} -- the next time at which a computed solution is desired

\item {} 
\emph{yout} -- the computed solution vector

\item {} 
\emph{tret} -- the time corresponding to \emph{yout} (output)

\item {} 
\emph{itask} -- a flag indicating the job of the solver for the next
user step.

The \emph{ARK\_NORMAL} option causes the solver to take internal steps
until it has reached or just passed the user-specified \emph{tout}
parameter. The solver then interpolates in order to return an
approximate value of \(y(tout)\).  This interpolation may be
slightly less accurate than the full time step solutions
produced by the solver, since the interpolation uses a cubic
Hermite polynomial even when the RK method is of higher order.

To ensure that this returned value has full method accuracy,
issue a call to {\hyperref[c_interface/User_callable:c.ARKodeSetStopTime]{\emph{\code{ARKodeSetStopTime()}}}} before the call
to ARKode to specify a fixed stop time to end the time step
and return to the user.  Once the integrator returns at a
\emph{tstop} time, any future testing for \emph{tstop} is disabled (and
can be reenabled only though a new call to
{\hyperref[c_interface/User_callable:c.ARKodeSetStopTime]{\emph{\code{ARKodeSetStopTime()}}}}).

The \emph{ARK\_ONE\_STEP} option tells the solver to take just one
internal step and then return the solution at the point
reached by that step.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_ROOT\_RETURN} if ARKode succeeded, and found one or more roots.
If \emph{nrtfn} is greater than 1, call {\hyperref[c_interface/User_callable:c.ARKodeGetRootInfo]{\emph{\code{ARKodeGetRootInfo()}}}} to see
which \(g_i\) were found to have a root at (\emph{*tret}).

\item {} 
\emph{ARK\_TSTOP\_RETURN} if ARKode succeeded and returned at \emph{tstop}.

\item {} 
\emph{ARK\_MEM\_NULL} if the \emph{arkode\_mem} argument was \code{NULL}.

\item {} 
\emph{ARK\_NO\_MALLOC} if \emph{arkode\_mem} was not allocated.

\item {} 
\emph{ARK\_ILL\_INPUT} if one of the inputs to ARKode is illegal, or
some other input to the solver was either illegal or missing.
Details will be provided in the error message.  Typical causes
of this failure:
\begin{enumerate}
\item {} 
The tolerances have not been set.

\item {} 
A component of the error weight vector became zero during
internal time-stepping.

\item {} 
The linear solver initialization function (called by the
user after calling {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}}) failed to set
the linear solver-specific \emph{lsolve} field in
\emph{arkode\_mem}.

\item {} 
A root of one of the root functions was found both at a
point \(t\) and also very near \(t\).

\end{enumerate}

\item {} 
\emph{ARK\_TOO\_MUCH\_WORK} if the solver took \emph{mxstep} internal steps
but could not reach \emph{tout}.  The default value for \emph{mxstep} is
\emph{MXSTEP\_DEFAULT = 500}.

\item {} 
\emph{ARK\_TOO\_MUCH\_ACC} if the solver could not satisfy the accuracy
demanded by the user for some internal step.

\item {} 
\emph{ARK\_ERR\_FAILURE} if error test failures occurred either too many
times (\emph{ark\_maxnef}) during one internal time step or occurred
with \(|h| = h_{min}\).

\item {} 
\emph{ARK\_CONV\_FAILURE} if either convergence test failures occurred
too many times (\emph{ark\_maxncf}) during one internal time step or
occurred with \(|h| = h_{min}\).

\item {} 
\emph{ARK\_LINIT\_FAIL} if the linear solver's initialization function failed.

\item {} 
\emph{ARK\_LSETUP\_FAIL} if the linear solver's setup routine failed in
an unrecoverable manner.

\item {} 
\emph{ARK\_LSOLVE\_FAIL} if the linear solver's solve routine failed in
an unrecoverable manner.

\item {} 
\emph{ARK\_MASSINIT\_FAIL} if the mass matrix solver's
initialization function failed.

\item {} 
\emph{ARK\_MASSSETUP\_FAIL} if the mass matrix solver's setup routine
failed.

\item {} 
\emph{ARK\_MASSSOLVE\_FAIL} if the mass matrix solver's solve routine
failed.

\end{itemize}

\end{description}

\textbf{Notes:} The input vector \emph{yout} can use the same memory as the
vector \emph{y0} of initial conditions that was passed to
{\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}.

In \emph{ARK\_ONE\_STEP} mode, \emph{tout} is used only on the first call, and
only to get the direction and a rough scale of the independent
variable. All failure return values are negative and so testing the
return argument for negative values will trap all ARKode failures.

On any error return in which one or more internal steps were taken
by ARKode, the returned values of \emph{tret} and \emph{yout} correspond to
the farthest point reached in the integration.  On all other error
returns, \emph{tret} and \emph{yout} are left unchanged from those provided
to the routine.

\end{fulllineitems}



\subsection{Optional input functions}
\label{c_interface/User_callable:cinterface-optionalinputs}\label{c_interface/User_callable:optional-input-functions}
There are numerous optional input parameters that control the behavior
of the ARKode solver, each of which may be modified from its default
value through calling an appropriate input function.  The following
tables list all optional input functions, grouped by which aspect of
ARKode they control.  Detailed information on the calling syntax and
arguments for each function are then provided following each table.

The optional inputs are grouped into the following categories:
\begin{itemize}
\item {} 
General solver options ({\hyperref[c_interface/User_callable:cinterface-arkodeinputtable]{\emph{\DUspan{}{Optional inputs for ARKode}}}}),

\item {} 
IVP method solver options ({\hyperref[c_interface/User_callable:cinterface-arkodemethodinputtable]{\emph{\DUspan{}{Optional inputs for IVP method selection}}}}),

\item {} 
Step adaptivity solver options ({\hyperref[c_interface/User_callable:cinterface-arkodeadaptivityinputtable]{\emph{\DUspan{}{Optional inputs for time step adaptivity}}}}),

\item {} 
Implicit stage solver options ({\hyperref[c_interface/User_callable:cinterface-cinterface-arkodesolverinputtable]{\emph{\DUspan{}{Optional inputs for implicit stage solves}}}}),

\item {} 
Direct linear solver interface options ({\hyperref[c_interface/User_callable:cinterface-arkdlsinputs]{\emph{\DUspan{}{Direct linear solver interface optional input functions}}}}),

\item {} 
Iterative linear solver interface options ({\hyperref[c_interface/User_callable:cinterface-arkspilsinputs]{\emph{\DUspan{}{Iterative linear solvers optional input functions}}}}).

\end{itemize}

For the most casual use of ARKode, relying on the default set of
solver parameters, the reader can skip to the following section,
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

We note that, on an error return, all of the optional input functions
send an error message to the error handler function.  We also note
that all error return values are negative, so a test on the return
arguments for negative values will catch all errors.


\subsubsection{Optional inputs for ARKode}
\label{c_interface/User_callable:cinterface-arkodeinputtable}\label{c_interface/User_callable:optional-inputs-for-arkode}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Optional input
} & \textsf{\relax 
Function name
} & \textsf{\relax 
Default
}\\
\hline
Return all solver parameters to their defaults
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetDefaults]{\emph{\code{ARKodeSetDefaults()}}}}
 & 
internal
\\
\hline
Set dense output order
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetDenseOrder]{\emph{\code{ARKodeSetDenseOrder()}}}}
 & 
3
\\
\hline
Supply a pointer to a diagnostics output file
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetDiagnostics]{\emph{\code{ARKodeSetDiagnostics()}}}}
 & 
\code{NULL}
\\
\hline
Supply a pointer to an error output file
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetErrFile]{\emph{\code{ARKodeSetErrFile()}}}}
 & 
\code{stderr}
\\
\hline
Supply a custom error handler function
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetErrHandlerFn]{\emph{\code{ARKodeSetErrHandlerFn()}}}}
 & 
internal fn
\\
\hline
Supply an initial step size to attempt
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetInitStep]{\emph{\code{ARKodeSetInitStep()}}}}
 & 
estimated
\\
\hline
Disable time step adaptivity (fixed-step mode)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}}
 & 
disabled
\\
\hline
Maximum no. of warnings for \(t_n+h = t_n\)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxHnilWarns]{\emph{\code{ARKodeSetMaxHnilWarns()}}}}
 & 
10
\\
\hline
Maximum no. of internal steps before \emph{tout}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxNumSteps]{\emph{\code{ARKodeSetMaxNumSteps()}}}}
 & 
500
\\
\hline
Maximum no. of error test failures
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxErrTestFails]{\emph{\code{ARKodeSetMaxErrTestFails()}}}}
 & 
7
\\
\hline
Maximum absolute step size
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxStep]{\emph{\code{ARKodeSetMaxStep()}}}}
 & 
\(\infty\)
\\
\hline
Minimum absolute step size
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMinStep]{\emph{\code{ARKodeSetMinStep()}}}}
 & 
0.0
\\
\hline
Set `optimal' adaptivity params for a method
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetOptimalParams]{\emph{\code{ARKodeSetOptimalParams()}}}}
 & 
internal
\\
\hline
Set a value for \(t_{stop}\)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetStopTime]{\emph{\code{ARKodeSetStopTime()}}}}
 & 
\(\infty\)
\\
\hline
Supply a pointer for user data
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}
 & 
\code{NULL}
\\
\hline\end{tabulary}

\index{ARKodeSetDefaults (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetDefaults}\pysiglinewithargsret{int \bfcode{ARKodeSetDefaults}}{void*\emph{ arkode\_mem}}{}
Resets all optional input parameters to ARKode's original
default values.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Does not change problem-defining function pointers \emph{fe}
and \emph{fi} or the \emph{user\_data} pointer.

Also leaves alone any data structures or options related to
root-finding (those can be reset using {\hyperref[c_interface/User_callable:c.ARKodeRootInit]{\emph{\code{ARKodeRootInit()}}}}).

\end{fulllineitems}

\index{ARKodeSetDenseOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetDenseOrder}\pysiglinewithargsret{int \bfcode{ARKodeSetDenseOrder}}{void*\emph{ arkode\_mem}, int\emph{ dord}}{}
Specifies the order of accuracy for the polynomial interpolant
used for dense output (i.e. interpolation of solution output values
and implicit method predictors).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{dord} -- requested polynomial order of accuracy

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Allowed values are between 0 and \code{min(q,3)}, where \code{q} is
the order of the overall integration method.

\end{fulllineitems}

\index{ARKodeSetDiagnostics (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetDiagnostics}\pysiglinewithargsret{int \bfcode{ARKodeSetDiagnostics}}{void*\emph{ arkode\_mem}, FILE*\emph{ diagfp}}{}
Specifies the file pointer for a diagnostics file where
all ARKode step adaptivity and solver information is written.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{diagfp} -- pointer to the diagnostics output file

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This parameter can be \code{stdout} or \code{stderr}, although the
suggested approach is to specify a pointer to a unique file opened
by the user and returned by \code{fopen}.  If not called, or if called
with a \code{NULL} file pointer, all diagnostics output is disabled.

When run in parallel, only one process should set a non-NULL value
for this pointer, since statistics from all processes would be
identical.

\end{fulllineitems}

\index{ARKodeSetErrFile (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetErrFile}\pysiglinewithargsret{int \bfcode{ARKodeSetErrFile}}{void*\emph{ arkode\_mem}, FILE*\emph{ errfp}}{}
Specifies a pointer to the file where all ARKode warning and error
messages will be written if the default internal error handling
function is used.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{errfp} -- pointer to the output file.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default value for \emph{errfp} is \code{stderr}.

Passing a \code{NULL} value disables all future error message output
(except for the case wherein the ARKode memory pointer is
\code{NULL}.  This use of the function is strongly discouraged.

If used, this routine should be called before any other
optional input functions, in order to take effect for subsequent
error messages.

\end{fulllineitems}

\index{ARKodeSetErrHandlerFn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetErrHandlerFn}\pysiglinewithargsret{int \bfcode{ARKodeSetErrHandlerFn}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKErrHandlerFn]{\emph{ARKErrHandlerFn}}}\emph{ ehfun}, void*\emph{ eh\_data}}{}
Specifies the optional user-defined function to be used
in handling error messages.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{ehfun} -- name of user-supplied error handler function.

\item {} 
\emph{eh\_data} -- pointer to user data passed to \emph{ehfun} every time
it is called

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Error messages indicating that the ARKode solver memory is
\code{NULL} will always be directed to \code{stderr}.

\end{fulllineitems}

\index{ARKodeSetInitStep (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetInitStep}\pysiglinewithargsret{int \bfcode{ARKodeSetInitStep}}{void*\emph{ arkode\_mem}, realtype\emph{ hin}}{}
Specifies the initial time step size ARKode should use after
initialization or reinitialization.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hin} -- value of the initial step to be attempted \((\ge 0)\)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Pass 0.0 to use the default value.

By default, ARKode estimates the initial step size to be the
solution \(h\) of the equation \(\left\| \frac{h^2
\ddot{y}}{2}\right\| = 1\), where \(\ddot{y}\) is an estimated
value of the second derivative of the solution at \emph{t0}.

\end{fulllineitems}

\index{ARKodeSetFixedStep (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetFixedStep}\pysiglinewithargsret{int \bfcode{ARKodeSetFixedStep}}{void*\emph{ arkode\_mem}, realtype\emph{ hfixed}}{}
Disabled time step adaptivity within ARKode, and specifies the
fixed time step size to use for all internal steps.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hfixed} -- value of the fixed step size to use

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Pass 0.0 to return ARKode to the default (adaptive-step) mode.

Use of this function is not recommended, since we may give no
assurance of the validity of the computed solutions.  It is
primarily provided for code-to-code verification testing purposes.

When using {\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}}, any values provided to
the functions
{\hyperref[c_interface/User_callable:c.ARKodeSetInitStep]{\emph{\code{ARKodeSetInitStep()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityFn]{\emph{\code{ARKodeSetAdaptivityFn()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxErrTestFails]{\emph{\code{ARKodeSetMaxErrTestFails()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetCFLFraction]{\emph{\code{ARKodeSetCFLFraction()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetErrorBias]{\emph{\code{ARKodeSetErrorBias()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStepBounds]{\emph{\code{ARKodeSetFixedStepBounds()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxCFailGrowth]{\emph{\code{ARKodeSetMaxCFailGrowth()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxEFailGrowth]{\emph{\code{ARKodeSetMaxEFailGrowth()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxFirstGrowth]{\emph{\code{ARKodeSetMaxFirstGrowth()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxGrowth]{\emph{\code{ARKodeSetMaxGrowth()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetSafetyFactor]{\emph{\code{ARKodeSetSafetyFactor()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetSmallNumEFails]{\emph{\code{ARKodeSetSmallNumEFails()}}}} and
{\hyperref[c_interface/User_callable:c.ARKodeSetStabilityFn]{\emph{\code{ARKodeSetStabilityFn()}}}}
will be ignored, since temporal adaptivity is disabled.

If both {\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}} and
{\hyperref[c_interface/User_callable:c.ARKodeSetStopTime]{\emph{\code{ARKodeSetStopTime()}}}} are used, then the fixed step size
will be used for all steps until the final step preceding the
provided stop time (which may be shorter).  To resume use of the
previous fixed step size, another call to
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}} must be made prior to calling
{\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} to resume integration.

It is \emph{not} recommended that {\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}} be used
in concert with {\hyperref[c_interface/User_callable:c.ARKodeSetMaxStep]{\emph{\code{ARKodeSetMaxStep()}}}} or
{\hyperref[c_interface/User_callable:c.ARKodeSetMinStep]{\emph{\code{ARKodeSetMinStep()}}}}, since at best those routines will
provide no useful information to the solver, and at worst they may
interfere with the desired fixed step size.

\end{fulllineitems}

\index{ARKodeSetMaxHnilWarns (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxHnilWarns}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxHnilWarns}}{void*\emph{ arkode\_mem}, int\emph{ mxhnil}}{}
Specifies the maximum number of messages issued by the
solver to warn that \(t+h=t\) on the next internal step, before
ARKode will instead return with an error.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{mxhnil} -- maximum allowed number of warning messages (\textgreater{}0).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default value is 10; set \emph{mxhnil} to zero to specify
this default.

A negative value indicates that no warning messages should be issued.

\end{fulllineitems}

\index{ARKodeSetMaxNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxNumSteps}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxNumSteps}}{void*\emph{ arkode\_mem}, long int\emph{ mxsteps}}{}
Specifies the maximum number of steps to be taken by the
solver in its attempt to reach the next output time, before ARKode
will return with an error.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{mxsteps} -- maximum allowed number of internal steps.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Passing \emph{mxsteps} = 0 results in ARKode using the
default value (500).

Passing \emph{mxsteps} \textless{} 0 disables the test (not recommended).

\end{fulllineitems}

\index{ARKodeSetMaxErrTestFails (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxErrTestFails}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxErrTestFails}}{void*\emph{ arkode\_mem}, int\emph{ maxnef}}{}
Specifies the maximum number of error test failures
permitted in attempting one step, before ARKode
will return with an error.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{maxnef} -- maximum allowed number of error test failures \((>0)\)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default value is 7; set \emph{maxnef} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{ARKodeSetMaxStep (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxStep}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxStep}}{void*\emph{ arkode\_mem}, realtype\emph{ hmax}}{}
Specifies the upper bound on the magnitude of the time step size.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hmax} -- maximum absolute value of the time step size \((\ge 0)\)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Pass \emph{hmax} \(\le 0.0\) to set the default value of \(\infty\).

\end{fulllineitems}

\index{ARKodeSetMinStep (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMinStep}\pysiglinewithargsret{int \bfcode{ARKodeSetMinStep}}{void*\emph{ arkode\_mem}, realtype\emph{ hmin}}{}
Specifies the lower bound on the magnitude of the time step size.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hmin} -- minimum absolute value of the time step size \((\ge 0)\)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Pass \emph{hmin} \(\le 0.0\) to set the default value of 0.

\end{fulllineitems}

\index{ARKodeSetOptimalParams (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetOptimalParams}\pysiglinewithargsret{int \bfcode{ARKodeSetOptimalParams}}{void*\emph{ arkode\_mem}}{}
Sets all adaptivity and solver parameters to our `best
guess' values, for a given integration method (ERK, DIRK, ARK) and
a given method order.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Should only be called after the method order and integration
method have been set.  These values resulted from repeated testing
of ARKode's solvers on a variety of training problems.  However,
all problems are different, so these values may not be optimal for
all users.

\end{fulllineitems}

\index{ARKodeSetStopTime (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetStopTime}\pysiglinewithargsret{int \bfcode{ARKodeSetStopTime}}{void*\emph{ arkode\_mem}, realtype\emph{ tstop}}{}
Specifies the value of the independent variable
\(t\) past which the solution is not to proceed.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{tstop} -- stopping time for the integrator.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default is that no stop time is imposed.

\end{fulllineitems}

\index{ARKodeSetUserData (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetUserData}\pysiglinewithargsret{int \bfcode{ARKodeSetUserData}}{void*\emph{ arkode\_mem}, void*\emph{ user\_data}}{}
Specifies the user data block \emph{user\_data} and
attaches it to the main ARKode memory block.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{user\_data} -- pointer to the user data.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} If specified, the pointer to \emph{user\_data} is passed to all
user-supplied functions for which it is an argument; otherwise
\code{NULL} is passed.

If \emph{user\_data} is needed in user linear solver or preconditioner
functions, the call to this function must be made \emph{before} the call
to specify the linear solver.

\end{fulllineitems}



\subsubsection{Optional inputs for IVP method selection}
\label{c_interface/User_callable:optional-inputs-for-ivp-method-selection}\label{c_interface/User_callable:cinterface-arkodemethodinputtable}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Optional input
} & \textsf{\relax 
Function name
} & \textsf{\relax 
Default
}\\
\hline
Set integrator method order
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetOrder]{\emph{\code{ARKodeSetOrder()}}}}
 & 
4
\\
\hline
Specify implicit/explicit problem
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetImEx]{\emph{\code{ARKodeSetImEx()}}}}
 & 
\code{SUNTRUE}
\\
\hline
Specify explicit problem
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetExplicit]{\emph{\code{ARKodeSetExplicit()}}}}
 & 
\code{SUNFALSE}
\\
\hline
Specify implicit problem
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetImplicit]{\emph{\code{ARKodeSetImplicit()}}}}
 & 
\code{SUNFALSE}
\\
\hline
Set additive RK tables
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetARKTables]{\emph{\code{ARKodeSetARKTables()}}}}
 & 
internal
\\
\hline
Set explicit RK table
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetERKTable]{\emph{\code{ARKodeSetERKTable()}}}}
 & 
internal
\\
\hline
Set implicit RK table
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetIRKTable]{\emph{\code{ARKodeSetIRKTable()}}}}
 & 
internal
\\
\hline
Specify additive RK table numbers
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetARKTableNum]{\emph{\code{ARKodeSetARKTableNum()}}}}
 & 
internal
\\
\hline
Specify explicit RK table number
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}
 & 
internal
\\
\hline
Specify implicit RK table number
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}
 & 
internal
\\
\hline\end{tabulary}

\index{ARKodeSetOrder (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetOrder}\pysiglinewithargsret{int \bfcode{ARKodeSetOrder}}{void*\emph{ arkode\_mem}, int\emph{ ord}}{}
Specifies the order of accuracy for the integration method.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{ord} -- requested order of accuracy.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} For explicit methods, the allowed values are \(2 \le\)
\emph{ord} \(\le 8\).  For implicit methods, the allowed values are
\(2\le\) \emph{ord} \(\le 5\), and for ImEx methods the allowed
values are \(3 \le\) \emph{ord} \(\le 5\).  Any illegal input
will result in the default value of 4.

Since \emph{ord} affects the memory requirements for the internal
ARKode memory block, it cannot be increased between calls to
{\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} unless {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} is called.

\end{fulllineitems}
\index{ARKodeSetImEx (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetImEx}\pysiglinewithargsret{int \bfcode{ARKodeSetImEx}}{void*\emph{ arkode\_mem}}{}
Specifies that both the implicit and explicit portions
of problem are enabled, and to use an additive Runge Kutta method.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This is automatically deduced when neither of the function
pointers \emph{fe} or \emph{fi} passed to {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}} are \code{NULL}, but
may be set directly by the user if desired.

\end{fulllineitems}

\index{ARKodeSetExplicit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetExplicit}\pysiglinewithargsret{int \bfcode{ARKodeSetExplicit}}{void*\emph{ arkode\_mem}}{}
Specifies that the implicit portion of problem is disabled,
and to use an explicit RK method.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This is automatically deduced when the function pointer \emph{fi}
passed to {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}} is \code{NULL}, but may be set
directly by the user if desired.

\end{fulllineitems}

\index{ARKodeSetImplicit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetImplicit}\pysiglinewithargsret{int \bfcode{ARKodeSetImplicit}}{void*\emph{ arkode\_mem}}{}
Specifies that the explicit portion of problem is disabled,
and to use a diagonally implicit RK method.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This is automatically deduced when the function pointer \emph{fe}
passed to {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}} is \code{NULL}, but may be set directly by the
user if desired.

\end{fulllineitems}

\index{ARKodeSetARKTables (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetARKTables}\pysiglinewithargsret{int \bfcode{ARKodeSetARKTables}}{void*\emph{ arkode\_mem}, int\emph{ s}, int\emph{ q}, int\emph{ p}, realtype*\emph{ ci}, realtype*\emph{ ce}, realtype*\emph{ Ai}, realtype*\emph{ Ae}, realtype*\emph{ bi}, realtype*\emph{ be}, realtype*\emph{ b2i}, realtype*\emph{ b2e}}{}
Specifies a customized Butcher table pair for the
additive RK method.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{s} -- number of stages in the RK method.

\item {} 
\emph{q} -- global order of accuracy for the RK method.

\item {} 
\emph{p} -- global order of accuracy for the embedded RK method.

\item {} 
\emph{ci} -- array (of length \emph{s}) of stage times for the implicit RK method.

\item {} 
\emph{ce} -- array (of length \emph{s}) of stage times for the explicit RK method.

\item {} 
\emph{Ai} -- array of coefficients defining the implicit RK stages.  This should
be stored as a 1D array of size \emph{s*s}, in row-major order.

\item {} 
\emph{Ae} -- array of coefficients defining the explicit RK stages.  This should
be stored as a 1D array of size \emph{s*s}, in row-major order.

\item {} 
\emph{bi} -- array of implicit coefficients (of length \emph{s}) defining the time step solution.

\item {} 
\emph{be} -- array of explicit coefficients (of length \emph{s}) defining the time step solution.

\item {} 
\emph{b2i} -- array of implicit coefficients (of length \emph{s}) defining the embedded solution.

\item {} 
\emph{b2e} -- array of explicit coefficients (of length \emph{s}) defining the embedded solution.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This automatically calls {\hyperref[c_interface/User_callable:c.ARKodeSetImEx]{\emph{\code{ARKodeSetImEx()}}}}.

No error checking is performed to ensure that either \emph{p} or \emph{q}
correctly describe the coefficients that were input.

Error checking is performed on both \emph{Ai} and \emph{Ae} to ensure
that they specify DIRK and ERK methods, respectively.

If either the inputs \emph{b2i} or \emph{b2e} are set to \code{NULL}, ARKode
will run in fixed-step mode (see {\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}});
if called in this manner the user \emph{must} call either
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}} or {\hyperref[c_interface/User_callable:c.ARKodeSetInitStep]{\emph{\code{ARKodeSetInitStep()}}}} to
set the desired time step size.

\end{fulllineitems}

\index{ARKodeSetERKTable (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetERKTable}\pysiglinewithargsret{int \bfcode{ARKodeSetERKTable}}{void*\emph{ arkode\_mem}, int\emph{ s}, int\emph{ q}, int\emph{ p}, realtype*\emph{ c}, realtype*\emph{ A}, realtype*\emph{ b}, realtype*\emph{ bembed}}{}
Specifies a customized Butcher table for the explicit portion of the system.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{s} -- number of stages in the RK method.

\item {} 
\emph{q} -- global order of accuracy for the RK method.

\item {} 
\emph{p} -- global order of accuracy for the embedded RK method.

\item {} 
\emph{c} -- array (of length \emph{s}) of stage times for the RK method.

\item {} 
\emph{A} -- array of coefficients defining the RK stages.  This should
be stored as a 1D array of size \emph{s*s}, in row-major order.

\item {} 
\emph{b} -- array of coefficients (of length \emph{s}) defining the time step solution.

\item {} 
\emph{bembed} -- array of coefficients (of length \emph{s}) defining the embedded solution.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This automatically calls {\hyperref[c_interface/User_callable:c.ARKodeSetExplicit]{\emph{\code{ARKodeSetExplicit()}}}}.

No error checking is performed to ensure that either \emph{p} or \emph{q}
correctly describe the coefficients that were input.

Error checking is performed to ensure that \emph{A} is strictly
lower-triangular (i.e. that it specifies an ERK method).

An input \emph{bembed} of \code{NULL} will signal that ARKode will run in
fixed-step mode (see {\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}}); if called in
this manner the user \emph{must} call either
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}} or {\hyperref[c_interface/User_callable:c.ARKodeSetInitStep]{\emph{\code{ARKodeSetInitStep()}}}} to
set the desired time step size.

\end{fulllineitems}

\index{ARKodeSetIRKTable (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetIRKTable}\pysiglinewithargsret{int \bfcode{ARKodeSetIRKTable}}{void*\emph{ arkode\_mem}, int\emph{ s}, int\emph{ q}, int\emph{ p}, realtype*\emph{ c}, realtype*\emph{ A}, realtype*\emph{ b}, realtype*\emph{ bembed}}{}
Specifies a customized Butcher table for the implicit portion of the system.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{s} -- number of stages in the RK method.

\item {} 
\emph{q} -- global order of accuracy for the RK method.

\item {} 
\emph{p} -- global order of accuracy for the embedded RK method.

\item {} 
\emph{c} -- array (of length \emph{s}) of stage times for the RK method.

\item {} 
\emph{A} -- array of coefficients defining the RK stages.  This should
be stored as a 1D array of size \emph{s*s}, in row-major order.

\item {} 
\emph{b} -- array of coefficients (of length \emph{s}) defining the time step solution.

\item {} 
\emph{bembed} -- array of coefficients (of length \emph{s}) defining the embedded solution.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This automatically calls {\hyperref[c_interface/User_callable:c.ARKodeSetImplicit]{\emph{\code{ARKodeSetImplicit()}}}}.

No error checking is performed to ensure that either \emph{p} or \emph{q}
correctly describe the coefficients that were input.

Error checking is performed to ensure that \emph{A} is
lower-triangular with a nonzero value on at least one of the
diagonal entries (i.e. that it specifies a DIRK method).

An input \emph{bembed} of \code{NULL} will signal that ARKode will run in
fixed-step mode (see {\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}}); if called in
this manner the user \emph{must} call either
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}} or {\hyperref[c_interface/User_callable:c.ARKodeSetInitStep]{\emph{\code{ARKodeSetInitStep()}}}} to
set the desired time step size.

\end{fulllineitems}

\index{ARKodeSetARKTableNum (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetARKTableNum}\pysiglinewithargsret{int \bfcode{ARKodeSetARKTableNum}}{void*\emph{ arkode\_mem}, int\emph{ itable}, int\emph{ etable}}{}
Indicates to use specific built-in Butcher tables for the ImEx system.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{itable} -- index of the DIRK Butcher table.

\item {} 
\emph{etable} -- index of the ERK Butcher table.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Both \emph{itable} and \emph{etable} should match an existing
implicit/explicit pair, listed in the section {\hyperref[Butcher:butcher-additive]{\emph{\DUspan{}{Additive Butcher tables}}}}.
Error-checking is performed to ensure that the tables exist.
Subsequent error-checking is automatically performed to ensure that
the tables' stage times and solution coefficients match.

This automatically calls {\hyperref[c_interface/User_callable:c.ARKodeSetImEx]{\emph{\code{ARKodeSetImEx()}}}}.

\end{fulllineitems}

\index{ARKodeSetERKTableNum (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetERKTableNum}\pysiglinewithargsret{int \bfcode{ARKodeSetERKTableNum}}{void*\emph{ arkode\_mem}, int\emph{ etable}}{}
Indicates to use a specific built-in Butcher table for explicit
integration of the problem.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{etable} -- index of the Butcher table.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} \emph{etable} should match an existing explicit method from
the section {\hyperref[Butcher:butcher-explicit]{\emph{\DUspan{}{Explicit Butcher tables}}}}.  Error-checking is performed
to ensure that the table exists, and is not implicit.

This automatically calls {\hyperref[c_interface/User_callable:c.ARKodeSetExplicit]{\emph{\code{ARKodeSetExplicit()}}}}.

\end{fulllineitems}

\index{ARKodeSetIRKTableNum (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetIRKTableNum}\pysiglinewithargsret{int \bfcode{ARKodeSetIRKTableNum}}{void*\emph{ arkode\_mem}, int\emph{ itable}}{}
Indicates to use a specific built-in Butcher table for implicit
integration of the problem.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{itable} -- index of the Butcher table.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} \emph{itable} should match an existing implicit method from
the section {\hyperref[Butcher:butcher-implicit]{\emph{\DUspan{}{Implicit Butcher tables}}}}.  Error-checking is performed
to ensure that the table exists, and is not explicit.

This automatically calls {\hyperref[c_interface/User_callable:c.ARKodeSetImplicit]{\emph{\code{ARKodeSetImplicit()}}}}.

\end{fulllineitems}



\subsubsection{Optional inputs for time step adaptivity}
\label{c_interface/User_callable:cinterface-arkodeadaptivityinputtable}\label{c_interface/User_callable:optional-inputs-for-time-step-adaptivity}
The mathematical explanation of ARKode's time step adaptivity
algorithm, including how each of the parameters below is used within
the code, is provided in the section {\hyperref[Mathematics:mathematics-adaptivity]{\emph{\DUspan{}{Time step adaptivity}}}}.

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Optional input
} & \textsf{\relax 
Function name
} & \textsf{\relax 
Default
}\\
\hline
Set a custom time step adaptivity function
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityFn]{\emph{\code{ARKodeSetAdaptivityFn()}}}}
 & 
internal
\\
\hline
Choose an existing time step adaptivity method
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}}
 & 
0
\\
\hline
Explicit stability safety factor
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetCFLFraction]{\emph{\code{ARKodeSetCFLFraction()}}}}
 & 
0.5
\\
\hline
Time step error bias factor
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetErrorBias]{\emph{\code{ARKodeSetErrorBias()}}}}
 & 
1.5
\\
\hline
Bounds determining no change in step size
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStepBounds]{\emph{\code{ARKodeSetFixedStepBounds()}}}}
 & 
1.0  1.5
\\
\hline
Maximum step growth factor on convergence fail
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxCFailGrowth]{\emph{\code{ARKodeSetMaxCFailGrowth()}}}}
 & 
0.25
\\
\hline
Maximum step growth factor on error test fail
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxEFailGrowth]{\emph{\code{ARKodeSetMaxEFailGrowth()}}}}
 & 
0.3
\\
\hline
Maximum first step growth factor
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxFirstGrowth]{\emph{\code{ARKodeSetMaxFirstGrowth()}}}}
 & 
10000.0
\\
\hline
Maximum general step growth factor
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxGrowth]{\emph{\code{ARKodeSetMaxGrowth()}}}}
 & 
20.0
\\
\hline
Time step safety factor
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetSafetyFactor]{\emph{\code{ARKodeSetSafetyFactor()}}}}
 & 
0.96
\\
\hline
Error fails before MaxEFailGrowth takes effect
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetSmallNumEFails]{\emph{\code{ARKodeSetSmallNumEFails()}}}}
 & 
2
\\
\hline
Explicit stability function
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetStabilityFn]{\emph{\code{ARKodeSetStabilityFn()}}}}
 & 
internal
\\
\hline\end{tabulary}

\index{ARKodeSetAdaptivityFn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetAdaptivityFn}\pysiglinewithargsret{int \bfcode{ARKodeSetAdaptivityFn}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKAdaptFn]{\emph{ARKAdaptFn}}}\emph{ hfun}, void*\emph{ h\_data}}{}
Sets a user-supplied time-step adaptivity function.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hfun} -- name of user-supplied adaptivity function.

\item {} 
\emph{h\_data} -- pointer to user data passed to \emph{hfun} every time
it is called.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This function should focus on accuracy-based time step
estimation; for stability based time steps the function
{\hyperref[c_interface/User_callable:c.ARKodeSetStabilityFn]{\emph{\code{ARKodeSetStabilityFn()}}}} should be used instead.

\end{fulllineitems}

\index{ARKodeSetAdaptivityMethod (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetAdaptivityMethod}\pysiglinewithargsret{int \bfcode{ARKodeSetAdaptivityMethod}}{void*\emph{ arkode\_mem}, int\emph{ imethod}, int\emph{ idefault}, int\emph{ pq}, realtype*\emph{ adapt\_params}}{}
Specifies the method (and associated parameters) used for time step adaptivity.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{imethod} -- accuracy-based adaptivity method choice
(0 \(\le\) \emph{imethod} \(\le\) 5):
0 is PID, 1 is PI, 2 is I, 3 is explicit Gustafsson, 4 is
implicit Gustafsson, and 5 is the ImEx Gustafsson.

\item {} 
\emph{idefault} -- flag denoting whether to use default adaptivity
parameters (1), or that they will be supplied in the
\emph{adapt\_params} argument (0).

\item {} 
\emph{pq} -- flag denoting whether to use the embedding order of
accuracy \emph{p} (0) or the method order of accuracy \emph{q} (1)
within the adaptivity algorithm.  \emph{p} is the ARKode default.

\item {} 
\emph{adapt\_params{[}0{]}} -- \(k_1\) parameter within accuracy-based adaptivity algorithms.

\item {} 
\emph{adapt\_params{[}1{]}} -- \(k_2\) parameter within accuracy-based adaptivity algorithms.

\item {} 
\emph{adapt\_params{[}2{]}} -- \(k_3\) parameter within accuracy-based adaptivity algorithms.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} If custom parameters are supplied, they will be checked
for validity against published stability intervals.  If other
parameter values are desired, it is recommended to instead provide
a custom function through a call to {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityFn]{\emph{\code{ARKodeSetAdaptivityFn()}}}}.

\end{fulllineitems}

\index{ARKodeSetCFLFraction (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetCFLFraction}\pysiglinewithargsret{int \bfcode{ARKodeSetCFLFraction}}{void*\emph{ arkode\_mem}, realtype\emph{ cfl\_frac}}{}
Specifies the fraction of the estimated explicitly stable step to use.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{cfl\_frac} -- maximum allowed fraction of explicitly stable step (default is 0.5).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any non-positive parameter will imply a reset to the default
value.

\end{fulllineitems}

\index{ARKodeSetErrorBias (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetErrorBias}\pysiglinewithargsret{int \bfcode{ARKodeSetErrorBias}}{void*\emph{ arkode\_mem}, realtype\emph{ bias}}{}
Specifies the bias to be applied to the error estimates within
accuracy-based adaptivity strategies.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{bias} -- bias applied to error in accuracy-based time
step estimation (default is 1.5).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any value below 1.0 will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetFixedStepBounds (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetFixedStepBounds}\pysiglinewithargsret{int \bfcode{ARKodeSetFixedStepBounds}}{void*\emph{ arkode\_mem}, realtype\emph{ lb}, realtype\emph{ ub}}{}
Specifies the step growth interval in which the step size will remain unchanged.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lb} -- lower bound on window to leave step size fixed (default is 1.0).

\item {} 
\emph{ub} -- upper bound on window to leave step size fixed (default is 1.5).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any interval \emph{not} containing 1.0 will imply a reset to the default values.

\end{fulllineitems}

\index{ARKodeSetMaxCFailGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxCFailGrowth}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxCFailGrowth}}{void*\emph{ arkode\_mem}, realtype\emph{ etacf}}{}
Specifies the maximum step size growth factor upon a convergence
failure on a stage solve within a step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{etacf} -- time step reduction factor on a nonlinear solver
convergence failure (default is 0.25).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any value outside the interval \((0,1]\) will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetMaxEFailGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxEFailGrowth}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxEFailGrowth}}{void*\emph{ arkode\_mem}, realtype\emph{ etamxf}}{}
Specifies the maximum step size growth factor upon multiple successive
accuracy-based error failures in the solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{etamxf} -- time step reduction factor on multiple error fails (default is 0.3).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any value outside the interval \((0,1]\) will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetMaxFirstGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxFirstGrowth}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxFirstGrowth}}{void*\emph{ arkode\_mem}, realtype\emph{ etamx1}}{}
Specifies the maximum allowed step size change following the very
first integration step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{etamx1} -- maximum allowed growth factor after the first time
step (default is 10000.0).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any value \(\le 1.0\) will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetMaxGrowth (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxGrowth}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxGrowth}}{void*\emph{ arkode\_mem}, realtype\emph{ mx\_growth}}{}
Specifies the maximum growth of the step size between consecutive
steps in the integration process.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{growth} -- maximum allowed growth factor between consecutive time steps (default is 20.0).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any value \(\le 1.0\) will imply a reset to the default
value.

\end{fulllineitems}

\index{ARKodeSetSafetyFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetSafetyFactor}\pysiglinewithargsret{int \bfcode{ARKodeSetSafetyFactor}}{void*\emph{ arkode\_mem}, realtype\emph{ safety}}{}
Specifies the safety factor to be applied to the accuracy-based
estimated step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{safety} -- safety factor applied to accuracy-based time step (default is 0.96).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any non-positive parameter will imply a reset to the default
value.

\end{fulllineitems}

\index{ARKodeSetSmallNumEFails (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetSmallNumEFails}\pysiglinewithargsret{int \bfcode{ARKodeSetSmallNumEFails}}{void*\emph{ arkode\_mem}, int\emph{ small\_nef}}{}
Specifies the threshold for ``multiple'' successive error failures
before the \emph{etamxf} parameter from
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxEFailGrowth]{\emph{\code{ARKodeSetMaxEFailGrowth()}}}} is applied.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{small\_nef} -- bound to determine `multiple' for \emph{etamxf} (default is 2).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetStabilityFn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetStabilityFn}\pysiglinewithargsret{int \bfcode{ARKodeSetStabilityFn}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKExpStabFn]{\emph{ARKExpStabFn}}}\emph{ EStab}, void*\emph{ estab\_data}}{}
Sets the problem-dependent function to estimate a stable
time step size for the explicit portion of the ODE system.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{EStab} -- name of user-supplied stability function.

\item {} 
\emph{estab\_data} -- pointer to user data passed to \emph{EStab} every time
it is called.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This function should return an estimate of the absolute
value of the maximum stable time step for the explicit portion of
the ODE system.  It is not required, since accuracy-based
adaptivity may be sufficient for retaining stability, but this can
be quite useful for problems where the explicit right-hand side
function \(f_E(t,y)\) may contain stiff terms.

\end{fulllineitems}



\subsubsection{Optional inputs for implicit stage solves}
\label{c_interface/User_callable:cinterface-cinterface-arkodesolverinputtable}\label{c_interface/User_callable:optional-inputs-for-implicit-stage-solves}
The mathematical explanation for ARKode's nonlinear solver strategies,
including how each of the parameters below is used within the code, is
provided in the section {\hyperref[Mathematics:mathematics-nonlinear]{\emph{\DUspan{}{Nonlinear solver methods}}}}.

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Optional input
} & \textsf{\relax 
Function name
} & \textsf{\relax 
Default
}\\
\hline
Specify use of the fixed-point stage solver
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedPoint]{\emph{\code{ARKodeSetFixedPoint()}}}}
 & 
\code{SUNFALSE}
\\
\hline
Specify use of the Newton stage solver
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNewton]{\emph{\code{ARKodeSetNewton()}}}}
 & 
\code{SUNTRUE}
\\
\hline
Specify linearly implicit \(f_I\)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetLinear]{\emph{\code{ARKodeSetLinear()}}}}
 & 
\code{SUNFALSE}
\\
\hline
Specify nonlinearly implicit \(f_I\)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinear]{\emph{\code{ARKodeSetNonlinear()}}}}
 & 
\code{SUNTRUE}
\\
\hline
Implicit predictor method
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetPredictorMethod]{\emph{\code{ARKodeSetPredictorMethod()}}}}
 & 
0
\\
\hline
Maximum number of nonlinear iterations
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxNonlinIters]{\emph{\code{ARKodeSetMaxNonlinIters()}}}}
 & 
3
\\
\hline
Coefficient in the nonlinear convergence test
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinConvCoef]{\emph{\code{ARKodeSetNonlinConvCoef()}}}}
 & 
0.1
\\
\hline
Nonlinear convergence rate constant
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinCRDown]{\emph{\code{ARKodeSetNonlinCRDown()}}}}
 & 
0.3
\\
\hline
Nonlinear residual divergence ratio
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinRDiv]{\emph{\code{ARKodeSetNonlinRDiv()}}}}
 & 
2.3
\\
\hline
Max change in step signaling new \(J\)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetDeltaGammaMax]{\emph{\code{ARKodeSetDeltaGammaMax()}}}}
 & 
0.2
\\
\hline
Max steps between calls to new \(J\)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxStepsBetweenLSet]{\emph{\code{ARKodeSetMaxStepsBetweenLSet()}}}}
 & 
20
\\
\hline
Maximum number of convergence failures
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxConvFails]{\emph{\code{ARKodeSetMaxConvFails()}}}}
 & 
10
\\
\hline\end{tabulary}

\index{ARKodeSetFixedPoint (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetFixedPoint}\pysiglinewithargsret{int \bfcode{ARKodeSetFixedPoint}}{void*\emph{ arkode\_mem}, long int\emph{ fp\_m}}{}
Specifies that the implicit portion of the problem should be solved
using the accelerated fixed-point solver instead of the modified
Newton iteration, and provides the maximum dimension of the
acceleration subspace.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{fp\_m} -- number of vectors to store within the Anderson
acceleration subspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Since the accelerated fixed-point solver has a slower
rate of convergence than the Newton iteration (but each iteration
is typically much more efficient), it is recommended that the
maximum nonlinear correction iterations be increased through a call
to {\hyperref[c_interface/User_callable:c.ARKodeSetMaxNonlinIters]{\emph{\code{ARKodeSetMaxNonlinIters()}}}}.

\end{fulllineitems}

\index{ARKodeSetNewton (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetNewton}\pysiglinewithargsret{int \bfcode{ARKodeSetNewton}}{void*\emph{ arkode\_mem}}{}
Specifies that the implicit portion of the problem should be solved
using the modified Newton solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This is the default behavior of ARKode, so the function
is primarily useful to undo a previous call to {\hyperref[c_interface/User_callable:c.ARKodeSetFixedPoint]{\emph{\code{ARKodeSetFixedPoint()}}}}.

\end{fulllineitems}

\index{ARKodeSetLinear (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetLinear}\pysiglinewithargsret{int \bfcode{ARKodeSetLinear}}{void*\emph{ arkode\_mem}, int\emph{ timedepend}}{}
Specifies that the implicit portion of the problem is linear.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{timedepend} -- flag denoting whether the Jacobian of
\(f_I(t,y)\) is time-dependent (1) or not (0).
Alternately, when using an iterative linear solver this flag
denotes time dependence of the preconditioner.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Tightens the linear solver tolerances and takes only a
single Newton iteration.  Calls {\hyperref[c_interface/User_callable:c.ARKodeSetDeltaGammaMax]{\emph{\code{ARKodeSetDeltaGammaMax()}}}}
to enforce Jacobian recomputation when the step size ratio changes
by more than 100 times the unit roundoff (since nonlinear
convergence is not tested).  Only applicable when used in
combination with the modified Newton iteration (not the fixed-point
solver).

\end{fulllineitems}

\index{ARKodeSetNonlinear (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetNonlinear}\pysiglinewithargsret{int \bfcode{ARKodeSetNonlinear}}{void*\emph{ arkode\_mem}}{}
Specifies that the implicit portion of the problem is nonlinear.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} This is the default behavior of ARKode, so the function
is primarily useful to undo a previous call to
{\hyperref[c_interface/User_callable:c.ARKodeSetLinear]{\emph{\code{ARKodeSetLinear()}}}}.  Calls
{\hyperref[c_interface/User_callable:c.ARKodeSetDeltaGammaMax]{\emph{\code{ARKodeSetDeltaGammaMax()}}}} to reset the step size ratio
threshold to the default value.

\end{fulllineitems}

\index{ARKodeSetPredictorMethod (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetPredictorMethod}\pysiglinewithargsret{int \bfcode{ARKodeSetPredictorMethod}}{void*\emph{ arkode\_mem}, int\emph{ method}}{}
Specifies the method to use for predicting implicit solutions.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{method} -- method choice (0 \(\le\) \emph{method} \(\le\) 4):
\begin{itemize}
\item {} 
0 is the trivial predictor,

\item {} 
1 is the maximum order (dense output) predictor,

\item {} 
2 is the variable order predictor, that decreases the
polynomial degree for more distant RK stages,

\item {} 
3 is the cutoff order predictor, that uses the maximum order
for early RK stages, and a first-order predictor for distant
RK stages,

\item {} 
4 is the bootstrap predictor, that uses a second-order
predictor based on only information within the current step.

\item {} 
5 is the minimum correction predictor, that uses all
preceding stage information within the current step for
prediction.

\end{itemize}

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default value is 0.  If \emph{method} is set to an
undefined value, this default predictor will be used.

\end{fulllineitems}

\index{ARKodeSetMaxNonlinIters (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxNonlinIters}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxNonlinIters}}{void*\emph{ arkode\_mem}, int\emph{ maxcor}}{}
Specifies the maximum number of nonlinear solver
iterations permitted per RK stage within each time step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{maxcor} -- maximum allowed solver iterations per stage \((>0)\).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default value is 3; set \emph{maxcor} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{ARKodeSetNonlinConvCoef (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetNonlinConvCoef}\pysiglinewithargsret{int \bfcode{ARKodeSetNonlinConvCoef}}{void*\emph{ arkode\_mem}, realtype\emph{ nlscoef}}{}
Specifies the safety factor used within the nonlinear
solver convergence test.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nlscoef} -- coefficient in nonlinear solver convergence test \((>0.0)\).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default value is 0.1; set \emph{nlscoef} \(\le 0\)
to specify this default.

\end{fulllineitems}

\index{ARKodeSetNonlinCRDown (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetNonlinCRDown}\pysiglinewithargsret{int \bfcode{ARKodeSetNonlinCRDown}}{void*\emph{ arkode\_mem}, realtype\emph{ crdown}}{}
Specifies the constant used in estimating the nonlinear solver convergence rate.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{crdown} -- nonlinear convergence rate estimation constant (default is 0.3).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetNonlinRDiv (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetNonlinRDiv}\pysiglinewithargsret{int \bfcode{ARKodeSetNonlinRDiv}}{void*\emph{ arkode\_mem}, realtype\emph{ rdiv}}{}
Specifies the nonlinear correction threshold beyond which the
iteration will be declared divergent.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{rdiv} -- tolerance on nonlinear correction size ratio to
declare divergence (default is 2.3).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetDeltaGammaMax (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetDeltaGammaMax}\pysiglinewithargsret{int \bfcode{ARKodeSetDeltaGammaMax}}{void*\emph{ arkode\_mem}, realtype\emph{ dgmax}}{}
Specifies a scaled step size ratio tolerance, beyond which the
linear solver setup routine will be signaled.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{dgmax} -- tolerance on step size ratio change before calling
linear solver setup routine (default is 0.2).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:}  Any non-positive parameter will imply a reset to the default value.

\end{fulllineitems}

\index{ARKodeSetMaxStepsBetweenLSet (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxStepsBetweenLSet}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxStepsBetweenLSet}}{void*\emph{ arkode\_mem}, int\emph{ msbp}}{}
Specifies the frequency of calls to the linear solver setup
routine.  Positive values specify the number of time steps between
setup calls; negative values force recomputation at each Newton
step; zero values reset to the default.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{msbp} -- maximum number of time steps between linear solver
setup calls, or flag to force recomputation at each Newton
iteration (default is 20).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeSetMaxConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetMaxConvFails}\pysiglinewithargsret{int \bfcode{ARKodeSetMaxConvFails}}{void*\emph{ arkode\_mem}, int\emph{ maxncf}}{}
Specifies the maximum number of nonlinear solver
convergence failures permitted during one step, before ARKode will
return with an error.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{maxncf} -- maximum allowed nonlinear solver convergence failures
per step \((>0)\).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\end{description}

\textbf{Notes:} The default value is 10; set \emph{maxncf} \(\le 0\)
to specify this default.

Upon each convergence failure, ARKode will first call the Jacobian
setup routine and try again (if a Newton method is used).  If a
convergence failure still occurs, the time step size is reduced by
the factor \emph{etacf} (set within {\hyperref[c_interface/User_callable:c.ARKodeSetMaxCFailGrowth]{\emph{\code{ARKodeSetMaxCFailGrowth()}}}}).

\end{fulllineitems}



\subsubsection{Direct linear solver interface optional input functions}
\label{c_interface/User_callable:cinterface-arkdlsinputs}\label{c_interface/User_callable:direct-linear-solver-interface-optional-input-functions}
The mathematical explanation of ARKode's direct linear solver methods
is provided in the section {\hyperref[Mathematics:mathematics-linear]{\emph{\DUspan{}{Linear solver methods}}}}.


\paragraph{Table: Optional inputs for ARKDLS}
\label{c_interface/User_callable:table-optional-inputs-for-arkdls}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Optional input
} & \textsf{\relax 
Function name
} & \textsf{\relax 
Default
}\\
\hline
Jacobian function
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}}
 & 
\code{DQ}
\\
\hline
Mass matrix function
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}}
 & 
none
\\
\hline\end{tabulary}


The ARKDLS solver interface needs a function to compute an
approximation to the Jacobian matrix \(J(t,y)\). This function
must be of type {\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}}.  The user can supply a custom
Jacobian function, or if using a dense or banded \(J\) can use the
default internal difference quotient approximation that comes with the
ARKDLS interface.  To specify a user-supplied Jacobian function \emph{jac},
ARKDLS provides the function {\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}}. The ARKDLS
interface passes the user data pointer to the Jacobian function. This
allows the user to create an arbitrary structure with relevant problem
data and access it during the execution of the user-supplied Jacobian
function, without using global data in the program. The user
data pointer may be specified through {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

Similarly, if the ODE system involves a non-identity mass matrix,
\(M\ne I\), the ARKDLS interface needs a function to compute an
approximation to the mass matrix \(M(t)\). There is no default
difference quotient approximation, so this routine must be supplied by
the user. This function must be of type {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}, and
should be set using the function {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}}.  We note
that the ARKDLS solver passes the user data pointer to the mass matrix
function. This allows the user to create an arbitrary structure with
relevant problem data and access it during the execution of the
user-supplied mass matrix function, without using global data in the
program. The pointer user data may be specified through
{\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.
\index{ARKDlsSetJacFn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsSetJacFn}\pysiglinewithargsret{int \bfcode{ARKDlsSetJacFn}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{ARKDlsJacFn}}}\emph{ jac}}{}
Specifies the Jacobian approximation routine to
be used for the ARKDLS interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{jac} -- name of user-supplied Jacobian approximation function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS}  if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} This routine must be called after the ARKDLS linear
solver interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKDlsSetLinearSolver]{\emph{\code{ARKDlsSetLinearSolver()}}}}.

By default, ARKDLS uses an internal difference quotient
function for dense and band matrices.  If \code{NULL} is passed in for
\emph{jac}, this default is used. An error will occur if no \emph{jac}
is supplied when using a sparse matrix.

The function type {\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}} is described in the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKDlsSetMassFn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsSetMassFn}\pysiglinewithargsret{int \bfcode{ARKDlsSetMassFn}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{ARKDlsMassFn}}}\emph{ mass}}{}
Specifies the mass matrix approximation routine to be used for the
ARKDLS interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{mass} -- name of user-supplied mass matrix approximation function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS}  if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_MASSMEM\_NULL} if the mass matrix solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} This routine must be called after the ARKDLS mass matrix
solver interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKDlsSetMassLinearSolver]{\emph{\code{ARKDlsSetMassLinearSolver()}}}}.

Since there is no default difference quotient function for mass
matrices, \emph{mass} must be non-\code{NULL}.

The function type {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}} is described in the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

\end{fulllineitems}



\subsubsection{Iterative linear solvers optional input functions}
\label{c_interface/User_callable:iterative-linear-solvers-optional-input-functions}\label{c_interface/User_callable:cinterface-arkspilsinputs}
As described in the section {\hyperref[Mathematics:mathematics-linear]{\emph{\DUspan{}{Linear solver methods}}}}, when using
the ARKSPILS iterative linear solver interface, a user may supply a
preconditioning operator to aid in solution of the system.  This
operator consists of two user-supplied functions, \emph{psetup} and
\emph{psolve}, that are supplied to ARKode using either the function
{\hyperref[c_interface/User_callable:c.ARKSpilsSetPreconditioner]{\emph{\code{ARKSpilsSetPreconditioner()}}}} (for preconditioning the
Newton system), or the function
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassPreconditioner]{\emph{\code{ARKSpilsSetMassPreconditioner()}}}} (for preconditioning the
mass matrix system).  The \emph{psetup} function should handle evaluation
and preprocessing of any Jacobian or mass-matrix data needed by the
user's preconditioner solve function, \emph{psolve}.  The user data pointer
received through {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}} (or a pointer to
\code{NULL} if user data was not specified) is passed to the \emph{psetup} and
\emph{psolve} functions.  This allows the user to create an arbitrary
structure with relevant problem data and access it during the
execution of the user-supplied preconditioner functions without using
global data in the program.  If preconditioning is supplied for both
the Newton and mass matrix linear systems, it is expected that the
user will supply different \emph{psetup} and \emph{psolve} function for each.

Additionally, when solving the Newton linear systems, the ARKSPILS
interface requires a \emph{jtimes} function to compute an approximation to the
product between the Jacobian matrix \(J(t,y)\) and a vector
\(v\). The user can supply a custom Jacobian-times-vector
approximation function, or use the default internal difference
quotient function that comes with the ARKSPILS interface.  A
user-defined Jacobian-vector function must be of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{\code{ARKSpilsJacTimesVecFn}}}} and can be specified through a call
to {\hyperref[c_interface/User_callable:c.ARKSpilsSetJacTimes]{\emph{\code{ARKSpilsSetJacTimes()}}}} (see the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}} for specification details).  As with the
user-supplied preconditioner functions, the evaluation and
processing of any Jacobian-related data needed by the user's
Jacobian-times-vector function is done in the optional user-supplied
function of type {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{\code{ARKSpilsJacTimesSetupFn}}}} (see the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}} for specification details).  As with
the preconditioner functions, a pointer to the user-defined
data structure, \emph{user\_data}, specified through
{\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}} (or a \code{NULL} pointer otherwise) is
passed to the Jacobian-times-vector setup and product functions each
time they are called.

Similarly, if a problem involves a non-identity mass matrix,
\(M\ne I\), then the ARKSPILS solvers require a \emph{mtimes} function
to compute an approximation to the product between the mass matrix
\(M(t)\) and a vector \(v\).  This function must be
user-supplied, since there is no default value.  \emph{mtimes} must be
of type {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{\code{ARKSpilsMassTimesVecFn()}}}}, and can be specified
through a call to the  \code{ARKSpilsSetMassTimes()} routine.
As with the user-supplied preconditioner functions, the evaluation and
processing of any Jacobian-related data needed by the user's
mass-matrix-times-vector function is done in the optional user-supplied
function of type {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesSetupFn]{\emph{\code{ARKSpilsMassTimesSetupFn}}}} (see the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}} for specification details).

Finally, as described in the section {\hyperref[Mathematics:mathematics-error-linear]{\emph{\DUspan{}{Linear iteration error control}}}}, the
ARKSPILS interface requires that iterative linear solvers stop when
the norm of the preconditioned residual satisfies
\begin{gather}
\begin{split}\|r\| \le \frac{\epsilon_L \epsilon}{10}\end{split}\notag
\end{gather}
where the default \(\epsilon_L = 0.05\), which may be modified by
the user through the {\hyperref[c_interface/User_callable:c.ARKSpilsSetEpsLin]{\emph{\code{ARKSpilsSetEpsLin()}}}} function.


\paragraph{Table: Optional inputs for ARKSPILS}
\label{c_interface/User_callable:cinterface-arkspilsinputtable}\label{c_interface/User_callable:table-optional-inputs-for-arkspils}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Optional input
} & \textsf{\relax 
Function name
} & \textsf{\relax 
Default
}\\
\hline
\(Jv\) functions (\emph{jtimes} and \emph{jtsetup})
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsSetJacTimes]{\emph{\code{ARKSpilsSetJacTimes()}}}}
 & 
DQ,  none
\\
\hline
Newton linear and nonlinear tolerance ratio
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsSetEpsLin]{\emph{\code{ARKSpilsSetEpsLin()}}}}
 & 
0.05
\\
\hline
Newton preconditioning functions
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsSetPreconditioner]{\emph{\code{ARKSpilsSetPreconditioner()}}}}
 & 
\code{NULL}, \code{NULL}
\\
\hline
\(Mv\) functions (\emph{mtimes} and \emph{mtsetup})
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassTimes]{\emph{\code{ARKSpilsSetMassTimes()}}}}
 & 
none, none
\\
\hline
Mass matrix linear and nonlinear tolerance ratio
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassEpsLin]{\emph{\code{ARKSpilsSetMassEpsLin()}}}}
 & 
0.05
\\
\hline
Mass matrix preconditioning functions
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassPreconditioner]{\emph{\code{ARKSpilsSetMassPreconditioner()}}}}
 & 
\code{NULL}, \code{NULL}
\\
\hline\end{tabulary}

\index{ARKSpilsSetJacTimes (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetJacTimes}\pysiglinewithargsret{int \bfcode{ARKSpilsSetJacTimes}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{ARKSpilsJacTimesSetupFn}}}\emph{ jtsetup}, {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{ARKSpilsJacTimesVecFn}}}\emph{ jtimes}}{}
Specifies the Jacobian-times-vector setup and product functions.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{jtsetup} -- user-defined Jacobian-vector setup function.
Pass \code{NULL} if no setup is necessary.

\item {} 
\emph{jtimes} -- user-defined Jacobian-vector product function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful.

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\emph{ARKSPILS\_SUNLS\_FAIL} if an error occurred when setting up
the Jacobian-vector product in the \code{SUNLinearSolver}
object used by the ARKSPILS interface.

\end{itemize}

\end{description}

\textbf{Notes:} The default is to use an internal finite difference
quotient for \emph{jtimes} and to leave out \emph{jtsetup}.  If \code{NULL} is
passed to \emph{jtimes}, these defaults are used.  A user may
specify non-\code{NULL} \emph{jtimes} and \code{NULL} \emph{jtsetup}.

This function must be called \emph{after} the ARKSPILS system solver
interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}}.

The function types {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{\code{ARKSpilsJacTimesSetupFn}}}} and
{\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{\code{ARKSpilsJacTimesVecFn}}}} is described in the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKSpilsSetEpsLin (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetEpsLin}\pysiglinewithargsret{int \bfcode{ARKSpilsSetEpsLin}}{void*\emph{ arkode\_mem}, realtype\emph{ eplifac}}{}
Specifies the factor by which the tolerance on the nonlinear
iteration is multiplied to get a tolerance on the linear
iteration.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{eplifac} -- linear convergence safety factor \((\ge 0.0)\).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful.

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value.

\end{itemize}

\end{description}

\textbf{Notes:} Passing a value \emph{eplifac} of 0.0 indicates to use the
default value of 0.05.

This function must be called \emph{after} the ARKSPILS system solver
interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}}.

\end{fulllineitems}

\index{ARKSpilsSetPreconditioner (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetPreconditioner}\pysiglinewithargsret{int \bfcode{ARKSpilsSetPreconditioner}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSetupFn]{\emph{ARKSpilsPrecSetupFn}}}\emph{ psetup}, {\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSolveFn]{\emph{ARKSpilsPrecSolveFn}}}\emph{ psolve}}{}
Specifies the user-supplied preconditioner setup and solve functions.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{psetup} -- user defined preconditioner setup function.  Pass
\code{NULL} if no setup is needed.

\item {} 
\emph{psolve} -- user-defined preconditioner solve function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful.

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\emph{ARKSPILS\_SUNLS\_FAIL} if an error occurred when setting up
preconditioning in the \code{SUNLinearSolver} object used
by the ARKSPILS interface.

\end{itemize}

\end{description}

\textbf{Notes:} The default is \code{NULL} for both arguments (i.e. no
preconditioning).

This function must be called \emph{after} the ARKSPILS system solver
interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}}.

Both of the function types {\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSetupFn]{\emph{\code{ARKSpilsPrecSetupFn()}}}} and
{\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSolveFn]{\emph{\code{ARKSpilsPrecSolveFn()}}}} are described in the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKSpilsSetMassTimes (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetMassTimes}\pysiglinewithargsret{int \bfcode{ARKSpilsSetMassTimes}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesSetupFn]{\emph{ARKSpilsMassTimesSetupFn}}}\emph{ mtsetup}, {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{ARKSpilsMassTimesVecFn}}}\emph{ mtimes}, void*\emph{ mtimes\_data}}{}
Specifies the mass matrix-times-vector setup and product functions.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{mtsetup} -- user-defined mass matrix-vector setup function.
Pass \code{NULL} if no setup is necessary.

\item {} 
\emph{mtimes} -- user-defined mass matrix-vector product function.

\item {} 
\emph{mtimes\_data} -- a pointer to user data, that will be supplied
to both the \emph{mtsetup} and \emph{mtimes} functions.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful.

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_MASSMEM\_NULL} if the mass matrix solver memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\emph{ARKSPILS\_SUNLS\_FAIL} if an error occurred when setting up
the mass-matrix-vector product in the \code{SUNLinearSolver}
object used by the ARKSPILS interface.

\end{itemize}

\end{description}

\textbf{Notes:} There is no default finite difference quotient for
\emph{mtimes}, so if using the ARKSPILS mass matrix solver interface and
this routine is not called with non-\code{NULL} \emph{mtimes}, and error
will occur.  A user may specify \code{NULL} for \emph{mtsetup}.

This function must be called \emph{after} the ARKSPILS mass
matrix solver interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}}.

The function types {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesSetupFn]{\emph{\code{ARKSpilsMassTimesSetupFn}}}} and
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{\code{ARKSpilsMassTimesVecFn}}}} are described in the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

\end{fulllineitems}

\index{ARKSpilsSetMassEpsLin (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetMassEpsLin}\pysiglinewithargsret{int \bfcode{ARKSpilsSetMassEpsLin}}{void*\emph{ arkode\_mem}, realtype\emph{ eplifac}}{}
Specifies the factor by which the tolerance on the nonlinear
iteration is multiplied to get a tolerance on the mass matrix
linear iteration.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{eplifac} -- linear convergence safety factor \((\ge 0.0)\).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful.

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_MASSMEM\_NULL} if the mass matrix solver memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value.

\end{itemize}

\end{description}

\textbf{Notes:}  This function must be called \emph{after} the ARKSPILS mass
matrix solver interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}}.

Passing a value \emph{eplifac} of 0.0 indicates to use the default value
of 0.05.

\end{fulllineitems}

\index{ARKSpilsSetMassPreconditioner (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsSetMassPreconditioner}\pysiglinewithargsret{int \bfcode{ARKSpilsSetMassPreconditioner}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSetupFn]{\emph{ARKSpilsMassPrecSetupFn}}}\emph{ psetup}, {\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSolveFn]{\emph{ARKSpilsMassPrecSolveFn}}}\emph{ psolve}}{}
Specifies the mass matrix preconditioner setup and solve functions.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{psetup} -- user defined preconditioner setup function.  Pass
\code{NULL} if no setup is to be done.

\item {} 
\emph{psolve} -- user-defined preconditioner solve function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful.

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}.

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value.

\item {} 
\emph{ARKSPILS\_SUNLS\_FAIL} if an error occurred when setting up
preconditioning in the \code{SUNLinearSolver} object used
by the ARKSPILS interface.

\end{itemize}

\end{description}

\textbf{Notes:} This function must be called \emph{after} the ARKSPILS mass
matrix solver interface has been initialized through a call to
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}}.

The default is \code{NULL} for both arguments (i.e. no
preconditioning).

Both of the function types {\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSetupFn]{\emph{\code{ARKSpilsMassPrecSetupFn()}}}} and
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSolveFn]{\emph{\code{ARKSpilsMassPrecSolveFn()}}}} are described in the section
{\hyperref[c_interface/User_supplied:cinterface-usersupplied]{\emph{\DUspan{}{User-supplied functions}}}}.

\end{fulllineitems}



\subsubsection{Rootfinding optional input functions}
\label{c_interface/User_callable:rootfinding-optional-input-functions}
The following functions can be called to set optional inputs to
control the rootfinding algorithm, the mathematics of which are
described in the section {\hyperref[Mathematics:mathematics-rootfinding]{\emph{\DUspan{}{Rootfinding}}}}.

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Optional input
} & \textsf{\relax 
Function name
} & \textsf{\relax 
Default
}\\
\hline
Direction of zero-crossings to monitor
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetRootDirection]{\emph{\code{ARKodeSetRootDirection()}}}}
 & 
both
\\
\hline
Disable inactive root warnings
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNoInactiveRootWarn]{\emph{\code{ARKodeSetNoInactiveRootWarn()}}}}
 & 
enabled
\\
\hline\end{tabulary}

\index{ARKodeSetRootDirection (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetRootDirection}\pysiglinewithargsret{int \bfcode{ARKodeSetRootDirection}}{void*\emph{ arkode\_mem}, int*\emph{ rootdir}}{}
Specifies the direction of zero-crossings to be located and returned.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{rootdir} -- state array of length \emph{nrtfn}, the number of root
functions \(g_i\), as specified in the call to the function
{\hyperref[c_interface/User_callable:c.ARKodeRootInit]{\emph{\code{ARKodeRootInit()}}}}.  If \code{rootdir{[}i{]} == 0} then
crossing in either direction for \(g_i\) should be
reported.  A value of +1 or -1 indicates that the solver
should report only zero-crossings where \(g_i\) is
increasing or decreasing, respectively.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value

\end{itemize}

\item[{\textbf{Notes:} The default behavior is to monitor for both zero-crossing}] \leavevmode
directions.

\end{description}

\end{fulllineitems}

\index{ARKodeSetNoInactiveRootWarn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeSetNoInactiveRootWarn}\pysiglinewithargsret{int \bfcode{ARKodeSetNoInactiveRootWarn}}{void*\emph{ arkode\_mem}}{}
Disables issuing a warning if some root function appears
to be identically zero at the beginning of the integration.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} ARKode will not report the initial conditions as a
possible zero-crossing (assuming that one or more components
\(g_i\) are zero at the initial time).  However, if it appears
that some \(g_i\) is identically zero at the initial time
(i.e., \(g_i\) is zero at the initial time \emph{and} after the
first step), ARKode will issue a warning which can be disabled with
this optional input function.

\end{fulllineitems}



\subsection{Interpolated output function}
\label{c_interface/User_callable:cinterface-interpolatedoutput}\label{c_interface/User_callable:interpolated-output-function}
An optional function {\hyperref[c_interface/User_callable:c.ARKodeGetDky]{\emph{\code{ARKodeGetDky()}}}} is available to obtain
additional output values.  This function should only be called after a
successful return from {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}, as it provides interpolated
values either of \(y\) or of its derivatives (up to the 3rd
derivative) interpolated to any value of \(t\) in the last
internal step taken by {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}.  Internally, this \emph{dense
output} algorithm is identical to the algorithm used for the maximum
order implicit predictors, described in the section
{\hyperref[Mathematics:mathematics-predictors-max]{\emph{\DUspan{}{Maximum order predictor}}}}, except that derivatives of the
polynomial model may be evaluated upon request.
\index{ARKodeGetDky (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetDky}\pysiglinewithargsret{int \bfcode{ARKodeGetDky}}{void*\emph{ arkode\_mem}, realtype\emph{ t}, int\emph{ k}, N\_Vector\emph{ dky}}{}
Computes the \emph{k}-th derivative of the function
\(y\) at the time \emph{t},
i.e. \(\frac{d^{(k)}}{dt^{(k)}}y(t)\), for values of the
independent variable satisfying \(t_n-h_n \le t \le t_n\), with
\(t_n\) as current internal time reached, and \(h_n\) is
the last internal step size successfully used by the solver.  The
user may request \emph{k} in the range \{0,1,2,3\}.  This routine uses an
interpolating polynomial of degree \emph{max(dord, k)}, where \emph{dord} is the
argument provided to {\hyperref[c_interface/User_callable:c.ARKodeSetDenseOrder]{\emph{\code{ARKodeSetDenseOrder()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{t} -- the value of the independent variable at which the
derivative is to be evaluated.

\item {} 
\emph{k} -- the derivative order requested.

\item {} 
\emph{dky} -- output vector (must be allocated by the user).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_BAD\_K} if \emph{k} is not in the range \{0,1,2,3\}.

\item {} 
\emph{ARK\_BAD\_T} if \emph{t} is not in the interval \([t_n-h_n, t_n]\)

\item {} 
\emph{ARK\_BAD\_DKY} if the \emph{dky} vector was \code{NULL}

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory is \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} It is only legal to call this function after a successful
return from {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}.

A user may access the values \(t_n\) and \(h_n\) via the
functions {\hyperref[c_interface/User_callable:c.ARKodeGetCurrentTime]{\emph{\code{ARKodeGetCurrentTime()}}}} and
{\hyperref[c_interface/User_callable:c.ARKodeGetLastStep]{\emph{\code{ARKodeGetLastStep()}}}}, respectively.

\end{fulllineitems}



\subsection{Optional output functions}
\label{c_interface/User_callable:optional-output-functions}\label{c_interface/User_callable:cinterface-optionaloutputs}
ARKode provides an extensive set of functions that can be used to
obtain solver performance information.  We organize these into groups:
\begin{enumerate}
\item {} 
General ARKode output routines are in the subsection
{\hyperref[c_interface/User_callable:cinterface-arkodemainoutputs]{\emph{\DUspan{}{Main solver optional output functions}}}},

\item {} 
ARKode implicit solver output routines are in the subsection
{\hyperref[c_interface/User_callable:cinterface-arkodeimplicitsolveroutputs]{\emph{\DUspan{}{Implicit solver optional output functions}}}},

\item {} 
Output routines regarding root-finding results are in the subsection
{\hyperref[c_interface/User_callable:cinterface-arkoderootoutputs]{\emph{\DUspan{}{Rootfinding optional output functions}}}},

\item {} 
Dense linear solver output routines are in the subsection
{\hyperref[c_interface/User_callable:cinterface-arkdlsoutputs]{\emph{\DUspan{}{Direct linear solver interface optional output functions}}}} and

\item {} 
Iterative linear solver output routines are in the subsection
{\hyperref[c_interface/User_callable:cinterface-arkspilsoutputs]{\emph{\DUspan{}{Iterative linear solver interface optional output functions}}}}.

\item {} 
General usability routines (e.g. to print the current ARKode
parameters, or output the current Butcher table(s)) are in the subsection
{\hyperref[c_interface/User_callable:cinterface-arkodeextraoutputs]{\emph{\DUspan{}{General usability functions}}}}.

\end{enumerate}

Following each table, we elaborate on each function.

Some of the optional outputs, especially the various counters, can be
very useful in determining the efficiency of various methods inside
the {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} solver.  For example:
\begin{itemize}
\item {} 
The counters \emph{nsteps}, \emph{nfe\_evals} and \emph{nfi\_evals} provide a rough
measure of the overall cost of a given run, and can be compared
between runs with different solver options to suggest which set of
options is the most efficient.

\item {} 
The ratio \emph{nniters}/\emph{nsteps} measures the performance of the
nonlinear iteration in solving the nonlinear systems at each stage,
providing a measure of the degree of nonlinearity in the problem.
Typical values of this for a Newton solver on a general problem
range from 1.1 to 1.8.

\item {} 
When using a Newton nonlinear solver, the ratio \emph{njevals}/\emph{nniters}
(in the case of a direct linear solver), and the ratio
\emph{npevals}/\emph{nniters} (in the case of an iterative linear solver)
can measure the overall degree of nonlinearity in the problem,
since these are updated infrequently, unless the Newton method
convergence slows.

\item {} 
When using a Newton nonlinear solver, the ratio \emph{njevals}/\emph{nniters}
(when using a direct linear solver), and the ratio
\emph{nliters}/\emph{nniters} (when using an iterative linear solver) can
indicate the quality of the approximate Jacobian or preconditioner being
used.  For example, if this ratio is larger for a user-supplied
Jacobian or Jacobian-vector product routine than for the
difference-quotient routine, it can indicate that the user-supplied
Jacobian is inaccurate.

\item {} 
The ratio \emph{expsteps}/\emph{accsteps} can measure the quality of the ImEx
splitting used, since a higher-quality splitting will be dominated
by accuracy-limited steps.

\item {} 
The ratio \emph{nsteps}/\emph{step\_attempts} can measure the quality of the
time step adaptivity algorithm, since a poor algorithm will result
in more failed steps, and hence a lower ratio.

\end{itemize}

It is therefore recommended that users retrieve and output these
statistics following each run, and take some time to investigate
alternate solver options that will be more optimal for their
particular problem of interest.


\subsubsection{SUNDIALS version information}
\label{c_interface/User_callable:sundials-version-information}\label{c_interface/User_callable:cinterface-sunversioninfo}
The following functions provide a way to get SUNDIALS version
information at runtime.
\index{SUNDIALSGetVersion (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.SUNDIALSGetVersion}\pysiglinewithargsret{int \bfcode{SUNDIALSGetVersion}}{char\emph{ *version}, int\emph{ len}}{}
This routine fills a string with SUNDIALS version information.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{version} -- character array to hold the SUNDIALS version information.

\item {} 
\emph{len} -- allocated length of the \emph{version} character array.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS version

\end{itemize}

\end{description}

\textbf{Notes:} An array of 25 characters should be sufficient to hold
the version information.

\end{fulllineitems}

\index{SUNDIALSGetVersionNumber (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.SUNDIALSGetVersionNumber}\pysiglinewithargsret{int \bfcode{SUNDIALSGetVersionNumber}}{int\emph{ *major}, int\emph{ *minor}, int\emph{ *patch}, char\emph{ *label}, int\emph{ len}}{}
This routine The function sets integers for the SUNDIALS major,
minor, and patch release numbers and fills a string with the
release label if applicable.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{major} -- SUNDIALS release major version number.

\item {} 
\emph{minor} -- SUNDIALS release minor version number.

\item {} 
\emph{patch} -- SUNDIALS release patch version number.

\item {} 
\emph{label} -- string to hold the SUNDIALS release label.

\item {} 
\emph{len} -- allocated length of the \emph{label} character array.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
0 if successful

\item {} 
-1 if the input string is too short to store the SUNDIALS label

\end{itemize}

\end{description}

\textbf{Notes:} An array of 10 characters should be sufficient to hold
the label information. If a label is not used in the release
version, no information is copied to \emph{label}.

\end{fulllineitems}



\subsubsection{Main solver optional output functions}
\label{c_interface/User_callable:main-solver-optional-output-functions}\label{c_interface/User_callable:cinterface-arkodemainoutputs}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Optional output
} & \textsf{\relax 
Function name
}\\
\hline
Size of ARKode real and integer workspaces
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetWorkSpace]{\emph{\code{ARKodeGetWorkSpace()}}}}
\\
\hline
Cumulative number of internal steps
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumSteps]{\emph{\code{ARKodeGetNumSteps()}}}}
\\
\hline
No. of explicit stability-limited steps
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumExpSteps]{\emph{\code{ARKodeGetNumExpSteps()}}}}
\\
\hline
No. of accuracy-limited steps
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumAccSteps]{\emph{\code{ARKodeGetNumAccSteps()}}}}
\\
\hline
No. of attempted steps
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumStepAttempts]{\emph{\code{ARKodeGetNumStepAttempts()}}}}
\\
\hline
No. of calls to \emph{fe} and \emph{fi} functions
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumRhsEvals]{\emph{\code{ARKodeGetNumRhsEvals()}}}}
\\
\hline
No. of local error test failures that have occurred
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumErrTestFails]{\emph{\code{ARKodeGetNumErrTestFails()}}}}
\\
\hline
Actual initial time step size used
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetActualInitStep]{\emph{\code{ARKodeGetActualInitStep()}}}}
\\
\hline
Step size used for the last successful step
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetLastStep]{\emph{\code{ARKodeGetLastStep()}}}}
\\
\hline
Step size to be attempted on the next step
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetCurrentStep]{\emph{\code{ARKodeGetCurrentStep()}}}}
\\
\hline
Current internal time reached by the solver
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetCurrentTime]{\emph{\code{ARKodeGetCurrentTime()}}}}
\\
\hline
Current ERK and DIRK Butcher tables
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetCurrentButcherTables]{\emph{\code{ARKodeGetCurrentButcherTables()}}}}
\\
\hline
Suggested factor for tolerance scaling
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetTolScaleFactor]{\emph{\code{ARKodeGetTolScaleFactor()}}}}
\\
\hline
Error weight vector for state variables
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetErrWeights]{\emph{\code{ARKodeGetErrWeights()}}}}
\\
\hline
Estimated local truncation error vector
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetEstLocalErrors]{\emph{\code{ARKodeGetEstLocalErrors()}}}}
\\
\hline
Single accessor to many statistics at once
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetIntegratorStats]{\emph{\code{ARKodeGetIntegratorStats()}}}}
\\
\hline
Name of constant associated with a return flag
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetReturnFlagName]{\emph{\code{ARKodeGetReturnFlagName()}}}}
\\
\hline\end{tabulary}

\index{ARKodeGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetWorkSpace}\pysiglinewithargsret{int \bfcode{ARKodeGetWorkSpace}}{void*\emph{ arkode\_mem}, long int*\emph{ lenrw}, long int*\emph{ leniw}}{}
Returns the ARKode real and integer workspace sizes.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lenrw} -- the number of \code{realtype} values in the ARKode workspace.

\item {} 
\emph{leniw} -- the number of integer values in the ARKode workspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNumSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumSteps}\pysiglinewithargsret{int \bfcode{ARKodeGetNumSteps}}{void*\emph{ arkode\_mem}, long int*\emph{ nsteps}}{}
Returns the cumulative number of internal steps taken by
the solver (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nsteps} -- number of steps taken in the solver.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNumExpSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumExpSteps}\pysiglinewithargsret{int \bfcode{ARKodeGetNumExpSteps}}{void*\emph{ arkode\_mem}, long int*\emph{ expsteps}}{}
Returns the cumulative number of stability-limited steps
taken by the solver (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{expsteps} -- number of stability-limited steps taken in the solver.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNumAccSteps (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumAccSteps}\pysiglinewithargsret{int \bfcode{ARKodeGetNumAccSteps}}{void*\emph{ arkode\_mem}, long int*\emph{ accsteps}}{}
Returns the cumulative number of accuracy-limited steps
taken by the solver (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{accsteps} -- number of accuracy-limited steps taken in the solver.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNumStepAttempts (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumStepAttempts}\pysiglinewithargsret{int \bfcode{ARKodeGetNumStepAttempts}}{void*\emph{ arkode\_mem}, long int*\emph{ step\_attempts}}{}
Returns the cumulative number of steps attempted by the solver (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{step\_attempts} -- number of steps attempted by solver.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumRhsEvals}\pysiglinewithargsret{int \bfcode{ARKodeGetNumRhsEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ nfe\_evals}, long int*\emph{ nfi\_evals}}{}
Returns the number of calls to the user's right-hand
side functions, \(f_E\) and \(f_I\) (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nfe\_evals} -- number of calls to the user's \(f_E(t,y)\) function.

\item {} 
\emph{nfi\_evals} -- number of calls to the user's \(f_I(t,y)\) function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The \emph{nfi\_evals} value does not account for calls made to
\(f_I\) by a linear solver or preconditioner module.

\end{fulllineitems}

\index{ARKodeGetNumErrTestFails (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumErrTestFails}\pysiglinewithargsret{int \bfcode{ARKodeGetNumErrTestFails}}{void*\emph{ arkode\_mem}, long int*\emph{ netfails}}{}
Returns the number of local error test failures that
have occured (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{netfails} -- number of error test failures.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetActualInitStep (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetActualInitStep}\pysiglinewithargsret{int \bfcode{ARKodeGetActualInitStep}}{void*\emph{ arkode\_mem}, realtype*\emph{ hinused}}{}
Returns the value of the integration step size used on the first step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hinused} -- actual value of initial step size.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} Even if the value of the initial integration step was
specified by the user through a call to
{\hyperref[c_interface/User_callable:c.ARKodeSetInitStep]{\emph{\code{ARKodeSetInitStep()}}}}, this value may have been changed by
ARKode to ensure that the step size fell within the prescribed
bounds \((h_{min} \le h_0 \le h_{max})\), or to satisfy the
local error test condition, or to ensure convergence of the
nonlinear solver.

\end{fulllineitems}

\index{ARKodeGetLastStep (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetLastStep}\pysiglinewithargsret{int \bfcode{ARKodeGetLastStep}}{void*\emph{ arkode\_mem}, realtype*\emph{ hlast}}{}
Returns the integration step size taken on the last successful
internal step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hlast} -- step size taken on the last internal step.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetCurrentStep (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetCurrentStep}\pysiglinewithargsret{int \bfcode{ARKodeGetCurrentStep}}{void*\emph{ arkode\_mem}, realtype*\emph{ hcur}}{}
Returns the integration step size to be attempted on the next internal step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{hcur} -- step size to be attempted on the next internal step.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetCurrentTime (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetCurrentTime}\pysiglinewithargsret{int \bfcode{ARKodeGetCurrentTime}}{void*\emph{ arkode\_mem}, realtype*\emph{ tcur}}{}
Returns the current internal time reached by the solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{tcur} -- current internal time reached.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetCurrentButcherTables (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetCurrentButcherTables}\pysiglinewithargsret{int \bfcode{ARKodeGetCurrentButcherTables}}{void*\emph{ arkode\_mem}, int*\emph{ s}, int*\emph{ q}, int*\emph{ p}, realtype*\emph{ Ai}, realtype*\emph{ Ae}, realtype*\emph{ ci}, realtype*\emph{ ce}, realtype*\emph{ bi}, realtype*\emph{ be}, realtype*\emph{ b2i}, realtype*\emph{ b2e}}{}
Returns the explicit and implicit Butcher tables
currently in use by the solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{s} -- number of stages in the method.

\item {} 
\emph{q} -- global order of accuracy of the method.

\item {} 
\emph{p} -- global order of accuracy of the embedding.

\item {} 
\emph{Ai} -- coefficients of DIRK method.

\item {} 
\emph{Ae} -- coefficients of ERK method.

\item {} 
\emph{ci} -- array of implicit stage times.

\item {} 
\emph{ce} -- array of explicit stage times.

\item {} 
\emph{bi} -- array of implicit solution coefficients.

\item {} 
\emph{be} -- array of explicit solution coefficients.

\item {} 
\emph{b2i} -- array of implicit embedding coefficients.

\item {} 
\emph{b2e} -- array of explicit embedding coefficients.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:}  The user must allocate space for \emph{Ae} and \emph{Ai} of size
\code{ARK\_S\_MAX*ARK\_S\_MAX}, and for \emph{ci}, \emph{ce}, \emph{bi}, \emph{be}, \emph{b2i}, and
\emph{b2e} of size \code{ARK\_S\_MAX} prior to calling this function.

\end{fulllineitems}

\index{ARKodeGetTolScaleFactor (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetTolScaleFactor}\pysiglinewithargsret{int \bfcode{ARKodeGetTolScaleFactor}}{void*\emph{ arkode\_mem}, realtype*\emph{ tolsfac}}{}
Returns a suggested factor by which the user's
tolerances should be scaled when too much accuracy has been
requested for some internal step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{tolsfac} -- suggested scaling factor for user-supplied tolerances.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetErrWeights (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetErrWeights}\pysiglinewithargsret{int \bfcode{ARKodeGetErrWeights}}{void*\emph{ arkode\_mem}, N\_Vector\emph{ eweight}}{}
Returns the current error weight vector.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{eweight} -- solution error weights at the current time.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The user must allocate space for \emph{eweight}, that will be
filled in by this function.

\end{fulllineitems}

\index{ARKodeGetEstLocalErrors (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetEstLocalErrors}\pysiglinewithargsret{int \bfcode{ARKodeGetEstLocalErrors}}{void*\emph{ arkode\_mem}, N\_Vector\emph{ ele}}{}
Returns the vector of estimated local truncation errors
for the current step.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{ele} -- vector of estimated local truncation errors.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:}  The user must allocate space for \emph{ele}, that will be
filled in by this function.

The values returned in \emph{ele} are valid only if {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}
returned a non-negative value.

The \emph{ele} vector, together with the \emph{eweight} vector from
{\hyperref[c_interface/User_callable:c.ARKodeGetErrWeights]{\emph{\code{ARKodeGetErrWeights()}}}}, can be used to determine how the
various components of the system contributed to the estimated local
error test.  Specifically, that error test uses the RMS norm of a
vector whose components are the products of the components of these
two vectors.  Thus, for example, if there were recent error test
failures, the components causing the failures are those with largest
values for the products, denoted loosely as \code{eweight{[}i{]}*ele{[}i{]}}.

\end{fulllineitems}

\index{ARKodeGetIntegratorStats (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetIntegratorStats}\pysiglinewithargsret{int \bfcode{ARKodeGetIntegratorStats}}{void*\emph{ arkode\_mem}, long int*\emph{ nsteps}, long int*\emph{ expsteps}, long int*\emph{ accsteps}, long int*\emph{ step\_attempts}, long int*\emph{ nfe\_evals}, long int*\emph{ nfi\_evals}, long int*\emph{ nlinsetups}, long int*\emph{ netfails}, realtype*\emph{ hinused}, realtype*\emph{ hlast}, realtype*\emph{ hcur}, realtype*\emph{ tcur}}{}
Returns many of the most useful integrator statistics in a single call.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nsteps} -- number of steps taken in the solver.

\item {} 
\emph{expsteps} -- number of stability-limited steps taken in the solver.

\item {} 
\emph{accsteps} -- number of accuracy-limited steps taken in the solver.

\item {} 
\emph{step\_attempts} -- number of steps attempted by the solver.

\item {} 
\emph{nfe\_evals} -- number of calls to the user's \(f_E(t,y)\) function.

\item {} 
\emph{nfi\_evals} -- number of calls to the user's \(f_I(t,y)\) function.

\item {} 
\emph{nlinsetups} -- number of linear solver setup calls made.

\item {} 
\emph{netfails} -- number of error test failures.

\item {} 
\emph{hinused} -- actual value of initial step size.

\item {} 
\emph{hlast} -- step size taken on the last internal step.

\item {} 
\emph{hcur} -- step size to be attempted on the next internal step.

\item {} 
\emph{tcur} -- current internal time reached.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetReturnFlagName}\pysiglinewithargsret{char *\bfcode{ARKodeGetReturnFlagName}}{long int\emph{ flag}}{}
Returns the name of the ARKode constant corresponding to \emph{flag}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{flag} -- a return flag from an ARKode function.

\end{itemize}

\end{description}

\textbf{Return value:}
The return value is a string containing the name of
the corresponding constant.

\end{fulllineitems}



\subsubsection{Implicit solver optional output functions}
\label{c_interface/User_callable:cinterface-arkodeimplicitsolveroutputs}\label{c_interface/User_callable:implicit-solver-optional-output-functions}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Optional output
} & \textsf{\relax 
Function name
}\\
\hline
No. of calls to linear solver setup function
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumLinSolvSetups]{\emph{\code{ARKodeGetNumLinSolvSetups()}}}}
\\
\hline
No. of nonlinear solver iterations
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumNonlinSolvIters]{\emph{\code{ARKodeGetNumNonlinSolvIters()}}}}
\\
\hline
No. of nonlinear solver convergence failures
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumNonlinSolvConvFails]{\emph{\code{ARKodeGetNumNonlinSolvConvFails()}}}}
\\
\hline
Single accessor to all nonlinear solver statistics
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNonlinSolvStats]{\emph{\code{ARKodeGetNonlinSolvStats()}}}}
\\
\hline\end{tabulary}

\index{ARKodeGetNumLinSolvSetups (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumLinSolvSetups}\pysiglinewithargsret{int \bfcode{ARKodeGetNumLinSolvSetups}}{void*\emph{ arkode\_mem}, long int*\emph{ nlinsetups}}{}
Returns the number of calls made to the linear solver's
setup routine (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nlinsetups} -- number of linear solver setup calls made.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNumNonlinSolvIters (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumNonlinSolvIters}\pysiglinewithargsret{int \bfcode{ARKodeGetNumNonlinSolvIters}}{void*\emph{ arkode\_mem}, long int*\emph{ nniters}}{}
Returns the number of nonlinear solver iterations
performed (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nniters} -- number of nonlinear iterations performed.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNumNonlinSolvConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumNonlinSolvConvFails}\pysiglinewithargsret{int \bfcode{ARKodeGetNumNonlinSolvConvFails}}{void*\emph{ arkode\_mem}, long int*\emph{ nncfails}}{}
Returns the number of nonlinear solver convergence
failures that have occurred (so far).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nncfails} -- number of nonlinear convergence failures.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeGetNonlinSolvStats (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNonlinSolvStats}\pysiglinewithargsret{int \bfcode{ARKodeGetNonlinSolvStats}}{void*\emph{ arkode\_mem}, long int*\emph{ nniters}, long int*\emph{ nncfails}}{}
Returns all of the nonlinear solver statistics in a single call.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nniters} -- number of nonlinear iterations performed.

\item {} 
\emph{nncfails} -- number of nonlinear convergence failures.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Rootfinding optional output functions}
\label{c_interface/User_callable:rootfinding-optional-output-functions}\label{c_interface/User_callable:cinterface-arkoderootoutputs}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Optional output
} & \textsf{\relax 
Function name
}\\
\hline
Array showing roots found
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetRootInfo]{\emph{\code{ARKodeGetRootInfo()}}}}
\\
\hline
No. of calls to user root function
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumGEvals]{\emph{\code{ARKodeGetNumGEvals()}}}}
\\
\hline\end{tabulary}

\index{ARKodeGetRootInfo (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetRootInfo}\pysiglinewithargsret{int \bfcode{ARKodeGetRootInfo}}{void*\emph{ arkode\_mem}, int*\emph{ rootsfound}}{}
Returns an array showing which functions were found to
have a root.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{rootsfound} -- array of length \emph{nrtfn} with the indices of the
user functions \(g_i\) found to have a root.  For
\(i = 0 \ldots\) \emph{nrtfn}-1, \code{rootsfound{[}i{]}} is nonzero
if \(g_i\) has a root, and 0 if not.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The user must allocate space for \emph{rootsfound} prior to
calling this function.

For the components of \(g_i\) for which a root was found, the
sign of \code{rootsfound{[}i{]}} indicates the direction of
zero-crossing.  A value of +1 indicates that \(g_i\) is
increasing, while a value of -1 indicates a decreasing \(g_i\).

\end{fulllineitems}

\index{ARKodeGetNumGEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeGetNumGEvals}\pysiglinewithargsret{int \bfcode{ARKodeGetNumGEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ ngevals}}{}
Returns the cumulative number of calls made to the
user's root function \(g\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{ngevals} -- number of calls made to \(g\) so far.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Direct linear solver interface optional output functions}
\label{c_interface/User_callable:cinterface-arkdlsoutputs}\label{c_interface/User_callable:direct-linear-solver-interface-optional-output-functions}
The following optional outputs are available from the ARKDLS
modules: workspace requirements, number of calls to the Jacobian
routine, number of calls to the mass matrix routine, number of calls
to the implicit right-hand side routine for finite-difference Jacobian
approximation, and last return value from an ARKDLS function.  Note
that, where the name of an output would otherwise conflict with the
name of an optional output from the main solver, a suffix LS (for
Linear Solver) or MLS (for Mass Linear Solver) has been added here
(e.g. \emph{lenrwLS}).

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Optional output
} & \textsf{\relax 
Function name
}\\
\hline
Size of real and integer workspaces
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetWorkSpace]{\emph{\code{ARKDlsGetWorkSpace()}}}}
\\
\hline
Size of mass real and integer workspaces
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetMassWorkSpace]{\emph{\code{ARKDlsGetMassWorkSpace()}}}}
\\
\hline
No. of Jacobian evaluations
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumJacEvals]{\emph{\code{ARKDlsGetNumJacEvals()}}}}
\\
\hline
No. of mass matrix setups
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumMassSetups]{\emph{\code{ARKDlsGetNumMassSetups()}}}}
\\
\hline
No. of mass matrix solves
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumMassSolves]{\emph{\code{ARKDlsGetNumMassSolves()}}}}
\\
\hline
No. of mass matrix multiplies
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumMassMult]{\emph{\code{ARKDlsGetNumMassMult()}}}}
\\
\hline
No. of \emph{fi} calls for finite diff. Jacobian evals
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumRhsEvals]{\emph{\code{ARKDlsGetNumRhsEvals()}}}}
\\
\hline
Last return flag from a linear solver function
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetLastFlag]{\emph{\code{ARKDlsGetLastFlag()}}}}
\\
\hline
Last return flag from a mass matrix solver function
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetLastMassFlag]{\emph{\code{ARKDlsGetLastMassFlag()}}}}
\\
\hline
Name of constant associated with a return flag
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetReturnFlagName]{\emph{\code{ARKDlsGetReturnFlagName()}}}}
\\
\hline\end{tabulary}

\index{ARKDlsGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetWorkSpace}\pysiglinewithargsret{int \bfcode{ARKDlsGetWorkSpace}}{void*\emph{ arkode\_mem}, long int*\emph{ lenrwLS}, long int*\emph{ leniwLS}}{}
Returns the real and integer workspace used by the
ARKDLS linear solver interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lenrwLS} -- the number of \code{realtype} values in the ARKDLS workspace.

\item {} 
\emph{leniwLS} -- the number of integer values in the ARKDLS workspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within this interface and to
memory allocated by the \code{SUNLinearSolver} object attached
to it.  The template Jacobian matrix allocated by the user outside
of ARKDLS is not included in this report.

\end{fulllineitems}

\index{ARKDlsGetMassWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetMassWorkSpace}\pysiglinewithargsret{int \bfcode{ARKDlsGetMassWorkSpace}}{void*\emph{ arkode\_mem}, long int*\emph{ lenrwMLS}, long int*\emph{ leniwMLS}}{}
Returns the real and integer workspace used by the
ARKDLS mass matrix linear solver interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lenrwMLS} -- the number of \code{realtype} values in the ARKDLS workspace.

\item {} 
\emph{leniwMLS} -- the number of integer values in the ARKDLS workspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within this interface and to
memory allocated by the \code{SUNLinearSolver} object attached
to it.  The template mass matrix allocated by the user outside
of ARKDLS is not included in this report.

\end{fulllineitems}

\index{ARKDlsGetNumJacEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetNumJacEvals}\pysiglinewithargsret{int \bfcode{ARKDlsGetNumJacEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ njevals}}{}
Returns the number of calls made to the ARKDLS Jacobian
approximation routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{njevals} -- number of calls to the Jacobian function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKDlsGetNumMassSetups (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetNumMassSetups}\pysiglinewithargsret{int \bfcode{ARKDlsGetNumMassSetups}}{void*\emph{ arkode\_mem}, long int*\emph{ nmsetups}}{}
Returns the number of calls made to the ARKDLS mass matrix solver `setup' routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmsetups} -- number of calls to the mass matrix solver setup routine.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKDlsGetNumMassSolves (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetNumMassSolves}\pysiglinewithargsret{int \bfcode{ARKDlsGetNumMassSolves}}{void*\emph{ arkode\_mem}, long int*\emph{ nmsolves}}{}
Returns the number of calls made to the ARKDLS mass matrix solver 'solve' routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmsolves} -- number of calls to the mass matrix solver solve routine.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKDlsGetNumMassMult (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetNumMassMult}\pysiglinewithargsret{int \bfcode{ARKDlsGetNumMassMult}}{void*\emph{ arkode\_mem}, long int*\emph{ nmmults}}{}
Returns the number of calls made to the ARKDLS mass matrix 'matvec' routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmmults} -- number of calls to the mass matrix solver matrix-times-vector routine

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKDlsGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetNumRhsEvals}\pysiglinewithargsret{int \bfcode{ARKDlsGetNumRhsEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ nfevalsLS}}{}
Returns the number of calls made to the user-supplied
\(f_I\) routine due to the finite difference Jacobian
approximation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nfevalsLS} -- the number of calls made to the user-supplied
\(f_I\) function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The value of \emph{nfevalsLS} is incremented only if one of
the default internal difference quotient functions (dense or
banded) is used.

\end{fulllineitems}

\index{ARKDlsGetLastFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetLastFlag}\pysiglinewithargsret{int \bfcode{ARKDlsGetLastFlag}}{void*\emph{ arkode\_mem}, long int*\emph{ lsflag}}{}
Returns the last return value from an ARKDLS routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lsflag} -- the value of the last return flag from an ARKDLS function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:}   If the \code{SUNLINSOL\_DENSE} or \code{SUNLINSOL\_BAND} setup
function failed (ARKode returned \code{ARK\_LSETUP\_FAIL}), then the
value of \emph{lsflag} is equal to the column index (numbered from one)
at which a zero diagonal element was encountered during the LU
factorization of the (dense or banded) Jacobian matrix.  For all
other failures, \emph{lsflag} is negative.

\end{fulllineitems}

\index{ARKDlsGetLastMassFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetLastMassFlag}\pysiglinewithargsret{int \bfcode{ARKDlsGetLastMassFlag}}{void*\emph{ arkode\_mem}, long int*\emph{ mlsflag}}{}
Returns the last return value from an ARKDLS mass matrix solve routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{mlsflag} -- the value of the last return flag from an ARKDLS
mass matrix solver function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKDLS\_SUCCESS} if successful

\item {} 
\emph{ARKDLS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKDLS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} If the \code{SUNLINSOL\_DENSE} or \code{SUNLINSOL\_BAND} setup
function failed (ARKode returned \code{ARK\_LSETUP\_FAIL}), then the
value of \emph{lsflag} is equal to the column index (numbered from one)
at which a zero diagonal element was encountered during the LU
factorization of the (dense or banded) mass matrix.  For all
other failures, \emph{lsflag} is negative.

\end{fulllineitems}

\index{ARKDlsGetReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKDlsGetReturnFlagName}\pysiglinewithargsret{char *\bfcode{ARKDlsGetReturnFlagName}}{long int\emph{ lsflag}}{}
Returns the name of the ARKDLS constant
corresponding to \emph{lsflag}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{lsflag} -- a return flag from an ARKDLS function.

\end{itemize}

\end{description}

\textbf{Return value:}  The return value is a string containing the name of
the corresponding constant. If 1 \(\le\) \emph{lsflag} \(\le
n\) (LU factorization failed), this routine returns ``NONE''.

\end{fulllineitems}



\subsubsection{Iterative linear solver interface optional output functions}
\label{c_interface/User_callable:cinterface-arkspilsoutputs}\label{c_interface/User_callable:iterative-linear-solver-interface-optional-output-functions}
The following optional outputs are available from the ARKSPILS
modules: workspace requirements, number of linear iterations, number
of linear convergence failures, number of calls to the preconditioner
setup and solve routines, number of calls to the Jacobian-vector
setup and product routines, number of calls to the mass-matrix-vector
setup and product routines, number of calls to the implicit right-hand
side routine for finite-difference Jacobian-vector product
approximation, and last return value from a linear solver function.
Note that, where the name of an output would otherwise conflict with
the name of an optional output from the main solver, a suffix LS (for
Linear Solver) or MLS (for Mass Linear Solver) has been added here
(e.g. \emph{lenrwLS}).

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Optional output
} & \textsf{\relax 
Function name
}\\
\hline
Size of real and integer workspaces
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetWorkSpace]{\emph{\code{ARKSpilsGetWorkSpace()}}}}
\\
\hline
No. of preconditioner evaluations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumPrecEvals]{\emph{\code{ARKSpilsGetNumPrecEvals()}}}}
\\
\hline
No. of preconditioner solves
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumPrecSolves]{\emph{\code{ARKSpilsGetNumPrecSolves()}}}}
\\
\hline
No. of linear iterations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumLinIters]{\emph{\code{ARKSpilsGetNumLinIters()}}}}
\\
\hline
No. of linear convergence failures
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumConvFails]{\emph{\code{ARKSpilsGetNumConvFails()}}}}
\\
\hline
No. of Jacobian-vector setup evaluations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumJTSetupEvals]{\emph{\code{ARKSpilsGetNumJTSetupEvals()}}}}
\\
\hline
No. of Jacobian-vector product evaluations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumJtimesEvals]{\emph{\code{ARKSpilsGetNumJtimesEvals()}}}}
\\
\hline
No. of \emph{fi} calls for finite diff. Jacobian-vector evals.
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumRhsEvals]{\emph{\code{ARKSpilsGetNumRhsEvals()}}}}
\\
\hline
Last return from a linear solver function
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetLastFlag]{\emph{\code{ARKSpilsGetLastFlag()}}}}
\\
\hline
Size of real and integer mass matrix solver workspaces
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetMassWorkSpace]{\emph{\code{ARKSpilsGetMassWorkSpace()}}}}
\\
\hline
No. of mass matrix preconditioner evaluations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassPrecEvals]{\emph{\code{ARKSpilsGetNumMassPrecEvals()}}}}
\\
\hline
No. of mass matrix preconditioner solves
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassPrecSolves]{\emph{\code{ARKSpilsGetNumMassPrecSolves()}}}}
\\
\hline
No. of mass matrix linear iterations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassIters]{\emph{\code{ARKSpilsGetNumMassIters()}}}}
\\
\hline
No. of mass matrix solver convergence failures
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassConvFails]{\emph{\code{ARKSpilsGetNumMassConvFails()}}}}
\\
\hline
No. of mass-matrix-vector setup evaluations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMTSetupEvals]{\emph{\code{ARKSpilsGetNumMTSetupEvals()}}}}
\\
\hline
No. of mass-matrix-vector product evaluations
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMtimesEvals]{\emph{\code{ARKSpilsGetNumMtimesEvals()}}}}
\\
\hline
Last return from a mass matrix solver function
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetLastMassFlag]{\emph{\code{ARKSpilsGetLastMassFlag()}}}}
\\
\hline
Name of constant associated with a return flag
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetReturnFlagName]{\emph{\code{ARKSpilsGetReturnFlagName()}}}}
\\
\hline\end{tabulary}

\index{ARKSpilsGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetWorkSpace}\pysiglinewithargsret{int \bfcode{ARKSpilsGetWorkSpace}}{void*\emph{ arkode\_mem}, long int*\emph{ lenrwLS}, long int*\emph{ leniwLS}}{}
Returns the global sizes of the ARKSPILS real and integer workspaces.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lenrwLS} -- the number of \code{realtype} values in the ARKSPILS workspace.

\item {} 
\emph{leniwLS} -- the number of integer values in the ARKSPILS workspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within this interface and to
memory allocated by the \code{SUNLinearSolver} object attached
to it.

In a parallel setting, the above values are global (i.e. summed over all
processors).

\end{fulllineitems}

\index{ARKSpilsGetNumPrecEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumPrecEvals}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumPrecEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ npevals}}{}
Returns the total number of preconditioner evaluations,
i.e. the number of calls made to \emph{psetup} with \emph{jok} = \code{SUNFALSE}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{npevals} -- the current number of calls to \emph{psetup}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumPrecSolves (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumPrecSolves}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumPrecSolves}}{void*\emph{ arkode\_mem}, long int*\emph{ npsolves}}{}
Returns the number of calls made to the preconditioner
solve function, \emph{psolve}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{npsolves} -- the number of calls to \emph{psolve}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumLinIters (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumLinIters}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumLinIters}}{void*\emph{ arkode\_mem}, long int*\emph{ nliters}}{}
Returns the cumulative number of linear iterations.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nliters} -- the current number of linear iterations.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumConvFails}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumConvFails}}{void*\emph{ arkode\_mem}, long int*\emph{ nlcfails}}{}
Returns the cumulative number of linear convergence failures.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nlcfails} -- the current number of linear convergence failures.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumJTSetupEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumJTSetupEvals}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumJTSetupEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ njtsetup}}{}
Returns the cumulative number of calls made to the
Jacobian-vector setup function, \emph{jtsetup}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{njtsetup} -- the current number of calls to \emph{jtsetup}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumJtimesEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumJtimesEvals}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumJtimesEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ njvevals}}{}
Returns the cumulative number of calls made to the
Jacobian-vector product function, \emph{jtimes}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{njvevals} -- the current number of calls to \emph{jtimes}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumRhsEvals}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumRhsEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ nfevalsLS}}{}
Returns the number of calls to the user-supplied implicit
right-hand side function \(f_I\) for finite difference
Jacobian-vector product approximation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nfevalsLS} -- the number of calls to the user implicit
right-hand side function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The value \emph{nfevalsLS} is incremented only if the default
internal difference quotient function is used.

\end{fulllineitems}

\index{ARKSpilsGetLastFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetLastFlag}\pysiglinewithargsret{int \bfcode{ARKSpilsGetLastFlag}}{void*\emph{ arkode\_mem}, long int*\emph{ lsflag}}{}
Returns the last return value from an ARKSPILS routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lsflag} -- the value of the last return flag from an
ARKSPILS function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} If the ARKSPILS setup function failed ({\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}
returned \emph{ARK\_LSETUP\_FAIL}), then \emph{lsflag} will be
\emph{SUNLS\_PSET\_FAIL\_UNREC}, \emph{SUNLS\_ASET\_FAIL\_UNREC} or
\emph{SUNLS\_PACKAGE\_FAIL\_UNREC}.

If the ARKSPILS solve function failed ({\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}
returned \emph{ARK\_LSOLVE\_FAIL}), then \emph{lsflag} contains the error
return flag from the \code{SUNLinearSolver} object, which will
be one of:
\emph{SUNLS\_MEM\_NULL}, indicating that the \code{SUNLinearSolver}
memory is \code{NULL};
\emph{SUNLS\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in
the \(Jv\) function;
\emph{SUNLS\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
function failed unrecoverably;
\emph{SUNLS\_GS\_FAIL}, indicating a failure in the Gram-Schmidt procedure
(SPGMR and SPFGMR only);
\emph{SUNLS\_QRSOL\_FAIL}, indicating that the matrix \(R\) was found
to be singular during the QR solve phase (SPGMR and SPFGMR only); or
\emph{SUNLS\_PACKAGE\_FAIL\_UNREC}, indicating an unrecoverable failure in
an external iterative linear solver package.

\end{fulllineitems}

\index{ARKSpilsGetReturnFlagName (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetReturnFlagName}\pysiglinewithargsret{char *\bfcode{ARKSpilsGetReturnFlagName}}{long int\emph{ lsflag}}{}
Returns the name of the ARKSPILS constant
corresponding to \emph{lsflag}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{lsflag} -- a return flag from an ARKSPILS function.

\end{itemize}

\end{description}

\textbf{Return value:}
The return value is a string containing the name of
the corresponding constant.

\end{fulllineitems}

\index{ARKSpilsGetMassWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetMassWorkSpace}\pysiglinewithargsret{int \bfcode{ARKSpilsGetMassWorkSpace}}{void*\emph{ arkode\_mem}, long int*\emph{ lenrwMLS}, long int*\emph{ leniwMLS}}{}
Returns the global sizes of the ARKSPILS real and integer workspaces.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lenrwMLS} -- the number of \code{realtype} values in the ARKSPILS workspace.

\item {} 
\emph{leniwMLS} -- the number of integer values in the ARKSPILS workspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within this interface and to
memory allocated by the \code{SUNLinearSolver} object attached
to it.

In a parallel setting, the above values are global (i.e. summed over all
processors).

\end{fulllineitems}

\index{ARKSpilsGetNumMassPrecEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumMassPrecEvals}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumMassPrecEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ nmpevals}}{}
Returns the total number of mass matrix preconditioner evaluations,
i.e. the number of calls made to \emph{psetup}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmpevals} -- the current number of calls to \emph{psetup}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumMassPrecSolves (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumMassPrecSolves}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumMassPrecSolves}}{void*\emph{ arkode\_mem}, long int*\emph{ nmpsolves}}{}
Returns the number of calls made to the mass matrix preconditioner
solve function, \emph{psolve}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmpsolves} -- the number of calls to \emph{psolve}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumMassIters (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumMassIters}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumMassIters}}{void*\emph{ arkode\_mem}, long int*\emph{ nmiters}}{}
Returns the cumulative number of mass matrix solver iterations.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmiters} -- the current number of mass matrix solver linear iterations.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumMassConvFails (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumMassConvFails}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumMassConvFails}}{void*\emph{ arkode\_mem}, long int*\emph{ nmcfails}}{}
Returns the cumulative number of mass matrix solver convergence failures.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmcfails} -- the current number of mass matrix solver convergence failures.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumMTSetupEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumMTSetupEvals}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumMTSetupEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ nmtsetup}}{}
Returns the cumulative number of calls made to the
mass-matrix-vector setup function, \emph{mtsetup}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmtsetup} -- the current number of calls to \emph{mtsetup}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetNumMtimesEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetNumMtimesEvals}\pysiglinewithargsret{int \bfcode{ARKSpilsGetNumMtimesEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ nmvevals}}{}
Returns the cumulative number of calls made to the
mass-matrix-vector product function, \emph{mtimes}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nmvevals} -- the current number of calls to \emph{mtimes}.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKSpilsGetLastMassFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKSpilsGetLastMassFlag}\pysiglinewithargsret{int \bfcode{ARKSpilsGetLastMassFlag}}{void*\emph{ arkode\_mem}, long int*\emph{ msflag}}{}
Returns the last return value from an ARKSPILS mass matrix solver routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{msflag} -- the value of the last return flag from an
ARKSPILS mass matrix solver function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The values of \emph{msflag} for each of the various solvers
will match those described above for the function
{\hyperref[c_interface/User_callable:c.ARKSpilsGetLastFlag]{\emph{\code{ARKSpilsGetLastFlag()}}}}.

\end{fulllineitems}



\subsubsection{General usability functions}
\label{c_interface/User_callable:cinterface-arkodeextraoutputs}\label{c_interface/User_callable:general-usability-functions}
The following optional routines may be called by a user to inquire
about existing solver parameters, to retrieve stored Butcher tables,
write the current Butcher table(s), or even to test a provided Butcher
table to determine its analytical order of accuracy.  While none of
these would typically be called during the course of solving an
initial value problem, these may be useful for users wishing to better
understand ARKode and/or specific Runge-Kutta methods.

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Optional routine
} & \textsf{\relax 
Function name
}\\
\hline
Output all ARKode solver parameters
 & 
{\hyperref[c_interface/User_callable:c.ARKodeWriteParameters]{\emph{\code{ARKodeWriteParameters()}}}}
\\
\hline
Retrieve a given Butcher table by its unique name
 & 
{\hyperref[c_interface/User_callable:c.ARKodeLoadButcherTable]{\emph{\code{ARKodeLoadButcherTable()}}}}
\\
\hline
Output the current Butcher table(s)
 & 
{\hyperref[c_interface/User_callable:c.ARKodeWriteButcher]{\emph{\code{ARKodeWriteButcher()}}}}
\\
\hline
Test the analytical order of accuracy for a Butcher table
 & 
{\hyperref[c_interface/User_callable:c.ARKodeTestButcherTable]{\emph{\code{ARKodeTestButcherTable()}}}}
\\
\hline
Test the analytical order for a pair of Butcher tables
 & 
{\hyperref[c_interface/User_callable:c.ARKodeTestButcherTables]{\emph{\code{ARKodeTestButcherTables()}}}}
\\
\hline\end{tabulary}

\index{ARKodeWriteParameters (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeWriteParameters}\pysiglinewithargsret{int \bfcode{ARKodeWriteParameters}}{void*\emph{ arkode\_mem}, FILE\emph{ *fp}}{}
Outputs all solver parameters to the provided file pointer.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{fp} -- pointer to use for printing the solver parameters

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The \emph{fp} argument can be \code{stdout} or \code{stderr}, or it
may point to a specific file created using \code{fopen}.

When run in parallel, only one process should set a non-NULL value
for this pointer, since parameters for all processes would be
identical.

\end{fulllineitems}

\index{ARKodeLoadButcherTable (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeLoadButcherTable}\pysiglinewithargsret{int \bfcode{ARKodeLoadButcherTable}}{int\emph{ imethod}, int\emph{ *s}, int\emph{ *q}, int\emph{ *p}, realtype\emph{ *A}, realtype\emph{ *b}, realtype\emph{ *c}, realtype\emph{ *b2}}{}
Retrieves a specified Butcher table.  The array \emph{A} must be declared
of size \code{ARK\_S\_MAX*ARK\_S\_MAX}, and the arrays \emph{c}, \emph{b}
and \emph{b2} should all have length at least \code{ARK\_S\_MAX}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{imethod} -- integer input specifying the given Butcher table --
valid values match those for the functions
{\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}} and {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}

\item {} 
\emph{s} -- integer number of stages for the method (output)

\item {} 
\emph{q} -- integer order of the method (output)

\item {} 
\emph{p} -- integer order of the embedding (output)

\item {} 
\emph{A} -- realtype Butcher table coefficients (output)

\item {} 
\emph{b} -- realtype root node coefficients (output)

\item {} 
\emph{c} -- realtype canopy node coefficients (output)

\item {} 
\emph{b2} -- realtype embedding coefficients (output)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if \emph{imethod} was invalid

\end{itemize}

\end{description}

\end{fulllineitems}

\index{ARKodeWriteButcher (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeWriteButcher}\pysiglinewithargsret{int \bfcode{ARKodeWriteButcher}}{void*\emph{ arkode\_mem}, FILE\emph{ *fp}}{}
Outputs the current Butcher table(s) to the provided file pointer.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{fp} -- pointer to use for printing the Butcher table(s)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if successful

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the ARKode memory was \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The \emph{fp} argument can be \code{stdout} or \code{stderr}, or it
may point to a specific file created using \code{fopen}.

If ARKode is currently configured to run in purely explicit or
purely implicit mode, this will output a single Butcher table;  if
configured to run an ImEx method then both tables will be output.

When run in parallel, only one process should set a non-NULL value
for this pointer, since tables for all processes would be
identical.

\end{fulllineitems}

\index{ARKodeTestButcherTable (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeTestButcherTable}\pysiglinewithargsret{int \bfcode{ARKodeTestButcherTable}}{realtype\emph{ *A}, realtype\emph{ *b}, realtype\emph{ *c}, int\emph{ s}, booleantype\emph{ printstats}}{}
Checks the order conditions for a single Butcher table (ERK or DIRK
or even IRK), and returns the integer order of accuracy for the
method (up to 6th order).  It will optionally output detailed
information on the tests that pass/fail, depending on the
\emph{printstats} argument.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{A} -- realtype Butcher table of allocated size
\code{ARK\_S\_MAX*ARK\_S\_MAX}, although not all of this space need
be used.

\item {} 
\emph{b} -- realtype root node coefficients for the Butcher table

\item {} 
\emph{c} -- realtype canopy node coefficients for the Butcher table

\item {} 
\emph{s} -- integer number of stages in this Butcher table

\item {} 
\emph{printstats} -- booleantype flag denoting whether to output
detailed test statistics to \code{stdout}

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
the integer order of accuracy for the method (0 through 6); a
return value of \code{-1} indicates that the row sum condition is
not satisfied (see below).

\end{itemize}

\end{description}

\textbf{Notes:} The only assumption is that the row-sum condition must
be satisfied, i.e. that
\begin{gather}
\begin{split}c_i = \sum_{j=1}^s A_{i,j}, \quad i=1,\ldots,s,\end{split}\notag
\end{gather}
no other ``simplifying assumptions'' are made.

\end{fulllineitems}

\index{ARKodeTestButcherTables (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeTestButcherTables}\pysiglinewithargsret{int \bfcode{ARKodeTestButcherTables}}{realtype\emph{ *A1}, realtype\emph{ *b1}, realtype\emph{ *c1}, realtype\emph{ *A2}, realtype\emph{ *b2}, realtype\emph{ *c2}, int\emph{ s}, booleantype\emph{ printstats}}{}
Checks the order conditions for a pair of Butcher tables that
comprise a 2-additive Runge-Kutta method, and returns the integer
order of accuracy for the coupled method (up to 6th order).  No
assumptions are made about whether each method is explicit or
implicit.  It will optionally output detailed information on the
tests that pass/fail, depending on the \emph{printstats} argument.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{A1} -- realtype Butcher table of allocated size
\code{ARK\_S\_MAX*ARK\_S\_MAX}, although not all of this space need
be used.

\item {} 
\emph{b1} -- realtype root node coefficients for the Butcher table

\item {} 
\emph{c1} -- realtype root node coefficients for the Butcher table

\item {} 
\emph{A2} -- realtype Butcher table of allocated size
\code{ARK\_S\_MAX*ARK\_S\_MAX}, although not all of this space need
be used.

\item {} 
\emph{b2} -- realtype root node coefficients for the Butcher table

\item {} 
\emph{c2} -- realtype canopy coefficients for the Butcher table

\item {} 
\emph{s} -- integer number of stages in this Butcher table

\item {} 
\emph{printstats} -- booleantype flag denoting whether to output
detailed test statistics to \code{stdout}

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
the integer order of accuracy for the coupled method (0
through 6); a return value of \code{-1} indicates that one or
both of the row sum conditions is not satisfied (see below).

\end{itemize}

\end{description}

\textbf{Notes:} The only assumptions are that the row-sum
condition for each component method must be satisfied, i.e. that
\begin{gather}
\begin{split}c^1_i &= \sum_{j=1}^s A^1_{i,j}, \quad i=1,\ldots,s\\
\text{and}\qquad\quad&\\
c^2_i &= \sum_{j=1}^s A^2_{i,j}, \quad i=1,\ldots,s,\end{split}\notag
\end{gather}
where \(c^i\) and \(A^i\), \(i =\) \{1,2\}  denote the
coefficients for the respective table; no other ``simplifying
assumptions'' are made.

\end{fulllineitems}



\subsection{ARKode reinitialization function}
\label{c_interface/User_callable:cinterface-reinitialization}\label{c_interface/User_callable:arkode-reinitialization-function}
The function {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} reinitializes the main ARKode
solver for the solution of a new problem, where a prior call to
{\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}} has been made. The new problem must have the
same size as the previous one.  {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} performs the
same input checking and initializations that {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}
does, but does no memory allocation as it assumes that the existing
internal memory is sufficient for the new problem.  A call to
{\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} deletes the solution history that was stored
internally during the previous integration.  Following a successful
call to {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}}, call {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} again for
the solution of the new problem.

The use of {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} requires that the number of Runge
Kutta stages, denoted by \emph{s}, be no larger for the new problem than
for the previous problem.  This condition is automatically fulfilled
if the method order \emph{q} and the problem type (explicit, implicit,
ImEx) are left unchanged.  If there are changes to the linear solver
specifications, the user should make the appropriate calls to either
the linear solver objects themselves, or to the ARKDLS or ARKSPILS
interface routines, as described  in the section
{\hyperref[c_interface/User_callable:cinterface-linearsolvers]{\emph{\DUspan{}{Linear solver interface functions}}}}. Otherwise, all solver inputs set
previously remain in effect.

One important use of the {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} function is in the
treating of jump discontinuities in the RHS function.  Except in cases
of fairly small jumps, it is usually more efficient to stop at each
point of discontinuity and restart the integrator with a readjusted
ODE model, using a call to {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}}.  To stop when the
location of the discontinuity is known, simply make that location a
value of \code{tout}.  To stop when the location of the discontinuity is
determined by the solution, use the rootfinding feature.  In either
case, it is critical that the RHS function \emph{not} incorporate the
discontinuity, but rather have a smooth extention over the
discontinuity, so that the step across it (and subsequent rootfinding,
if used) can be done efficiently.  Then use a switch within the RHS
function (communicated through \code{user\_data}) that can be flipped
between the stopping of the integration and the restart, so that the
restarted problem uses the new values (which have jumped).  Similar
comments apply if there is to be a jump in the dependent variable
vector.
\index{ARKodeReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeReInit}\pysiglinewithargsret{int \bfcode{ARKodeReInit}}{void*\emph{ arkode\_mem}, {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{ARKRhsFn}}}\emph{ fe}, {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{ARKRhsFn}}}\emph{ fi}, realtype\emph{ t0}, N\_Vector\emph{ y0}}{}
Provides required problem specifications and reinitializes ARKode.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{fe} -- the name of the C function (of type {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn()}}}})
defining the explicit portion of the right-hand side function in
\(\dot{y} = f_E(t,y) + f_I(t,y)\).

\item {} 
\emph{fi} -- the name of the C function (of type {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn()}}}})
defining the implicit portion of the right-hand side function in
\(\dot{y} = f_E(t,y) + f_I(t,y)\).

\item {} 
\emph{t0} -- the initial value of \(t\).

\item {} 
\emph{y0} -- the initial condition vector \(y(t_0)\).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_MEM\_FAIL}  if a memory allocation failed

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\textbf{Notes:} If an error occurred, {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} also
sends an error message to the error handler function.

\end{fulllineitems}



\subsection{ARKode system resize function}
\label{c_interface/User_callable:arkode-system-resize-function}\label{c_interface/User_callable:cinterface-resizing}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatially-adaptive
PDE simulations under a method-of-lines approach), the ARKode
integrator may be ``resized'' between integration steps, through calls
to the {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}} function. This function modifies
ARKode's internal memory structures to use the new problem size,
without destruction of the temporal adaptivity heuristics.  It is
assumed that the dynamical time scales before and after the vector
resize will be comparable, so that all time-stepping heuristics prior
to calling {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}} remain valid after the call.  If
instead the dynamics should be recomputed from scratch, the ARKode
memory structure should be deleted with a call to
{\hyperref[c_interface/User_callable:c.ARKodeFree]{\emph{\code{ARKodeFree()}}}}, and recreated with calls to
{\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}} and {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}.

To aid in the vector resize operation, the user can supply a vector
resize function that will take as input a vector with the previous
size, and transform it in-place to return a corresponding vector of
the new size.  If this function (of type {\hyperref[c_interface/User_supplied:c.ARKVecResizeFn]{\emph{\code{ARKVecResizeFn()}}}})
is not supplied (i.e. is set to \code{NULL}), then all existing vectors
internal to ARKode will be destroyed and re-cloned from the new input
vector.

In the case that the dynamical time scale should be modified slightly
from the previous time scale, an input \emph{hscale} is allowed, that will
rescale the upcoming time step by the specified factor.  If a value
\emph{hscale} \(\le 0\) is specified, the default of 1.0 will be used.
\index{ARKodeResize (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_callable:c.ARKodeResize}\pysiglinewithargsret{int \bfcode{ARKodeResize}}{void*\emph{ arkode\_mem}, N\_Vector\emph{ ynew}, realtype\emph{ hscale}, realtype\emph{ t0}, {\hyperref[c_interface/User_supplied:c.ARKVecResizeFn]{\emph{ARKVecResizeFn}}}\emph{ resize}, void*\emph{ resize\_data}}{}
Re-initializes ARKode with a different state vector but with
comparable dynamical time scale.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{ynew} -- the newly-sized solution vector, holding the current
dependent variable values \(y(t_0)\).

\item {} 
\emph{hscale} -- the desired scaling factor for the dynamical time
scale (i.e. the next step will be of size \emph{h*hscale}).

\item {} 
\emph{t0} -- the current value of the independent variable
\(t_0\) (this must be consistent with \emph{ynew}.

\item {} 
\emph{resize} -- the user-supplied vector resize function (of type
{\hyperref[c_interface/User_supplied:c.ARKVecResizeFn]{\emph{\code{ARKVecResizeFn()}}}}.

\item {} 
\emph{resize\_data} -- the user-supplied data structure to be passed
to \emph{resize} when modifying internal ARKode vectors.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARK\_SUCCESS} if successful

\item {} 
\emph{ARK\_MEM\_NULL}  if the ARKode memory was \code{NULL}

\item {} 
\emph{ARK\_NO\_MALLOC} if \emph{arkode\_mem} was not allocated.

\item {} 
\emph{ARK\_ILL\_INPUT} if an argument has an illegal value.

\end{itemize}

\end{description}

\textbf{Notes:} If an error occurred, {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}} also sends an error
message to the error handler function.

\end{fulllineitems}



\subsubsection{Resizing the linear solver}
\label{c_interface/User_callable:resizing-the-linear-solver}
When using any of the SUNDIALS-provided linear solver modules, the
linear solver memory structures must also be resized.  At present,
none of these include a solver-specific `resize' function, so the linear
solver memory must be destroyed and re-allocated \textbf{following} each
call to {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}}.  Moreover, the existing ARKDLS or
ARKSPILS interface should then be deleted and recreated by attaching
the updated \code{SUNLinearSolver} (and possibly
\code{SUNMatrix}) object(s) through calls to
{\hyperref[c_interface/User_callable:c.ARKDlsSetLinearSolver]{\emph{\code{ARKDlsSetLinearSolver()}}}},
{\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}},
{\hyperref[c_interface/User_callable:c.ARKDlsSetMassLinearSolver]{\emph{\code{ARKDlsSetMassLinearSolver()}}}} and
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}}.

If any user-supplied routines are provided to aid the linear solver
(e.g. Jacobian construction, Jacobian-vector product,
mass-matrix-vector product, preconditioning), then the corresponding
``set'' routines must be called again \textbf{following} the solver
re-specification.


\subsubsection{Resizing the absolute tolerance array}
\label{c_interface/User_callable:resizing-the-absolute-tolerance-array}
If using array-valued absolute tolerances, the absolute tolerance
vector will be invalid after the call to {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}}, so
the new absolute tolerance vector should be re-set \textbf{following} each
call to {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}} through a new call to
{\hyperref[c_interface/User_callable:c.ARKodeSVtolerances]{\emph{\code{ARKodeSVtolerances()}}}} (and similarly to
{\hyperref[c_interface/User_callable:c.ARKodeResVtolerance]{\emph{\code{ARKodeResVtolerance()}}}} if that was used for the original
problem).

If scalar-valued tolerances or a tolerance function was specified
through either {\hyperref[c_interface/User_callable:c.ARKodeSStolerances]{\emph{\code{ARKodeSStolerances()}}}} or
{\hyperref[c_interface/User_callable:c.ARKodeWFtolerances]{\emph{\code{ARKodeWFtolerances()}}}}, then these will remain valid. and no
further action is necessary.

\begin{notice}{note}{Note:}
For an example of {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}} usage, see the
supplied serial C example problem, \code{ark\_heat1D\_adapt.c}.
\end{notice}


\section{User-supplied functions}
\label{c_interface/User_supplied:cinterface-usersupplied}\label{c_interface/User_supplied:user-supplied-functions}\label{c_interface/User_supplied::doc}
The user-supplied functions for ARKode consist of:
\begin{itemize}
\item {} 
at least one function defining the ODE (required),

\item {} 
a function that handles error and warning messages (optional),

\item {} 
a function that provides the error weight vector (optional),

\item {} 
a function that provides the residual weight vector (optional),

\item {} 
a function that handles adaptive time step error control (optional),

\item {} 
a function that handles explicit time step stability (optional),

\item {} 
a function that defines the root-finding problem(s) to solve
(optional),

\item {} 
one or two functions that provide Jacobian-related information for
the linear solver, if a Newton-based nonlinear iteration is chosen
(optional),

\item {} 
one or two functions that define the preconditioner for use in any
of the Krylov iterative algorithms, if a Newton-based nonlinear
iteration and iterative linear solver are chosen (optional), and

\item {} 
if the problem involves a non-identity mass matrix \(M\ne I\):
\begin{itemize}
\item {} 
one or two functions that provide mass-matrix-related information
for the linear and mass matrix solvers (required),

\item {} 
one or two functions that define the mass matrix preconditioner
for use in an iterative mass matrix solver is chosen (optional), and

\end{itemize}

\item {} 
a function that handles vector resizing operations, if the
underlying vector structure supports resizing (as opposed to
deletion/recreation), and if the user plans to call
{\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}} (optional).

\end{itemize}


\subsection{ODE right-hand side}
\label{c_interface/User_supplied:ode-right-hand-side}\label{c_interface/User_supplied:cinterface-oderhs}
The user must supply at least one function of type {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn}}}} to
specify the explicit and/or implicit portions of the ODE system:
\index{ARKRhsFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKRhsFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKRhsFn)}}{realtype\emph{ t}, N\_Vector\emph{ y}, N\_Vector\emph{ ydot}, void*\emph{ user\_data}}{}
These functions compute the ODE right-hand side for a given
value of the independent variable \(t\) and state vector \(y\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{y} -- the current value of teh dependent variable vector, \(y(t)\).

\item {} 
\emph{ydot} -- the output vector that forms a portion of the ODE RHS \(f_E(t,y) + f_I(t,y)\).

\item {} 
\emph{user\_data} -- the \emph{user\_data} pointer that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKRhsFn} should return 0 if successful, a positive value if a
recoverable error occurred (in which case ARKode will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and \emph{ARK\_RHSFUNC\_FAIL} is returned).

\textbf{Notes:} Allocation of memory for \emph{ydot} is handled within
ARKode.  A recoverable failure error return from the \emph{ARKRhsFn} is
typically used to flag a value of the dependent variable \(y\)
that is ``illegal'' in some way (e.g., negative where only a
nonnegative value is physically meaningful).  If such a return is
made, ARKode will attempt to recover (possibly repeating the
nonlinear iteration, or reducing the step size) in order to avoid
this recoverable error return.  There are some situations in which
recovery is not possible even if the right-hand side function
returns a recoverable error flag.  One is when this occurs at the
very first call to the \emph{ARKRhsFn} (in which case
ARKode returns \emph{ARK\_FIRST\_RHSFUNC\_ERR}).  Another is when a
recoverable error is reported by \emph{ARKRhsFn} after the integrator
completes a successful stage, in which case ARKode returns
\emph{ARK\_UNREC\_RHSFUNC\_ERR}).

\end{fulllineitems}



\subsection{Error message handler function}
\label{c_interface/User_supplied:cinterface-errorhandler}\label{c_interface/User_supplied:error-message-handler-function}
As an alternative to the default behavior of directing error and
warning messages to the file pointed to by \emph{errfp} (see
{\hyperref[c_interface/User_callable:c.ARKodeSetErrFile]{\emph{\code{ARKodeSetErrFile()}}}}), the user may provide a function of type
{\hyperref[c_interface/User_supplied:c.ARKErrHandlerFn]{\emph{\code{ARKErrHandlerFn}}}} to process any such messages.
\index{ARKErrHandlerFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKErrHandlerFn}\pysiglinewithargsret{typedef void \bfcode{(*ARKErrHandlerFn)}}{int\emph{ error\_code}, const char*\emph{ module}, const char*\emph{ function}, char*\emph{ msg}, void*\emph{ user\_data}}{}
This function processes error and warning messages from
ARKode and is sub-modules.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{error\_code} -- the error code.

\item {} 
\emph{module} -- the name of the ARKode module reporting the error.

\item {} 
\emph{function} -- the name of the function in which the error occurred.

\item {} 
\emph{msg} -- the error message.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{eh\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetErrHandlerFn]{\emph{\code{ARKodeSetErrHandlerFn()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKErrHandlerFn} function has no return value.

\textbf{Notes:} \emph{error\_code} is negative for errors and positive
(\emph{ARK\_WARNING}) for warnings.  If a function that returns a
pointer to memory encounters an error, it sets \emph{error\_code} to
0.

\end{fulllineitems}



\subsection{Error weight function}
\label{c_interface/User_supplied:cinterface-errorweight}\label{c_interface/User_supplied:error-weight-function}
As an alternative to providing the relative and absolute tolerances,
the user may provide a function of type {\hyperref[c_interface/User_supplied:c.ARKEwtFn]{\emph{\code{ARKEwtFn}}}} to compute a
vector \emph{ewt} containing the weights in the WRMS norm
\(\|v\|_{WRMS} = \left(\frac{1}{n} \sum_{i=1}^n \left(ewt_i\; v_i\right)^2
\right)^{1/2}\).  These weights will be used in place of those defined
in the section {\hyperref[Mathematics:mathematics-error-norm]{\emph{\DUspan{}{Choice of norm}}}}.
\index{ARKEwtFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKEwtFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKEwtFn)}}{N\_Vector\emph{ y}, N\_Vector\emph{ ewt}, void*\emph{ user\_data}}{}
This function computes the WRMS error weights for the vector
\(y\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{y} -- the dependent variable vector at which the
weight vector is to be computed.

\item {} 
\emph{ewt} -- the output vector containing the error weights.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKEwtFn} function must return 0 if it
successfully set the error weights, and -1 otherwise.

\textbf{Notes:} Allocation of memory for \emph{ewt} is handled within ARKode.

The error weight vector must have all components positive.  It is
the user's responsibility to perform this test and return -1 if it
is not satisfied.

\end{fulllineitems}



\subsection{Residual weight function}
\label{c_interface/User_supplied:cinterface-residualweight}\label{c_interface/User_supplied:residual-weight-function}
As an alternative to providing the scalar or vector absolute residual
tolerances (when the IVP units differ from the solution units), the
user may provide a function of type {\hyperref[c_interface/User_supplied:c.ARKRwtFn]{\emph{\code{ARKRwtFn}}}} to compute a
vector \emph{rwt} containing the weights in the WRMS norm
\(\|v\|_{WRMS} = \left(\frac{1}{n} \sum_{i=1}^n \left(rwt_i\; v_i\right)^2
\right)^{1/2}\).  These weights will be used in place of those defined
in the section {\hyperref[Mathematics:mathematics-error-norm]{\emph{\DUspan{}{Choice of norm}}}}.
\index{ARKRwtFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKRwtFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKRwtFn)}}{N\_Vector\emph{ y}, N\_Vector\emph{ rwt}, void*\emph{ user\_data}}{}
This function computes the WRMS residual weights for the vector
\(y\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{y} -- the dependent variable vector at which the
weight vector is to be computed.

\item {} 
\emph{rwt} -- the output vector containing the residual weights.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKRwtFn} function must return 0 if it
successfully set the residual weights, and -1 otherwise.

\textbf{Notes:} Allocation of memory for \emph{rwt} is handled within ARKode.

The residual weight vector must have all components positive.  It is
the user's responsibility to perform this test and return -1 if it
is not satisfied.

\end{fulllineitems}



\subsection{Time step adaptivity function}
\label{c_interface/User_supplied:time-step-adaptivity-function}\label{c_interface/User_supplied:cinterface-adaptivityfn}
As an alternative to using one of the built-in time step adaptivity
methods for controlling solution error, the user may provide a
function of type {\hyperref[c_interface/User_supplied:c.ARKAdaptFn]{\emph{\code{ARKAdaptFn}}}} to compute a target step size
\(h\) for the next integration step.  These steps should be chosen
as the maximum value such that the error estimates remain below 1.
\index{ARKAdaptFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKAdaptFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKAdaptFn)}}{N\_Vector\emph{ y}, realtype\emph{ t}, realtype\emph{ h1}, realtype\emph{ h2}, realtype\emph{ h3}, realtype\emph{ e1}, realtype\emph{ e2}, realtype\emph{ e3}, int\emph{ q}, int\emph{ p}, realtype*\emph{ hnew}, void*\emph{ user\_data}}{}
This function implements a time step adaptivity algorithm
that chooses \(h\) satisfying the error tolerances.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{y} -- the current value of the dependent variable vector, \(y(t)\).

\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{h1} -- the current step size, \(t_m - t_{m-1}\).

\item {} 
\emph{h2} -- the previous step size, \(t_{m-1} - t_{m-2}\).

\item {} 
\emph{h3} -- the step size \(t_{m-2}-t_{m-3}\).

\item {} 
\emph{e1} -- the error estimate from the current step, \(m\).

\item {} 
\emph{e2} -- the error estimate from the previous step, \(m-1\).

\item {} 
\emph{e3} -- the error estimate from the step \(m-2\).

\item {} 
\emph{q} -- the global order of accuracy for the integration method.

\item {} 
\emph{p} -- the global order of accuracy for the embedding.

\item {} 
\emph{hnew} -- the output value of the next step size.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{h\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityFn]{\emph{\code{ARKodeSetAdaptivityFn()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKAdaptFn} function should return 0 if it
successfuly set the next step size, and a non-zero value otherwise.

\end{fulllineitems}



\subsection{Explicit stability function}
\label{c_interface/User_supplied:explicit-stability-function}\label{c_interface/User_supplied:cinterface-stabilityfn}
A user may supply a function to predict the maximum stable step size
for the explicit portion of the ImEx system, \(f_E(t,y)\).  While
the accuracy-based time step adaptivity algorithms may be sufficient
for retaining a stable solution to the ODE system, these may be
inefficient if \(f_E(t,y)\) contains moderately stiff terms.  In
this scenario, a user may provide a function of type {\hyperref[c_interface/User_supplied:c.ARKExpStabFn]{\emph{\code{ARKExpStabFn}}}}
to provide this stability information to ARKode.  This function
must set the scalar step size satisfying the stability restriction for
the upcoming time step.  This value will subsequently be bounded by
the user-supplied values for the minimum and maximum allowed time
step, and the accuracy-based time step.
\index{ARKExpStabFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKExpStabFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKExpStabFn)}}{N\_Vector\emph{ y}, realtype\emph{ t}, realtype*\emph{ hstab}, void*\emph{ user\_data}}{}
This function predicts the maximum stable step size for the
explicit portions of the ImEx ODE system.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{y} -- the current value of the dependent variable vector, \(y(t)\).

\item {} 
\emph{t} -- the current value of the independent variable

\item {} 
\emph{hstab} -- the output value with the absolute value of the
maximum stable step size.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{estab\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetStabilityFn]{\emph{\code{ARKodeSetStabilityFn()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKExpStabFn} function should return 0 if it
successfully set the upcoming stable step size, and a non-zero
value otherwise.

\textbf{Notes:}  If this function is not supplied, or if it returns
\emph{hstab} \(\le 0.0\), then ARKode will assume that there is no explicit
stability restriction on the time step size.

\end{fulllineitems}



\subsection{Rootfinding function}
\label{c_interface/User_supplied:cinterface-rootfindingfn}\label{c_interface/User_supplied:rootfinding-function}
If a rootfinding problem is to be solved during the integration of the
ODE system, the user must supply a function of type {\hyperref[c_interface/User_supplied:c.ARKRootFn]{\emph{\code{ARKRootFn}}}}.
\index{ARKRootFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKRootFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKRootFn)}}{realtype\emph{ t}, N\_Vector\emph{ y}, realtype*\emph{ gout}, void*\emph{ user\_data}}{}
This function implements a vector-valued function
\(g(t,y)\) such that the roots of the \emph{nrtfn} components
\(g_i(t,y)\) are sought.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable

\item {} 
\emph{y} -- the current value of the dependent variable vector, \(y(t)\).

\item {} 
\emph{gout} -- the output array, of length \emph{nrtfn}, with components \(g_i(t,y)\).

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKRootFn} function should return 0 if successful
or a non-zero value if an error occurred (in which case the
integration is halted and ARKode returns \emph{ARK\_RTFUNC\_FAIL}).

\textbf{Notes:} Allocation of memory for \emph{gout} is handled within ARKode.

\end{fulllineitems}



\subsection{Jacobian information (direct method Jacobian)}
\label{c_interface/User_supplied:cinterface-jacobianfn}\label{c_interface/User_supplied:jacobian-information-direct-method-jacobian}
If the direct linear solver interface is used (i.e.,
{\hyperref[c_interface/User_callable:c.ARKDlsSetLinearSolver]{\emph{\code{ARKDlsSetLinearSolver()}}}} is called in the section
{\hyperref[c_interface/Skeleton:cinterface-skeleton]{\emph{\DUspan{}{A skeleton of the user's main program}}}}), the user may provide a function of type
{\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn}}}} to provide the Jacobian approximation.
\index{ARKDlsJacFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKDlsJacFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKDlsJacFn)}}{realtype\emph{ t}, N\_Vector\emph{ y}, N\_Vector\emph{ fy}, SUNMatrix\emph{ Jac}, void*\emph{ user\_data}, N\_Vector\emph{ tmp1}, N\_Vector\emph{ tmp2}, N\_Vector\emph{ tmp3}}{}
This function computes the Jacobian matrix \(J =
\frac{\partial f_I}{\partial y}\) (or an approximation to it).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{y} -- the current value of the dependent variable vector, namely
the predicted value of \(y(t)\).

\item {} 
\emph{fy} -- the current value of the vector \(f_I(t,y)\).

\item {} 
\emph{Jac} -- the output Jacobian matrix.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\item {} 
\emph{tmp1}, \emph{tmp2}, \emph{tmp3} -- pointers to memory allocated to
variables of type \code{N\_Vector} which can be used by an
ARKDlsacFn as temporary storage or work space.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKDlsJacFn} function should return 0 if successful, a positive
value if a recoverable error occurred (in which case ARKode will
attempt to correct, while ARKDLS sets \emph{last\_flag} to
\emph{ARKDLS\_JACFUNC\_RECVR}), or a negative value if it failed
unrecoverably (in which case the integration is halted,
{\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} returns \emph{ARK\_LSETUP\_FAIL} and ARKDLS sets
\emph{last\_flag} to \emph{ARKDLS\_JACFUNC\_UNRECVR}).

\textbf{Notes:} Information regarding the structure of the specific
\code{SUNMatrix} structure (e.g.\textasciitilde{}number of rows, upper/lower
bandwidth, sparsity type) may be obtained through using the
implementation-specific \code{SUNMatrix} interface functions
(see the section {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}} for details).

Prior to calling the user-supplied Jacobian function, the Jacobian
matrix \(J(t,y)\) is zeroed out, so only nonzero elements need
to be loaded into \emph{Jac}.

If the user's {\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn}}}} function uses difference
quotient approximations, then it may need to access quantities not
in the argument list.  These include the current step size, the
error weights, etc.  To obtain these, the user will need to add a
pointer to the \code{ark\_mem} structure to their \code{user\_data}, and
then use the ARKodeGet* functions listed in
{\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}}. The unit roundoff can be
accessed as \code{UNIT\_ROUNDOFF}, which is defined in the header
file \code{sundials\_types.h}.

\textbf{dense}:

A user-supplied dense Jacobian function must load the
\emph{N} by \emph{N} dense matrix \emph{Jac} with an approximation to the Jacobian
matrix \(J(t,y)\) at the point \((t,y)\). The accessor
macros \code{SM\_ELEMENT\_D} and \code{SM\_COLUMN\_D} allow the user to read
and write dense matrix elements without making explicit references
to the underlying representation of the SUNMATRIX\_DENSE type.
\code{SM\_ELEMENT\_D(J, i, j)} references the \code{(i,j)}-th element of
the dense matrix \code{J} (for \code{i}, \code{j} between 0 and
N-1). This macro is meant for small problems for which
efficiency of access is not a major concern. Thus, in terms of the
indices \(m\) and \(n\) ranging from 1 to \emph{N}, the
Jacobian element \(J_{m,n}\) can be set using the statement
\code{SM\_ELEMENT\_D(J, m-1, n-1) =} \(J_{m,n}\).  Alternatively,
\code{SM\_COLUMN\_D(J, j)} returns a pointer to the first element of the
\code{j}-th column of \code{J} (for \code{j} ranging from 0 to \emph{N}-1),
and the elements of the \code{j}-th column can then be accessed using
ordinary array indexing. Consequently, \(J_{m,n}\) can be
loaded using the statements
\code{col\_n = SM\_COLUMN\_D(J, n-1); col\_n{[}m-1{]} =} \(J_{m,n}\).
For large problems, it is more efficient to use \code{SM\_COLUMN\_D}
than to use \code{SM\_ELEMENT\_D}.  Note that both of these macros
number rows and columns starting from 0.  The SUNMATRIX\_DENSE type
and accessor macros are documented in section
{\hyperref[sunmatrix/SUNMatrix_Dense:sunmatrix-dense]{\emph{\DUspan{}{The SUNMATRIX\_DENSE Module}}}}.

\textbf{band}:

A user-supplied banded Jacobian function must load the band
matrix \emph{Jac} with the elements of the Jacobian
\(J(t,y)\) at the point \((t,y)\). The accessor macros
\code{SM\_ELEMENT\_B}, \code{SM\_COLUMN\_B}, and \code{SM\_COLUMN\_ELEMENT\_B}
allow the user to read and write band matrix elements without
making specific references to the underlying representation of the
SUNMATRIX\_BAND type.  \code{SM\_ELEMENT\_B(J, i, j)} references the
\code{(i,j)}-th element of the band matrix \code{J}, counting
from 0. This macro is meant for use in small problems for
which efficiency of access is not a major concern. Thus, in terms
of the indices \(m\) and \(n\) ranging from 1 to \emph{N} with
\((m, n)\) within the band defined by \emph{mupper} and
\emph{mlower}, the Jacobian element \(J_{m,n}\) can be loaded
using the statement \code{SM\_ELEMENT\_B(J, m-1, n-1)} \(=
J_{m,n}\). The elements within the band are those with \emph{-mupper}
\(\le m-n \le\) \emph{mlower}.  Alternatively, \code{SM\_COLUMN\_B(J, j)}
returns a pointer to the diagonal element of the \code{j}-th column of
\code{J}, and if we assign this address to \code{realtype *col\_j}, then
the \code{i}-th element of the \code{j}-th column is given by
\code{SM\_COLUMN\_ELEMENT\_B(col\_j, i, j)}, counting from 0. Thus, for
\((m,n)\) within the band, \(J_{m,n}\) can be loaded by
setting \code{col\_n = SM\_COLUMN\_B(J, n-1); SM\_COLUMN\_ELEMENT\_B(col\_n, m-1,
n-1)} \(= J_{m,n}\) . The elements of the \code{j}-th column can
also be accessed via ordinary array indexing, but this approach
requires knowledge of the underlying storage for a band matrix of
type SUNMATRIX\_BAND. The array \code{col\_n} can be indexed from
\emph{-mupper} to \emph{mlower}. For large problems, it is more efficient
to use \code{SM\_COLUMN\_B} and \code{SM\_COLUMN\_ELEMENT\_B} than to use the
\code{SM\_ELEMENT\_B} macro. As in the dense case, these macros all
number rows and columns starting from 0. The SUNMATRIX\_BAND type
and accessor macros are documented in section {\hyperref[sunmatrix/SUNMatrix_Band:sunmatrix-band]{\emph{\DUspan{}{The SUNMATRIX\_BAND Module}}}}.

\textbf{sparse}:

A user-supplied sparse Jacobian function must load the
compressed-sparse-column (CSC) or compressed-sparse-row (CSR)
matrix \emph{Jac} with an approximation to the Jacobian matrix
\(J(t,y)\) at the point \((t,y)\).  Storage for \emph{Jac}
already exists on entry to this function, although the user should
ensure that sufficient space is allocated in \emph{Jac} to hold the
nonzero values to be set; if the existing space is insufficient the
user may reallocate the data and index arrays as needed.  The
amount of allocated space in a SUNMATRIX\_SPARSE object may be
accessed using the macro \code{SM\_NNZ\_S} or the routine
{\hyperref[sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NNZ]{\emph{\code{SUNSparseMatrix\_NNZ()}}}}.  The SUNMATRIX\_SPARSE type is
further documented in the section {\hyperref[sunmatrix/SUNMatrix_Sparse:sunmatrix-sparse]{\emph{\DUspan{}{The SUNMATRIX\_SPARSE Module}}}}.

\end{fulllineitems}



\subsection{Jacobian information (matrix-vector product)}
\label{c_interface/User_supplied:cinterface-jtimesfn}\label{c_interface/User_supplied:jacobian-information-matrix-vector-product}
If the ARKSPILS solver interface is selected
(i.e. {\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}} is called in the
section {\hyperref[c_interface/Skeleton:cinterface-skeleton]{\emph{\DUspan{}{A skeleton of the user's main program}}}}), the user may provide a function
of type {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{\code{ARKSpilsJacTimesVecFn}}}} in the following form, to
compute matrix-vector products \(Jv\). If such a function is not
supplied, the default is a difference quotient approximation to these
products.
\index{ARKSpilsJacTimesVecFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsJacTimesVecFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsJacTimesVecFn)}}{N\_Vector\emph{ v}, N\_Vector\emph{ Jv}, realtype\emph{ t}, N\_Vector\emph{ y}, N\_Vector\emph{ fy}, void*\emph{ user\_data}, N\_Vector\emph{ tmp}}{}
This function computes the product \(Jv =
\left(\frac{\partial f_I}{\partial y}\right)v\) (or an approximation to it).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{v} -- the vector to multiply.

\item {} 
\emph{Jv} -- the output vector computed.

\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{y} -- the current value of the dependent variable vector.

\item {} 
\emph{fy} -- the current value of the vector \(f_I(t,y)\).

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\item {} 
\emph{tmp} -- pointer to memory allocated to a variable of type
\code{N\_Vector} which can be used as temporary storage or work space.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the Jacobian-vector product
function should be 0 if successful. Any other return value will
result in an unrecoverable error of the generic Krylov solver,
in which case the integration is halted.

\textbf{Notes:} If the user's {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{\code{ARKSpilsJacTimesVecFn}}}} function
uses difference quotient approximations, it may need to access
quantities not in the argument list.  These include the current
step size, the error weights, etc.  To obtain these, the
user will need to add a pointer to the \code{ark\_mem} structure to
their \code{user\_data}, and then use the ARKodeGet* functions listed
in {\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}}. The unit roundoff can be
accessed as \code{UNIT\_ROUNDOFF}, which is defined in the header
file \code{sundials\_types.h}.

\end{fulllineitems}



\subsection{Jacobian information (matrix-vector setup)}
\label{c_interface/User_supplied:cinterface-jtsetupfn}\label{c_interface/User_supplied:jacobian-information-matrix-vector-setup}
If the user's Jacobian-times-vector requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied function of type {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{\code{ARKSpilsJacTimesSetupFn}}}},
defined as follows:
\index{ARKSpilsJacTimesSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsJacTimesSetupFn)}}{realtype\emph{ t}, N\_Vector\emph{ y}, N\_Vector\emph{ fy}, void*\emph{ user\_data}}{}
This function preprocesses and/or evaluates any Jacobian-related
data needed by the Jacobian-times-vector routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{y} -- the current value of the dependent variable vector.

\item {} 
\emph{fy} -- the current value of the vector \(f_I(t,y)\).

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the Jacobian-vector setup
function should be 0 if successful, positive for a recoverable
error (in which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\textbf{Notes:}    Each call to the Jacobian-vector setup function is
preceded by a call to the implicit {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn}}}} user
function with the same \((t,y)\) arguments.  Thus, the setup
function can use any auxiliary data that is computed and saved
during the evaluation of the implicit ODE right-hand side.

If the user's {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{\code{ARKSpilsJacTimesSetupFn}}}} function uses
difference quotient approximations, it may need to access
quantities not in the argument list.  These include the current
step size, the error weights, etc.  To obtain these, the
user will need to add a pointer to the \code{ark\_mem} structure to
their \code{user\_data}, and then use the ARKodeGet* functions listed
in {\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}}. The unit roundoff can be
accessed as \code{UNIT\_ROUNDOFF}, which is defined in the header
file \code{sundials\_types.h}.

\end{fulllineitems}



\subsection{Preconditioning (linear system solution)}
\label{c_interface/User_supplied:cinterface-precsolvefn}\label{c_interface/User_supplied:preconditioning-linear-system-solution}
If preconditioning is used with the ARKSPILS solver interface, then
the user must provide a function of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSolveFn]{\emph{\code{ARKSpilsPrecSolveFn}}}} to solve the linear system
\(Pz=r\), where \(P\) may be either a left or right
preconditioning matrix.  Here \(P\) should approximate (at least
crudely) the Newton matrix \(A=M-\gamma J\), where \(M\) is
the mass matrix (typically \(M=I\) unless working in a
finite-element setting) and \(J = \frac{\partial f_I}{\partial
y}\)  If preconditioning is done on both sides, the product of the two
preconditioner matrices should approximate \(A\).
\index{ARKSpilsPrecSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsPrecSolveFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsPrecSolveFn)}}{realtype\emph{ t}, N\_Vector\emph{ y}, N\_Vector\emph{ fy}, N\_Vector\emph{ r}, N\_Vector\emph{ z}, realtype\emph{ gamma}, realtype\emph{ delta}, int\emph{ lr}, void*\emph{ user\_data}}{}
This function solves the preconditioner system \(Pz=r\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{y} -- the current value of the dependent variable vector.

\item {} 
\emph{fy} -- the current value of the vector \(f_I(t,y)\).

\item {} 
\emph{r} -- the right-hand side vector of the linear system.

\item {} 
\emph{z} -- the computed output solution vector.

\item {} 
\emph{gamma} -- the scalar \(\gamma\) appearing in the Newton
matrix given by \(A=M-\gamma J\).

\item {} 
\emph{delta} -- an input tolerance to be used if an iterative method
is employed in the solution.  In that case, the resdual vector
\(Res = r-Pz\) of the system should be made to be less than \emph{delta}
in the weighted \(l_2\) norm, i.e. \(\left(\sum_{i=1}^n
\left(Res_i * ewt_i\right)^2 \right)^{1/2} < \delta\), where \(\delta =\)
\emph{delta}.  To obtain the \code{N\_Vector} \emph{ewt}, call
{\hyperref[c_interface/User_callable:c.ARKodeGetErrWeights]{\emph{\code{ARKodeGetErrWeights()}}}}.

\item {} 
\emph{lr} -- an input flag indicating whether the preconditioner
solve is to use the left preconditioner (\emph{lr} = 1) or the right
preconditioner (\emph{lr} = 2).

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the preconditioner solve
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\end{fulllineitems}



\subsection{Preconditioning (Jacobian data)}
\label{c_interface/User_supplied:cinterface-precsetupfn}\label{c_interface/User_supplied:preconditioning-jacobian-data}
If the user's preconditioner requires that any data be preprocessed or
evaluated, then these actions need to occur within a user-supplied
function of type {\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSetupFn]{\emph{\code{ARKSpilsPrecSetupFn}}}}.
\index{ARKSpilsPrecSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsPrecSetupFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsPrecSetupFn)}}{realtype\emph{ t}, N\_Vector\emph{ y}, N\_Vector\emph{ fy}, booleantype\emph{ jok}, booleantype*\emph{ jcurPtr}, realtype\emph{ gamma}, void*\emph{ user\_data}}{}
This function preprocesses and/or evaluates Jacobian-related
data needed by the preconditioner.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{y} -- the current value of the dependent variable vector.

\item {} 
\emph{fy} -- the current value of the vector \(f_I(t,y)\).

\item {} 
\emph{jok} -- is an input flag indicating whether the Jacobian-related
data needs to be updated. The \emph{jok} argument provides for the
reuse of Jacobian data in the preconditioner solve function. When
\emph{jok} = \code{SUNFALSE}, the Jacobian-related data should be recomputed
from scratch. When \emph{jok} = \code{SUNTRUE} the Jacobian data, if saved from the
previous call to this function, can be reused (with the current
value of \emph{gamma}). A call with \emph{jok} = \code{SUNTRUE} can only occur
after a call with \emph{jok} = \code{SUNFALSE}.

\item {} 
\emph{jcurPtr} -- is a pointer to a flag which should be set to
\code{SUNTRUE} if Jacobian data was recomputed, or set to \code{SUNFALSE} if
Jacobian data was not recomputed, but saved data was still reused.

\item {} 
\emph{gamma} -- the scalar \(\gamma\) appearing in the Newton
matrix given by \(A=M-\gamma J\).

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the preconditioner setup
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\textbf{Notes:}  The operations performed by this function might include
forming a crude approximate Jacobian, and performing an LU
factorization of the resulting approximation to \(A = M -
\gamma J\).

Each call to the preconditioner setup function is preceded by a
call to the implicit {\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn}}}} user function with the
same \((t,y)\) arguments.  Thus, the preconditioner setup
function can use any auxiliary data that is computed and saved
during the evaluation of the ODE right-hand side.

This function is not called in advance of every call to the
preconditioner solve function, but rather is called only as often
as needed to achieve convergence in the Newton iteration.

If the user's {\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSetupFn]{\emph{\code{ARKSpilsPrecSetupFn}}}} function uses
difference quotient approximations, it may need to access
quantities not in the call list. These include the current step
size, the error weights, etc.  To obtain these, the user will need
to add a pointer to the \code{ark\_mem} structure to their
\code{user\_data}, and then use the ARKodeGet* functions listed in
{\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}}. The unit roundoff can be
accessed as \code{UNIT\_ROUNDOFF}, which is defined in the header
file \code{sundials\_types.h}.

\end{fulllineitems}



\subsection{Mass matrix information (direct method mass matrix)}
\label{c_interface/User_supplied:cinterface-massfn}\label{c_interface/User_supplied:mass-matrix-information-direct-method-mass-matrix}
If the direct mass matrix linear solver interface is
used (i.e., {\hyperref[c_interface/User_callable:c.ARKDlsSetMassLinearSolver]{\emph{\code{ARKDlsSetMassLinearSolver()}}}} is called in the
section {\hyperref[c_interface/Skeleton:cinterface-skeleton]{\emph{\DUspan{}{A skeleton of the user's main program}}}}), the user must provide a function
of type {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn}}}} to provide the mass matrix
approximation.
\index{ARKDlsMassFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKDlsMassFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKDlsMassFn)}}{realtype\emph{ t}, SUNMatrix\emph{ M}, void*\emph{ user\_data}, N\_Vector\emph{ tmp1}, N\_Vector\emph{ tmp2}, N\_Vector\emph{ tmp3}}{}
This function computes the mass matrix \(M\) (or an approximation to it).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{N} -- the size of the ODE system.

\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{M} -- the output mass matrix.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\item {} 
\emph{tmp1}, \emph{tmp2}, \emph{tmp3} -- pointers to memory allocated to
variables of type \code{N\_Vector} which can be used by an
ARKDlsDenseMassFn as temporary storage or work space.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKDlsMassFn} function should return 0 if successful, or a
negative value if it failed unrecoverably (in which case the
integration is halted, {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} returns
\emph{ARK\_MASSSETUP\_FAIL} and ARKDLS sets \emph{last\_flag} to
\emph{ARKDLS\_MASSFUNC\_UNRECVR}).

\textbf{Notes:} Information regarding the structure of the specific
\code{SUNMatrix} structure (e.g.\textasciitilde{}number of rows, upper/lower
bandwidth, sparsity type) may be obtained through using the
implementation-specific \code{SUNMatrix} interface functions
(see the section {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}} for details).

Prior to calling the user-supplied mass matrix function, the mass
matrix \(M(t)\) is zeroed out, so only nonzero elements need to
be loaded into \emph{M}.

\textbf{dense}:

A user-supplied dense mass matrix function must load the \emph{N} by \emph{N}
dense matrix \emph{M} with an approximation to the mass matrix
\(M(t)\). As discussed above in section {\hyperref[c_interface/User_supplied:cinterface-jacobianfn]{\emph{\DUspan{}{Jacobian information (direct method Jacobian)}}}},
the accessor macros \code{SM\_ELEMENT\_D} and \code{SM\_COLUMN\_D} allow the user
to read and write dense matrix elements without making explicit
references to the underlying representation of the SUNMATRIX\_DENSE
type. Similarly, the SUNMATRIX\_DENSE type and accessor macros
\code{SM\_ELEMENT\_D} and \code{SM\_COLUMN\_D} are documented in the section
{\hyperref[sunmatrix/SUNMatrix_Dense:sunmatrix-dense]{\emph{\DUspan{}{The SUNMATRIX\_DENSE Module}}}}.

\textbf{band}:

A user-supplied banded mass matrix function must load
the band matrix \emph{M} with the elements of the mass matrix
\(M(t)\). As discussed above in section
{\hyperref[c_interface/User_supplied:cinterface-jacobianfn]{\emph{\DUspan{}{Jacobian information (direct method Jacobian)}}}}, the accessor macros \code{SM\_ELEMENT\_B},
\code{SM\_COLUMN\_B}, and \code{SM\_COLUMN\_ELEMENT\_B} allow the user to read
and write band matrix elements without making specific references
to the underlying representation of the SUNMATRIX\_BAND type.
Similarly, the SUNMATRIX\_BAND type and the accessor macros \code{SM\_ELEMENT\_B},
\code{SM\_COLUMN\_B}, and \code{SM\_COLUMN\_ELEMENT\_B} are documented in the section
{\hyperref[sunmatrix/SUNMatrix_Band:sunmatrix-band]{\emph{\DUspan{}{The SUNMATRIX\_BAND Module}}}}.

\textbf{sparse}:

A user-supplied sparse mass matrix function must load the
compressed-sparse-column (CSR) or compressed-sparse-row (CSR)
matrix \emph{M} with an approximation to the mass matrix \(M(t)\).
Storage for \emph{M} already exists on entry to this function, although
the user should ensure that sufficient space is allocated in \emph{M}
to hold the nonzero values to be set; if the existing space is
insufficient the user may reallocate the data and row index arrays
as needed.  The type of \emph{M} is SUNMATRIX\_SPARSE, and the amount of
allocated space in a SUNMATRIX\_SPARSE object may be
accessed using the macro \code{SM\_NNZ\_S} or the routine
{\hyperref[sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NNZ]{\emph{\code{SUNSparseMatrix\_NNZ()}}}}.  The SUNMATRIX\_SPARSE type is
further documented in the section {\hyperref[sunmatrix/SUNMatrix_Sparse:sunmatrix-sparse]{\emph{\DUspan{}{The SUNMATRIX\_SPARSE Module}}}}.

\end{fulllineitems}



\subsection{Mass matrix information (matrix-vector product)}
\label{c_interface/User_supplied:mass-matrix-information-matrix-vector-product}\label{c_interface/User_supplied:cinterface-mtimesfn}
If the ARKSPILS solver interface is selected
(i.e. {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}} is called in the
section {\hyperref[c_interface/Skeleton:cinterface-skeleton]{\emph{\DUspan{}{A skeleton of the user's main program}}}}), the user must provide a function
of type {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{\code{ARKSpilsMassTimesVecFn}}}} in the following form, to
compute matrix-vector products \(Mv\).
\index{ARKSpilsMassTimesVecFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsMassTimesVecFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsMassTimesVecFn)}}{N\_Vector\emph{ v}, N\_Vector\emph{ Mv}, realtype\emph{ t}, void*\emph{ mtimes\_data}}{}
This function computes the product \(M*v\) (or an approximation to it).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{v} -- the vector to multiply.

\item {} 
\emph{Mv} -- the output vector computed.

\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{mtimes\_data} -- a pointer to user data, the same as the
\emph{mtimes\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassTimes]{\emph{\code{ARKSpilsSetMassTimes()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the mass-matrix-vector product
function should be 0 if successful. Any other return value will
result in an unrecoverable error of the generic Krylov solver,
in which case the integration is halted.

\end{fulllineitems}



\subsection{Mass matrix information (matrix-vector setup)}
\label{c_interface/User_supplied:cinterface-mtsetupfn}\label{c_interface/User_supplied:mass-matrix-information-matrix-vector-setup}
If the user's mass-matrix-times-vector requires that any mass
matrix-related data be preprocessed or evaluated, then this needs to
be done in a user-supplied function of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesSetupFn]{\emph{\code{ARKSpilsMassTimesSetupFn}}}}, defined as follows:
\index{ARKSpilsMassTimesSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsMassTimesSetupFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsMassTimesSetupFn)}}{realtype\emph{ t}, void*\emph{ mtimes\_data}}{}
This function preprocesses and/or evaluates any mass-matrix-related
data needed by the mass-matrix-times-vector routine.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{mtimes\_data} -- a pointer to user data, the same as the
\emph{mtimes\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassTimes]{\emph{\code{ARKSpilsSetMassTimes()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the mass-matrix-vector setup
function should be 0 if successful. Any other return value will
result in an unrecoverable error of the ARKSPILS mass matrix solver
interface, in which case the integration is halted.

\end{fulllineitems}



\subsection{Mass matrix preconditioning (linear system solution)}
\label{c_interface/User_supplied:cinterface-massprecsolvefn}\label{c_interface/User_supplied:mass-matrix-preconditioning-linear-system-solution}
If preconditioning is used with the ARKSPILS mass matrix solver
interface, then the user must provide a function of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSolveFn]{\emph{\code{ARKSpilsMassPrecSolveFn}}}} to solve the linear system
\(Pz=r\), where \(P\) may be either a left or right
preconditioning matrix.  Here \(P\) should approximate (at least
crudely) the mass matrix \(M\).  If preconditioning is done on
both sides, the product of the two preconditioner matrices should
approximate \(M\).
\index{ARKSpilsMassPrecSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsMassPrecSolveFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsMassPrecSolveFn)}}{realtype\emph{ t}, N\_Vector\emph{ r}, N\_Vector\emph{ z}, realtype\emph{ delta}, int\emph{ lr}, void*\emph{ user\_data}}{}
This function solves the preconditioner system \(Pz=r\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{r} -- the right-hand side vector of the linear system.

\item {} 
\emph{z} -- the computed output solution vector.

\item {} 
\emph{delta} -- an input tolerance to be used if an iterative method
is employed in the solution.  In that case, the resdual vector
\(Res = r-Pz\) of the system should be made to be less than \emph{delta}
in the weighted \(l_2\) norm, i.e. \(\left(\sum_{i=1}^n
\left(Res_i * ewt_i\right)^2 \right)^{1/2} < \delta\), where \(\delta =\)
\emph{delta}.  To obtain the \code{N\_Vector} \emph{ewt}, call
{\hyperref[c_interface/User_callable:c.ARKodeGetErrWeights]{\emph{\code{ARKodeGetErrWeights()}}}}.

\item {} 
\emph{lr} -- an input flag indicating whether the preconditioner
solve is to use the left preconditioner (\emph{lr} = 1) or the right
preconditioner (\emph{lr} = 2).

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the preconditioner solve
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\end{fulllineitems}



\subsection{Mass matrix preconditioning (mass matrix data)}
\label{c_interface/User_supplied:cinterface-masprecsetupfn}\label{c_interface/User_supplied:mass-matrix-preconditioning-mass-matrix-data}
If the user's mass matrix preconditioner requires that any problem
data be preprocessed or evaluated, then these actions need to occur
within a user-supplied function of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSetupFn]{\emph{\code{ARKSpilsMassPrecSetupFn}}}}.
\index{ARKSpilsMassPrecSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKSpilsMassPrecSetupFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKSpilsMassPrecSetupFn)}}{realtype\emph{ t}, void*\emph{ user\_data}}{}
This function preprocesses and/or evaluates mass-matrix-related
data needed by the preconditioner.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{t} -- the current value of the independent variable.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
The value to be returned by the mass matrix preconditioner setup
function is a flag indicating whether it was successful. This value
should be 0 if successful, positive for a recoverable error (in
which case the step will be retried), or negative for an
unrecoverable error (in which case the integration is halted).

\textbf{Notes:}  The operations performed by this function might include
forming a mass matrix and performing an incomplete
factorization of the result.  Although such operations would
typically be performed only once at the beginning of a simulation,
these may be required if the mass matrix can change as a function
of time.

\end{fulllineitems}



\subsection{Vector resize function}
\label{c_interface/User_supplied:cinterface-vecresizefn}\label{c_interface/User_supplied:vector-resize-function}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when using spatial adaptivity in a
PDE simulation), the ARKode integrator may be ``resized'' between
integration steps, through calls to the {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}}
function. Typically, when performing adaptive simulations the solution
is stored in a customized user-supplied data structure, to enable
adaptivity without repeated allocation/deallocation of memory.  In
these scenarios, it is recommended that the user supply a customized
vector kernel to interface between SUNDIALS and their problem-specific
data structure.  If this vector kernel includes a function of type
{\hyperref[c_interface/User_supplied:c.ARKVecResizeFn]{\emph{\code{ARKVecResizeFn}}}} to resize a given vector implementation, then
this function may be supplied to {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}} so that all
internal ARKode vectors may be resized, instead of deleting and
re-creating them at each call.  This resize function should have the
following form:
\index{ARKVecResizeFn (C type)}

\begin{fulllineitems}
\phantomsection\label{c_interface/User_supplied:c.ARKVecResizeFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKVecResizeFn)}}{N\_Vector\emph{ y}, N\_Vector\emph{ ytemplate}, void*\emph{ user\_data}}{}
This function resizes the vector \emph{y} to match the dimensions of the
supplied vector, \emph{ytemplate}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{y} -- the vector to resize.

\item {} 
\emph{ytemplate} -- a vector of the desired size.

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{resize\_data} parameter that was passed to {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKVecResizeFn} function should return 0 if it successfully
resizes the vector \emph{y}, and a non-zero value otherwise.

\textbf{Notes:}  If this function is not supplied, then ARKode will
instead destroy the vector \emph{y} and clone a new vector \emph{y} off of
\emph{ytemplate}.

\end{fulllineitems}



\section{Preconditioner modules}
\label{c_interface/Preconditioners::doc}\label{c_interface/Preconditioners:cinterface-preconditionermodules}\label{c_interface/Preconditioners:preconditioner-modules}
The efficiency of Krylov iterative methods for the solution of linear
systems can be greatly enhanced through preconditioning.  For problems
in which the user cannot define a more effective, problem-specific
preconditioner, ARKode provides two internal preconditioner modules:
a banded preconditioner for serial problems (ARKBANDPRE) and a
band-block-diagonal preconditioner  for parallel problems (ARKBBDPRE).


\subsection{A serial banded preconditioner module}
\label{c_interface/Preconditioners:cinterface-bandpre}\label{c_interface/Preconditioners:a-serial-banded-preconditioner-module}
This preconditioner provides a band matrix preconditioner for use with
the ARKSPILS iterative linear solver interface, in a serial setting.
It requires that the problem be set up using either the
NVECTOR\_SERIAL, NVECTOR\_OPENMP or NVECTOR\_PTHREADS module, due to data
access patterns.  It uses difference quotients of the ODE right-hand
side function \(f_I\) to generate a band matrix of bandwidth
\code{ml + mu + 1}, where the number of super-diagonals (\code{mu}, the
upper half-bandwidth) and sub-diagonals (\code{ml}, the lower
half-bandwidth) are specified by the user.  This band matrix is used
to to form a preconditioner the Krylov linear solver.  Although this
matrix is intended to approximate the Jacobian
\(J = \frac{\partial f_I}{\partial y}\), it may be a very crude
approximation, since the true Jacobian may not be banded, or its true
bandwidth may be larger than \code{ml + mu + 1}.  However, as long as the
banded approximation generated for the preconditioner is sufficiently
accurate, it may speed convergence of the Krylov iteration.


\subsubsection{ARKBANDPRE usage}
\label{c_interface/Preconditioners:arkbandpre-usage}
In order to use the ARKBANDPRE module, the user need not define
any additional functions.  In addition to the header files required
for the remainder of the ODE problem (see the section
{\hyperref[c_interface/General:cinterface-headers]{\emph{\DUspan{}{Access to library and header files}}}}), to use the ARKBANDPRE module, the user's
program must include the header file \code{arkode\_bandpre.h} which
declares the needed function prototypes.  The following is a summary
of the usage of this module.  Steps that are unchanged from the
skeleton program presented in {\hyperref[c_interface/Skeleton:cinterface-skeleton]{\emph{\DUspan{}{A skeleton of the user's main program}}}} are
\emph{italicized}.
\begin{enumerate}
\item {} 
\emph{Initialize multi-threaded environment (if appropriate)}

\item {} 
\emph{Set problem dimensions}

\item {} 
\emph{Set vector of initial values}

\item {} 
\emph{Create ARKode object}

\item {} 
\emph{Initialize ARKode solver}

\item {} 
\emph{Specify integration tolerances}

\item {} 
\emph{Set optional inputs}

\item {} 
Create iterative linear solver object

When creating the iterative linear solver object, specify the type
of preconditioning (\code{PREC\_LEFT} or \code{PREC\_RIGHT}) to use.

\item {} 
\emph{Set linear solver optional inputs}

\item {} 
\emph{Attach linear solver module}

\item {} 
Initialize the ARKBANDPRE preconditioner module

Specify the upper and lower half-bandwidths (\code{mu} and \code{ml},
respectively) and call

\code{ier = ARKBandPrecInit(arkode\_mem, N, mu, ml);}

to allocate memory and initialize the internal preconditioner
data.

\item {} 
\emph{Set linear solver interface optional inputs}

Note that the user should not overwrite the preconditioner setup
function or solve function through calls to the ARKSpilsSet*
optional input functions.

\item {} 
\emph{Specify rootfinding problem}

\item {} 
\emph{Advance solution in time}

\item {} 
Get optional outputs

Additional optional outputs associated with ARKBANDPRE are
available by way of the two routines described below,
{\hyperref[c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace]{\emph{\code{ARKBandPrecGetWorkSpace()}}}} and
{\hyperref[c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals]{\emph{\code{ARKBandPrecGetNumRhsEvals()}}}}.

\item {} 
\emph{Free solver memory}

\item {} 
\emph{Deallocate memory for solution vector}

\end{enumerate}

We note that the ARKBANDPRE preconditioner may not be used for
problems involving a non-identity mass matrix, \(M\ne I\).


\subsubsection{ARKBANDPRE user-callable functions}
\label{c_interface/Preconditioners:arkbandpre-user-callable-functions}
The ARKBANDPRE preconditioner module is initialized and attached
by calling the following function:
\index{ARKBandPrecInit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKBandPrecInit}\pysiglinewithargsret{int \bfcode{ARKBandPrecInit}}{void*\emph{ arkode\_mem}, sunindextype\emph{ N}, sunindextype\emph{ mu}, sunindextype\emph{ ml}}{}
Initializes the ARKBANDPRE preconditioner and
allocates required (internal) memory for it.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{N} -- problem dimension (size of ODE system).

\item {} 
\emph{mu} -- upper half-bandwidth of the Jacobian approximation.

\item {} 
\emph{ml} -- lower half-bandwidth of the Jacobian approximation.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if no errors occurred

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the integrator memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value

\item {} 
\emph{ARKSPILS\_MEM\_FAIL} if a memory allocation request failed

\end{itemize}

\end{description}

\textbf{Notes:} The banded approximate Jacobian will have nonzero elements
only in locations \((i,j)\) with \emph{ml} \(\le j-i \le\) \emph{mu}.

\end{fulllineitems}


The following two optional output functions are available for use with
the ARKBANDPRE module:
\index{ARKBandPrecGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace}\pysiglinewithargsret{int \bfcode{ARKBandPrecGetWorkSpace}}{void*\emph{ arkode\_mem}, long int*\emph{ lenrwLS}, long int*\emph{ leniwLS}}{}
Returns the sizes of the ARKBANDPRE real and integer
workspaces.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lenrwLS} -- the number of \code{realtype} values in the
ARKBANDPRE workspace.

\item {} 
\emph{leniwLS} -- the number of integer values in the  ARKBANDPRE workspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if no errors occurred

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the integrator memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_PMEM\_NULL} if the preconditioner memory is \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:} The workspace requirements reported by this routine
correspond only to memory allocated within the ARKBANDPRE module
(the banded matrix approximation, banded \code{SUNLinearSolver}
object, and temporary vectors).

The workspaces referred to here exist in addition to those given by
the corresponding function \code{ARKSpilsGetWorkspace()}.

\end{fulllineitems}

\index{ARKBandPrecGetNumRhsEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals}\pysiglinewithargsret{int \bfcode{ARKBandPrecGetNumRhsEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ nfevalsBP}}{}
Returns the number of calls made to the user-supplied
right-hand side function \(f_I\) for constructing the
finite-difference banded Jacobian approximation used within the
preconditioner setup function.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{nfevalsBP} -- number of calls to \(f_I\)

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if no errors occurred

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the integrator memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_PMEM\_NULL} if the preconditioner memory is \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:}  The counter \emph{nfevalsBP} is distinct from the counter
\emph{nfevalsLS} returned by the corresponding function
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumRhsEvals]{\emph{\code{ARKSpilsGetNumRhsEvals()}}}} and also from \emph{nfi\_evals} returned by
{\hyperref[c_interface/User_callable:c.ARKodeGetNumRhsEvals]{\emph{\code{ARKodeGetNumRhsEvals()}}}}.  The total number of right-hand
side function evaluations is the sum of all three of these
counters, plus the \emph{nfe\_evals} counter for \(f_E\) calls
returned by {\hyperref[c_interface/User_callable:c.ARKodeGetNumRhsEvals]{\emph{\code{ARKodeGetNumRhsEvals()}}}}.

\end{fulllineitems}



\subsection{A parallel band-block-diagonal preconditioner module}
\label{c_interface/Preconditioners:cinterface-bbdpre}\label{c_interface/Preconditioners:a-parallel-band-block-diagonal-preconditioner-module}
A principal reason for using a parallel ODE solver (such as ARKode)
lies in the solution of partial differential equations
(PDEs). Moreover, Krylov iterative methods are used on many such
problems due to the nature of the underlying linear system of
equations that needs to solved at each time step.  For many PDEs, the
linear algebraic system is large, sparse and structured.  However, if
a Krylov iterative method is to be effective in this setting, then a
nontrivial preconditioner is required.  Otherwise, the rate of
convergence of the Krylov iterative method is usually slow, and
degrades as the PDE mesh is refined.  Typically, an effective
preconditioner must be problem-specific.

However, we have developed one type of preconditioner that treats a
rather broad class of PDE-based problems.  It has been successfully
used with CVODE for several realistic, large-scale problems \phantomsection\label{c_interface/Preconditioners:id1}{\hyperref[References:ht1998]{\emph{{[}HT1998{]}}}}
and is included in a software module within the ARKode package.  This
module works with the parallel vector module NVECTOR\_PARALLEL and is
usable with any of the Krylov iterative linear solvers through the
ARKSPILS interface. It generates a preconditioner that is a
block-diagonal matrix with each block being a band matrix. The blocks
need not have the same number of super- and sub-diagonals and these
numbers may vary from block to block. This Band-Block-Diagonal
Preconditioner module is called ARKBBDPRE.

One way to envision these preconditioners is to think of the
computational PDE domain as being subdivided into \(Q\)
non-overlapping subdomains, where each subdomain is assigned to one of
the \(Q\) MPI tasks used to solve the ODE system.  The basic idea
is to isolate the preconditioning so that it is local to each process,
and also to use a (possibly cheaper) approximate right-hand side
function for construction of this preconditioning matrix.  This
requires the definition of a new function \(g(t,y) \approx
f_I(t,y)\) that will be used to construct the BBD preconditioner
matrix.  As with the rest of ARKode, we assume here that the ODE
system is written as
\begin{gather}
\begin{split}M\dot{y} = f_E(t,y) + f_I(t,y),\end{split}\notag
\end{gather}
where \(f_I\) corresponds to the ODE components to be treated
implicitly.  The user may set \(g = f_I\), if no less expensive
approximation is desired.

Corresponding to the domain decomposition, there is a decomposition of
the solution vector \(y\) into \(Q\) disjoint blocks
\(y_q\), and a decomposition of \(g\) into blocks
\(g_q\). The block \(g_q\) depends both on \(y_p\) and on
components of blocks \(y_{q'}\) associated with neighboring
subdomains (so-called ghost-cell data).  If we let \(\bar{y}_q\)
denote \(y_q\) augmented with those other components on which
\(g_q\) depends, then we have
\begin{gather}
\begin{split}g(t,y) = \left[ g_1(t,\bar{y}_1), g_2(t,\bar{y}_2), \ldots , g_Q(t,\bar{y}_Q) \right]^T,\end{split}\notag
\end{gather}
and each of the blocks \(g_q(t,\bar{y}_q)\) is decoupled from one another.

The preconditioner associated with this decomposition has the form
\begin{gather}
\begin{split}P = \text{diag}[P_1, P_2, \ldots, P_Q]\end{split}\notag
\end{gather}
where
\begin{gather}
\begin{split}P_q \approx M - \gamma J_q\end{split}\notag
\end{gather}
and where \(J_q\) is a difference quotient approximation to
\(\frac{\partial g_q}{\partial \bar{y}_q}\).  This matrix is taken
to be banded, with upper and lower half-bandwidths \emph{mudq} and
\emph{mldq} defined as the number of non-zero diagonals above and below
the main diagonal, respectively.  The difference quotient
approximation is computed using \emph{mudq} + \emph{mldq} + 2 evaluations of
\(g_m\), but only a matrix of bandwidth \emph{mukeep} + \emph{mlkeep} + 1 is
retained. Neither pair of parameters need be the true half-bandwidths
of the Jacobian of the local block of \(g\), if smaller values
provide a more efficient preconditioner. The solution of the complete
linear system
\begin{gather}
\begin{split}Px = b\end{split}\notag
\end{gather}
reduces to solving each of the distinct equations
\begin{gather}
\begin{split}P_q x_q = b_q, \quad q=1,\ldots,Q,\end{split}\notag
\end{gather}
and this is done by banded LU factorization of \(P_q\) followed by
a banded backsolve.

Similar block-diagonal preconditioners could be considered with
different treatments of the blocks \(P_q\).  For example,
incomplete LU factorization or an iterative method could be used
instead of banded LU factorization.


\subsubsection{ARKBBDPRE user-supplied functions}
\label{c_interface/Preconditioners:arkbbdpre-user-supplied-functions}
The ARKBBDPRE module calls two user-provided functions to construct
\(P\): a required function \emph{gloc} (of type {\hyperref[c_interface/Preconditioners:c.ARKLocalFn]{\emph{\code{ARKLocalFn()}}}})
which approximates the right-hand side function \(g(t,y) \approx
f_I(t,y)\) and which is computed locally, and an optional function
\emph{cfn} (of type {\hyperref[c_interface/Preconditioners:c.ARKCommFn]{\emph{\code{ARKCommFn()}}}}) which performs all interprocess
communication necessary to evaluate the approximate right-hand side
\(g\). These are in addition to the user-supplied right-hand side
function \(f_I\). Both functions take as input the same pointer
\emph{user\_data} that is passed by the user to
{\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}} and that was passed to the user's
function \(f_I\). The user is responsible for providing space
(presumably within \emph{user\_data}) for components of \(y\) that are
communicated between processes by \emph{cfn}, and that are then used by
\emph{gloc}, which should not do any communication.
\index{ARKLocalFn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKLocalFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKLocalFn)}}{sunindextype\emph{ Nlocal}, realtype\emph{ t}, N\_Vector\emph{ y}, N\_Vector\emph{ glocal}, void*\emph{ user\_data}}{}
This \emph{gloc} function computes \(g(t,y)\).  It
fills the vector \emph{glocal} as a function of \emph{t} and \emph{y}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{Nlocal} -- the local vector length

\item {} 
\emph{t} -- the value of the independent variable

\item {} 
\emph{y} -- the value of the dependent variable vector on this process

\item {} 
\emph{glocal} -- the output vector of \(g(t,y)\) on this process

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKLocalFn} should return 0 if successful, a positive value if
a recoverable error occurred (in which case ARKode will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} will return
\emph{ARK\_LSETUP\_FAIL}).

\textbf{Notes:}  This function should assume that all interprocess
communication of data needed to calculate \emph{glocal} has already been
done, and that this data is accessible within user data.

The case where \(g\) is mathematically identical to \(f_I\)
is allowed.

\end{fulllineitems}

\index{ARKCommFn (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKCommFn}\pysiglinewithargsret{typedef int \bfcode{(*ARKCommFn)}}{sunindextype\emph{ Nlocal}, realtype\emph{ t}, N\_Vector\emph{ y}, void*\emph{ user\_data}}{}
This \emph{cfn} function performs all interprocess
communication necessary for the executation of the \emph{gloc} function
above, using the input vector \emph{y}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{Nlocal} -- the local vector length

\item {} 
\emph{t} -- the value of the independent variable

\item {} 
\emph{y} -- the value of the dependent variable vector on this process

\item {} 
\emph{user\_data} -- a pointer to user data, the same as the
\emph{user\_data} parameter passed to {\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}.

\end{itemize}

\end{description}

\textbf{Return value:}
An \emph{ARKCommFn} should return 0 if successful, a positive value if a
recoverable error occurred (in which case ARKode will attempt to
correct), or a negative value if it failed unrecoverably (in which
case the integration is halted and {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} will return
\emph{ARK\_LSETUP\_FAIL}).

\textbf{Notes:}  The \emph{cfn} function is expected to save communicated data in
space defined within the data structure \emph{user\_data}.

Each call to the \emph{cfn} function is preceded by a call to the
right-hand side function \(f_I\) with the same \((t,y)\)
arguments. Thus, \emph{cfn} can omit any communication done by
\(f_I\) if relevant to the evaluation of \emph{glocal}. If all
necessary communication was done in \(f_I\), then \emph{cfn} =
\code{NULL} can be passed in the call to {\hyperref[c_interface/Preconditioners:c.ARKBBDPrecInit]{\emph{\code{ARKBBDPrecInit()}}}}
(see below).

\end{fulllineitems}



\subsubsection{ARKBBDPRE usage}
\label{c_interface/Preconditioners:arkbbdpre-usage}
In addition to the header files required for the integration of the
ODE problem (see the section {\hyperref[c_interface/General:cinterface-headers]{\emph{\DUspan{}{Access to library and header files}}}}), to use the
ARKBBDPRE module, the user's program must include the header file
\code{arkode\_bbdpre.h} which declares the needed function prototypes.

The following is a summary of the proper usage of this module. Steps
that are unchanged from the skeleton program presented in
{\hyperref[c_interface/Skeleton:cinterface-skeleton]{\emph{\DUspan{}{A skeleton of the user's main program}}}} are \emph{italicized}.
\begin{enumerate}
\item {} 
\emph{Initialize MPI}

\item {} 
\emph{Set problem dimensions}

\item {} 
\emph{Set vector of initial values}

\item {} 
\emph{Create ARKode object}

\item {} 
\emph{Initialize ARKode solver}

\item {} 
\emph{Specify integration tolerances}

\item {} 
\emph{Set optional inputs}

\item {} 
Create iterative linear solver object

When creating the iterative linear solver object, specify the type
of preconditioning (\code{PREC\_LEFT} or \code{PREC\_RIGHT}) to use.

\item {} 
Set linear solver optional inputs

\item {} 
\emph{Attach linear solver module}

\item {} 
Initialize the ARKBBDPRE preconditioner module

Specify the upper and lower half-bandwidths for computation
\code{mudq} and \code{mldq}, the upper and lower half-bandwidths for
storage \code{mukeep} and \code{mlkeep}, and call

\code{ier = ARKBBDPrecInit(arkode\_mem, Nlocal, mudq, mldq, mukeep, mlkeep, dqrely, gloc, cfn);}

to allocate memory and initialize the internal preconditioner
data. The last two arguments of {\hyperref[c_interface/Preconditioners:c.ARKBBDPrecInit]{\emph{\code{ARKBBDPrecInit()}}}} are the
two user-supplied functions of type {\hyperref[c_interface/Preconditioners:c.ARKLocalFn]{\emph{\code{ARKLocalFn()}}}} and
{\hyperref[c_interface/Preconditioners:c.ARKCommFn]{\emph{\code{ARKCommFn()}}}} described above, respectivelyl.

\item {} 
\emph{Set the linear solver interface optional inputs}

Note that the user should not overwrite the preconditioner setup
function or solve function through calls to ARKSPILS optional
input functions.

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{10}
\item {} 
\emph{Specify rootfinding problem}

\item {} 
\emph{Advance solution in time}

\item {} 
\emph{Get optional outputs}

Additional optional outputs associated with ARKBBDPRE are
available through the routines
{\hyperref[c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace]{\emph{\code{ARKBBDPrecGetWorkSpace()}}}} and
{\hyperref[c_interface/Preconditioners:c.ARKBBDPrecGetNumGfnEvals]{\emph{\code{ARKBBDPrecGetNumGfnEvals()}}}}.

\item {} 
\emph{Free solver memory}

\item {} 
\emph{Deallocate memory for solution vector}

\item {} 
\emph{Finalize MPI}

\end{enumerate}

We note that the ARKBBDPRE preconditioner may not be used
for problems involving a non-identity mass matrix, \(M\ne I\).


\subsubsection{ARKBBDPRE user-callable functions}
\label{c_interface/Preconditioners:arkbbdpre-user-callable-functions}
The ARKBBDPRE preconditioner module is initialized (or re-initialized)
and attached to the integrator by calling the following functions:
\index{ARKBBDPrecInit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKBBDPrecInit}\pysiglinewithargsret{int \bfcode{ARKBBDPrecInit}}{void*\emph{ arkode\_mem}, sunindextype\emph{ Nlocal}, sunindextype\emph{ mudq}, sunindextype\emph{ mldq}, sunindextype\emph{ mukeep}, sunindextype\emph{ mlkeep}, realtype\emph{ dqrely}, {\hyperref[c_interface/Preconditioners:c.ARKLocalFn]{\emph{ARKLocalFn}}}\emph{ gloc}, {\hyperref[c_interface/Preconditioners:c.ARKCommFn]{\emph{ARKCommFn}}}\emph{ cfn}}{}
Initializes and allocates (internal) memory for the
ARKBBDPRE preconditioner.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{Nlocal} -- local vector length.

\item {} 
\emph{mudq} -- upper half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\emph{mldq} -- lower half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\emph{mukeep} -- upper half-bandwidth of the retained banded
approximate Jacobian block.

\item {} 
\emph{mlkeep} -- lower half-bandwidth of the retained banded
approximate Jacobian block.

\item {} 
\emph{dqrely} -- the relative increment in components of \emph{y} used in
the difference quotient approximations.  The default is \emph{dqrely}
= \(\sqrt{\text{unit roundoff}}\), which can be specified by
passing \emph{dqrely} = 0.0.

\item {} 
\emph{gloc} -- the name of the C function (of type {\hyperref[c_interface/Preconditioners:c.ARKLocalFn]{\emph{\code{ARKLocalFn()}}}})
which computes the approximation \(g(t,y) \approx f_I(t,y)\).

\item {} 
\emph{cfn} -- the name of the C function (of type {\hyperref[c_interface/Preconditioners:c.ARKCommFn]{\emph{\code{ARKCommFn()}}}}) which
performs all interprocess communication required for the
computation of \(g(t,y)\).

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if no errors occurred

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the integrator memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_ILL\_INPUT} if an input has an illegal value

\item {} 
\emph{ARKSPILS\_MEM\_FAIL} if a memory allocation request failed

\end{itemize}

\end{description}

\textbf{Notes:}  If one of the half-bandwidths \emph{mudq} or \emph{mldq} to be used
in the difference quotient calculation of the approximate Jacobian is
negative or exceeds the value \emph{Nlocal}-1, it is replaced by 0 or
\emph{Nlocal}-1 accordingly.

The half-bandwidths \emph{mudq} and \emph{mldq} need not be the true
half-bandwidths of the Jacobian of the local block of \(g\)
when smaller values may provide a greater efficiency.

Also, the half-bandwidths \emph{mukeep} and \emph{mlkeep} of the retained
banded approximate Jacobian block may be even smaller than
\emph{mudq} and \emph{mldq}, to reduce storage and computational costs
further.

For all four half-bandwidths, the values need not be the same on
every processor.

\end{fulllineitems}


The ARKBBDPRE module also provides a reinitialization function to
allow solving a sequence of problems of the same size, with the same
linear solver choice, provided there is no change in \emph{Nlocal},
\emph{mukeep}, or \emph{mlkeep}. After solving one problem, and after
calling {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}} to re-initialize ARKode for a
subsequent problem, a call to {\hyperref[c_interface/Preconditioners:c.ARKBBDPrecReInit]{\emph{\code{ARKBBDPrecReInit()}}}} can be made
to change any of the following: the half-bandwidths \emph{mudq} and
\emph{mldq} used in the difference-quotient Jacobian approximations, the
relative increment \emph{dqrely}, or one of the user-supplied functions
\emph{gloc} and \emph{cfn}. If there is a change in any of the linear solver
inputs, an additional call to the \code{Set'{'} routines provided by the
{}`{}`SUNLinearSolver} module, and/or one or more of the
corresponding \code{ARKSpilsSet***} functions, must also be made (in
the proper order).
\index{ARKBBDPrecReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKBBDPrecReInit}\pysiglinewithargsret{int \bfcode{ARKBBDPrecReInit}}{void*\emph{ arkode\_mem}, sunindextype\emph{ mudq}, sunindextype\emph{ mldq}, realtype\emph{ dqrely}}{}
Re-initializes the ARKBBDPRE preconditioner module.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{mudq} -- upper half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\emph{mldq} -- lower half-bandwidth to be used in the difference
quotient Jacobian approximation.

\item {} 
\emph{dqrely} -- the relative increment in components of \emph{y} used in
the difference quotient approximations.  The default is \emph{dqrely}
= \(\sqrt{\text{unit roundoff}}\), which can be specified by
passing \emph{dqrely} = 0.0.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if no errors occurred

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the integrator memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_PMEM\_NULL} if the preconditioner memory is \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:}  If one of the half-bandwidths \emph{mudq} or \emph{mldq} is
negative or exceeds the value \emph{Nlocal}-1, it is replaced by 0 or
\emph{Nlocal}-1 accordingly.

\end{fulllineitems}


The following two optional output functions are available for use with
the ARKBBDPRE module:
\index{ARKBBDPrecGetWorkSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace}\pysiglinewithargsret{int \bfcode{ARKBBDPrecGetWorkSpace}}{void*\emph{ arkode\_mem}, long int*\emph{ lenrwBBDP}, long int*\emph{ leniwBBDP}}{}
Returns the processor-local ARKBBDPRE real and
integer workspace sizes.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{lenrwBBDP} -- the number of \code{realtype} values in the
ARKBBDPRE workspace.

\item {} 
\emph{leniwBBDP} -- the number of integer values in the  ARKBBDPRE workspace.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if no errors occurred

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the integrator memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_PMEM\_NULL} if the preconditioner memory is \code{NULL}

\end{itemize}

\end{description}

\textbf{Notes:}  The workspace requirements reported by this routine
correspond only to memory allocated within the ARKBBDPRE module
(the banded matrix approximation, banded \code{SUNLinearSolver}
object, temporary vectors). These values are local to each process.

The workspaces referred to here exist in addition to those given by
the corresponding function {\hyperref[c_interface/User_callable:c.ARKSpilsGetWorkSpace]{\emph{\code{ARKSpilsGetWorkSpace()}}}}.

\end{fulllineitems}

\index{ARKBBDPrecGetNumGfnEvals (C function)}

\begin{fulllineitems}
\phantomsection\label{c_interface/Preconditioners:c.ARKBBDPrecGetNumGfnEvals}\pysiglinewithargsret{int \bfcode{ARKBBDPrecGetNumGfnEvals}}{void*\emph{ arkode\_mem}, long int*\emph{ ngevalsBBDP}}{}
Returns the number of calls made to the user-supplied
\emph{gloc} function (of type {\hyperref[c_interface/Preconditioners:c.ARKLocalFn]{\emph{\code{ARKLocalFn()}}}}) due to the finite
difference approximation of the Jacobian blocks used within the
preconditioner setup function.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{arkode\_mem} -- pointer to the ARKode memory block.

\item {} 
\emph{ngevalsBBDP} -- the number of calls made to the user-supplied
\emph{gloc} function.

\end{itemize}

\item[{\textbf{Return value:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ARKSPILS\_SUCCESS} if no errors occurred

\item {} 
\emph{ARKSPILS\_MEM\_NULL} if the integrator memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_LMEM\_NULL} if the linear solver memory is \code{NULL}

\item {} 
\emph{ARKSPILS\_PMEM\_NULL} if the preconditioner memory is \code{NULL}

\end{itemize}

\end{description}

\end{fulllineitems}


In addition to the \emph{ngevalsBBDP} \emph{gloc} evaluations, the costs
associated with ARKBBDPRE also include \emph{nlinsetups} LU
factorizations, \emph{nlinsetups} calls to \emph{cfn}, \emph{npsolves} banded
backsolve calls, and \emph{nfevalsLS} right-hand side function
evaluations, where \emph{nlinsetups} is an optional ARKode output and
\emph{npsolves} and \emph{nfevalsLS} are linear solver optional outputs (see
the table {\hyperref[c_interface/User_callable:cinterface-arkspilsoutputs]{\emph{\DUspan{}{Iterative linear solver interface optional output functions}}}}).


\chapter{FARKODE, an Interface Module for FORTRAN Applications}
\label{f_interface/index:farkode-an-interface-module-for-fortran-applications}\label{f_interface/index:fortraninterface}\label{f_interface/index::doc}
The FARKODE interface module is a package of C functions which
support the use of the ARKODE solver for the solution of ODE
systems
\begin{gather}
\begin{split}M \dot{y} = f_E(t,y) + f_I(t,y),\end{split}\notag
\end{gather}
in a mixed Fortran/C setting.  While ARKODE is written in C, it is
assumed here that the user's calling program and user-supplied
problem-defining routines are written in Fortran. This package
provides the necessary interfaces to ARKODE for all supplied serial
and parallel NVECTOR implementations.


\section{Important note on portability}
\label{f_interface/index:important-note-on-portability}\label{f_interface/index:finterface-portability}
In this package, the names of the interface functions, and the names
of the Fortran user routines called by them, appear as dummy names
which are mapped to actual values by a series of definitions in the
header files.  By default, those mapping definitions depend in turn
on the C macro \code{F77\_FUNC} defined in the header file
\code{sundials\_config.h}.  The mapping defined by \code{F77\_FUNC} in turn
transforms the C interface names to match the name-mangling approach
used by the supplied Fortran compiler.

By ``name-mangling'', we mean that due to the case-independent nature of
the Fortran language, Fortran compilers convert all subroutine and
object names to use either all lower-case or all upper-case
characters, and append either zero, one or two underscores as a prefix
or suffix the the name.  For example, the Fortran subroutine
\code{MyFunction()} will be changed to one of \code{myfunction},
\code{MYFUNCTION}, \code{myfunction\_\_}, \code{MYFUNCTION\_}, and so on,
depending on the Fortran compiler used.

SUNDIALS determines this name-mangling scheme at configuration time
(see {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}}).


\section{Fortran Data Types}
\label{f_interface/index:fortran-data-types}\label{f_interface/index:finterface-datatypes}
Throughout this documentation, we will refer to data types according
to their usage in C.  The equivalent types to these may vary,
depending on your computer architecture and on how SUNDIALS was
compiled (see {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}}).  A Fortran user should first
determine the equivalent types for their architecture and compiler,
and then take care that all arguments passed through this Fortran/C
interface are declared of the appropriate type.

\textbf{Integers}: SUNDIALS uses \code{int}, \code{long int} and \code{sunindextype}
types.  As discussed in {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}}, at compilation SUNDIALS
allows the configuration of the `index' type, that accepts values of
32-bit signed and 64-bit signed. This choice dictates the size of a
SUNDIALS \code{sunindextype} variable.
\begin{itemize}
\item {} 
\code{int} -- equivalent to an \code{INTEGER} or \code{INTEGER*4} in Fortran

\item {} 
\code{long int} -- this will depend on the computer architecture:
\begin{itemize}
\item {} 
32-bit architecture -- equivalent to an \code{INTEGER} or \code{INTEGER*4} in Fortran

\item {} 
64-bit architecture -- equivalent to an \code{INTEGER*8} in Fortran

\end{itemize}

\item {} 
\code{sunindextype} -- this will depend on the SUNDIALS configuration:
\begin{itemize}
\item {} 
32-bit -- equivalent to an \code{INTEGER} or \code{INTEGER*4} in Fortran

\item {} 
64-bit -- equivalent to an \code{INTEGER*8} in Fortran

\end{itemize}

\end{itemize}

\textbf{Real numbers}:  As discussed in {\hyperref[Install:installation]{\emph{\DUspan{}{ARKode Installation Procedure}}}}, at compilation
SUNDIALS allows the configuration option  \code{-{-}with-precision},
that accepts values of \code{single}, \code{double} or \code{extended} (the
default is \code{double}).  This choice dictates the size of a
\code{realtype} variable.  The corresponding Fortran types for these
\code{realtype} sizes are:
\begin{itemize}
\item {} 
\code{single} -- equivalent to a \code{REAL} or \code{REAL*4} in Fortran

\item {} 
\code{double} -- equivalent to a \code{DOUBLE PRECISION} or \code{REAL*8} in Fortran

\item {} 
\code{extended} -- equivalent to a \code{REAL*16} in Fortran

\end{itemize}

Details on the Fortran interface to ARKode are provided in the
following sub-sections:


\subsection{FARKODE routines}
\label{f_interface/Routines:finterface-routines}\label{f_interface/Routines::doc}\label{f_interface/Routines:farkode-routines}
In this section, we list the full set of user-callable functions
comprising the FARKODE solver interface.  For each function, we list
the corresponding ARKode functions, to provide a mapping between the
two solver interfaces.  Further documentation on each FARKODE function
is provided in the following sections, {\hyperref[f_interface/Usage:finterface-usage]{\emph{\DUspan{}{Usage of the FARKODE interface module}}}},
{\hyperref[f_interface/Optional_output:finterface-optionaloutputs]{\emph{\DUspan{}{FARKODE optional output}}}}, {\hyperref[f_interface/Rootfinding:finterface-rootfinding]{\emph{\DUspan{}{Usage of the FARKROOT interface to rootfinding}}}} and
{\hyperref[f_interface/Preconditioning:finterface-preconditioning]{\emph{\DUspan{}{Usage of the FARKODE interface to built-in preconditioners}}}}.  Additionally, all Fortran and C
functions below are hyperlinked to their definitions in the
documentation, for simplified access.


\subsubsection{Interface to the NVECTOR modules}
\label{f_interface/Routines:interface-to-the-nvector-modules}\begin{itemize}
\item {} 
\code{FNVINITS()} (defined by NVECTOR\_SERIAL) interfaces to
{\hyperref[nvectors/NVector_Serial:c.N_VNewEmpty_Serial]{\emph{\code{N\_VNewEmpty\_Serial()}}}}.

\item {} 
\code{FNVINITP()} (defined by NVECTOR\_PARALLEL) interfaces to
{\hyperref[nvectors/NVector_Parallel:c.N_VNewEmpty_Parallel]{\emph{\code{N\_VNewEmpty\_Parallel()}}}}.

\item {} 
\code{FNVINITOMP()} (defined by NVECTOR\_OPENMP) interfaces to
{\hyperref[nvectors/NVector_OpenMP:c.N_VNewEmpty_OpenMP]{\emph{\code{N\_VNewEmpty\_OpenMP()}}}}.

\item {} 
\code{FNVINITPTS()} (defined by NVECTOR\_PTHREADS) interfaces to
{\hyperref[nvectors/NVector_Pthreads:c.N_VNewEmpty_Pthreads]{\emph{\code{N\_VNewEmpty\_Pthreads()}}}}.

\item {} 
\code{FNVINITPH()} (defined by NVECTOR\_PARHYP) interfaces to
{\hyperref[nvectors/NVector_ParHyp:c.N_VNewEmpty_ParHyp]{\emph{\code{N\_VNewEmpty\_ParHyp()}}}}.

\end{itemize}


\subsubsection{Interface to the SUNMATRIX modules}
\label{f_interface/Routines:interface-to-the-sunmatrix-modules}\begin{itemize}
\item {} 
\code{FSUNBANDMATINIT()} (defined by SUNMATRIX\_BAND) interfaces
to {\hyperref[sunmatrix/SUNMatrix_Band:c.SUNBandMatrix]{\emph{\code{SUNBandMatrix()}}}}.

\item {} 
\code{FSUNDENSEMATINIT()} (defined by SUNMATRIX\_DENSE) interfaces
to {\hyperref[sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix]{\emph{\code{SUNDenseMatrix()}}}}.

\item {} 
\code{FSUNSPARSEMATINIT()} (defined by SUNMATRIX\_SPARSE) interfaces
to {\hyperref[sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix]{\emph{\code{SUNSparseMatrix()}}}}.

\end{itemize}


\subsubsection{Interface to the SUNLINSOL modules}
\label{f_interface/Routines:interface-to-the-sunlinsol-modules}\begin{itemize}
\item {} 
\code{FSUNBANDLINSOLINIT()} (defined by SUNLINSOL\_BAND)
interfaces to {\hyperref[sunlinsol/SUNLinSol_Band:c.SUNBandLinearSolver]{\emph{\code{SUNBandLinearSolver()}}}}.

\item {} 
\code{FSUNDENSELINSOLINIT()} (defined by SUNLINSOL\_DENSE)
interfaces to {\hyperref[sunlinsol/SUNLinSol_Dense:c.SUNDenseLinearSolver]{\emph{\code{SUNDenseLinearSolver()}}}}.

\item {} 
\code{FSUNKLUINIT()} (defined by SUNLINSOL\_KLU)
interfaces to {\hyperref[sunlinsol/SUNLinSol_KLU:c.SUNKLU]{\emph{\code{SUNKLU()}}}}.

\item {} 
\code{FSUNKLUREINIT()} (defined by SUNLINSOL\_KLU)
interfaces to \code{SUNKLUReinit()}.

\item {} 
\code{FSUNLAPACKBANDINIT()} (defined by SUNLINSOL\_LAPACKBAND)
interfaces to {\hyperref[sunlinsol/SUNLinSol_LapackBand:c.SUNLapackBand]{\emph{\code{SUNLapackBand()}}}}.

\item {} 
\code{FSUNLAPACKDENSEINIT()} (defined by SUNLINSOL\_LAPACKDENSE)
interfaces to {\hyperref[sunlinsol/SUNLinSol_LapackDense:c.SUNLapackDense]{\emph{\code{SUNLapackDense()}}}}.

\item {} 
\code{FSUNPCGINIT()} (defined by SUNLINSOL\_PCG)
interfaces to {\hyperref[sunlinsol/SUNLinSol_PCG:c.SUNPCG]{\emph{\code{SUNPCG()}}}}.

\item {} 
\code{FSUNSPBCGSINIT()} (defined by SUNLINSOL\_SPBCGS)
interfaces to {\hyperref[sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGS]{\emph{\code{SUNSPBCGS()}}}}.

\item {} 
\code{FSUNSPFGMRINIT()} (defined by SUNLINSOL\_SPFGMR)
interfaces to {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMR]{\emph{\code{SUNSPFGMR()}}}}.

\item {} 
\code{FSUNSPGMRINIT()} (defined by SUNLINSOL\_SPGMR)
interfaces to {\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMR]{\emph{\code{SUNSPGMR()}}}}.

\item {} 
\code{FSUNSPTFQMRINIT()} (defined by SUNLINSOL\_SPTFQMR)
interfaces to {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMR]{\emph{\code{SUNSPTFQMR()}}}}.

\item {} 
\code{FSUNSUPERLUMTINIT()} (defined by SUNLINSOL\_SUPERLUMT)
interfaces to {\hyperref[sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMT]{\emph{\code{SUNSuperLUMT()}}}}.

\end{itemize}


\subsubsection{Interface to the main ARKODE module}
\label{f_interface/Routines:interface-to-the-main-arkode-module}\begin{itemize}
\item {} 
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}, and {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}, as well
as one of {\hyperref[c_interface/User_callable:c.ARKodeSStolerances]{\emph{\code{ARKodeSStolerances()}}}} or {\hyperref[c_interface/User_callable:c.ARKodeSVtolerances]{\emph{\code{ARKodeSVtolerances()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKREINIT]{\emph{\code{FARKREINIT()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeReInit]{\emph{\code{ARKodeReInit()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKRESIZE]{\emph{\code{FARKRESIZE()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} and {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} interface to the
ARKodeSet* functions (see {\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}}).

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKEWTSET]{\emph{\code{FARKEWTSET()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeWFtolerances]{\emph{\code{ARKodeWFtolerances()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKADAPTSET]{\emph{\code{FARKADAPTSET()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityFn]{\emph{\code{ARKodeSetAdaptivityFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKEXPSTABSET]{\emph{\code{FARKEXPSTABSET()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeSetStabilityFn]{\emph{\code{ARKodeSetStabilityFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSETERKTABLE]{\emph{\code{FARKSETERKTABLE()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeSetERKTable]{\emph{\code{ARKodeSetERKTable()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSETIRKTABLE]{\emph{\code{FARKSETIRKTABLE()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTable]{\emph{\code{ARKodeSetIRKTable()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSETARKTABLES]{\emph{\code{FARKSETARKTABLES()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeSetARKTables]{\emph{\code{ARKodeSetARKTables()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSETRESTOLERANCE]{\emph{\code{FARKSETRESTOLERANCE()}}}} interfaces to either
{\hyperref[c_interface/User_callable:c.ARKodeResStolerance]{\emph{\code{ARKodeResStolerance()}}}} and {\hyperref[c_interface/User_callable:c.ARKodeResVtolerance]{\emph{\code{ARKodeResVtolerance()}}}}

\end{itemize}
\begin{itemize}
\item {} 
{\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}, the
ARKodeGet* functions (see {\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}}),
and to the optional output functions for the selected linear
solver module (see {\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}}).

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKDKY]{\emph{\code{FARKDKY()}}}} interfaces to the interpolated output function
{\hyperref[c_interface/User_callable:c.ARKodeGetDky]{\emph{\code{ARKodeGetDky()}}}}.

\item {} 
{\hyperref[f_interface/Optional_output:f/_/FARKGETERRWEIGHTS]{\emph{\code{FARKGETERRWEIGHTS()}}}} interfaces to
{\hyperref[c_interface/User_callable:c.ARKodeGetErrWeights]{\emph{\code{ARKodeGetErrWeights()}}}}.

\item {} 
{\hyperref[f_interface/Optional_output:f/_/FARKGETESTLOCALERR]{\emph{\code{FARKGETESTLOCALERR()}}}} interfaces to
{\hyperref[c_interface/User_callable:c.ARKodeGetEstLocalErrors]{\emph{\code{ARKodeGetEstLocalErrors()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKFREE]{\emph{\code{FARKFREE()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeFree]{\emph{\code{ARKodeFree()}}}}.

\end{itemize}


\subsubsection{Interface to the system linear solver interfaces}
\label{f_interface/Routines:interface-to-the-system-linear-solver-interfaces}\begin{itemize}
\item {} 
{\hyperref[f_interface/Usage:f/_/FARKDLSINIT]{\emph{\code{FARKDLSINIT()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetLinearSolver]{\emph{\code{ARKDlsSetLinearSolver()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKDENSESETJAC]{\emph{\code{FARKDENSESETJAC()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKBANDSETJAC]{\emph{\code{FARKBANDSETJAC()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPARSESETJAC]{\emph{\code{FARKSPARSESETJAC()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}}

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETEPSLIN]{\emph{\code{FARKSPILSSETEPSLIN()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKSpilsSetEpsLin]{\emph{\code{ARKSpilsSetEpsLin()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETJAC]{\emph{\code{FARKSPILSSETJAC()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKSpilsSetJacTimes]{\emph{\code{ARKSpilsSetJacTimes()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETPREC]{\emph{\code{FARKSPILSSETPREC()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKSpilsSetPreconditioner]{\emph{\code{ARKSpilsSetPreconditioner()}}}}.

\end{itemize}


\subsubsection{Interface to the mass matrix linear solver interfaces}
\label{f_interface/Routines:interface-to-the-mass-matrix-linear-solver-interfaces}\begin{itemize}
\item {} 
{\hyperref[f_interface/Usage:f/_/FARKDLSMASSINIT]{\emph{\code{FARKDLSMASSINIT()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetMassLinearSolver]{\emph{\code{ARKDlsSetMassLinearSolver()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKDENSESETMASS]{\emph{\code{FARKDENSESETMASS()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKBANDSETMASS]{\emph{\code{FARKBANDSETMASS()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPARSESETMASS]{\emph{\code{FARKSPARSESETMASS()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSMASSINIT]{\emph{\code{FARKSPILSMASSINIT()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASSEPSLIN]{\emph{\code{FARKSPILSSETMASSEPSLIN()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassEpsLin]{\emph{\code{ARKSpilsSetMassEpsLin()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASS]{\emph{\code{FARKSPILSSETMASS()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassTimes]{\emph{\code{ARKSpilsSetMassTimes()}}}}.

\item {} 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASSPREC]{\emph{\code{FARKSPILSSETMASSPREC()}}}} interfaces to
{\hyperref[c_interface/User_callable:c.ARKSpilsSetMassPreconditioner]{\emph{\code{ARKSpilsSetMassPreconditioner()}}}}.

\end{itemize}


\subsubsection{User-supplied routines}
\label{f_interface/Routines:finterface-usersupplied}\label{f_interface/Routines:user-supplied-routines}
As with the native C interface, the FARKode solver interface requires
user-supplied functions to specify the ODE problem to be solved.  In
contrast to the case of direct use of ARKode, and of most Fortran ODE
solvers, the names of all user-supplied routines here are fixed, in
order to maximize portability for the resulting mixed-language program.
As a result, whether using a purely implicit, purely explicit, or
mixed implicit-explicit solver, routines for both \(f_E(t,y)\) and
\(f_I(t,y)\) must be provided by the user (though either of which
may do nothing):

\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
FARKODE routine
(FORTRAN, user-supplied)
} & \textsf{\relax 
ARKode interface
function type
}\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKIFUN]{\emph{\code{FARKIFUN()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKEFUN]{\emph{\code{FARKEFUN()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKRhsFn]{\emph{\code{ARKRhsFn()}}}}
\\
\hline\end{tabulary}


In addition, as with the native C interface a user may provide
additional routines to assist in the solution process.  Each of the
following user-supplied routines is activated by calling the specified
``activation'' routine, with the exception of {\hyperref[f_interface/Usage:f/_/FARKSPJAC]{\emph{\code{FARKSPJAC()}}}}
which is required whenever a sparse matrix solver is used:

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
FARKODE routine
(FORTRAN, user-supplied)
} & \textsf{\relax 
ARKode interface
function type
} & \textsf{\relax 
FARKODE ``activation'' routine
}\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKDJAC]{\emph{\code{FARKDJAC()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKDENSESETJAC]{\emph{\code{FARKDENSESETJAC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKBJAC]{\emph{\code{FARKBJAC()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKBANDSETJAC]{\emph{\code{FARKBANDSETJAC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKSPJAC]{\emph{\code{FARKSPJAC()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPARSESETJAC]{\emph{\code{FARKSPARSESETJAC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKDMASS]{\emph{\code{FARKDMASS()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKDENSESETMASS]{\emph{\code{FARKDENSESETMASS()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKBMASS]{\emph{\code{FARKBMASS()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKBANDSETMASS]{\emph{\code{FARKBANDSETMASS()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKSPMASS]{\emph{\code{FARKSPMASS()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPARSESETMASS]{\emph{\code{FARKSPARSESETMASS()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKPSET]{\emph{\code{FARKPSET()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSetupFn]{\emph{\code{ARKSpilsPrecSetupFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETPREC]{\emph{\code{FARKSPILSSETPREC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSolveFn]{\emph{\code{ARKSpilsPrecSolveFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETPREC]{\emph{\code{FARKSPILSSETPREC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{\code{ARKSpilsJacTimesSetupFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETJAC]{\emph{\code{FARKSPILSSETJAC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{\code{ARKSpilsJacTimesVecFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETJAC]{\emph{\code{FARKSPILSSETJAC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKMASSPSET]{\emph{\code{FARKMASSPSET()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSetupFn]{\emph{\code{ARKSpilsMassPrecSetupFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASSPREC]{\emph{\code{FARKSPILSSETMASSPREC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKMASSPSOL]{\emph{\code{FARKMASSPSOL()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSolveFn]{\emph{\code{ARKSpilsMassPrecSolveFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASSPREC]{\emph{\code{FARKSPILSSETMASSPREC()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKMTSETUP]{\emph{\code{FARKMTSETUP()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesSetupFn]{\emph{\code{ARKSpilsMassTimesSetupFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASS]{\emph{\code{FARKSPILSSETMASS()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKMTIMES]{\emph{\code{FARKMTIMES()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{\code{ARKSpilsMassTimesVecFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASS]{\emph{\code{FARKSPILSSETMASS()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKEWT]{\emph{\code{FARKEWT()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKEwtFn]{\emph{\code{ARKEwtFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKEWTSET]{\emph{\code{FARKEWTSET()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKADAPT]{\emph{\code{FARKADAPT()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKAdaptFn]{\emph{\code{ARKAdaptFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKADAPTSET]{\emph{\code{FARKADAPTSET()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKEXPSTAB]{\emph{\code{FARKEXPSTAB()}}}}
 & 
{\hyperref[c_interface/User_supplied:c.ARKExpStabFn]{\emph{\code{ARKExpStabFn()}}}}
 & 
{\hyperref[f_interface/Usage:f/_/FARKEXPSTABSET]{\emph{\code{FARKEXPSTABSET()}}}}
\\
\hline\end{tabulary}



\subsection{Usage of the FARKODE interface module}
\label{f_interface/Usage:finterface-usage}\label{f_interface/Usage::doc}\label{f_interface/Usage:usage-of-the-farkode-interface-module}
The usage of FARKODE requires calls to a variety of interface
functions, depending on the method options selected, and two or more
user-supplied routines which define the problem to be solved.  These
function calls and user routines are summarized separately below.
Some details are omitted, and the user is referred to the description
of the corresponding C interface ARKode functions for complete
information on the arguments of any given user-callable interface
routine, or of a given user-supplied function called by an interface
function.  The usage of FARKODE for rootfinding and with
preconditioner modules is described in later subsections.


\subsubsection{Right-hand side specification}
\label{f_interface/Usage:right-hand-side-specification}\label{f_interface/Usage:finterface-rhs}
The user must in all cases supply the following Fortran routines:
\index{FARKIFUN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKIFUN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKIFUN}}{\emph{T}, \emph{Y}, \emph{YDOT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Sets the \emph{YDOT} array to \(f_I(t,y)\), the implicit portion of
the right-hand side of the ODE system, as function of the
independent variable \emph{T} \(=t\) and the array of dependent state
variables \emph{Y} \(=y\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y} (\code{realtype}, input) -- array containing state variables.

\item {} 
\emph{YDOT} (\code{realtype}, output) -- array containing state derivatives.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user
data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user
data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \textgreater{}0
recoverable error, \textless{}0 unrecoverable error).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKEFUN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKEFUN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKEFUN}}{\emph{T}, \emph{Y}, \emph{YDOT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Sets the \emph{YDOT} array to \(f_E(t,y)\), the explicit portion of
the right-hand side of the ODE system, as function of the
independent variable \emph{T} \(=t\) and the array of dependent state
variables \emph{Y} \(=y\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y} (\code{realtype}, input) -- array containing state variables.

\item {} 
\emph{YDOT} (\code{realtype}, output) -- array containing state derivatives.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user
data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user
data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \textgreater{}0
recoverable error, \textless{}0 unrecoverable error).

\end{itemize}

\end{description}

\end{fulllineitems}


For purely explicit problems, although the routine
{\hyperref[f_interface/Usage:f/_/FARKIFUN]{\emph{\code{FARKIFUN()}}}} must exist, it will never be called, and may
remain empty.  Similarly, for purely implicit problems,
{\hyperref[f_interface/Usage:f/_/FARKEFUN]{\emph{\code{FARKEFUN()}}}} will never be called and must exist and may
remain empty.


\subsubsection{NVECTOR module initialization}
\label{f_interface/Usage:nvector-module-initialization}\label{f_interface/Usage:finterface-nvector}
If using one of the NVECTOR modules supplied with SUNDIALS, the user
must make a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FNVINITS}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NEQ}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITP}\PYG{p}{(}\PYG{n}{COMM}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NLOCAL}\PYG{p}{,} \PYG{n}{NGLOBAL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITOMP}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NEQ}\PYG{p}{,} \PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITPTS}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NEQ}\PYG{p}{,} \PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FNVINITPH}\PYG{p}{(}\PYG{n}{COMM}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NLOCAL}\PYG{p}{,} \PYG{n}{NGLOBAL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{Verbatim}

in which the specific arguments are as described in the
appropriate section of the Chapter {\hyperref[nvectors/index:nvectors]{\emph{\DUspan{}{Vector Data Structures}}}}.


\subsubsection{SUNMATRIX module initialization}
\label{f_interface/Usage:sunmatrix-module-initialization}\label{f_interface/Usage:finterface-sunmatrix}
In the case of using either an implicit or ImEx method, the solution
of each Runge-Kutta stage may involve the solution of linear systems
related to the Jacobian \(J = \frac{\partial f_I}{\partial y}\) of
the implicit portion of the ODE system.  If using a Newton iteration
with direct SUNLINSOL linear solver module and one of the SUNMATRIX
modules supplied with SUNDIALS, the user must make a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNBANDMATINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{MU}\PYG{p}{,} \PYG{n}{ML}\PYG{p}{,} \PYG{n}{SMU}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNDENSEMATINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPARSEMATINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{NNZ}\PYG{p}{,} \PYG{n}{SPARSETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{Verbatim}

in which the specific arguments are as described in the appropriate
section of the Chapter {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}}.  Note that these matrix
options are usable only in a serial or multi-threaded environment.

As described in the section {\hyperref[Mathematics:mathematics-masssolve]{\emph{\DUspan{}{Mass matrix solver}}}}, in the case
of using a problem with a non-identity mass matrix (no matter whether
the integrator is implicit, explicit or ImEx), linear systems of the
form \(Mx=b\) must be solved, where \(M(t)\) is the possibly
time-dependent system mass matrix.  If these are to be solved with a
direct SUNLINSOL linear solver module and one of the SUNMATRIX modules
supplied with SUNDIALS, the user must make a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNBANDMASSMATINIT}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{MU}\PYG{p}{,} \PYG{n}{ML}\PYG{p}{,} \PYG{n}{SMU}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNDENSEMASSMATINIT}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPARSEMASSMATINIT}\PYG{p}{(}\PYG{n}{M}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{NNZ}\PYG{p}{,} \PYG{n}{SPARSETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{Verbatim}

in which the specific arguments are as described in the appropriate
section of the Chapter {\hyperref[sunmatrix/index:sunmatrix]{\emph{\DUspan{}{Matrix Data Structures}}}}, again noting that these are
only usable in a serial or multi-threaded environment.


\subsubsection{SUNLINSOL module initialization}
\label{f_interface/Usage:sunlinsol-module-initialization}\label{f_interface/Usage:finterface-sunlinsol}
If using a Newton iteration with one of the SUNLINSOL linear
solver modules supplied with SUNDIALS, the user must make a call
of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNBANDLINSOLINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNDENSELINSOLINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNKLUINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNLAPACKBANDINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNLAPACKDENSEINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNPCGINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPBCGSINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPFGMRINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPGMRINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPTFQMRINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSUPERLUMTINIT}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{Verbatim}

in which the specific arguments are as described in the
appropriate section of the Chapter {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.  Note that the
dense, band and sparse solvers are usable only in a serial or
multi-threaded environment.

Once one of these has been initialized, its solver parameters may be
modified using a call to the functions

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNKLUSETORDERING}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSUPERLUMTSETORDERING}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNPCGSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNPCGSETMAXL}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPBCGSSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPBCGSSETMAXL}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPFGMRSETGSTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPFGMRSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPGMRSETGSTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPGMRSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPTFQMRSETPRECTYPE}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNSPTFQMRSETMAXL}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{Verbatim}

where again the call sequences are described in the appropriate
sections of the Chapter {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.

Similarly, in the case of using one of the SUNLINSOL linear solver
modules supplied with SUNDIALS to solve a problem with a non-identity
mass matrix, the user must make a call of the form

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNMASSBANDLINSOLINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSDENSELINSOLINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSKLUINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSLAPACKBANDINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSLAPACKDENSEINIT}\PYG{p}{(}\PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSPCGINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPBCGSINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPFGMRINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPGMRINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPTFQMRINIT}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSUPERLUMTINIT}\PYG{p}{(}\PYG{n}{NUM\PYGZus{}THREADS}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{Verbatim}

in which the specific arguments are as described in the
appropriate section of the Chapter {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.

Once one of these has been initialized, its solver parameters may be
modified using a call to the functions

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{CALL} \PYG{n}{FSUNMASSKLUSETORDERING}\PYG{p}{(}\PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSUPERLUMTSETORDERING}\PYG{p}{(}\PYG{n}{ORD\PYGZus{}CHOICE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSPCGSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSPCGSETMAXL}\PYG{p}{(}\PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPBCGSSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPBCGSSETMAXL}\PYG{p}{(}\PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPFGMRSETGSTYPE}\PYG{p}{(}\PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPFGMRSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPGMRSETGSTYPE}\PYG{p}{(}\PYG{n}{GSTYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPGMRSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPTFQMRSETPRECTYPE}\PYG{p}{(}\PYG{n}{PRETYPE}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\PYG{n}{CALL} \PYG{n}{FSUNMASSSPTFQMRSETMAXL}\PYG{p}{(}\PYG{n}{MAXL}\PYG{p}{,} \PYG{n}{IER}\PYG{p}{)}
\end{Verbatim}

where again the call sequences are described in the appropriate
sections of the Chapter {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.


\subsubsection{Problem specification}
\label{f_interface/Usage:problem-specification}\label{f_interface/Usage:finterface-problem}
To set various problem and solution parameters and allocate internal
memory, the user must call {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.
\index{FARKMALLOC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKMALLOC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKMALLOC}}{\emph{T0}, \emph{Y0}, \emph{IMEX}, \emph{IATOL}, \emph{RTOL}, \emph{ATOL}, \emph{IOUT}, \emph{ROUT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Initializes the Fortran interface to the ARKode solver, providing
interfaces to the C routines {\hyperref[c_interface/User_callable:c.ARKodeCreate]{\emph{\code{ARKodeCreate()}}}},
{\hyperref[c_interface/User_callable:c.ARKodeSetUserData]{\emph{\code{ARKodeSetUserData()}}}}, and {\hyperref[c_interface/User_callable:c.ARKodeInit]{\emph{\code{ARKodeInit()}}}}, as well
as one of {\hyperref[c_interface/User_callable:c.ARKodeSStolerances]{\emph{\code{ARKodeSStolerances()}}}} or
{\hyperref[c_interface/User_callable:c.ARKodeSVtolerances]{\emph{\code{ARKodeSVtolerances()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T0} (\code{realtype}, input) -- initial value of \(t\).

\item {} 
\emph{Y0} (\code{realtype}, input) -- array of initial conditions.

\item {} 
\emph{IMEX} (\code{int}, input) -- flag denoting basic integration
method: 0 = implicit, 1 = explicit, 2 = ImEx.

\item {} 
\emph{IATOL} (\code{int}, input) -- type for absolute tolerance input
\emph{ATOL}: 1 = scalar, 2 = array, 3 = user-supplied function; the
user must subsequently call {\hyperref[f_interface/Usage:f/_/FARKEWTSET]{\emph{\code{FARKEWTSET()}}}} and supply
a routine {\hyperref[f_interface/Usage:f/_/FARKEWT]{\emph{\code{FARKEWT()}}}} to compute the error weight vector.

\item {} 
\emph{RTOL} (\code{realtype}, input) -- scalar relative tolerance.

\item {} 
\emph{ATOL} (\code{realtype}, input) -- scalar or array absolute tolerance.

\item {} 
\emph{IOUT} (\code{long int}, input/output) -- array of length 29 for integer optional outputs.

\item {} 
\emph{ROUT} (\code{realtype}, input/output) -- array of length 6 for real optional outputs.

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- array of user integer data, which will be passed
unmodified to all user-provided routines.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- array with user real data, which will be passed
unmodified to all user-provided routines.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\textbf{Notes:} Modifications to the user data arrays \emph{IPAR} and \emph{RPAR}
inside a user-provided routine will be propagated to all
subsequent calls to such routines. The optional outputs
associated with the main ARKode integrator are listed in
{\hyperref[f_interface/Optional_output:finterface-iouttable]{\emph{\DUspan{}{Table: Optional FARKODE integer outputs}}}} and {\hyperref[f_interface/Optional_output:finterface-routtable]{\emph{\DUspan{}{Table: Optional FARKODE real outputs}}}}, in
the section {\hyperref[f_interface/Optional_output:finterface-optionaloutputs]{\emph{\DUspan{}{FARKODE optional output}}}}.

\end{fulllineitems}


As an alternative to providing tolerances in the call to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}, the user may provide a routine to compute the
error weights used in the WRMS norm evaluations.  If supplied, it must
have the following form:
\index{FARKEWT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKEWT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKEWT}}{\emph{Y}, \emph{EWT}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
It must set the positive components of the error weight
vector \emph{EWT} for the calculation of the WRMS norm of \emph{Y}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{Y} (\code{realtype}, input) -- array containing state variables.

\item {} 
\emph{EWT} (\code{realtype}, output) -- array containing the error weight vector.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing the integer user data that was passed
to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing the real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


If the {\hyperref[f_interface/Usage:f/_/FARKEWT]{\emph{\code{FARKEWT()}}}} routine is provided, then, following the
call to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}, the user must call the function
{\hyperref[f_interface/Usage:f/_/FARKEWTSET]{\emph{\code{FARKEWTSET()}}}}.
\index{FARKEWTSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKEWTSET}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKEWTSET}}{\emph{FLAG}, \emph{IER}}{}
Informs FARKODE to use the user-supplied {\hyperref[f_interface/Usage:f/_/FARKEWT]{\emph{\code{FARKEWT()}}}} function.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- flag, use ``1'' to denoting to use {\hyperref[f_interface/Usage:f/_/FARKEWT]{\emph{\code{FARKEWT()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Setting optional inputs}
\label{f_interface/Usage:setting-optional-inputs}\label{f_interface/Usage:finterface-optionalinputs}
Unlike ARKode's C interface, that provides separate functions for
setting each optional input, FARKODE uses only two functions, that
accept keywords to specify which optional input should be set to the
provided value.  These routines are {\hyperref[f_interface/Usage:f/_/FARKSETIIN]{\emph{\code{FARKSETIIN()}}}} and
{\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}}, and are further described below.
\index{FARKSETIIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETIIN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETIIN}}{\emph{KEY}, \emph{IVAL}, \emph{IER}}{}
Specification routine to pass optional integer inputs
to the {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{KEY} (quoted string, input) -- which optional input
is set (see {\hyperref[f_interface/Usage:finterface-iinoptiontable]{\emph{\DUspan{}{Table: Keys for setting FARKODE integer optional inputs}}}}).

\item {} 
\emph{IVAL} (\code{long int}, input) -- the integer input value to be used.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Table: Keys for setting FARKODE integer optional inputs}
\label{f_interface/Usage:table-keys-for-setting-farkode-integer-optional-inputs}\label{f_interface/Usage:finterface-iinoptiontable}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Key
} & \textsf{\relax 
ARKode routine
}\\
\hline
\code{ORDER}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetOrder]{\emph{\code{ARKodeSetOrder()}}}}
\\
\hline
\code{DENSE\_ORDER}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetDenseOrder]{\emph{\code{ARKodeSetDenseOrder()}}}}
\\
\hline
\code{LINEAR}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetLinear]{\emph{\code{ARKodeSetLinear()}}}}
\\
\hline
\code{NONLINEAR}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinear]{\emph{\code{ARKodeSetNonlinear()}}}}
\\
\hline
\code{FIXEDPOINT}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedPoint]{\emph{\code{ARKodeSetFixedPoint()}}}}
\\
\hline
\code{NEWTON}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNewton]{\emph{\code{ARKodeSetNewton()}}}}
\\
\hline
\code{EXPLICIT}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetExplicit]{\emph{\code{ARKodeSetExplicit()}}}}
\\
\hline
\code{IMPLICIT}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetImplicit]{\emph{\code{ARKodeSetImplicit()}}}}
\\
\hline
\code{IMEX}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetImEx]{\emph{\code{ARKodeSetImEx()}}}}
\\
\hline
\code{IRK\_TABLE\_NUM}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}
\\
\hline
\code{ERK\_TABLE\_NUM}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}
\\
\hline
\code{ARK\_TABLE\_NUM} \emph{(a)}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetARKTableNum]{\emph{\code{ARKodeSetARKTableNum()}}}}
\\
\hline
\code{MAX\_NSTEPS}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxNumSteps]{\emph{\code{ARKodeSetMaxNumSteps()}}}}
\\
\hline
\code{HNIL\_WARNS}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxHnilWarns]{\emph{\code{ARKodeSetMaxHnilWarns()}}}}
\\
\hline
\code{PREDICT\_METHOD}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetPredictorMethod]{\emph{\code{ARKodeSetPredictorMethod()}}}}
\\
\hline
\code{MAX\_ERRFAIL}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxErrTestFails]{\emph{\code{ARKodeSetMaxErrTestFails()}}}}
\\
\hline
\code{MAX\_CONVFAIL}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxConvFails]{\emph{\code{ARKodeSetMaxConvFails()}}}}
\\
\hline
\code{MAX\_NITERS}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxNonlinIters]{\emph{\code{ARKodeSetMaxNonlinIters()}}}}
\\
\hline
\code{ADAPT\_SMALL\_NEF}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetSmallNumEFails]{\emph{\code{ARKodeSetSmallNumEFails()}}}}
\\
\hline
\code{LSETUP\_MSBP}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxStepsBetweenLSet]{\emph{\code{ARKodeSetMaxStepsBetweenLSet()}}}}
\\
\hline\end{tabulary}


\emph{(a)} When setting \code{ARK\_TABLE\_NUM}, pass in \emph{IVAL} as an array of
length 2, specifying the IRK table number first, then the ERK table
number.  The integer specifiers for each table may be found in the
section {\hyperref[Constants:constants]{\emph{\DUspan{}{Appendix: ARKode Constants}}}}, or in the ARKode header file \code{arkode.h}.
\index{FARKSETRIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETRIN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETRIN}}{\emph{KEY}, \emph{RVAL}, \emph{IER}}{}
Specification routine to pass optional real inputs
to the {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{KEY} (quoted string, input) -- which optional input
is set (see {\hyperref[f_interface/Usage:finterface-rinoptiontable]{\emph{\DUspan{}{Table: Keys for setting FARKODE real optional inputs}}}}).

\item {} 
\emph{RVAL} (\code{realtype}, input) -- the real input value to be used.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Table: Keys for setting FARKODE real optional inputs}
\label{f_interface/Usage:finterface-rinoptiontable}\label{f_interface/Usage:table-keys-for-setting-farkode-real-optional-inputs}
\begin{tabulary}{\linewidth}{|L|L|}
\hline
\textsf{\relax 
Key
} & \textsf{\relax 
ARKode routine
}\\
\hline
\code{INIT\_STEP}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetInitStep]{\emph{\code{ARKodeSetInitStep()}}}}
\\
\hline
\code{MAX\_STEP}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxStep]{\emph{\code{ARKodeSetMaxStep()}}}}
\\
\hline
\code{MIN\_STEP}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMinStep]{\emph{\code{ARKodeSetMinStep()}}}}
\\
\hline
\code{STOP\_TIME}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetStopTime]{\emph{\code{ARKodeSetStopTime()}}}}
\\
\hline
\code{NLCONV\_COEF}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinConvCoef]{\emph{\code{ARKodeSetNonlinConvCoef()}}}}
\\
\hline
\code{ADAPT\_CFL}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetCFLFraction]{\emph{\code{ARKodeSetCFLFraction()}}}}
\\
\hline
\code{ADAPT\_SAFETY}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetSafetyFactor]{\emph{\code{ARKodeSetSafetyFactor()}}}}
\\
\hline
\code{ADAPT\_BIAS}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetErrorBias]{\emph{\code{ARKodeSetErrorBias()}}}}
\\
\hline
\code{ADAPT\_GROWTH}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxGrowth]{\emph{\code{ARKodeSetMaxGrowth()}}}}
\\
\hline
\code{ADAPT\_ETAMX1}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxFirstGrowth]{\emph{\code{ARKodeSetMaxFirstGrowth()}}}}
\\
\hline
\code{ADAPT\_BOUNDS}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStepBounds]{\emph{\code{ARKodeSetFixedStepBounds()}}}}
\\
\hline
\code{ADAPT\_ETAMXF}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxEFailGrowth]{\emph{\code{ARKodeSetMaxEFailGrowth()}}}}
\\
\hline
\code{ADAPT\_ETACF}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetMaxCFailGrowth]{\emph{\code{ARKodeSetMaxCFailGrowth()}}}}
\\
\hline
\code{NONLIN\_CRDOWN}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinCRDown]{\emph{\code{ARKodeSetNonlinCRDown()}}}}
\\
\hline
\code{NONLIN\_RDIV}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetNonlinRDiv]{\emph{\code{ARKodeSetNonlinRDiv()}}}}
\\
\hline
\code{LSETUP\_DGMAX}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetDeltaGammaMax]{\emph{\code{ARKodeSetDeltaGammaMax()}}}}
\\
\hline
\code{FIXED\_STEP}
 & 
{\hyperref[c_interface/User_callable:c.ARKodeSetFixedStep]{\emph{\code{ARKodeSetFixedStep()}}}}
\\
\hline\end{tabulary}


If a user wishes to reset all of the options to their default values,
they may call the routine {\hyperref[f_interface/Usage:f/_/FARKSETDEFAULTS]{\emph{\code{FARKSETDEFAULTS()}}}}.
\index{FARKSETDEFAULTS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETDEFAULTS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETDEFAULTS}}{\emph{IER}}{}
Specification routine to reset all FARKODE optional
inputs to their default values.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{Optional advanced FARKODE inputs}
\label{f_interface/Usage:optional-advanced-farkode-inputs}
FARKODE supplies additional routines to specify optional advanced
inputs to the {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} solver.  These are summarized below,
and the user is referred to their C routine counterparts for more
complete information.
\index{FARKSETERKTABLE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETERKTABLE}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETERKTABLE}}{\emph{S}, \emph{Q}, \emph{P}, \emph{C}, \emph{A}, \emph{B}, \emph{BEMBED}, \emph{IER}}{}
Interface to the routine {\hyperref[c_interface/User_callable:c.ARKodeSetERKTable]{\emph{\code{ARKodeSetERKTable()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{S} (\code{int}, input) -- number of stages in the table.

\item {} 
\emph{Q} (\code{int}, input) -- global order of accuracy of the method.

\item {} 
\emph{P} (\code{int}, input) -- global order of accuracy of the embedding.

\item {} 
\emph{C} (\code{realtype}, input) -- array of length \emph{S} containing the stage times.

\item {} 
\emph{A} (\code{realtype}, input) -- array of length \emph{S*S} containing the ERK coefficients
(stored in row-major, ``C'', order).

\item {} 
\emph{B} (\code{realtype}, input) -- array of length \emph{S} containing the solution coefficients.

\item {} 
\emph{BEMBED} (\code{realtype}, input) -- array of length \emph{S} containing the embedding
coefficients.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKSETIRKTABLE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETIRKTABLE}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETIRKTABLE}}{\emph{S}, \emph{Q}, \emph{P}, \emph{C}, \emph{A}, \emph{B}, \emph{BEMBED}, \emph{IER}}{}
Interface to the routine {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTable]{\emph{\code{ARKodeSetIRKTable()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{S} (\code{int}, input) -- number of stages in the table.

\item {} 
\emph{Q} (\code{int}, input) -- global order of accuracy of the method.

\item {} 
\emph{P} (\code{int}, input) -- global order of accuracy of the embedding.

\item {} 
\emph{C} (\code{realtype}, input) -- array of length \emph{S} containing the stage times.

\item {} 
\emph{A} (\code{realtype}, input) -- array of length \emph{S*S} containing the IRK coefficients
(stored in row-major, ``C'', order).

\item {} 
\emph{B} (\code{realtype}, input) -- array of length \emph{S} containing the solution coefficients.

\item {} 
\emph{BEMBED} (\code{realtype}, input) -- array of length \emph{S} containing the embedding
coefficients.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKSETARKTABLES() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETARKTABLES}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETARKTABLES}}{\emph{S}, \emph{Q}, \emph{P}, \emph{CI}, \emph{CE}, \emph{AI}, \emph{AE}, \emph{BI}, \emph{BE}, \emph{B2I}, \emph{B2E}, \emph{IER}}{}
Interface to the routine {\hyperref[c_interface/User_callable:c.ARKodeSetARKTables]{\emph{\code{ARKodeSetARKTables()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{S} (\code{int}, input) -- number of stages in the table.

\item {} 
\emph{Q} (\code{int}, input) -- global order of accuracy of the method.

\item {} 
\emph{P} (\code{int}, input) -- global order of accuracy of the embedding.

\item {} 
\emph{CI} (\code{realtype}, input) -- array of length \emph{S} containing
the implicit stage times.

\item {} 
\emph{CE} (\code{realtype}, input) -- array of length \emph{S} containing
the explicit stage times.

\item {} 
\emph{AI} (\code{realtype}, input) -- array of length \emph{S*S} containing the IRK coefficients
(stored in row-major, ``C'', order)

\item {} 
\emph{AE} (\code{realtype}, input) -- array of length \emph{S*S} containing the ERK coefficients
(stored in row-major, ``C'', order)

\item {} 
\emph{BI} (\code{realtype}, input) -- array of length \emph{S} containing
the implicit solution coefficients

\item {} 
\emph{BE} (\code{realtype}, input) -- array of length \emph{S} containing
the explicit solution coefficients

\item {} 
\emph{B2I} (\code{realtype}, input) -- array of length \emph{S} containing
the implicit embedding coefficients

\item {} 
\emph{B2E} (\code{realtype}, input) -- array of length \emph{S} containing
the explicit embedding coefficients

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure)

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKSETRESTOLERANCE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETRESTOLERANCE}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETRESTOLERANCE}}{\emph{IATOL}, \emph{ATOL}, \emph{IER}}{}
Interface to the routines {\hyperref[c_interface/User_callable:c.ARKodeResStolerance]{\emph{\code{ARKodeResStolerance()}}}} and {\hyperref[c_interface/User_callable:c.ARKodeResVtolerance]{\emph{\code{ARKodeResVtolerance()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IATOL} (\code{int}, input) -- type for absolute residual tolerance input
\emph{ATOL}: 1 = scalar, 2 = array

\item {} 
\emph{ATOL} (\code{realtype}, input) -- scalar or array absolute residual tolerance.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, a user may set the accuracy-based step size adaptivity
strategy (and it's associated parameters) through a call to
{\hyperref[f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD]{\emph{\code{FARKSETADAPTIVITYMETHOD()}}}}, as described below.
\index{FARKSETADAPTIVITYMETHOD() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSETADAPTIVITYMETHOD}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSETADAPTIVITYMETHOD}}{\emph{IMETHOD}, \emph{IDEFAULT}, \emph{IPQ}, \emph{PARAMS}, \emph{IER}}{}
Specification routine to set the step size adaptivity strategy and
parameters within the {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} solver.  Interfaces with
the C routine {\hyperref[c_interface/User_callable:c.ARKodeSetAdaptivityMethod]{\emph{\code{ARKodeSetAdaptivityMethod()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IMETHOD} (\code{int}, input) -- choice of adaptivity method.

\item {} 
\emph{IDEFAULT} (\code{int}, input) -- flag denoting whether to use
default parameters (1) or that customized parameters will be
supplied (1).

\item {} 
\emph{IPQ} (\code{int}, input) -- flag denoting whether to use
the embedding order of accuracy (0) or the method order of
accuracy (1) within step adaptivity algorithm.

\item {} 
\emph{PARAMS} (\code{realtype}, input) -- array of 3 parameters to be
used within the adaptivity strategy.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Lastly, the user may provide functions to aid/replace those within
ARKode for handling adaptive error control and explicit stability.
The former of these is designed for advanced users who wish to
investigate custom step adaptivity approaches as opposed to using any
of those built-in to ARKode.  In ARKode's C/C++ interface, this would be
provided by a function of type {\hyperref[c_interface/User_supplied:c.ARKAdaptFn]{\emph{\code{ARKAdaptFn()}}}}; in the Fortran
interface this is provided through the user-supplied function:
\index{FARKADAPT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKADAPT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKADAPT}}{\emph{Y}, \emph{T}, \emph{H1}, \emph{H2}, \emph{H3}, \emph{E1}, \emph{E2}, \emph{E3}, \emph{Q}, \emph{P}, \emph{HNEW}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
It must set the new step size \emph{HNEW} based on the three previous
steps (\emph{H1}, \emph{H2}, \emph{H3}) and the three previous error estimates
(\emph{E1}, \emph{E2}, \emph{E3}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{Y} (\code{realtype}, input) -- array containing state variables.

\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{H1} (\code{realtype}, input) -- current step size.

\item {} 
\emph{H2} (\code{realtype}, input) -- previous step size.

\item {} 
\emph{H3} (\code{realtype}, input) -- previous-previous step size.

\item {} 
\emph{E1} (\code{realtype}, input) -- estimated temporal error in current step.

\item {} 
\emph{E2} (\code{realtype}, input) -- estimated temporal error in previous step.

\item {} 
\emph{E3} (\code{realtype}, input) -- estimated temporal error in previous-previous step.

\item {} 
\emph{Q} (\code{int}, input) -- global order of accuracy for RK method.

\item {} 
\emph{P} (\code{int}, input) -- global order of accuracy for RK embedding.

\item {} 
\emph{HNEW} (\code{realtype}, output) -- array containing the error weight vector.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing the integer
user data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing the real user
data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


This routine is enabled by a call to the activation routine:
\index{FARKADAPTSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKADAPTSET}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKADAPTSET}}{\emph{FLAG}, \emph{IER}}{}
Informs FARKODE to use the user-supplied {\hyperref[f_interface/Usage:f/_/FARKADAPT]{\emph{\code{FARKADAPT()}}}} function.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- flag, use ``1'' to denoting to use
{\hyperref[f_interface/Usage:f/_/FARKADAPT]{\emph{\code{FARKADAPT()}}}}, or use ``0'' to denote a return to the
default adaptivity strategy.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne
0\) failure).

\end{itemize}

\end{description}

Note: The call to {\hyperref[f_interface/Usage:f/_/FARKADAPTSET]{\emph{\code{FARKADAPTSET()}}}} must occur \emph{after} the call
to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\end{fulllineitems}


Similarly, if either an explicit or mixed implicit-explicit
integration method is to be employed, the user may specify a function
to provide the maximum explicitly-stable step for their problem.
Again, in the C/C++ interface this would be a function of type
{\hyperref[c_interface/User_supplied:c.ARKExpStabFn]{\emph{\code{ARKExpStabFn()}}}}, while in ARKode's Fortran interface this
must be given through the user-supplied function:
\index{FARKEXPSTAB() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKEXPSTAB}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKEXPSTAB}}{\emph{Y}, \emph{T}, \emph{HSTAB}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
It must set the maximum explicitly-stable step size, \emph{HSTAB}, based
on the current solution, \emph{Y}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{Y} (\code{realtype}, input) -- array containing state variables.

\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{HSTAB} (\code{realtype}, output) -- maximum explicitly-stable step size.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing the integer user data that was passed
to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing the real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\end{fulllineitems}


This routine is enabled by a call to the activation routine:
\index{FARKEXPSTABSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKEXPSTABSET}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKEXPSTABSET}}{\emph{FLAG}, \emph{IER}}{}
Informs FARKODE to use the user-supplied {\hyperref[f_interface/Usage:f/_/FARKEXPSTAB]{\emph{\code{FARKEXPSTAB()}}}} function.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- flag, use ``1'' to denoting to use
{\hyperref[f_interface/Usage:f/_/FARKEXPSTAB]{\emph{\code{FARKEXPSTAB()}}}}, or use ``0'' to denote a return to the
default error-based stability strategy.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne
0\) failure).

\end{itemize}

\end{description}

Note: The call to {\hyperref[f_interface/Usage:f/_/FARKEXPSTABSET]{\emph{\code{FARKEXPSTABSET()}}}} must occur \emph{after} the call
to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\end{fulllineitems}



\subsubsection{System linear solver interface specification}
\label{f_interface/Usage:finterface-linearsolver}\label{f_interface/Usage:system-linear-solver-interface-specification}
To attach the linear solver (and optionally the matrix) object(s)
initialized in steps {\hyperref[f_interface/Usage:finterface-sunmatrix]{\emph{\DUspan{}{SUNMATRIX module initialization}}}} and
{\hyperref[f_interface/Usage:finterface-sunlinsol]{\emph{\DUspan{}{SUNLINSOL module initialization}}}} above, the user of FARKODE must
initialize the ARKDLS or ARKSPILS linear solver interface.


\paragraph{ARKDLS direct linear solver interface}
\label{f_interface/Usage:arkdls-direct-linear-solver-interface}
To attach a direct SUNLINSOL object and corresponding SUNMATRIX
object to the ARKDLS interface, then following calls to initialize the
SUNLINSOL and SUNMATRIX objects in steps {\hyperref[f_interface/Usage:finterface-sunmatrix]{\emph{\DUspan{}{SUNMATRIX module initialization}}}} and
{\hyperref[f_interface/Usage:finterface-sunlinsol]{\emph{\DUspan{}{SUNLINSOL module initialization}}}} above, the user must call the
{\hyperref[f_interface/Usage:f/_/FARKDLSINIT]{\emph{\code{FARKDLSINIT()}}}} routine:
\index{FARKDLSINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKDLSINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKDLSINIT}}{\emph{IER}}{}
Interfaces with the {\hyperref[c_interface/User_callable:c.ARKDlsSetLinearSolver]{\emph{\code{ARKDlsSetLinearSolver()}}}} function to
specify use of the direct linear solver interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, -1 if a memory allocation
error occurred, -2 for an illegal input).

\end{itemize}

\end{description}

\end{fulllineitems}


As an option when using the ARKDLS interface with SUNLINSOL\_DENSE or
SUNLINSOL\_LAPACKDENSE linear solver modules, the user may supply a
routine that computes a dense approximation of the system Jacobian
\(J = \frac{\partial f_I}{\partial y}\).  If supplied, it must
have the following form:
\index{FARKDJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKDJAC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKDJAC}}{\emph{NEQ}, \emph{T}, \emph{Y}, \emph{FY}, \emph{DJAC}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied dense Jacobian approximation
function (of type {\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}}), to be used by the
SUNLINSOL\_DENSE or SUNLINSOL\_LAPACKDENSE solver modules.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NEQ} (\code{long int}, input) -- size of the ODE system.

\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y} (\code{realtype}, input) -- array containing values of the dependent state variables.

\item {} 
\emph{FY} (\code{realtype}, input) -- array containing values of the dependent state derivatives.

\item {} 
\emph{DJAC} (\code{realtype} of size (NEQ,NEQ), output) -- 2D array containing the Jacobian entries.

\item {} 
\emph{H} (\code{realtype}, input) -- current step size.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{WK1}, \emph{WK2}, \emph{WK3}  (\code{realtype}, input) -- array containing temporary workspace
of same size as \emph{Y}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\textbf{Notes:} Typically this routine will use only \emph{NEQ}, \emph{T}, \emph{Y}, and
\emph{DJAC}. It must compute the Jacobian and store it column-wise in \emph{DJAC}.

\end{fulllineitems}


If the above routine uses difference quotient approximations, it may
need to access the error weight array \emph{EWT} in the calculation of
suitable increments. The array \emph{EWT} can be obtained by calling
{\hyperref[f_interface/Optional_output:f/_/FARKGETERRWEIGHTS]{\emph{\code{FARKGETERRWEIGHTS()}}}} using one of the work arrays as
temporary storage for \emph{EWT}. It may also need the unit roundoff, which
can be obtained as the optional output \emph{ROUT(6)}, passed from the
calling program to this routine using either \emph{RPAR} or a common block.

If the {\hyperref[f_interface/Usage:f/_/FARKDJAC]{\emph{\code{FARKDJAC()}}}} routine is provided, then, following the
call to {\hyperref[f_interface/Usage:f/_/FARKDLSINIT]{\emph{\code{FARKDLSINIT()}}}}, the user must call the routine
{\hyperref[f_interface/Usage:f/_/FARKDENSESETJAC]{\emph{\code{FARKDENSESETJAC()}}}}:
\index{FARKDENSESETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKDENSESETJAC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKDENSESETJAC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the {\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}} function, specifying
to use the user-supplied routine {\hyperref[f_interface/Usage:f/_/FARKDJAC]{\emph{\code{FARKDJAC()}}}} for the
Jacobian approximation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- any nonzero value specifies to use
{\hyperref[f_interface/Usage:f/_/FARKDJAC]{\emph{\code{FARKDJAC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


As an option when using the ARKDLS interface with SUNLINSOL\_BAND or
SUNLINSOL\_LAPACKBAND linear solver modules, the user may supply a
routine that computes a banded approximation of the linear system
Jacobian \(J = \frac{\partial f_I}{\partial y}\). If supplied, it
must have the following form:
\index{FARKBJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKBJAC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBJAC}}{\emph{NEQ}, \emph{MU}, \emph{ML}, \emph{MDIM}, \emph{T}, \emph{Y}, \emph{FY}, \emph{BJAC}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied band Jacobian approximation
function (of type {\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}}), to be used by the
SUNLINSOL\_BAND or SUNLINSOL\_LAPACKBAND solver modules.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NEQ} (\code{long int}, input) -- size of the ODE system.

\item {} 
\emph{MU}   (\code{long int}, input) -- upper half-bandwidth.

\item {} 
\emph{ML}   (\code{long int}, input) -- lower half-bandwidth.

\item {} 
\emph{MDIM} (\code{long int}, input) -- leading dimension of \emph{BJAC} array.

\item {} 
\emph{T}    (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y}    (\code{realtype}, input) -- array containing dependent state variables.

\item {} 
\emph{FY}   (\code{realtype}, input) -- array containing dependent state derivatives.

\item {} 
\emph{BJAC} (\code{realtype} of size \emph{(MDIM,NEQ)}, output) -- 2D array
containing the Jacobian entries.

\item {} 
\emph{H}    (\code{realtype}, input) -- current step size.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{WK1}, \emph{WK2}, \emph{WK3}  (\code{realtype}, input) -- array containing temporary workspace
of same size as \emph{Y}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{NEQ}, \emph{MU}, \emph{ML}, \emph{T}, \emph{Y}, and
\emph{BJAC}. It must load the \emph{MDIM} by \emph{N} array \emph{BJAC} with the Jacobian
matrix at the current \((t,y)\) in band form.  Store in
\emph{BJAC(k,j)} the Jacobian element \(J_{i,j}\) with
\emph{k = i - j + MU + 1} (or \emph{k = 1, ..., ML+MU+1}) and \emph{j = 1, ..., N}.

\end{fulllineitems}


If the above routine uses difference quotient approximations, it may
need to use the error weight array \emph{EWT} in the calculation of
suitable increments. The array \emph{EWT} can be obtained by calling
{\hyperref[f_interface/Optional_output:f/_/FARKGETERRWEIGHTS]{\emph{\code{FARKGETERRWEIGHTS()}}}} using one of the work
arrays as temporary storage for \emph{EWT}. It may also need the unit
roundoff, which can be obtained as the optional output \emph{ROUT(6)},
passed from the calling program to this routine using either \emph{RPAR}
or a common block.

If the {\hyperref[f_interface/Usage:f/_/FARKBJAC]{\emph{\code{FARKBJAC()}}}} routine is provided, then, following the
call to {\hyperref[f_interface/Usage:f/_/FARKDLSINIT]{\emph{\code{FARKDLSINIT()}}}}, the user must call the routine
{\hyperref[f_interface/Usage:f/_/FARKBANDSETJAC]{\emph{\code{FARKBANDSETJAC()}}}}.
\index{FARKBANDSETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKBANDSETJAC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBANDSETJAC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the {\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}} function, specifying
to use the user-supplied routine {\hyperref[f_interface/Usage:f/_/FARKBJAC]{\emph{\code{FARKBJAC()}}}} for the
Jacobian approximation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- any nonzero value specifies to use
{\hyperref[f_interface/Usage:f/_/FARKBJAC]{\emph{\code{FARKBJAC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


When using the ARKDLS interface with the SUNLINSOL\_KLU or
SUNLINSOL\_SUPERLUMT sparse direct linear solver modules, the user must
supply a routine that computes a sparse approximation of the system
Jacobian \(J = \frac{\partial f_I}{\partial y}\).  Both the KLU
and SuperLU\_MT solvers allow specification of \(J\) in either
compressed-sparse-column (CSC) format or compressed-sparse-row (CSR)
format.  The sparse Jacobian approximation function must have the
following form:
\index{FARKSPJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPJAC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPJAC}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{N}, \emph{NNZ}, \emph{JDATA}, \emph{JINDEXVALS}, \emph{JINDEXPTRS}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied sparse Jacobian approximation
function (of type {\hyperref[c_interface/User_supplied:c.ARKDlsJacFn]{\emph{\code{ARKDlsJacFn()}}}}), to be used by the
SUNLINSOL\_KLU or SUNLINSOL\_SUPERLUMT solver modules.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y} (\code{realtype}, input) -- array containing values of the dependent state variables.

\item {} 
\emph{FY} (\code{realtype}, input) -- array containing values of the dependent state derivatives.

\item {} 
\emph{N} (\code{sunindextype}, input) -- number of matrix rows and columns in Jacobian.

\item {} 
\emph{NNZ} (\code{sunindextype}, input) -- allocated length of nonzero storage in Jacobian.

\item {} 
\emph{JDATA} (\code{realtype} of size NNZ, output) -- nonzero values in Jacobian.

\item {} 
\emph{JINDEXVALS} (\code{sunindextype} of size NNZ, output) -- row \emph{{[}CSR: column{]}} indices for each
nonzero Jacobian entry.

\item {} 
\emph{JINDEXPTRS} (\code{sunindextype} of size N+1, output) -- indices of where
each column's \emph{{[}CSR: row's{]}} nonzeros begin in data array; last entry points
just past end of data values.

\item {} 
\emph{H} (\code{realtype}, input) -- current step size.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{WK1}, \emph{WK2}, \emph{WK3}  (\code{realtype}, input) -- array containing temporary workspace
of same size as \emph{Y}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\textbf{Notes:} due to the internal storage format of the
SUNMATRIX\_SPARSE module, the matrix-specific integer parameters and
arrays are all of type \code{sunindextype} -- the index precision
(32-bit vs 64-bit signed integers) specified during the SUNDIALS
build.  It is assumed that the user's Fortran codes are constructed
to have matching type to how SUNDIALS was installed.

\end{fulllineitems}


If the above routine uses difference quotient approximations to
compute the nonzero entries, it may need to access the error weight
array \emph{EWT} in the calculation of suitable increments. The array \emph{EWT}
can be obtained by calling {\hyperref[f_interface/Optional_output:f/_/FARKGETERRWEIGHTS]{\emph{\code{FARKGETERRWEIGHTS()}}}} using one of
the work arrays as temporary storage for \emph{EWT}.  It may also need the
unit roundoff, which can be obtained as the optional output \emph{ROUT(6)},
passed from the calling program to this routine using either \emph{RPAR} or
a common block.

When supplying the {\hyperref[f_interface/Usage:f/_/FARKSPJAC]{\emph{\code{FARKSPJAC()}}}} routine, following the call
to {\hyperref[f_interface/Usage:f/_/FARKDLSINIT]{\emph{\code{FARKDLSINIT()}}}}, the user must call the routine
{\hyperref[f_interface/Usage:f/_/FARKSPARSESETJAC]{\emph{\code{FARKSPARSESETJAC()}}}}.
\index{FARKSPARSESETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPARSESETJAC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPARSESETJAC}}{\emph{IER}}{}
Interface to the {\hyperref[c_interface/User_callable:c.ARKDlsSetJacFn]{\emph{\code{ARKDlsSetJacFn()}}}} function,
specifying that the user-supplied routine {\hyperref[f_interface/Usage:f/_/FARKSPJAC]{\emph{\code{FARKSPJAC()}}}} has
been provided for the Jacobian approximation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{ARKSPILS iterative linear solver interface}
\label{f_interface/Usage:finterface-spils}\label{f_interface/Usage:arkspils-iterative-linear-solver-interface}
To attach an iterative SUNLINSOL object to the ARKSPILS interface,
then following the call to initialize the SUNLINSOL object in step
{\hyperref[f_interface/Usage:finterface-sunlinsol]{\emph{\DUspan{}{SUNLINSOL module initialization}}}} above, the user must call the
{\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}} routine:
\index{FARKSPILSINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSINIT}}{\emph{IER}}{}
Interfaces with the {\hyperref[c_interface/User_callable:c.ARKSpilsSetLinearSolver]{\emph{\code{ARKSpilsSetLinearSolver()}}}} function to
specify use of the iterative linear solver interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, -1 if a memory allocation
error occurred, -2 for an illegal input).

\end{itemize}

\end{description}

\end{fulllineitems}


As described in the section {\hyperref[Mathematics:mathematics-error-linear]{\emph{\DUspan{}{Linear iteration error control}}}}, a user
may adjust the linear solver tolerance scaling factor
\(\epsilon_L\).  Fortran users may adjust this value by calling
the function {\hyperref[f_interface/Usage:f/_/FARKSPILSSETEPSLIN]{\emph{\code{FARKSPILSSETEPSLIN()}}}}:
\index{FARKSPILSSETEPSLIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSSETEPSLIN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSSETEPSLIN}}{\emph{EPLIFAC}, \emph{IER}}{}
Interface to the function {\hyperref[c_interface/User_callable:c.ARKSpilsSetEpsLin]{\emph{\code{ARKSpilsSetEpsLin()}}}} to
specify the linear solver tolerance scale factor \(\epsilon_L\)
for the Newton system linear solver.

This routine must be called \emph{after} {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{EPLIFAC} (\code{realtype}, input) -- value to use for
\(\epsilon_L\).  Passing a value of 0 indicates to use the
default value (0.05).

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


Optional user-supplied routines {\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}} and
{\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}} may be provided to compute the product
of the system Jacobian \(J = \frac{\partial f_I}{\partial y}\) and
a given vector \(v\).  If these are supplied, then following the
call to {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}}, the user must call the
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETJAC]{\emph{\code{FARKSPILSSETJAC()}}}} routine with \emph{FLAG} \(\ne 0\):
\index{FARKSPILSSETJAC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSSETJAC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSSETJAC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the function {\hyperref[c_interface/User_callable:c.ARKSpilsSetJacTimes]{\emph{\code{ARKSpilsSetJacTimes()}}}} to
specify use of the user-supplied Jacobian-times-vector setup and
product functions, {\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}} and
{\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}}, respectively.

This routine must be called \emph{after} {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- flag denoting use of user-supplied
Jacobian-times-vector routines.  A nonzero value specifies to
use these the user-supplied routines, a zero value specifies
not to use these.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


Similarly, optional user-supplied routines {\hyperref[f_interface/Usage:f/_/FARKPSET]{\emph{\code{FARKPSET()}}}} and
{\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}} may be provided to perform preconditioning of the
iterative linear solver (note: the SUNLINSOL module must have been
configured with preconditioning enabled).  If these routines are
supplied, then following the call to {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}} the
user must call the routine {\hyperref[f_interface/Usage:f/_/FARKSPILSSETPREC]{\emph{\code{FARKSPILSSETPREC()}}}} with \emph{FLAG}
\(\ne 0\):
\index{FARKSPILSSETPREC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSSETPREC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSSETPREC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the function {\hyperref[c_interface/User_callable:c.ARKSpilsSetPreconditioner]{\emph{\code{ARKSpilsSetPreconditioner()}}}} to
specify use of the user-supplied preconditioner setup and solve
functions, {\hyperref[f_interface/Usage:f/_/FARKPSET]{\emph{\code{FARKPSET()}}}} and {\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}}, respectively.

This routine must be called \emph{after} {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- flag denoting use of user-supplied
preconditioning routines.  A nonzero value specifies to
use these the user-supplied routines, a zero value specifies
not to use these.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


With treatment of the linear systems by any of the Krylov iterative
solvers, there are four optional user-supplied routines --
{\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}}, {\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}}, {\hyperref[f_interface/Usage:f/_/FARKPSET]{\emph{\code{FARKPSET()}}}}
and {\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}}. The specifications of these functions are
given below.

As an option when using the ARKSPILS linear solver interface, the user
may supply a routine that computes the product of the system Jacobian
\(J = \frac{\partial f_I}{\partial y}\) and a given vector
\(v\).  If supplied, it must have the following form:
\index{FARKJTIMES() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKJTIMES}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKJTIMES}}{\emph{V}, \emph{FJV}, \emph{T}, \emph{Y}, \emph{FY}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{WORK}, \emph{IER}}{}
Interface to provide a user-supplied Jacobian-times-vector product
approximation function (corresponding to a C interface routine of
type {\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{\code{ARKSpilsJacTimesVecFn()}}}}), to be used by one of the
Krylov iterative linear solvers.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{V}    (\code{realtype}, input) -- array containing the vector to multiply.

\item {} 
\emph{FJV}  (\code{realtype}, output) -- array containing resulting product vector.

\item {} 
\emph{T}    (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y}    (\code{realtype}, input) -- array containing dependent state variables.

\item {} 
\emph{FY}   (\code{realtype}, input) -- array containing dependent state derivatives.

\item {} 
\emph{H}    (\code{realtype}, input) -- current step size.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{WORK} (\code{realtype}, input) -- array containing temporary workspace of same size as
\emph{Y}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{T}, \emph{Y}, \emph{V}, and
\emph{FJV}.  It must compute the product vector \(Jv\), where
\(v\) is given in \emph{V}, and the product is stored in \emph{FJV}.

\end{fulllineitems}


If the user's Jacobian-times-vector product routine requires that any
Jacobian related data be evaluated or preprocessed, then the following
routine can be used for the evaluation and preprocessing of this data:
\index{FARKJTSETUP() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKJTSETUP}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKJTSETUP}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Interface to setup data for use in a user-supplied
Jacobian-times-vector product approximation function (corresponding
to a C interface routine of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{\code{ARKSpilsJacTimesSetupFn()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T}    (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y}    (\code{realtype}, input) -- array containing dependent state variables.

\item {} 
\emph{FY}   (\code{realtype}, input) -- array containing dependent state derivatives.

\item {} 
\emph{H}    (\code{realtype}, input) -- current step size.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{T} and \emph{Y}, and store
the results in either the arrays \emph{IPAR} and \emph{RPAR}, or in a Fortran
module or common block.

\end{fulllineitems}


If preconditioning is to be included, the following routine must be
supplied, for solution of the preconditioner linear system:
\index{FARKPSOL() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKPSOL}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKPSOL}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{R}, \emph{Z}, \emph{GAMMA}, \emph{DELTA}, \emph{LR}, \emph{IPAR}, \emph{RPAR}, \emph{VT}, \emph{IER}}{}
User-supplied preconditioner solve routine (of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSolveFn]{\emph{\code{ARKSpilsPrecSolveFn()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y} (\code{realtype}, input) -- current dependent state variable array.

\item {} 
\emph{FY} (\code{realtype}, input) -- current dependent state variable derivative array.

\item {} 
\emph{R} (\code{realtype}, input) -- right-hand side array.

\item {} 
\emph{Z} (\code{realtype}, output) -- solution array.

\item {} 
\emph{GAMMA} (\code{realtype}, input) -- Jacobian scaling factor.

\item {} 
\emph{DELTA} (\code{realtype}, input) -- desired residual tolerance.

\item {} 
\emph{LR} (\code{int}, input) -- flag denoting to solve the right or left preconditioner
system: 1 = left preconditioner, 2 = right preconditioner.

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \textgreater{}0 if a recoverable
failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{T}, \emph{Y}, \emph{GAMMA}, \emph{R},
\emph{LR}, and \emph{Z}.  It must solve the preconditioner linear system
\(Pz = r\).  The preconditioner (or the product of the left and
right preconditioners if both are nontrivial) should be an
approximation to the matrix  \(M(T) - \gamma J\), where
\(M\) is the system mass matrix, \(\gamma\) is the input
GAMMA, and \(J = \frac{\partial f_I}{\partial y}\).

\end{fulllineitems}


If the user's preconditioner requires that any Jacobian related data be evaluated
or preprocessed, then the following routine can be used for the evaluation and
preprocessing of the preconditioner:
\index{FARKPSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKPSET}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKPSET}}{\emph{T}, \emph{Y}, \emph{FY}, \emph{JOK}, \emph{JCUR}, \emph{GAMMA}, \emph{H}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied preconditioner setup routine (of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsPrecSetupFn]{\emph{\code{ARKSpilsPrecSetupFn()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{Y} (\code{realtype}, input) -- current dependent state variable array.

\item {} 
\emph{FY} (\code{realtype}, input) -- current dependent state variable derivative array.

\item {} 
\emph{JOK} (\code{int}, input) -- flag indicating whether Jacobian-related data needs to be
recomputed: 0 = recompute, 1 = reuse with the current value of \emph{GAMMA}.

\item {} 
\emph{JCUR} (\code{realtype}, output) -- return flag to denote if
Jacobian data was recomputed (1=yes, 0=no).

\item {} 
\emph{GAMMA} (\code{realtype}, input) -- Jacobian scaling factor.

\item {} 
\emph{H} (\code{realtype}, input) -- current step size.

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \textgreater{}0 if a recoverable
failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\textbf{Notes:}
This routine must set up the preconditioner \(P\) to be used in
the subsequent call to {\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}}.  The preconditioner (or
the product of the left and right preconditioners if using both)
should be an approximation to the matrix  \(M - \gamma J\),
where \(M\) is the system mass matrix, \(\gamma\) is the
input \emph{GAMMA}, and \(J = \frac{\partial f_I}{\partial y}\).

\end{fulllineitems}


Notes:
\begin{enumerate}
\item {} 
If the user's {\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}}, {\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}} or
{\hyperref[f_interface/Usage:f/_/FARKPSET]{\emph{\code{FARKPSET()}}}} routines use difference quotient
approximations, they may need to use the error weight array \emph{EWT}
and/or the unit roundoff, in the calculation of suitable
increments.  Also, if {\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}} uses an iterative
method in its solution, the residual vector \(\rho = r - Pz\)
of the system should be made less than \(\delta =\) \emph{DELTA} in
the weighted l2 norm, i.e.
\begin{gather}
\begin{split}\left(\sum_i \left(\rho_i\, EWT_i\right)^2 \right)^{1/2} < \delta.\end{split}\notag
\end{gather}
\item {} 
If needed in {\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}} {\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}},
{\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}}, or {\hyperref[f_interface/Usage:f/_/FARKPSET]{\emph{\code{FARKPSET()}}}}, the error weight
array \emph{EWT} can be obtained by calling
{\hyperref[f_interface/Optional_output:f/_/FARKGETERRWEIGHTS]{\emph{\code{FARKGETERRWEIGHTS()}}}} using a user-allocated array as
temporary storage for \emph{EWT}.

\item {} 
If needed in {\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}} {\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}},
{\hyperref[f_interface/Usage:f/_/FARKPSOL]{\emph{\code{FARKPSOL()}}}}, or {\hyperref[f_interface/Usage:f/_/FARKPSET]{\emph{\code{FARKPSET()}}}}, the unit roundoff
can be obtained as the optional output \emph{ROUT(6)} (available after
the call to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}) and can be passed using either
the \emph{RPAR} user data array or a common block.

\end{enumerate}


\subsubsection{Mass matrix linear solver interface specification}
\label{f_interface/Usage:finterface-masslinearsolver}\label{f_interface/Usage:mass-matrix-linear-solver-interface-specification}
To attach the mass matrix linear solver (and optionally the mass
matrix) object(s) initialized in steps {\hyperref[f_interface/Usage:finterface-sunmatrix]{\emph{\DUspan{}{SUNMATRIX module initialization}}}} and
{\hyperref[f_interface/Usage:finterface-sunlinsol]{\emph{\DUspan{}{SUNLINSOL module initialization}}}} above, the user of FARKODE must
initialize the ARKMASSDLS or ARKMASSSPILS linear solver interface.


\paragraph{ARKDLS direct mass matrix linear solver interface}
\label{f_interface/Usage:arkdls-direct-mass-matrix-linear-solver-interface}
To attach a direct SUNLINSOL object and corresponding SUNMATRIX object
to the ARKDLS mass matrix solver interface, then following the calls
to initialize the SUNLINSOL and SUNMATRIX objects for the mass-matrix
system in steps {\hyperref[f_interface/Usage:finterface-sunmatrix]{\emph{\DUspan{}{SUNMATRIX module initialization}}}} and
{\hyperref[f_interface/Usage:finterface-sunlinsol]{\emph{\DUspan{}{SUNLINSOL module initialization}}}} above, the user must call the
{\hyperref[f_interface/Usage:f/_/FARKDLSMASSINIT]{\emph{\code{FARKDLSMASSINIT()}}}} routine:
\index{FARKDLSMASSINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKDLSMASSINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKDLSMASSINIT}}{\emph{TIME\_DEP}, \emph{IER}}{}
Interfaces with the {\hyperref[c_interface/User_callable:c.ARKDlsSetMassLinearSolver]{\emph{\code{ARKDlsSetMassLinearSolver()}}}} function to
specify use of the direct mass matrix linear solver interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{TIME\_DEP} (\code{int}, input) -- flag indicating whether the
mass matrix is time-dependent (1) or not (0).

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, -1 if a memory allocation
error occurred, -2 for an illegal input).

\end{itemize}

\end{description}

\end{fulllineitems}


When using the ARKDLS interface with the SUNLINSOL\_DENSE or
SUNLINSOL\_LAPACKDENSE mass matrix linear solver modules, the user must
supply a routine that computes the dense mass matrix \(M(t)\).  This
routine must have the following form:
\index{FARKDMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKDMASS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKDMASS}}{\emph{NEQ}, \emph{T}, \emph{DMASS}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied dense mass matrix computation
function (of type {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}), to be used by the
SUNLINSOL\_DENSE or SUNLINSOL\_LAPACKDENSE solver modules.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NEQ} (\code{long int}, input) -- size of the ODE system.

\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{DMASS} (\code{realtype} of size (NEQ,NEQ), output) -- 2D array
containing the mass matrix entries.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{WK1}, \emph{WK2}, \emph{WK3}  (\code{realtype}, input) -- array containing temporary workspace
of same size as \emph{Y}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\textbf{Notes:} Typically this routine will use only \emph{NEQ}, \emph{T}, and
\emph{DMASS}. It must compute the mass matrix and store it column-wise in \emph{DMASS}.

\end{fulllineitems}


To indicate that the {\hyperref[f_interface/Usage:f/_/FARKDMASS]{\emph{\code{FARKDMASS()}}}} routine has been provided, then,
following the call to {\hyperref[f_interface/Usage:f/_/FARKDLSMASSINIT]{\emph{\code{FARKDLSMASSINIT()}}}}, the user must call
the routine {\hyperref[f_interface/Usage:f/_/FARKDENSESETMASS]{\emph{\code{FARKDENSESETMASS()}}}}:
\index{FARKDENSESETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKDENSESETMASS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKDENSESETMASS}}{\emph{IER}}{}
Interface to the {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}} function,
specifying to use the user-supplied routine {\hyperref[f_interface/Usage:f/_/FARKDMASS]{\emph{\code{FARKDMASS()}}}}
for the mass matrix calculation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


When using the ARKDLS interface with the SUNLINSOL\_BAND or
SUNLINSOL\_LAPACKBAND mass matrix linear solver modules, the user must
supply a routine that computes the banded mass matrix \(M(t)\).  This
routine must have the following form:
\index{FARKBMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKBMASS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBMASS}}{\emph{NEQ}, \emph{MU}, \emph{ML}, \emph{MDIM}, \emph{T}, \emph{BMASS}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied band mass matrix calculation
function (of type {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}), to be used by the
SUNLINSOL\_BAND or SUNLINSOL\_LAPACKBAND solver modules.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NEQ} (\code{long int}, input) -- size of the ODE system.

\item {} 
\emph{MU}   (\code{long int}, input) -- upper half-bandwidth.

\item {} 
\emph{ML}   (\code{long int}, input) -- lower half-bandwidth.

\item {} 
\emph{MDIM} (\code{long int}, input) -- leading dimension of \emph{BMASS} array.

\item {} 
\emph{T}    (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{BMASS} (\code{realtype} of size \emph{(MDIM,NEQ)}, output) -- 2D array
containing the mass matrix entries.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{WK1}, \emph{WK2}, \emph{WK3}  (\code{realtype}, input) -- array containing temporary workspace
of same size as \emph{Y}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{NEQ}, \emph{MU}, \emph{ML}, \emph{T}, and
\emph{BMASS}. It must load the \emph{MDIM} by \emph{N} array \emph{BMASS} with the mass
matrix at the current \((t)\) in band form.  Store in
\emph{BMASS(k,j)} the mass matrix element \(M_{i,j}\) with
\emph{k = i - j + MU + 1} (or \emph{k = 1, ..., ML+MU+1}) and \emph{j = 1, ..., N}.

\end{fulllineitems}


To indicate that the {\hyperref[f_interface/Usage:f/_/FARKBMASS]{\emph{\code{FARKBMASS()}}}} routine has been provided, then,
following the call to {\hyperref[f_interface/Usage:f/_/FARKDLSMASSINIT]{\emph{\code{FARKDLSMASSINIT()}}}}, the user must call the routine
{\hyperref[f_interface/Usage:f/_/FARKBANDSETMASS]{\emph{\code{FARKBANDSETMASS()}}}}:
\index{FARKBANDSETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKBANDSETMASS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBANDSETMASS}}{\emph{IER}}{}
Interface to the {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}} function, specifying
to use the user-supplied routine {\hyperref[f_interface/Usage:f/_/FARKBMASS]{\emph{\code{FARKBMASS()}}}} for the mass
matrix calculation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


When using the ARKDLS interface with the SUNLINSOL\_KLU or
SUNLINSOL\_SUPERLUMT mass matrix linear solver modules, the user must
supply a routine that computes the sparse mass matrix \(M(t)\).
Both the KLU and SuperLU\_MT solver interfaces support the
compressed-sparse-column (CSC) and compressed-sparse-row (CSR) matrix
formats.  The desired format must have been specified to the
\code{FSUNSPARSEMASSMATINIT()} function when initializing the
sparse mass matrix.  The user-provided routine to compute \(M(t)\)
must have the following form:
\index{FARKSPMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPMASS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPMASS}}{\emph{T}, \emph{N}, \emph{NNZ}, \emph{MDATA}, \emph{MINDEXVALS}, \emph{MINDEXPTRS}, \emph{IPAR}, \emph{RPAR}, \emph{WK1}, \emph{WK2}, \emph{WK3}, \emph{IER}}{}
Interface to provide a user-supplied sparse mass matrix approximation
function (of type {\hyperref[c_interface/User_supplied:c.ARKDlsMassFn]{\emph{\code{ARKDlsMassFn()}}}}), to be used by the
SUNLINSOL\_KLU or SUNLINSOL\_SUPERLUMT solver modules.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{N} (\code{sunindextype}, input) -- number of mass matrix rows and columns.

\item {} 
\emph{NNZ} (\code{sunindextype}, input) -- allocated length of nonzero storage
in mass matrix.

\item {} 
\emph{MDATA} (\code{realtype} of size NNZ, output) -- nonzero values
in mass matrix.

\item {} 
\emph{MINDEXVALS} (\code{sunindextype} of size NNZ, output) -- row \emph{{[}CSR: column{]}} indices for each
nonzero mass matrix entry.

\item {} 
\emph{MINDEXPTRS} (\code{sunindextype} of size N+1, output) -- indices of where
each column's \emph{{[}CSR: row's{]}} nonzeros begin in data array; last entry points
just past end of data values.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{WK1}, \emph{WK2}, \emph{WK3}  (\code{realtype}, input) -- array containing temporary workspace
of same size as \emph{Y}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0 if a recoverable error
occurred, \textless{}0 if an unrecoverable error occurred).

\end{itemize}

\end{description}

\textbf{Notes:} due to the internal storage format of the
SUNMATRIX\_SPARSE module, the matrix-specific integer parameters and
arrays are all of type \code{sunindextype} -- the index precision
(32-bit vs 64-bit signed integers) specified during the SUNDIALS
build.  It is assumed that the user's Fortran codes are constructed
to have matching type to how SUNDIALS was installed.

\end{fulllineitems}


To indicate that the {\hyperref[f_interface/Usage:f/_/FARKSPMASS]{\emph{\code{FARKSPMASS()}}}} routine has been provided, then,
following the call to {\hyperref[f_interface/Usage:f/_/FARKDLSMASSINIT]{\emph{\code{FARKDLSMASSINIT()}}}}, the user must call the routine
{\hyperref[f_interface/Usage:f/_/FARKSPARSESETMASS]{\emph{\code{FARKSPARSESETMASS()}}}}:
\index{FARKSPARSESETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPARSESETMASS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPARSESETMASS}}{\emph{IER}}{}
Interface to the {\hyperref[c_interface/User_callable:c.ARKDlsSetMassFn]{\emph{\code{ARKDlsSetMassFn()}}}} function,
specifying that the user-supplied routine {\hyperref[f_interface/Usage:f/_/FARKSPMASS]{\emph{\code{FARKSPMASS()}}}} has
been provided for the mass matrix calculation.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success,
\(\ne 0\) if an error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}



\paragraph{ARKSPILS iterative mass matrix linear solver interface}
\label{f_interface/Usage:arkspils-iterative-mass-matrix-linear-solver-interface}
To attach an iterative SUNLINSOL object to the ARKSPILS mass matrix
solver interface, then following the call to initialize the SUNLINSOL
object in step {\hyperref[f_interface/Usage:finterface-sunlinsol]{\emph{\DUspan{}{SUNLINSOL module initialization}}}} above, the user must call
the {\hyperref[f_interface/Usage:f/_/FARKSPILSMASSINIT]{\emph{\code{FARKSPILSMASSINIT()}}}} routine:
\index{FARKSPILSMASSINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSMASSINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSMASSINIT}}{\emph{TIME\_DEP}, \emph{IER}}{}
Interfaces with the {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassLinearSolver]{\emph{\code{ARKSpilsSetMassLinearSolver()}}}}
function to specify use of the iterative mass matrix solver interface.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{TIME\_DEP} (\code{int}, input) -- flag indicating whether the
mass matrix is time-dependent (1) or not (0).

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, -1 if a memory allocation
error occurred, -2 for an illegal input).

\end{itemize}

\end{description}

\end{fulllineitems}


As described in the section {\hyperref[Mathematics:mathematics-error-linear]{\emph{\DUspan{}{Linear iteration error control}}}}, a user
may adjust the linear solver tolerance scaling factor
\(\epsilon_L\).  Fortran users may adjust this value for the mass
matrix linear solver by calling the function
{\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASSEPSLIN]{\emph{\code{FARKSPILSSETMASSEPSLIN()}}}}:
\index{FARKSPILSSETMASSEPSLIN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSSETMASSEPSLIN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSSETMASSEPSLIN}}{\emph{EPLIFAC}, \emph{IER}}{}
Interface to the function {\hyperref[c_interface/User_callable:c.ARKSpilsSetEpsLin]{\emph{\code{ARKSpilsSetEpsLin()}}}} to
specify the linear solver tolerance scale factor \(\epsilon_L\)
for the mass matrix linear solver.

This routine must be called \emph{after} {\hyperref[f_interface/Usage:f/_/FARKSPILSMASSINIT]{\emph{\code{FARKSPILSMASSINIT()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{EPLIFAC} (\code{realtype}, input) -- value to use for
\(\epsilon_L\).  Passing a value of 0 indicates to use the
default value (0.05).

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


With treatment of the mass matrix linear systems by any of the Krylov
iterative solvers, there are two required user-supplied routines,
{\hyperref[f_interface/Usage:f/_/FARKMTSETUP]{\emph{\code{FARKMTSETUP()}}}} and {\hyperref[f_interface/Usage:f/_/FARKMTIMES]{\emph{\code{FARKMTIMES()}}}}, and there are two
optional user-supplied routines, {\hyperref[f_interface/Usage:f/_/FARKMASSPSET]{\emph{\code{FARKMASSPSET()}}}} and
{\hyperref[f_interface/Usage:f/_/FARKMASSPSOL]{\emph{\code{FARKMASSPSOL()}}}}. The specifications of these functions are given below.

The required routines when using a Krylov iterative mass matrix linear
solver perform setup and computation of the product of the possibly
time-dependent system mass matrix \(M(t)\) and a given vector
\(v\).  The product routine must have the following form:
\index{FARKMTIMES() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKMTIMES}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKMTIMES}}{\emph{V}, \emph{MV}, \emph{T}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Interface to a user-supplied mass-matrix-times-vector product
approximation function (corresponding to a C interface routine of
type {\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesVecFn]{\emph{\code{ARKSpilsMassTimesVecFn()}}}}), to be used by one of the
Krylov iterative linear solvers.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{V}    (\code{realtype}, input) -- array containing the vector to multiply.

\item {} 
\emph{MV}   (\code{realtype}, output) -- array containing resulting product vector.

\item {} 
\emph{T}    (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{T}, \emph{V}, and
\emph{MV}.  It must compute the product vector \(Mv\), where
\(v\) is given in \emph{V}, and the product is stored in \emph{MV}.

\end{fulllineitems}


If the user's mass-matrix-times-vector product routine requires that
any mass matrix data be evaluated or preprocessed, then the following
routine can be used for the evaluation and preprocessing of this data:
\index{FARKMTSETUP() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKMTSETUP}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKMTSETUP}}{\emph{T}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
Interface to a user-supplied mass-matrix-times-vector setup
function (corresponding to a C interface routine of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassTimesSetupFn]{\emph{\code{ARKSpilsMassTimesSetupFn()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T}    (\code{realtype}, input) -- current value of the independent variable.

\item {} 
\emph{IPAR} (\code{long int}, input) -- array containing integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input) -- array containing real user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \(\ne 0\) if an error).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{T}, and store
the results in either the arrays \emph{IPAR} and \emph{RPAR}, or in a Fortran
module or common block.  If no mass matrix setup is needed, this
routine should just set \emph{IER} to 0 and return.

\end{fulllineitems}


To indicate that these routines have been supplied by the user, then,
following the call to {\hyperref[f_interface/Usage:f/_/FARKSPILSMASSINIT]{\emph{\code{FARKSPILSMASSINIT()}}}}, the user must
call the routine {\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASS]{\emph{\code{FARKSPILSSETMASS()}}}}:
\index{FARKSPILSSETMASS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSSETMASS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSSETMASS}}{\emph{IER}}{}
Interface to the function {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassTimes]{\emph{\code{ARKSpilsSetMassTimes()}}}} to
specify use of the user-supplied mass-matrix-times-vector setup and
product functions {\hyperref[f_interface/Usage:f/_/FARKMTSETUP]{\emph{\code{FARKMTSETUP()}}}} and {\hyperref[f_interface/Usage:f/_/FARKMTIMES]{\emph{\code{FARKMTIMES()}}}}.

This routine must be called \emph{after} {\hyperref[f_interface/Usage:f/_/FARKSPILSMASSINIT]{\emph{\code{FARKSPILSMASSINIT()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


Two optional user-supplied preconditioning routines may be supplied to
help accelerate convergence of the Krylov mass matrix linear solver.
If preconditioning was selected when enabling the Krylov solver
(i.e. the solver was set up with \emph{IPRETYPE} \(\ne 0\)), then the
user must also call the routine {\hyperref[f_interface/Usage:f/_/FARKSPILSSETMASSPREC]{\emph{\code{FARKSPILSSETMASSPREC()}}}} with
\emph{FLAG} \(\ne 0\):
\index{FARKSPILSSETMASSPREC() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKSPILSSETMASSPREC}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKSPILSSETMASSPREC}}{\emph{FLAG}, \emph{IER}}{}
Interface to the function {\hyperref[c_interface/User_callable:c.ARKSpilsSetMassPreconditioner]{\emph{\code{ARKSpilsSetMassPreconditioner()}}}} to
specify use of the user-supplied preconditioner setup and solve
functions, {\hyperref[f_interface/Usage:f/_/FARKMASSPSET]{\emph{\code{FARKMASSPSET()}}}} and {\hyperref[f_interface/Usage:f/_/FARKMASSPSOL]{\emph{\code{FARKMASSPSOL()}}}},
respectively.

This routine must be called \emph{after} {\hyperref[f_interface/Usage:f/_/FARKSPILSMASSINIT]{\emph{\code{FARKSPILSMASSINIT()}}}}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{FLAG} (\code{int}, input) -- flag denoting use of user-supplied
preconditioning routines.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\end{fulllineitems}


In addition, the user must provide the following two routines to
implement the preconditioner setup and solve functions to be used
within the solve.
\index{FARKMASSPSET() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKMASSPSET}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKMASSPSET}}{\emph{T}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied preconditioner setup routine (of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSetupFn]{\emph{\code{ARKSpilsMassPrecSetupFn()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent
variable.

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- array containing
integer user data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- array containing real
user data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \textgreater{}0 if
a recoverable failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\textbf{Notes:}
This routine must set up the preconditioner \(P\) to be used in
the subsequent call to {\hyperref[f_interface/Usage:f/_/FARKMASSPSOL]{\emph{\code{FARKMASSPSOL()}}}}.  The
preconditioner (or the product of the left and right
preconditioners if using both) should be an approximation to the
matrix \(M(t)\), where \(M\) is the system mass matrix.

\end{fulllineitems}

\index{FARKMASSPSOL() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKMASSPSOL}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKMASSPSOL}}{\emph{T}, \emph{R}, \emph{Z}, \emph{DELTA}, \emph{LR}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied preconditioner solve routine (of type
{\hyperref[c_interface/User_supplied:c.ARKSpilsMassPrecSolveFn]{\emph{\code{ARKSpilsMassPrecSolveFn()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- current value of the independent
variable.

\item {} 
\emph{R} (\code{realtype}, input) -- right-hand side array.

\item {} 
\emph{Z} (\code{realtype}, output) -- solution array.

\item {} 
\emph{DELTA} (\code{realtype}, input) -- desired residual tolerance.

\item {} 
\emph{LR} (\code{int}, input) -- flag denoting to solve the right or
left preconditioner system: 1 = left preconditioner, 2 = right
preconditioner.

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- array containing
integer user data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- array containing real
user data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, \textgreater{}0 if
a recoverable failure, \textless{}0 if a non-recoverable failure).

\end{itemize}

\end{description}

\textbf{Notes:}
Typically this routine will use only \emph{T}, \emph{R}, \emph{LR}, and \emph{Z}.  It
must solve the preconditioner linear system \(Pz = r\).  The
preconditioner (or the product of the left and right
preconditioners if both are nontrivial) should be an approximation
to the system mass matrix \(M(t)\).

\end{fulllineitems}


Notes:
\begin{enumerate}
\item {} 
If the user's {\hyperref[f_interface/Usage:f/_/FARKMASSPSOL]{\emph{\code{FARKMASSPSOL()}}}} uses an iterative method in
its solution, the residual vector \(\rho = r - Pz\) of the
system should be made less than \(\delta =\) \emph{DELTA} in the
weighted l2 norm, i.e.
\begin{gather}
\begin{split}\left(\sum_i \left(\rho_i\, EWT_i\right)^2 \right)^{1/2} < \delta.\end{split}\notag
\end{gather}
\item {} 
If needed in {\hyperref[f_interface/Usage:f/_/FARKMTIMES]{\emph{\code{FARKMTIMES()}}}}, {\hyperref[f_interface/Usage:f/_/FARKMTSETUP]{\emph{\code{FARKMTSETUP()}}}},
{\hyperref[f_interface/Usage:f/_/FARKMASSPSOL]{\emph{\code{FARKMASSPSOL()}}}}, or {\hyperref[f_interface/Usage:f/_/FARKMASSPSET]{\emph{\code{FARKMASSPSET()}}}}, the error
weight array \emph{EWT} can be obtained by calling
{\hyperref[f_interface/Optional_output:f/_/FARKGETERRWEIGHTS]{\emph{\code{FARKGETERRWEIGHTS()}}}} using a user-allocated array as
temporary storage for \emph{EWT}.

\item {} 
If needed in {\hyperref[f_interface/Usage:f/_/FARKMTIMES]{\emph{\code{FARKMTIMES()}}}}, {\hyperref[f_interface/Usage:f/_/FARKMTSETUP]{\emph{\code{FARKMTSETUP()}}}},
{\hyperref[f_interface/Usage:f/_/FARKMASSPSOL]{\emph{\code{FARKMASSPSOL()}}}}, or {\hyperref[f_interface/Usage:f/_/FARKMASSPSET]{\emph{\code{FARKMASSPSET()}}}}, the unit
roundoff can be obtained as the optional output \emph{ROUT(6)}
(available after the call to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}) and can be
passed using either the \emph{RPAR} user data array or a common block.

\end{enumerate}


\subsubsection{Problem solution}
\label{f_interface/Usage:finterface-solution}\label{f_interface/Usage:problem-solution}
Carrying out the integration is accomplished by making calls to
{\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}}.
\index{FARKODE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKODE}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKODE}}{\emph{TOUT}, \emph{T}, \emph{Y}, \emph{ITASK}, \emph{IER}}{}
Fortran interface to the C routine {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}
for performing the solve, along with many of the ARK*Get*
routines for reporting on solver statistics.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{TOUT} (\code{realtype}, input) -- next value of \(t\) at
which a solution is desired.

\item {} 
\emph{T} (\code{realtype}, output) -- value of independent variable
that corresponds to the output \emph{Y}

\item {} 
\emph{Y} (\code{realtype}, output) -- array containing dependent state
variables on output.

\item {} 
\emph{ITASK} (\code{int}, input) -- task indicator :
\begin{itemize}
\item {} 
1 = normal mode (overshoot \emph{TOUT} and interpolate)

\item {} 
2 = one-step mode (return after each internal step taken)

\item {} 
3 = normal `tstop' mode (like 1, but integration never
proceeds past \emph{TSTOP}, which must be specified through a
preceding call to {\hyperref[f_interface/Usage:f/_/FARKSETRIN]{\emph{\code{FARKSETRIN()}}}} using the key
\emph{STOP\_TIME})

\item {} 
4 = one step `tstop' mode (like 2, but integration never
goes past \emph{TSTOP}).

\end{itemize}

\item {} 
\emph{IER} (int, output) -- completion flag:
\begin{itemize}
\item {} 
0 = success,

\item {} 
1 = tstop return,

\item {} 
2 = root return,

\item {} 
values -1, ..., -10 are failure modes (see {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}} and
{\hyperref[Constants:constants]{\emph{\DUspan{}{Appendix: ARKode Constants}}}}).

\end{itemize}

\end{itemize}

\end{description}

\textbf{Notes:}
The current values of the optional outputs are immediately
available in \emph{IOUT} and \emph{ROUT} upon return from this function (see
{\hyperref[f_interface/Optional_output:finterface-iouttable]{\emph{\DUspan{}{Table: Optional FARKODE integer outputs}}}} and {\hyperref[f_interface/Optional_output:finterface-routtable]{\emph{\DUspan{}{Table: Optional FARKODE real outputs}}}}).

A full description of error flags and output behavior of the solver
(values filled in for \emph{T} and \emph{Y}) is provided in the description
of {\hyperref[c_interface/User_callable:c.ARKode]{\emph{\code{ARKode()}}}}.

\end{fulllineitems}



\subsubsection{Additional solution output}
\label{f_interface/Usage:finterface-additionaloutput}\label{f_interface/Usage:additional-solution-output}
After a successful return from {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}}, the routine
{\hyperref[f_interface/Usage:f/_/FARKDKY]{\emph{\code{FARKDKY()}}}} may be used to obtain a derivative of the solution,
of order up to 3, at any \(t\) within the last step taken.
\index{FARKDKY() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKDKY}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKDKY}}{\emph{T}, \emph{K}, \emph{DKY}, \emph{IER}}{}
Fortran interface to the C routine \code{ARKDKY()} for
interpolating output of the solution or its derivatives at any
point within the last step taken.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- time at which solution derivative
is desired, within the interval \([t_n-h,t_n]\).

\item {} 
\emph{K} (\code{int}, input) -- derivative order \((0 \le k \le 3)\).

\item {} 
\emph{DKY} (\code{realtype}, output) -- array containing the computed
\emph{K}-th derivative of \(y\).

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textless{}0 if an
illegal argument).

\end{itemize}

\end{description}

\end{fulllineitems}



\subsubsection{Problem reinitialization}
\label{f_interface/Usage:finterface-reinit}\label{f_interface/Usage:problem-reinitialization}
To re-initialize the ARKode solver for the solution of a new
problem of the same size as one already solved, the user must call
{\hyperref[f_interface/Usage:f/_/FARKREINIT]{\emph{\code{FARKREINIT()}}}}:
\index{FARKREINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKREINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKREINIT}}{\emph{T0}, \emph{Y0}, \emph{IMEX}, \emph{IATOL}, \emph{RTOL}, \emph{ATOL}, \emph{IER}}{}
Re-initializes the Fortran interface to the ARKode solver.

\textbf{Arguments:}  The arguments have the same names and meanings as those of
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\textbf{Notes:}
This routine performs no memory allocation, instead using the
existing memory created by the previous {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}
call.  The call to specify the linear system solution method may
or may not be needed.

\end{fulllineitems}


Following a call to {\hyperref[f_interface/Usage:f/_/FARKREINIT]{\emph{\code{FARKREINIT()}}}} if the choice of linear
solver is being changed then a user must make a call to create the
alternate SUNLINSOL module and then attach it to the ARKDLS or
ARKSPILS interface, as shown above.  If only linear solver parameters
are being modified, then these calls may be made without re-attaching
to the ARKDLS or ARKSPILS interface.


\subsubsection{Resizing the ODE system}
\label{f_interface/Usage:finterface-resize}\label{f_interface/Usage:resizing-the-ode-system}
For simulations involving changes to the number of equations and
unknowns in the ODE system (e.g. when solving a spatially-adaptive
PDE), the {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} integrator may be ``resized'' between
integration steps, through calls to the {\hyperref[f_interface/Usage:f/_/FARKRESIZE]{\emph{\code{FARKRESIZE()}}}}
function, that interfaces with the C routine {\hyperref[c_interface/User_callable:c.ARKodeResize]{\emph{\code{ARKodeResize()}}}}.
This function modifies ARKode's internal memory structures to use the
new problem size, without destruction of the temporal adaptivity
heuristics.  It is assumed that the dynamical time scales before and
after the vector resize will be comparable, so that all time-stepping
heuristics prior to calling \code{FARKRESIZE()} remain valid after
the call.  If instead the dynamics should be re-calibrated, the
FARKODE memory structure should be deleted with a call to
{\hyperref[f_interface/Usage:f/_/FARKFREE]{\emph{\code{FARKFREE()}}}}, and re-created with a call to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.
\index{FARKRESIZE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKRESIZE}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKRESIZE}}{\emph{T0}, \emph{Y0}, \emph{HSCALE}, \emph{ITOL}, \emph{RTOL}, \emph{ATOL}, \emph{IER}}{}
Re-initializes the Fortran interface to the ARKode solver for a
differently-sized ODE system.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T0} (\code{realtype}, input) -- initial value of the independent
variable \(t\).

\item {} 
\emph{Y0} (\code{realtype}, input) -- array of dependent-variable
initial conditions.

\item {} 
\emph{HSCALE} (\code{realtype}, input) -- desired step size scale factor:
\begin{itemize}
\item {} 
1.0 is the default,

\item {} 
any value \textless{}= 0.0 results in the default.

\end{itemize}

\item {} 
\emph{ITOL} (\code{int}, input) -- flag denoting that a new relative
tolerance and vector of absolute tolerances are supplied in
the \emph{RTOL} and \emph{ATOL} arguments:
\begin{itemize}
\item {} 
0 = retain the current scalar-valued relative and absolute
tolerances, or the user-supplied error weight function,
{\hyperref[f_interface/Usage:f/_/FARKEWT]{\emph{\code{FARKEWT()}}}}.

\item {} 
1 = \emph{RTOL} contains the new scalar-valued relative tolerance
and \emph{ATOL} contains a new array of absolute tolerances.

\end{itemize}

\item {} 
\emph{RTOL} (\code{realtype}, input) -- scalar relative tolerance.

\item {} 
\emph{ATOL} (\code{realtype}, input) -- array of absolute tolerances.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(\ne 0\) failure).

\end{itemize}

\end{description}

\textbf{Notes:}
This routine performs the opposite set of of operations as
{\hyperref[f_interface/Usage:f/_/FARKREINIT]{\emph{\code{FARKREINIT()}}}}: it does not reinitialize any of the
time-step heuristics, but it does perform memory reallocation.

\end{fulllineitems}


Following a call to {\hyperref[f_interface/Usage:f/_/FARKRESIZE]{\emph{\code{FARKRESIZE()}}}}, the internal data
structures for all linear solver and matrix objects will be the
incorrect size.  Hence, calls must be made to re-create the linear
system solver, mass matrix solver, linear system matrix, and mass
matrix, followed by calls to attach the updated objects to the ARKDLS
or ARKSPILS interfaces.

If any user-supplied linear solver helper routines were used (Jacobian
evaluation, Jacobian-vector product, mass matrix evaluation,
mass-matrix-vector product, preconditioning, etc.), then the
relevant ``set'' routines to specify their usage must be called again
\textbf{following} the re-specification of the linear solver module(s).


\subsubsection{Memory deallocation}
\label{f_interface/Usage:finterface-deallocation}\label{f_interface/Usage:memory-deallocation}
To free the internal memory created by {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}},
{\hyperref[f_interface/Usage:f/_/FARKDLSINIT]{\emph{\code{FARKDLSINIT()}}}}/{\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}},
{\hyperref[f_interface/Usage:f/_/FARKDLSMASSINIT]{\emph{\code{FARKDLSMASSINIT()}}}}/{\hyperref[f_interface/Usage:f/_/FARKSPILSMASSINIT]{\emph{\code{FARKSPILSMASSINIT()}}}},
and the SUNMATRIX and SUNLINSOL objects, the user may call
{\hyperref[f_interface/Usage:f/_/FARKFREE]{\emph{\code{FARKFREE()}}}}, as follows:
\index{FARKFREE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Usage:f/_/FARKFREE}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKFREE}}{}{}
Frees the internal memory created by {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\textbf{Arguments:} None.

\end{fulllineitems}



\subsection{FARKODE optional output}
\label{f_interface/Optional_output:finterface-optionaloutputs}\label{f_interface/Optional_output:farkode-optional-output}\label{f_interface/Optional_output::doc}
We note that the optional inputs to FARKODE have already been
described in the section {\hyperref[f_interface/Usage:finterface-optionalinputs]{\emph{\DUspan{}{Setting optional inputs}}}}.


\subsubsection{IOUT and ROUT arrays}
\label{f_interface/Optional_output:iout-and-rout-arrays}
In the Fortran interface, the optional outputs from the
{\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} solver are accessed not through individual
functions, but rather through a pair of user-allocated arrays, \emph{IOUT}
(having \code{long int} type) of dimension at least 29, and \emph{ROUT}
(having \code{realtype} type) of dimension at least 6.  These arrays must
be allocated by the user program that calls {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}}, that
passes them through the Fortran interface as arguments to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.  Following this call, {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} will
modify the entries of these arrays to contain all optional output
values provided to a Fortran user.

In the following tables, {\hyperref[f_interface/Optional_output:finterface-iouttable]{\emph{\DUspan{}{Table: Optional FARKODE integer outputs}}}} and
{\hyperref[f_interface/Optional_output:finterface-routtable]{\emph{\DUspan{}{Table: Optional FARKODE real outputs}}}}, we list the entries in these
arrays by index, naming them according to their role with the main
ARKode solver, and list the relevant ARKode C/C++ function that is
actually called to extract the output value.  Similarly, optional
integer output values that are specific to the ARKDLS linear solver
interface are listed in {\hyperref[f_interface/Optional_output:finterface-dlsiouttable]{\emph{\DUspan{}{Table: Optional ARKDLS interface outputs}}}}, while
integer optional output values specific to the ARKSPILS iterative
linear solver interface are listed in
{\hyperref[f_interface/Optional_output:finterface-spilsiouttable]{\emph{\DUspan{}{Table: Optional ARKSPILS interface outputs}}}}.

For more details on the optional inputs and outputs to ARKode, see
the sections {\hyperref[c_interface/User_callable:cinterface-optionalinputs]{\emph{\DUspan{}{Optional input functions}}}} and
{\hyperref[c_interface/User_callable:cinterface-optionaloutputs]{\emph{\DUspan{}{Optional output functions}}}}.


\paragraph{Table: Optional FARKODE integer outputs}
\label{f_interface/Optional_output:table-optional-farkode-integer-outputs}\label{f_interface/Optional_output:finterface-iouttable}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
\emph{IOUT} Index
} & \textsf{\relax 
Optional output
} & \textsf{\relax 
ARKode function
}\\
\hline
1
 & 
LENRW
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetWorkSpace]{\emph{\code{ARKodeGetWorkSpace()}}}}
\\
\hline
2
 & 
LENIW
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetWorkSpace]{\emph{\code{ARKodeGetWorkSpace()}}}}
\\
\hline
3
 & 
NST
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumSteps]{\emph{\code{ARKodeGetNumSteps()}}}}
\\
\hline
4
 & 
NST\_STB
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumExpSteps]{\emph{\code{ARKodeGetNumExpSteps()}}}}
\\
\hline
5
 & 
NST\_ACC
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumAccSteps]{\emph{\code{ARKodeGetNumAccSteps()}}}}
\\
\hline
6
 & 
NST\_ATT
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumStepAttempts]{\emph{\code{ARKodeGetNumStepAttempts()}}}}
\\
\hline
7
 & 
NFE
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumRhsEvals]{\emph{\code{ARKodeGetNumRhsEvals()}}}} (num \(f_E\) calls)
\\
\hline
8
 & 
NFI
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumRhsEvals]{\emph{\code{ARKodeGetNumRhsEvals()}}}} (num \(f_I\) calls)
\\
\hline
9
 & 
NSETUPS
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumLinSolvSetups]{\emph{\code{ARKodeGetNumLinSolvSetups()}}}}
\\
\hline
10
 & 
NETF
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumErrTestFails]{\emph{\code{ARKodeGetNumErrTestFails()}}}}
\\
\hline
11
 & 
NNI
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumNonlinSolvIters]{\emph{\code{ARKodeGetNumNonlinSolvIters()}}}}
\\
\hline
12
 & 
NCFN
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumNonlinSolvConvFails]{\emph{\code{ARKodeGetNumNonlinSolvConvFails()}}}}
\\
\hline
13
 & 
NGE
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetNumGEvals]{\emph{\code{ARKodeGetNumGEvals()}}}}
\\
\hline\end{tabulary}



\paragraph{Table: Optional FARKODE real outputs}
\label{f_interface/Optional_output:table-optional-farkode-real-outputs}\label{f_interface/Optional_output:finterface-routtable}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
\emph{ROUT} Index
} & \textsf{\relax 
Optional output
} & \textsf{\relax 
ARKode function
}\\
\hline
1
 & 
H0U
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetActualInitStep]{\emph{\code{ARKodeGetActualInitStep()}}}}
\\
\hline
2
 & 
HU
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetLastStep]{\emph{\code{ARKodeGetLastStep()}}}}
\\
\hline
3
 & 
HCUR
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetCurrentStep]{\emph{\code{ARKodeGetCurrentStep()}}}}
\\
\hline
4
 & 
TCUR
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetCurrentTime]{\emph{\code{ARKodeGetCurrentTime()}}}}
\\
\hline
5
 & 
TOLSF
 & 
{\hyperref[c_interface/User_callable:c.ARKodeGetTolScaleFactor]{\emph{\code{ARKodeGetTolScaleFactor()}}}}
\\
\hline
6
 & 
UROUND
 & 
\code{UNIT\_ROUNDOFF} (see the section {\hyperref[c_interface/General:cinterface-datatypes]{\emph{\DUspan{}{Data Types}}}})
\\
\hline\end{tabulary}



\paragraph{Table: Optional ARKDLS interface outputs}
\label{f_interface/Optional_output:table-optional-arkdls-interface-outputs}\label{f_interface/Optional_output:finterface-dlsiouttable}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
\emph{IOUT} Index
} & \textsf{\relax 
Optional output
} & \textsf{\relax 
ARKode function
}\\
\hline
14
 & 
LENRWLS
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetWorkSpace]{\emph{\code{ARKDlsGetWorkSpace()}}}}
\\
\hline
15
 & 
LENIWLS
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetWorkSpace]{\emph{\code{ARKDlsGetWorkSpace()}}}}
\\
\hline
16
 & 
LSTF
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetLastFlag]{\emph{\code{ARKDlsGetLastFlag()}}}}
\\
\hline
17
 & 
NFELS
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumRhsEvals]{\emph{\code{ARKDlsGetNumRhsEvals()}}}}
\\
\hline
18
 & 
NJE
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumJacEvals]{\emph{\code{ARKDlsGetNumJacEvals()}}}}
\\
\hline\end{tabulary}



\paragraph{Table: Optional ARKDLS mass interface outputs}
\label{f_interface/Optional_output:table-optional-arkdls-mass-interface-outputs}\label{f_interface/Optional_output:finterface-dlsmassiouttable}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
\emph{IOUT} Index
} & \textsf{\relax 
Optional output
} & \textsf{\relax 
ARKode function
}\\
\hline
23
 & 
LENRWMS
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetMassWorkSpace]{\emph{\code{ARKDlsGetMassWorkSpace()}}}}
\\
\hline
24
 & 
LENIWMS
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetMassWorkSpace]{\emph{\code{ARKDlsGetMassWorkSpace()}}}}
\\
\hline
25
 & 
LSTMF
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetLastMassFlag]{\emph{\code{ARKDlsGetLastMassFlag()}}}}
\\
\hline
26
 & 
NMSET
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumMassSetups]{\emph{\code{ARKDlsGetNumMassSetups()}}}}
\\
27
 & 
NMSOL
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumMassSolves]{\emph{\code{ARKDlsGetNumMassSolves()}}}}
\\
28
 & 
NMMUL
 & 
{\hyperref[c_interface/User_callable:c.ARKDlsGetNumMassMult]{\emph{\code{ARKDlsGetNumMassMult()}}}}
\\
\hline\end{tabulary}



\paragraph{Table: Optional ARKSPILS interface outputs}
\label{f_interface/Optional_output:finterface-spilsiouttable}\label{f_interface/Optional_output:table-optional-arkspils-interface-outputs}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
\emph{IOUT} Index
} & \textsf{\relax 
Optional output
} & \textsf{\relax 
ARKode function
}\\
\hline
14
 & 
LENRWLS
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetWorkSpace]{\emph{\code{ARKSpilsGetWorkSpace()}}}}
\\
\hline
15
 & 
LENIWLS
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetWorkSpace]{\emph{\code{ARKSpilsGetWorkSpace()}}}}
\\
\hline
16
 & 
LSTF
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetLastFlag]{\emph{\code{ARKSpilsGetLastFlag()}}}}
\\
\hline
17
 & 
NFELS
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumRhsEvals]{\emph{\code{ARKSpilsGetNumRhsEvals()}}}}
\\
\hline
18
 & 
NJTV
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumJtimesEvals]{\emph{\code{ARKSpilsGetNumJtimesEvals()}}}}
\\
\hline
19
 & 
NPE
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumPrecEvals]{\emph{\code{ARKSpilsGetNumPrecEvals()}}}}
\\
\hline
20
 & 
NPS
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumPrecSolves]{\emph{\code{ARKSpilsGetNumPrecSolves()}}}}
\\
\hline
21
 & 
NLI
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumLinIters]{\emph{\code{ARKSpilsGetNumLinIters()}}}}
\\
\hline
22
 & 
NCFL
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumConvFails]{\emph{\code{ARKSpilsGetNumConvFails()}}}}
\\
\hline\end{tabulary}



\paragraph{Table: Optional ARKSPILS mass interface outputs}
\label{f_interface/Optional_output:table-optional-arkspils-mass-interface-outputs}\label{f_interface/Optional_output:finterface-spilsmassiouttable}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
\emph{IOUT} Index
} & \textsf{\relax 
Optional output
} & \textsf{\relax 
ARKode function
}\\
\hline
23
 & 
LENRWMS
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetMassWorkSpace]{\emph{\code{ARKSpilsGetMassWorkSpace()}}}}
\\
\hline
24
 & 
LENIWMS
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetMassWorkSpace]{\emph{\code{ARKSpilsGetMassWorkSpace()}}}}
\\
\hline
25
 & 
LSTMF
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetLastMassFlag]{\emph{\code{ARKSpilsGetLastMassFlag()}}}}
\\
\hline
26
 & 
NMPE
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassPrecEvals]{\emph{\code{ARKSpilsGetNumMassPrecEvals()}}}}
\\
\hline
27
 & 
NMPS
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassPrecSolves]{\emph{\code{ARKSpilsGetNumMassPrecSolves()}}}}
\\
\hline
28
 & 
NMLI
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassIters]{\emph{\code{ARKSpilsGetNumMassIters()}}}}
\\
\hline
29
 & 
NMCFL
 & 
{\hyperref[c_interface/User_callable:c.ARKSpilsGetNumMassConvFails]{\emph{\code{ARKSpilsGetNumMassConvFails()}}}}
\\
\hline\end{tabulary}



\subsubsection{Additional optional output routines}
\label{f_interface/Optional_output:additional-optional-output-routines}
In addition to the optional inputs communicated through FARKSET*
calls and the optional outputs extracted from \emph{IOUT} and \emph{ROUT},
the following user-callable routines are available.

To obtain the error weight array \emph{EWT}, containing the
multiplicative error weights used in the WRMS norms, the user may call
the routine {\hyperref[f_interface/Optional_output:f/_/FARKGETERRWEIGHTS]{\emph{\code{FARKGETERRWEIGHTS()}}}} as follows:
\index{FARKGETERRWEIGHTS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Optional_output:f/_/FARKGETERRWEIGHTS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKGETERRWEIGHTS}}{\emph{EWT}, \emph{IER}}{}
Retrieves the current error weight vector (interfaces
with {\hyperref[c_interface/User_callable:c.ARKodeGetErrWeights]{\emph{\code{ARKodeGetErrWeights()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{EWT} (\code{realtype}, output) -- array containing the error
weight vector.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\textbf{Notes:}
The array \emph{EWT} must have already been allocated by the user, of
the same size as the solution array \emph{Y}.

\end{fulllineitems}


Similarly, to obtain the estimated local truncation errors, following
a successful call to {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}}, the user may call the
routine {\hyperref[f_interface/Optional_output:f/_/FARKGETESTLOCALERR]{\emph{\code{FARKGETESTLOCALERR()}}}} as follows:
\index{FARKGETESTLOCALERR() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Optional_output:f/_/FARKGETESTLOCALERR}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKGETESTLOCALERR}}{\emph{ELE}, \emph{IER}}{}
Retrieves the current local truncation error estimate
vector (interfaces with {\hyperref[c_interface/User_callable:c.ARKodeGetEstLocalErrors]{\emph{\code{ARKodeGetEstLocalErrors()}}}}).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{ELE} (\code{realtype}, output) -- array with the estimated local
truncation error vector.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success,
\(\ne 0\) if an error).

\end{itemize}

\end{description}

\textbf{Notes:}
The array \emph{ELE} must have already been allocated by the user, of
the same size as the solution array \emph{Y}.

\end{fulllineitems}



\subsection{Usage of the FARKROOT interface to rootfinding}
\label{f_interface/Rootfinding:usage-of-the-farkroot-interface-to-rootfinding}\label{f_interface/Rootfinding::doc}\label{f_interface/Rootfinding:finterface-rootfinding}
The FARKROOT interface package allows programs written in Fortran to
use the rootfinding feature of the ARKode solver module. The
user-callable functions in FARKROOT, with the corresponding ARKODE
functions, are as follows:
\begin{itemize}
\item {} 
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTINIT]{\emph{\code{FARKROOTINIT()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeRootInit]{\emph{\code{ARKodeRootInit()}}}},

\item {} 
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTINFO]{\emph{\code{FARKROOTINFO()}}}} interfaces to
{\hyperref[c_interface/User_callable:c.ARKodeGetRootInfo]{\emph{\code{ARKodeGetRootInfo()}}}}, and

\item {} 
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTFREE]{\emph{\code{FARKROOTFREE()}}}} interfaces to {\hyperref[c_interface/User_callable:c.ARKodeRootInit]{\emph{\code{ARKodeRootInit()}}}},
freeing memory by calling the initializer with no root functions.

\end{itemize}

Note that at this time, FARKROOT does not provide support to specify
the direction of zero-crossing that is to be monitored.  Instead, all
roots are considered.  However, the actual direction of zero-crossing
may be captured by the user through monitoring the sign of any
non-zero elements in the array \emph{INFO} returned by
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTINFO]{\emph{\code{FARKROOTINFO()}}}}.

In order to use the rootfinding feature of ARKode, after calling {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}} but prior to
calling {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}}, the user must call
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTINIT]{\emph{\code{FARKROOTINIT()}}}} to allocate and initialize memory for the FARKROOT module:
\index{FARKROOTINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Rootfinding:f/_/FARKROOTINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKROOTINIT}}{\emph{NRTFN}, \emph{IER}}{}
Initializes the Fortran interface to the FARKROOT module.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NRTFN} (\code{int}, input) -- total number of root functions.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 if
ARKode memory is \code{NULL}, and -11 if a memory allocation
error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}


If rootfinding is enabled, the user must specify the functions whose
roots are to be found.  These rootfinding functions should be
implemented in the user-supplied {\hyperref[f_interface/Rootfinding:f/_/FARKROOTFN]{\emph{\code{FARKROOTFN()}}}} subroutine:
\index{FARKROOTFN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Rootfinding:f/_/FARKROOTFN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKROOTFN}}{\emph{T}, \emph{Y}, \emph{G}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User supplied function implementing the vector-valued function
\(g(t,y)\) such that the roots of the \emph{NRTFN} components
\(g_i(t,y)=0\) are sought.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{T} (\code{realtype}, input) -- independent variable value \(t\).

\item {} 
\emph{Y} (\code{realtype}, input) -- dependent variable array \(y\).

\item {} 
\emph{G} (\code{realtype}, output) -- function value array \(g(t,y)\).

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- integer user data
array, the same as the array passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- real-valued user data
array, the same as the array passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag (0 success, \(<0\)
if error).

\end{itemize}

\end{description}

\end{fulllineitems}


When making calls to {\hyperref[f_interface/Usage:f/_/FARKODE]{\emph{\code{FARKODE()}}}} to solve the ODE system, the
occurrence of a root is flagged by the return value \emph{IER = 2}.  In
that case, if \emph{NRTFN \textgreater{} 1}, the functions \(g_i(t,y)\) which were
found to have a root can be identified by calling the routine
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTINFO]{\emph{\code{FARKROOTINFO()}}}}:
\index{FARKROOTINFO() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Rootfinding:f/_/FARKROOTINFO}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKROOTINFO}}{\emph{NRTFN}, \emph{INFO}, \emph{IER}}{}
Initializes the Fortran interface to the FARKROOT module.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NRTFN} (\code{int}, input) -- total number of root functions.

\item {} 
\emph{INFO} (\code{int}, input/output) -- array of length \emph{NRTFN} with
root information (must be allocated by the user).  For each
index, \emph{i = 1, ..., NRTFN}:
\begin{itemize}
\item {} 
\emph{INFO(i) = 1}  if \(g_i(t,y)\) was found to have a root,
and \(g_i\) is increasing.

\item {} 
\emph{INFO(i) = -1}  if \(g_i(t,y)\) was found to have a root,
and \(g_i\) is decreasing.

\item {} 
\emph{INFO(i) = 0}  otherwise.

\end{itemize}

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, \(<0\)
if error).

\end{itemize}

\end{description}

\end{fulllineitems}


The total number of calls made to the root function
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTFN]{\emph{\code{FARKROOTFN()}}}}, denoted \emph{NGE}, can be obtained from
\emph{IOUT(12)}.  If the FARKODE/ARKode memory block is reinitialized to
solve a different problem via a call to {\hyperref[f_interface/Usage:f/_/FARKREINIT]{\emph{\code{FARKREINIT()}}}}, then
the counter \emph{NGE} is reset to zero.

Lastly, to free the memory resources allocated by a prior call to
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTINIT]{\emph{\code{FARKROOTINIT()}}}}, the user must make a call to
{\hyperref[f_interface/Rootfinding:f/_/FARKROOTFREE]{\emph{\code{FARKROOTFREE()}}}}:
\index{FARKROOTFREE() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Rootfinding:f/_/FARKROOTFREE}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKROOTFREE}}{}{}
Frees memory associated with the FARKODE rootfinding module.

\end{fulllineitems}



\subsection{Usage of the FARKODE interface to built-in preconditioners}
\label{f_interface/Preconditioning:finterface-preconditioning}\label{f_interface/Preconditioning::doc}\label{f_interface/Preconditioning:usage-of-the-farkode-interface-to-built-in-preconditioners}
The FARKODE interface enables usage of the two built-in
preconditioning modules ARKBANDPRE and ARKBBDPRE.  Details on how
these preconditioners work are provided in the section
{\hyperref[c_interface/Preconditioners:cinterface-preconditionermodules]{\emph{\DUspan{}{Preconditioner modules}}}}.  In this section, we focus
specifically on the Fortran interface to these modules.


\subsubsection{Usage of the FARKBP interface to ARKBANDPRE}
\label{f_interface/Preconditioning:usage-of-the-farkbp-interface-to-arkbandpre}\label{f_interface/Preconditioning:finterface-bandpre}
The FARKBP interface module is a package of C functions which,
as part of the FARKODE interface module, support the use of the
ARKode solver with the serial or threaded NVector modules
({\hyperref[nvectors/NVector_Serial:nvectors-nvserial]{\emph{\DUspan{}{The NVECTOR\_SERIAL Module}}}}, {\hyperref[nvectors/NVector_OpenMP:nvectors-openmp]{\emph{\DUspan{}{The NVECTOR\_OPENMP Module}}}} or
{\hyperref[nvectors/NVector_Pthreads:nvectors-pthreads]{\emph{\DUspan{}{The NVECTOR\_PTHREADS Module}}}}), and the combination of the ARKBANDPRE
preconditioner module (see the section {\hyperref[c_interface/Preconditioners:cinterface-bandpre]{\emph{\DUspan{}{A serial banded preconditioner module}}}}) with
the ARKSPILS interface and any of the Krylov iterative linear solvers.

The two user-callable functions in this package, with the
corresponding ARKode function around which they wrap, are:
\begin{itemize}
\item {} 
{\hyperref[f_interface/Preconditioning:f/_/FARKBPINIT]{\emph{\code{FARKBPINIT()}}}} interfaces to {\hyperref[c_interface/Preconditioners:c.ARKBandPrecInit]{\emph{\code{ARKBandPrecInit()}}}}.

\item {} 
{\hyperref[f_interface/Preconditioning:f/_/FARKBPOPT]{\emph{\code{FARKBPOPT()}}}} interfaces to the ARKBANDPRE optional output
functions, {\hyperref[c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace]{\emph{\code{ARKBandPrecGetWorkSpace()}}}} and
{\hyperref[c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals]{\emph{\code{ARKBandPrecGetNumRhsEvals()}}}}.

\end{itemize}

As with the rest of the FARKODE routines, the names of the
user-supplied routines are mapped to actual values through a series of
definitions in the header file \code{farkbp.h}.

The following is a summary of the usage of this module.  Steps that
are unchanged from the main program described in the section
{\hyperref[f_interface/Usage:finterface-usage]{\emph{\DUspan{}{Usage of the FARKODE interface module}}}} are \emph{italicized}.
\begin{enumerate}
\item {} 
\emph{Right-hand side specification}

\item {} 
\emph{NVECTOR module initialization}

\item {} 
SUNLINSOL module initialization

Initialize one of the iterative SUNLINSOL modules, by calling one
of FSUNPCGINIT, FSUNSPBCGSINIT, FSUNSPFGMRINIT, FSUNSPGMRINIT or
FSUNSPTFQMRINIT, supplying an argument to specify that the
SUNLINSOL module should utilize left or right preconditioning.

\item {} 
\emph{Problem specification}

\item {} 
\emph{Set optional inputs}

\item {} 
Linear solver interface specification

First, initialize the ARKSPILS iterative linear solver interface by
calling {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}}.

Optionally, to specify that ARKSPILS should use the supplied
{\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}} and {\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}} routines, the
user should call {\hyperref[f_interface/Usage:f/_/FARKSPILSSETJAC]{\emph{\code{FARKSPILSSETJAC()}}}} with FLAG \(\ne 0\),
as described in the section {\hyperref[f_interface/Usage:finterface-spils]{\emph{\DUspan{}{ARKSPILS iterative linear solver interface}}}}.

Then, to initialize the ARKBANDPRE preconditioner, call the
routine {\hyperref[f_interface/Preconditioning:f/_/FARKBPINIT]{\emph{\code{FARKBPINIT()}}}}, as follows:
\index{FARKBPINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Preconditioning:f/_/FARKBPINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBPINIT}}{\emph{NEQ}, \emph{MU}, \emph{ML}, \emph{IER}}{}
Interfaces with the {\hyperref[c_interface/Preconditioners:c.ARKBandPrecInit]{\emph{\code{ARKBandPrecInit()}}}}
function to allocate memory and initialize data associated
with the ARKBANDPRE preconditioner.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NEQ} (\code{long int}, input) -- problem size.

\item {} 
\emph{MU} (\code{long int}, input) -- upper half-bandwidth of the
band matrix that is retained as an approximation of the
Jacobian.

\item {} 
\emph{ML}  (\code{long int}, input) -- lower half-bandwidth of the
band matrix approximation to the Jacobian.

\item {} 
\emph{IER}  (\code{int}, output) -- return flag  (0 if success, -1
if a memory failure).

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\emph{Problem solution}

\item {} 
ARKBANDPRE optional outputs

Optional outputs specific to the ARKSPILS interface are listed in
{\hyperref[f_interface/Optional_output:finterface-spilsiouttable]{\emph{\DUspan{}{Table: Optional ARKSPILS interface outputs}}}}.  To obtain the optional outputs
associated with the ARKBANDPRE module, the user should call the
{\hyperref[f_interface/Preconditioning:f/_/FARKBPOPT]{\emph{\code{FARKBPOPT()}}}}, as specified below:
\index{FARKBPOPT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Preconditioning:f/_/FARKBPOPT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBPOPT}}{\emph{LENRWBP}, \emph{LENIWBP}, \emph{NFEBP}}{}
Interfaces with the ARKBANDPRE optional output functions.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{LENRWBP} (\code{long int}, output) -- length of real
preconditioner work space (from
{\hyperref[c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace]{\emph{\code{ARKBandPrecGetWorkSpace()}}}}).

\item {} 
\emph{LENIWBP} (\code{long int}, output) -- length of integer
preconditioner work space, in integer words (from
{\hyperref[c_interface/Preconditioners:c.ARKBandPrecGetWorkSpace]{\emph{\code{ARKBandPrecGetWorkSpace()}}}}).

\item {} 
\emph{NFEBP} (\code{long int}, output) -- number of
\(f_I(t,y)\) evaluations (from
{\hyperref[c_interface/Preconditioners:c.ARKBandPrecGetNumRhsEvals]{\emph{\code{ARKBandPrecGetNumRhsEvals()}}}})

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\emph{Additional solution output}

\item {} 
\emph{Problem reinitialization}

\item {} 
\emph{Memory deallocation}

(The memory allocated for the FARKBP module is deallocated
automatically by {\hyperref[f_interface/Usage:f/_/FARKFREE]{\emph{\code{FARKFREE()}}}})

\end{enumerate}


\subsubsection{Usage of the FARKBBD interface to ARKBBDPRE}
\label{f_interface/Preconditioning:usage-of-the-farkbbd-interface-to-arkbbdpre}\label{f_interface/Preconditioning:finterface-bbdpre}
The FARKBBD interface module is a package of C functions which, as
part of the FARKODE interface module, support the use of the ARKode
solver with the parallel vector module ({\hyperref[nvectors/NVector_Parallel:nvectors-nvparallel]{\emph{\DUspan{}{The NVECTOR\_PARALLEL Module}}}}),
and the combination of the ARKBBDPRE preconditioner module (see the
section {\hyperref[c_interface/Preconditioners:cinterface-bbdpre]{\emph{\DUspan{}{A parallel band-block-diagonal preconditioner module}}}}) with any of the Krylov iterative
linear solvers.

The user-callable functions in this package, with the corresponding
ARKode and ARKBBDPRE functions, are as follows:
\begin{itemize}
\item {} 
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDINIT]{\emph{\code{FARKBBDINIT()}}}} interfaces to {\hyperref[c_interface/Preconditioners:c.ARKBBDPrecInit]{\emph{\code{ARKBBDPrecInit()}}}}.

\item {} 
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDREINIT]{\emph{\code{FARKBBDREINIT()}}}} interfaces to {\hyperref[c_interface/Preconditioners:c.ARKBBDPrecReInit]{\emph{\code{ARKBBDPrecReInit()}}}}.

\item {} 
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDOPT]{\emph{\code{FARKBBDOPT()}}}} interfaces to the ARKBBDPRE optional output
functions.

\end{itemize}

In addition to the functions required for general FARKODE usage, the
user-supplied functions required by this package are listed in the
table below, each with the corresponding interface function which
calls it (and its type within ARKBBDPRE or ARKode).

\emph{Table: FARKBBD function mapping}

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
FARKBBD routine
(FORTRAN, user-supplied)
} & \textsf{\relax 
ARKode routine
(C, interface)
} & \textsf{\relax 
ARKode interface
function type
}\\
\hline
{\hyperref[f_interface/Preconditioning:f/_/FARKGLOCFN]{\emph{\code{FARKGLOCFN()}}}}
 & 
FARKgloc
 & 
{\hyperref[c_interface/Preconditioners:c.ARKLocalFn]{\emph{\code{ARKLocalFn()}}}}
\\
\hline
{\hyperref[f_interface/Preconditioning:f/_/FARKCOMMFN]{\emph{\code{FARKCOMMFN()}}}}
 & 
FARKcfn
 & 
{\hyperref[c_interface/Preconditioners:c.ARKCommFn]{\emph{\code{ARKCommFn()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}}
 & 
FARKJtimes
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesVecFn]{\emph{\code{ARKSpilsJacTimesVecFn()}}}}
\\
\hline
{\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}}
 & 
FARKJTSetup
 & 
{\hyperref[c_interface/User_supplied:c.ARKSpilsJacTimesSetupFn]{\emph{\code{ARKSpilsJacTimesSetupFn()}}}}
\\
\hline\end{tabulary}


As with the rest of the FARKODE routines, the names of all
user-supplied routines here are fixed, in order to maximize
portability for the resulting mixed-language program.  Additionally,
based on flags discussed above in the section {\hyperref[f_interface/Routines:finterface-routines]{\emph{\DUspan{}{FARKODE routines}}}},
the names of the user-supplied routines are mapped to actual values
through a series of definitions in the header file \code{farkbbd.h}.

The following is a summary of the usage of this module. Steps that are
unchanged from the main program described in the section
{\hyperref[f_interface/Usage:finterface-usage]{\emph{\DUspan{}{Usage of the FARKODE interface module}}}} are \emph{italicized}.
\begin{enumerate}
\item {} 
\emph{Right-hand side specification}

\item {} 
\emph{NVECTOR module initialization}

\item {} 
SUNLINSOL module initialization

Initialize one of the iterative SUNLINSOL modules, by calling one
of FSUNPCGINIT, FSUNSPBCGSINIT, FSUNSPFGMRINIT, FSUNSPGMRINIT or
FSUNSPTFQMRINIT, supplying an argument to specify that the
SUNLINSOL module should utilize left or right preconditioning.

\item {} 
\emph{Problem specification}

\item {} 
\emph{Set optional inputs}

\item {} 
Linear solver interface specification

First, initialize the ARKSPILS iterative linear solver interface by
calling {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}}.

Optionally, to specify that ARKSPILS should use the supplied
{\hyperref[f_interface/Usage:f/_/FARKJTIMES]{\emph{\code{FARKJTIMES()}}}} and {\hyperref[f_interface/Usage:f/_/FARKJTSETUP]{\emph{\code{FARKJTSETUP()}}}} routines, the
user should call {\hyperref[f_interface/Usage:f/_/FARKSPILSSETJAC]{\emph{\code{FARKSPILSSETJAC()}}}} with FLAG \(\ne 0\),
as described in the section {\hyperref[f_interface/Usage:finterface-spils]{\emph{\DUspan{}{ARKSPILS iterative linear solver interface}}}}.

Then, to initialize the ARKBBDPRE preconditioner, call the function
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDINIT]{\emph{\code{FARKBBDINIT()}}}}, as described below:
\index{FARKBBDINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Preconditioning:f/_/FARKBBDINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBBDINIT}}{\emph{NLOCAL}, \emph{MUDQ}, \emph{MLDQ}, \emph{MU}, \emph{ML}, \emph{DQRELY}, \emph{IER}}{}
Interfaces with the {\hyperref[c_interface/Preconditioners:c.ARKBBDPrecInit]{\emph{\code{ARKBBDPrecInit()}}}}
routine to initialize the ARKBBDPRE preconditioning module.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NLOCAL} (\code{long int}, input) -- local vector size on this
process.

\item {} 
\emph{MUDQ} (\code{long int}, input) -- upper half-bandwidth to be
used in the computation of the local Jacobian blocks by
difference quotients.  These may be smaller than the
true half-bandwidths of the Jacobian of the local block
of \(g\), when smaller values may provide greater
efficiency.

\item {} 
\emph{MLDQ} (\code{long int}, input) -- lower half-bandwidth to be
used in the computation of the local Jacobian blocks by
difference quotients.

\item {} 
\emph{MU} (\code{long int}, input) -- upper half-bandwidth of the
band matrix that is retained as an approximation of the
local Jacobian block (may be smaller than \emph{MUDQ}).

\item {} 
\emph{ML} (\code{long int}, input) -- lower half-bandwidth of the
band matrix that is retained as an approximation of the
local Jacobian block (may be smaller than \emph{MLDQ}).

\item {} 
\emph{DQRELY} (\code{realtype}, input) -- relative increment factor
in \(y\) for difference quotients (0.0 indicates to use
the default).

\item {} 
\emph{IER}  (\code{int}, output) -- return flag (0 if success, -1
if a memory failure).

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\emph{Problem solution}

\item {} 
ARKBBDPRE optional outputs

Optional outputs specific to the ARKSPILS interface are listed in
{\hyperref[f_interface/Optional_output:finterface-spilsiouttable]{\emph{\DUspan{}{Table: Optional ARKSPILS interface outputs}}}}.  To obtain the optional outputs
associated with the ARKBBDPRE module, the user should call
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDOPT]{\emph{\code{FARKBBDOPT()}}}}, as specified below:
\index{FARKBBDOPT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Preconditioning:f/_/FARKBBDOPT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBBDOPT}}{\emph{LENRWBBD}, \emph{LENIWBBD}, \emph{NGEBBD}}{}
Interfaces with the ARKBBDPRE optional output functions.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{LENRWBP} (\code{long int}, output) -- length of real
preconditioner work space on this process (from
{\hyperref[c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace]{\emph{\code{ARKBBDPrecGetWorkSpace()}}}}).

\item {} 
\emph{LENIWBP} (\code{long int}, output) -- length of integer
preconditioner work space on this process (from
{\hyperref[c_interface/Preconditioners:c.ARKBBDPrecGetWorkSpace]{\emph{\code{ARKBBDPrecGetWorkSpace()}}}}).

\item {} 
\emph{NGEBBD} (\code{long int}, output) -- number of \(g(t,y)\)
evaluations (from {\hyperref[c_interface/Preconditioners:c.ARKBBDPrecGetNumGfnEvals]{\emph{\code{ARKBBDPrecGetNumGfnEvals()}}}}) so
far.

\end{itemize}

\end{description}

\end{fulllineitems}


\item {} 
\emph{Additional solution output}

\item {} 
Problem reinitialization

If a sequence of problems of the same size is being solved using
the same linear solver in combination with the ARKBBDPRE
preconditioner, then the ARKode package can be re-initialized for
the second and subsequent problems by calling
{\hyperref[f_interface/Usage:f/_/FARKREINIT]{\emph{\code{FARKREINIT()}}}}, following which a call to
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDREINIT]{\emph{\code{FARKBBDREINIT()}}}} may or may not be needed. If the input
arguments are the same, no {\hyperref[f_interface/Preconditioning:f/_/FARKBBDREINIT]{\emph{\code{FARKBBDREINIT()}}}} call is
needed.

If there is a change in input arguments other than \emph{MU} or
\emph{ML}, then the user program should call {\hyperref[f_interface/Preconditioning:f/_/FARKBBDREINIT]{\emph{\code{FARKBBDREINIT()}}}}
as specified below:
\index{FARKBBDREINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Preconditioning:f/_/FARKBBDREINIT}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBBDREINIT}}{\emph{NLOCAL}, \emph{MUDQ}, \emph{MLDQ}, \emph{DQRELY}, \emph{IER}}{}
Interfaces with the
{\hyperref[c_interface/Preconditioners:c.ARKBBDPrecReInit]{\emph{\code{ARKBBDPrecReInit()}}}} function to reinitialize the
ARKBBDPRE module.

\textbf{Arguments:}  The arguments of the same names have the same
meanings as in {\hyperref[f_interface/Preconditioning:f/_/FARKBBDINIT]{\emph{\code{FARKBBDINIT()}}}}.

\end{fulllineitems}


However, if the value of \emph{MU} or \emph{ML} is being changed, then a call
to {\hyperref[f_interface/Preconditioning:f/_/FARKBBDINIT]{\emph{\code{FARKBBDINIT()}}}} must be made instead.

Finally, if there is a change in any of the linear solver inputs,
then a call to one of \code{FSUNSPGMRINIT()},
\code{FSUNSPBCGSINIT()}, \code{FSUNSPTFQMRINIT()},
\code{FSUNSPFGMRINIT()} or \code{FSUNPCGINIT()}, followed by
a call to {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}} must also be made; in this case
the linear solver memory is reallocated.

\item {} 
Problem resizing

If a sequence of problems of different sizes (but with similar
dyanamical time scales) is being solved using the same linear
solver (SPGMR, SPBCG, SPTFQMR, SPFGMR or PCG) in combination with
the ARKBBDPRE preconditioner, then the ARKode package can be
re-initialized for the second and subsequent problems by calling
{\hyperref[f_interface/Usage:f/_/FARKRESIZE]{\emph{\code{FARKRESIZE()}}}}, following which a call to
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDINIT]{\emph{\code{FARKBBDINIT()}}}} is required to delete and re-allocate the
preconditioner memory of the correct size.
\index{FARKBBDREINIT() (fortran subroutine)|textbf}

\begin{fulllineitems}
\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKBBDREINIT}}{\emph{NLOCAL}, \emph{MUDQ}, \emph{MLDQ}, \emph{DQRELY}, \emph{IER}}{}
Interfaces with the
{\hyperref[c_interface/Preconditioners:c.ARKBBDPrecReInit]{\emph{\code{ARKBBDPrecReInit()}}}} function to reinitialize the
ARKBBDPRE module.

\textbf{Arguments:}  The arguments of the same names have the same
meanings as in {\hyperref[f_interface/Preconditioning:f/_/FARKBBDINIT]{\emph{\code{FARKBBDINIT()}}}}.

\end{fulllineitems}


However, if the value of MU or ML is being changed, then a call to
{\hyperref[f_interface/Preconditioning:f/_/FARKBBDINIT]{\emph{\code{FARKBBDINIT()}}}} must be made instead.

Finally, if there is a change in any of the linear solver inputs,
then a call to one of \code{FSUNSPGMRINIT()},
\code{FSUNSPBCGSINIT()}, \code{FSUNSPTFQMRINIT()},
\code{FSUNSPFGMRINIT()} or \code{FSUNPCGINIT()}, followed by
a call to {\hyperref[f_interface/Usage:f/_/FARKSPILSINIT]{\emph{\code{FARKSPILSINIT()}}}} must also be made; in this case
the linear solver memory is reallocated.

\item {} 
\emph{Memory deallocation}

(The memory allocated for the FARKBBD module is deallocated
automatically by {\hyperref[f_interface/Usage:f/_/FARKFREE]{\emph{\code{FARKFREE()}}}}).

\item {} 
User-supplied routines

The following two routines must be supplied for use with the
ARKBBDPRE module:
\index{FARKGLOCFN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Preconditioning:f/_/FARKGLOCFN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKGLOCFN}}{\emph{NLOC}, \emph{T}, \emph{YLOC}, \emph{GLOC}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied routine (of type {\hyperref[c_interface/Preconditioners:c.ARKLocalFn]{\emph{\code{ARKLocalFn()}}}}) that
computes a processor-local approximation \(g(t,y)\) to
the right-hand side function \(f_I(t,y)\).
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NLOC} (\code{long int}, input) -- local problem size.

\item {} 
\emph{T} (\code{realtype}, input) -- current value of the
independent variable.

\item {} 
\emph{YLOC} (\code{realtype}, input) -- array containing local
dependent state variables.

\item {} 
\emph{GLOC} (\code{realtype}, output) -- array containing local
dependent state derivatives.

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- array containing
integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- array containing
real user data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0
if a recoverable error occurred, \textless{}0 if an unrecoverable
error occurred).

\end{itemize}

\end{description}

\end{fulllineitems}

\index{FARKCOMMFN() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{f_interface/Preconditioning:f/_/FARKCOMMFN}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FARKCOMMFN}}{\emph{NLOC}, \emph{T}, \emph{YLOC}, \emph{IPAR}, \emph{RPAR}, \emph{IER}}{}
User-supplied routine (of type {\hyperref[c_interface/Preconditioners:c.ARKCommFn]{\emph{\code{ARKCommFn()}}}}) that
performs all interprocess communication necessary for the
executation of the {\hyperref[f_interface/Preconditioning:f/_/FARKGLOCFN]{\emph{\code{FARKGLOCFN()}}}} function above, using
the input vector \emph{YLOC}.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NLOC} (\code{long int}, input) -- local problem size.

\item {} 
\emph{T} (\code{realtype}, input) -- current value of the
independent variable.

\item {} 
\emph{YLOC} (\code{realtype}, input) -- array containing local
dependent state variables.

\item {} 
\emph{IPAR} (\code{long int}, input/output) -- array containing
integer user data that was passed to
{\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{RPAR} (\code{realtype}, input/output) -- array containing
real user data that was passed to {\hyperref[f_interface/Usage:f/_/FARKMALLOC]{\emph{\code{FARKMALLOC()}}}}.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 if success, \textgreater{}0
if a recoverable error occurred, \textless{}0 if an unrecoverable
error occurred).

\end{itemize}

\end{description}

\textbf{Notes:}
This subroutine must be supplied even if it is not needed, and
must return \emph{IER = 0}.

\end{fulllineitems}


\end{enumerate}


\chapter{Vector Data Structures}
\label{nvectors/index:nvectors}\label{nvectors/index::doc}\label{nvectors/index:vector-data-structures}
The SUNDIALS library comes packaged with a variety of NVECTOR
implementations, designed for simulations in serial, shared-memory
parallel, and distributed-memory parallel environments, as well as
interfaces to vector data structures used within external linear
solver libraries.  All native implementations assume that the
process-local data is stored contiguously, and they in turn provide a
variety of standard vector algebra operations that may be performed on
the data.

In addition, SUNDIALS provides a simple interface for generic vectors
(akin to a C++ \emph{abstract base class}).  All of the major SUNDIALS
solvers (CVODE(s), IDA(s), KINSOL, ARKODE) in turn are constructed to
only depend on these generic vector operations, making them immediately
extensible to new user-defined vector objects.  The only exceptions to
this rule relate to the dense, banded and sparse-direct linear system
solvers, since they rely on particular data storage and access
patterns in the NVECTORS used.


\section{Description of the NVECTOR Modules}
\label{nvectors/NVector_Description:description-of-the-nvector-modules}\label{nvectors/NVector_Description:nvectors-description}\label{nvectors/NVector_Description::doc}
The SUNDIALS solvers are written in a data-independent manner. They
all operate on generic vectors (of type \code{N\_Vector}) through a set of
operations defined by, and specific to, the particular NVECTOR
implementation. Users can provide a custom implementation of the
NVECTOR module or use one of four provided within SUNDIALS -- a serial
and three parallel implementations.  The generic operations are
described below.  In the sections following, the implementations
provided with SUNDIALS are described.

The generic \code{N\_Vector} type is a pointer to a structure that has an
implementation-dependent \emph{content} field containing the description
and actual data of the vector, and an \emph{ops} field pointing to a
structure with generic vector operations. The type \code{N\_Vector} is
defined as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector} \PYG{p}{\PYGZob{}}
   \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
   \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector\PYGZus{}Ops} \PYG{o}{*}\PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

Here, the \code{\_generic\_N\_Vector\_Op} structure is essentially a list of
function pointers to the various actual vector operations, and is
defined as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}N\PYGZus{}Vector\PYGZus{}Ops} \PYG{p}{\PYGZob{}}
   \PYG{n}{N\PYGZus{}Vector\PYGZus{}ID} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvgetvectorid}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{N\PYGZus{}Vector}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvclone}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{N\PYGZus{}Vector}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvcloneempty}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdestroy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvspace}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{sunindextype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{sunindextype} \PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}\PYG{o}{*}   \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvgetarraypointer}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvsetarraypointer}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype} \PYG{o}{*}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvlinearsum}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvconst}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvprod}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdiv}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvscale}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvabs}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvinv}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvaddconst}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvdotprod}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvmaxnorm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwrmsnorm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwrmsnormmask}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvmin}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvwl2norm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvl1norm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{k+kt}{void}        \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvcompare}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvinvtest}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvconstrmask}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{realtype}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{nvminquotient}\PYG{p}{)}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The generic NVECTOR module defines and implements the vector
operations acting on a \code{N\_Vector}. These routines are nothing but
wrappers for the vector operations defined by a particular NVECTOR
implementation, which are accessed through the \emph{ops} field of the
\code{N\_Vector} structure. To illustrate this point we show below the
implementation of a typical vector operation from the generic NVECTOR
module, namely \code{N\_VScale}, which performs the scaling of a vector
\code{x} by a scalar \code{c}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{N\PYGZus{}VScale}\PYG{p}{(}\PYG{n}{realtype} \PYG{n}{c}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{x}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{z}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{n}{z}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{nvscale}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The subsection {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}} contains a complete list of all
vector operations defined by the generic NVECTOR module.  Finally, we
note that the generic NVECTOR module defines the functions
\code{N\_VCloneVectorArray} and \code{N\_VCloneVectorArrayEmpty}. Both
functions create (by cloning) an array of \emph{count} variables of type
\code{N\_Vector}, each of the same type as an existing \code{N\_Vector}. Their
prototypes are:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n+nf}{N\PYGZus{}VCloneVectorArray}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{count}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n+nf}{N\PYGZus{}VCloneVectorArrayEmpty}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{count}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and their definitions are based on the implementation-specific
\code{N\_VClone} and \code{N\_VCloneEmpty} operations, respectively.

Similarly, an array of variables of type \code{N\_Vector} can be destroyed
by calling \code{N\_VDestroyVectorArray}, whose prototype is

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{N\PYGZus{}VDestroyVectorArray}\PYG{p}{(}\PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{vs}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{count}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

and whose definition is based on the implementation-specific
\code{N\_VDestroy} operation.

In particular, any implementation of the NVECTOR module \textbf{must}:
\begin{itemize}
\item {} 
Specify the \emph{content} field of the \code{N\_Vector}.

\item {} 
Define and implement the necessary vector operations. Note that the
names of these routines should be unique to that implementation in
order to permit using more than one NVECTOR module (each with
different \code{N\_Vector} internal data representations) in the same
code.  We further note that not all of the defined operations are
required for each solver in SUNDIALS.  The list of required
operations for use with ARKode is given in the section
{\hyperref[nvectors/ARKode_requirements:nvectors-arkode]{\emph{\DUspan{}{NVECTOR functions required by ARKode}}}}.

\item {} 
Define and implement user-callable constructor and destructor
routines to create and free a \code{N\_Vector} with the new \emph{content}
field and with \emph{ops} pointing to the new vector operations.

\item {} 
Optionally, define and implement additional user-callable routines
acting on the newly defined \code{N\_Vector} (e.g., a routine to print the
\emph{content} for debugging purposes).

\item {} 
Optionally, provide accessor macros as needed for that particular
implementation to be used to access different parts in the content
field of the newly defined \code{N\_Vector}.

\end{itemize}

Each NVECTOR implementation included in SUNDIALS has a unique
identifier specified in enumeration and shown in the table below.
It is recommended that a user supplied NVECTOR implementation use the
\code{SUNDIALS\_NVEC\_CUSTOM} identifier.


\subsection{Vector Identifications associated with vector kernels supplied with SUNDIALS}
\label{nvectors/NVector_Description:nvector-vectorids}\label{nvectors/NVector_Description:vector-identifications-associated-with-vector-kernels-supplied-with-sundials}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Vector ID
} & \textsf{\relax 
Vector type
} & \textsf{\relax 
ID Value
}\\
\hline
SUNDIALS\_NVEC\_SERIAL
 & 
Serial
 & 
0
\\
\hline
SUNDIALS\_NVEC\_PARALLEL
 & 
Distributed memory parallel (MPI)
 & 
1
\\
\hline
SUNDIALS\_NVEC\_OPENMP
 & 
OpenMP shared memory parallel
 & 
2
\\
\hline
SUNDIALS\_NVEC\_PTHREADS
 & 
PThreads shared memory parallel
 & 
3
\\
\hline
SUNDIALS\_NVEC\_PARHYP
 & 
\emph{hypre} ParHyp parallel vector
 & 
4
\\
\hline
SUNDIALS\_NVEC\_PETSC
 & 
PETSc parallel vector
 & 
5
\\
\hline
SUNDIALS\_NVEC\_CUSTOM
 & 
User-provided custom vector
 & 
6
\\
\hline\end{tabulary}



\section{Description of the NVECTOR operations}
\label{nvectors/NVector_Operations:nvectors-ops}\label{nvectors/NVector_Operations::doc}\label{nvectors/NVector_Operations:description-of-the-nvector-operations}
For each of the \code{N\_Vector} operations, we give the name, usage
of the function, and a description of its mathematical operations
below.
\index{N\_VGetVectorID (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VGetVectorID}\pysiglinewithargsret{N\_Vector\_ID \bfcode{N\_VGetVectorID}}{N\_Vector\emph{ w}}{}
Returns the vector type identifier for the vector \code{w}.  It is
used to determine the vector implementation type (e.g. serial,
parallel, ...) from the abstract \code{N\_Vector} interface.  Returned
values are given in the table, {\hyperref[nvectors/NVector_Description:nvector-vectorids]{\emph{\DUspan{}{Vector Identifications associated with vector kernels supplied with SUNDIALS}}}}

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{id} \PYG{o}{=} \PYG{n}{N\PYGZus{}VGetVectorID}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VClone (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VClone}\pysiglinewithargsret{N\_Vector \bfcode{N\_VClone}}{N\_Vector\emph{ w}}{}
Creates a new \code{N\_Vector} of the same type as an existing vector
\emph{w} and sets the \emph{ops} field.  It does not copy the vector, but
rather allocates storage for the new vector.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{n}{N\PYGZus{}VClone}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VCloneEmpty (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VCloneEmpty}\pysiglinewithargsret{N\_Vector \bfcode{N\_VCloneEmpty}}{N\_Vector\emph{ w}}{}
Creates a new \code{N\_Vector} of the same type as an existing vector
\emph{w} and sets the \emph{ops} field.  It does not allocate storage for the
new vector's data.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{v} \PYG{o}{=} \PYG{n}{N} \PYG{n}{VCloneEmpty}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VDestroy (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VDestroy}\pysiglinewithargsret{void \bfcode{N\_VDestroy}}{N\_Vector\emph{ v}}{}
Destroys the \code{N\_Vector} \emph{v} and frees memory allocated for its
internal data.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDestroy}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VSpace}\pysiglinewithargsret{void \bfcode{N\_VSpace}}{N\_Vector\emph{ v}, sunindextype*\emph{ lrw}, sunindextype*\emph{ liw}}{}
Returns storage requirements for the \code{N\_Vector} \emph{v}: \emph{lrw} contains
the number of \code{realtype} words and \emph{liw} contains the number of
integer words.  This function is advisory only, for use in
determining a user's total space requirements; it could be a dummy
function in a user-supplied NVECTOR module if that information is
not of interest.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VSpace}\PYG{p}{(}\PYG{n}{nvSpec}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{lrw}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{liw}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VGetArrayPointer (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VGetArrayPointer}\pysiglinewithargsret{realtype* \bfcode{N\_VGetArrayPointer}}{N\_Vector\emph{ v}}{}
Returns a pointer to a \code{realtype} array from the \code{N\_Vector}
\emph{v}.  Note that this assumes that the internal data in the
\code{N\_Vector} is a contiguous array of \code{realtype}. This routine is
only used in the solver-specific interfaces to the dense and banded
(serial) linear solvers, and in the interfaces to the banded
(serial) and band-block-diagonal (parallel) preconditioner modules
provided with SUNDIALS.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{vdata} \PYG{o}{=} \PYG{n}{NVGetArrayPointer}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VSetArrayPointer (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VSetArrayPointer}\pysiglinewithargsret{void \bfcode{N\_VSetArrayPointer}}{realtype*\emph{ vdata}, N\_Vector\emph{ v}}{}
Replaces the data array pointer in an \code{N\_Vector} with a given
array of \code{realtype}.  Note that this assumes that the internal
data in the \code{N\_Vector} is a contiguous array of
\code{realtype}. This routine is only used in the interfaces to the
dense (serial) linear solver, hence need not exist in a
user-supplied NVECTOR module.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{NVSetArrayPointer}\PYG{p}{(}\PYG{n}{vdata}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VLinearSum (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VLinearSum}\pysiglinewithargsret{void \bfcode{N\_VLinearSum}}{realtype\emph{ a}, N\_Vector\emph{ x}, realtype\emph{ b}, N\_Vector\emph{ y}, N\_Vector\emph{ z}}{}
Performs the operation \emph{z = ax + by}, where \emph{a} and \emph{b} are
\code{realtype} scalars and \emph{x} and \emph{y} are of type \code{N\_Vector}:
\begin{gather}
\begin{split}z_i = a x_i + b y_i, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VLinearSum}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VConst (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VConst}\pysiglinewithargsret{void \bfcode{N\_VConst}}{realtype\emph{ c}, N\_Vector\emph{ z}}{}
Sets all components of the \code{N\_Vector} \emph{z} to \code{realtype} \emph{c}:
\begin{gather}
\begin{split}z_i = c, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VConst}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VProd (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VProd}\pysiglinewithargsret{void \bfcode{N\_VProd}}{N\_Vector\emph{ x}, N\_Vector\emph{ y}, N\_Vector\emph{ z}}{}
Sets the \code{N\_Vector} \emph{z} to be the component-wise product of the
\code{N\_Vector} inputs \emph{x} and \emph{y}:
\begin{gather}
\begin{split}z_i = x_i y_i, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VProd}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VDiv (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VDiv}\pysiglinewithargsret{void \bfcode{N\_VDiv}}{N\_Vector\emph{ x}, N\_Vector\emph{ y}, N\_Vector\emph{ z}}{}
Sets the \code{N\_Vector} \emph{z} to be the component-wise ratio of the
\code{N\_Vector} inputs \emph{x} and \emph{y}:
\begin{gather}
\begin{split}z_i = \frac{x_i}{y_i}, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
The \(y_i\) may not be tested for 0 values. It should only be
called with a \emph{y} that is guaranteed to have all nonzero components.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VDiv}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VScale (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VScale}\pysiglinewithargsret{void \bfcode{N\_VScale}}{realtype\emph{ c}, N\_Vector\emph{ x}, N\_Vector\emph{ z}}{}
Scales the \code{N\_Vector} \emph{x} by the \code{realtype} scalar \emph{c} and
returns the result in \emph{z}:
\begin{gather}
\begin{split}z_i = c x_i, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VScale}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VAbs (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VAbs}\pysiglinewithargsret{void \bfcode{N\_VAbs}}{N\_Vector\emph{ x}, N\_Vector\emph{ z}}{}
Sets the components of the \code{N\_Vector} \emph{z} to be the absolute
values of the components of the \code{N\_Vector} \emph{x}:
\begin{gather}
\begin{split}y_i = |x_i|, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VAbs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VInv (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VInv}\pysiglinewithargsret{void \bfcode{N\_VInv}}{N\_Vector\emph{ x}, N\_Vector\emph{ z}}{}
Sets the components of the \code{N\_Vector} \emph{z} to be the inverses of
the components of the \code{N\_Vector} \emph{x}:
\begin{gather}
\begin{split}z_i = 1.0/x_i, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
This routine may not check for division by 0.  It should be called
only with an \emph{x} which is guaranteed to have all nonzero components.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VInv}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VAddConst (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VAddConst}\pysiglinewithargsret{void \bfcode{N\_VAddConst}}{N\_Vector\emph{ x}, realtype\emph{ b}, N\_Vector\emph{ z}}{}
Adds the \code{realtype} scalar \emph{b} to all components of \emph{x} and
returns the result in the \code{N\_Vector} \emph{z}:
\begin{gather}
\begin{split}z_i = x_i+b, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VAddConst}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VDotProd (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VDotProd}\pysiglinewithargsret{realtype \bfcode{N\_VDotProd}}{N\_Vector\emph{ x}, N\_Vector\emph{ z}}{}
Returns the value of the dot-product of the \code{N\_Vectors} \emph{x} and \emph{y}:
\begin{gather}
\begin{split}d = \sum_{i=1}^{n} x_i y_i.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{n}{N\PYGZus{}VDotProd}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VMaxNorm (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VMaxNorm}\pysiglinewithargsret{realtype \bfcode{N\_VMaxNorm}}{N\_Vector\emph{ x}}{}
Returns the value of the \(l_{\infty}\) norm of the
\code{N\_Vector} \emph{x}:
\begin{gather}
\begin{split}m = \max_{1\le i\le n} |x_i|.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMaxNorm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VWrmsNorm (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VWrmsNorm}\pysiglinewithargsret{realtype \bfcode{N\_VWrmsNorm}}{N\_Vector\emph{ x}, N\_Vector\emph{ w}}{}
Returns the weighted root-mean-square norm of the \code{N\_Vector} \emph{x}
with (positive) \code{realtype} weight vector \emph{w}:
\begin{gather}
\begin{split}m = \left( \frac1n \sum_{i=1}^{n} \left(x_i w_i\right)^2\right)^{1/2}.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWrmsNorm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VWrmsNormMask (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VWrmsNormMask}\pysiglinewithargsret{realtype \bfcode{N\_VWrmsNormMask}}{N\_Vector\emph{ x}, N\_Vector\emph{ w}, N\_Vector\emph{ id}}{}
Returns the weighted root mean square norm of the \code{N\_Vector} \emph{x}
with (positive) \code{realtype} weight vector \emph{w} built using only the
elements of \emph{x} corresponding to nonzero elements of the
\code{N\_Vector} \emph{id}:
\begin{gather}
\begin{split}m = \left( \frac1n \sum_{i=1}^{n} \left(x_i w_i \text{sign}(id_i)\right)^2 \right)^{1/2}.\end{split}\notag
\end{gather}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWrmsNormMask}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{,} \PYG{n}{id}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VMin (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VMin}\pysiglinewithargsret{realtype \bfcode{N\_VMin}}{N\_Vector\emph{ x}}{}
Returns the smallest element of the \code{N\_Vector} \emph{x}:
\begin{gather}
\begin{split}m = \min_{1\le i\le n} x_i.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMin}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VWl2Norm (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VWl2Norm}\pysiglinewithargsret{realtype \bfcode{N\_VWl2Norm}}{N\_Vector\emph{ x}, N\_Vector\emph{ w}}{}
Returns the weighted Euclidean \(l_2\) norm of the \code{N\_Vector}
\emph{x} with \code{realtype} weight vector \emph{w}:
\begin{gather}
\begin{split}m = \left(\sum_{i=1}^{n}\left(x_i w_i\right)^2\right)^{1/2}.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VWL2Norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VL1Norm (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VL1Norm}\pysiglinewithargsret{realtype \bfcode{N\_VL1Norm}}{N\_Vector\emph{ x}}{}
Returns the \(l_1\) norm of the \code{N\_Vector} \emph{x}:
\begin{gather}
\begin{split}m = \sum_{i=1}^{n} |x_i|.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{N\PYGZus{}VL1Norm}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VCompare (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VCompare}\pysiglinewithargsret{void \bfcode{N\_VCompare}}{realtype\emph{ c}, N\_Vector\emph{ x}, N\_Vector\emph{ z}}{}
Compares the components of the \code{N\_Vector} \emph{x} to the \code{realtype}
scalar \emph{c} and returns an \code{N\_Vector} \emph{z} such that for all
\(1\le i\le n\),
\begin{gather}
\begin{split}z_i = \begin{cases} 1.0 &\quad\text{if}\; |x_i| \ge c,\\
                    0.0 &\quad\text{otherwise}\end{cases}.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N\PYGZus{}VCompare}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VInvTest (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VInvTest}\pysiglinewithargsret{booleantype \bfcode{N\_VInvTest}}{N\_Vector\emph{ x}, N\_Vector\emph{ z}}{}
Sets the components of the \code{N\_Vector} \emph{z} to be the inverses of
the components of the \code{N\_Vector} \emph{x}, with prior testing for
zero values:
\begin{gather}
\begin{split}z_i = 1.0/x_i, \quad i=1,\ldots,n.\end{split}\notag
\end{gather}
This routine returns a boolean assigned to \code{SUNTRUE} if all
components of \emph{x} are nonzero (successful inversion) and returns
\code{SUNFALSE} otherwise.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{N\PYGZus{}VInvTest}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VConstrMask (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VConstrMask}\pysiglinewithargsret{booleantype \bfcode{N\_VConstrMask}}{N\_Vector\emph{ c}, N\_Vector\emph{ x}, N\_Vector\emph{ m}}{}
Performs the following constraint tests based on the values in
\(c_i\):
\begin{gather}
\begin{split}x_i > 0 \;\text{if}\; c_i = 2, \\
x_i \ge 0 \;\text{if}\; c_i = 1, \\
x_i < 0 \;\text{if}\; c_i = -2, \\
x_i \le 0 \;\text{if}\; c_i = -1.\end{split}\notag
\end{gather}
There is no constraint on \(x_i\) if \(c_i = 0\). This
routine returns a boolean assigned to \code{SUNFALSE} if any element
failed the constraint test and assigned to \code{SUNTRUE} if all
passed. It also sets a mask vector \emph{m}, with elements equal to 1.0
where the constraint test failed, and 0.0 where the test
passed. This routine is used only for constraint checking.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{t} \PYG{o}{=} \PYG{n}{N\PYGZus{}VConstrMask}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{N\_VMinQuotient (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Operations:c.N_VMinQuotient}\pysiglinewithargsret{realtype \bfcode{N\_VMinQuotient}}{N\_Vector\emph{ num}, N\_Vector\emph{ denom}}{}
This routine returns the minimum of the quotients obtained by
termwise dividing the elements of \emph{n} by the elements in \emph{d}:
\begin{gather}
\begin{split}\min_{i=1,\ldots,n} \frac{\text{num}_i}{\text{denom}_i}.\end{split}\notag
\end{gather}
A zero element in \emph{denom} will be skipped.  If no such quotients
are found, then the large value \code{BIG\_REAL} (defined in the header
file \code{sundials\_types.h}) is returned.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{minq} \PYG{o}{=} \PYG{n}{N\PYGZus{}VMinQuotient}\PYG{p}{(}\PYG{n}{num}\PYG{p}{,} \PYG{n}{denom}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}



\section{The NVECTOR\_SERIAL Module}
\label{nvectors/NVector_Serial:the-nvector-serial-module}\label{nvectors/NVector_Serial::doc}\label{nvectors/NVector_Serial:nvectors-nvserial}
The serial implementation of the NVECTOR module provided with
SUNDIALS, NVECTOR\_SERIAL, defines the \emph{content} field of a
\code{N\_Vector} to be a structure containing the length of the vector, a
pointer to the beginning of a contiguous data array, and a boolean
flag \emph{own\_data} which specifies the ownership of data.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Serial} \PYG{p}{\PYGZob{}}
   \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The header file to be included when using this module is \code{nvector\_serial.h}.

The following five macros are provided to access the content of an
NVECTOR\_SERIAL vector. The suffix \code{\_S} in the names denotes the serial
version.
\index{NV\_CONTENT\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.NV_CONTENT_S}\pysiglinewithargsret{\bfcode{NV\_CONTENT\_S}}{v}{}
This macro gives access to the contents of the serial vector
\code{N\_Vector} \emph{v}.

The assignment \code{v\_cont = NV\_CONTENT\_S(v)} sets \code{v\_cont} to be a
pointer to the serial \code{N\_Vector} \emph{content} structure.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}S(v) ( (N\PYGZus{}VectorContent\PYGZus{}Serial)(v\PYGZhy{}\PYGZgt{}content) )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.NV_OWN_DATA_S}\pysiglinewithargsret{\bfcode{NV\_OWN\_DATA\_S}}{v}{}
Access the \emph{own\_data} component of the serial \code{N\_Vector} \emph{v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}S(v) ( NV\PYGZus{}CONTENT\PYGZus{}S(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_DATA\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.NV_DATA_S}\pysiglinewithargsret{\bfcode{NV\_DATA\_S}}{v}{}
The assignment \code{v\_data = NV\_DATA\_S(v)} sets \code{v\_data} to be a
pointer to the first component of the \emph{data} for the \code{N\_Vector}
\code{v}.

Similarly, the assignment \code{NV\_DATA\_S(v) = v\_data} sets the component
array of \code{v} to be \code{v\_data} by storing the pointer \code{v\_data}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}S(v) ( NV\PYGZus{}CONTENT\PYGZus{}S(v)\PYGZhy{}\PYGZgt{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_LENGTH\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.NV_LENGTH_S}\pysiglinewithargsret{\bfcode{NV\_LENGTH\_S}}{v}{}
Access the \emph{length} component of the serial \code{N\_Vector} \emph{v}.

The assignment \code{v\_len = NV\_LENGTH\_S(v)} sets \code{v\_len} to be the
\emph{length} of \code{v}. On the other hand, the call \code{NV\_LENGTH\_S(v) =
len\_v} sets the \emph{length} of \code{v} to be \code{len\_v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LENGTH\PYGZus{}S(v) ( NV\PYGZus{}CONTENT\PYGZus{}S(v)\PYGZhy{}\PYGZgt{}length )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_Ith\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.NV_Ith_S}\pysiglinewithargsret{\bfcode{NV\_Ith\_S}}{v, i}{}
This macro gives access to the individual components of the \emph{data}
array of an \code{N\_Vector}, using standard 0-based C indexing.

The assignment \code{r = NV\_Ith\_S(v,i)} sets \code{r} to be the value of
the \code{i}-th component of \code{v}.

The assignment \code{NV\_Ith\_S(v,i) = r} sets the value of the \code{i}-th
component of \code{v} to be \code{r}.

Here \code{i} ranges from 0 to \(n-1\) for a vector of length
\(n\).

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}S(v,i) ( NV\PYGZus{}DATA\PYGZus{}S(v)[i] )}
\end{Verbatim}

\end{fulllineitems}


The NVECTOR\_SERIAL module defines serial implementations of all vector
operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}.  Their names are
obtained from those in that section by appending the suffix
\code{\_Serial} (e.g. \code{N\_VDestroy\_Serial}).  The module NVECTOR\_SERIAL
provides the following additional user-callable routines:
\index{N\_VNew\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VNew_Serial}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNew\_Serial}}{sunindextype\emph{ vec\_length}}{}
This function creates and allocates memory for a serial
\code{N\_Vector}. Its only argument is the vector length.

\end{fulllineitems}

\index{N\_VNewEmpty\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VNewEmpty_Serial}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_Serial}}{sunindextype\emph{ vec\_length}}{}
This function creates a new serial \code{N\_Vector} with an empty
(\code{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VMake_Serial}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_Serial}}{sunindextype\emph{ vec\_length}, realtype*\emph{ v\_data}}{}
This function creates and allocates memory for a serial vector with
user-provided data array, \emph{v\_data}.

(This function does \emph{not} allocate memory for \code{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VCloneVectorArray_Serial}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_Serial}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} serial
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VCloneVectorArrayEmpty_Serial}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_Serial}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} serial
vectors, each with an empty (\code{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VDestroyVectorArray_Serial}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_Serial}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_Serial:c.N_VCloneVectorArray_Serial]{\emph{\code{N\_VCloneVectorArray\_Serial()}}}} or with
{\hyperref[nvectors/NVector_Serial:c.N_VCloneVectorArrayEmpty_Serial]{\emph{\code{N\_VCloneVectorArrayEmpty\_Serial()}}}}.

\end{fulllineitems}

\index{N\_VGetLength\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VGetLength_Serial}\pysiglinewithargsret{sunindextype \bfcode{N\_VGetLength\_Serial}}{N\_Vector\emph{ v}}{}
This function returns the number of vector elements.

\end{fulllineitems}

\index{N\_VPrint\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VPrint_Serial}\pysiglinewithargsret{void \bfcode{N\_VPrint\_Serial}}{N\_Vector\emph{ v}}{}
This function prints the content of a serial vector to \code{stdout}.
\end{fulllineitems}

\index{N\_VPrintFile\_Serial (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Serial:c.N_VPrintFile_Serial}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_Serial}}{N\_Vector\emph{ v}, FILE\emph{ *outfile}}{}
This function prints the content of a serial vector to \code{outfile}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \code{N\_Vector v}, it is more
efficient to first obtain the component array via \code{v\_data =
NV\_DATA\_S(v)} and then access \code{v\_data{[}i{]}} within the loop than it
is to use \code{NV\_Ith\_S(v,i)} within the loop.

\item {} 
{\hyperref[nvectors/NVector_Serial:c.N_VNewEmpty_Serial]{\emph{\code{N\_VNewEmpty\_Serial()}}}}, {\hyperref[nvectors/NVector_Serial:c.N_VMake_Serial]{\emph{\code{N\_VMake\_Serial()}}}}, and
{\hyperref[nvectors/NVector_Serial:c.N_VCloneVectorArrayEmpty_Serial]{\emph{\code{N\_VCloneVectorArrayEmpty\_Serial()}}}} set the field \emph{own\_data}
to \code{SUNFALSE}.  The functions \code{N\_VDestroy\_Serial()} and
{\hyperref[nvectors/NVector_Serial:c.N_VDestroyVectorArray_Serial]{\emph{\code{N\_VDestroyVectorArray\_Serial()}}}} will not attempt to free the
pointer data for any \code{N\_Vector} with \emph{own\_data} set to \code{SUNFALSE}.
In such a case, it is the user's responsibility to deallocate the
data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_SERIAL
implementation that have more than one \code{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user's responsibility to ensure that such routines are called
with \code{N\_Vector} arguments that were all created with the same
length.

\end{itemize}

For solvers that include a Fortran interface module, the
NVECTOR\_SERIAL module also includes a Fortran-callable function
\code{FNVINITS(code, NEQ, IER)}, to initialize this NVECTOR\_SERIAL
module.  Here \code{code} is an input solver id (1 for CVODE, 2 for IDA,
3 for KINSOL, 4 for ARKode); \code{NEQ} is the problem size (declared so
as to match C type \code{long int}); and \code{IER} is an error return flag
equal 0 for success and -1 for failure.


\section{The NVECTOR\_PARALLEL Module}
\label{nvectors/NVector_Parallel:nvectors-nvparallel}\label{nvectors/NVector_Parallel:the-nvector-parallel-module}\label{nvectors/NVector_Parallel::doc}
The NVECTOR\_PARALLEL implementation of the NVECTOR module provided with
SUNDIALS is based on MPI.  It defines the \emph{content} field of a
\code{N\_Vector} to be a structure containing the global and local lengths
of the vector, a pointer to the beginning of a contiguous local data
array, an MPI communicator, an a boolean flag \emph{own\_data} indicating
ownership of the data array \emph{data}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Parallel} \PYG{p}{\PYGZob{}}
   \PYG{n}{sunindextype} \PYG{n}{local\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{sunindextype} \PYG{n}{global\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
   \PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{comm}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The header file to be included when using this module is
\code{nvector\_parallel.h}.

The following seven macros are provided to access the content of a
NVECTOR\_PARALLEL vector. The suffix \code{\_P} in the names denotes the
distributed memory parallel version.
\index{NV\_CONTENT\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.NV_CONTENT_P}\pysiglinewithargsret{\bfcode{NV\_CONTENT\_P}}{v}{}
This macro gives access to the contents of the parallel
\code{N\_Vector} \emph{v}.

The assignment \code{v\_cont = NV\_CONTENT\_P(v)} sets \code{v\_cont} to be a
pointer to the \code{N\_Vector} \emph{content} structure of type \code{struct
N\_VectorContent\_Parallel}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}P(v) ( (N\PYGZus{}VectorContent\PYGZus{}Parallel)(v\PYGZhy{}\PYGZgt{}content) )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.NV_OWN_DATA_P}\pysiglinewithargsret{\bfcode{NV\_OWN\_DATA\_P}}{v}{}
Access the \emph{own\_data} component of the parallel \code{N\_Vector} \emph{v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}P(v)   ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_DATA\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.NV_DATA_P}\pysiglinewithargsret{\bfcode{NV\_DATA\_P}}{v}{}
The assignment \code{v\_data = NV\_DATA\_P(v)} sets \code{v\_data} to be a
pointer to the first component of the \emph{local\_data} for the
\code{N\_Vector v}.

The assignment \code{NV\_DATA\_P(v) = v\_data} sets the component array of
\code{v} to be \code{v\_data} by storing the pointer \code{v\_data} into
\emph{data}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}P(v)       ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_LOCLENGTH\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.NV_LOCLENGTH_P}\pysiglinewithargsret{\bfcode{NV\_LOCLENGTH\_P}}{v}{}
The assignment \code{v\_llen = NV\_LOCLENGTH\_P(v)} sets \code{v\_llen} to be
the length of the local part of \code{v}.

The call \code{NV\_LOCLENGTH\_P(v) = llen\_v} sets the \emph{local\_length} of
\code{v} to be \code{llen\_v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LOCLENGTH\PYGZus{}P(v)  ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}local\PYGZus{}length )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_GLOBLENGTH\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.NV_GLOBLENGTH_P}\pysiglinewithargsret{\bfcode{NV\_GLOBLENGTH\_P}}{v}{}
The assignment \code{v\_glen = NV\_GLOBLENGTH\_P(v)} sets \code{v\_glen} to be
the \emph{global\_length} of the vector \code{v}.

The call \code{NV\_GLOBLENGTH\_P(v) = glen\_v} sets the \emph{global\_length}
of \code{v} to be \code{glen\_v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}GLOBLENGTH\PYGZus{}P(v) ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}global\PYGZus{}length )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_COMM\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.NV_COMM_P}\pysiglinewithargsret{\bfcode{NV\_COMM\_P}}{v}{}
This macro provides access to the MPI communicator used by the
parallel \code{N\_Vector} \emph{v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}COMM\PYGZus{}P(v) ( NV\PYGZus{}CONTENT\PYGZus{}P(v)\PYGZhy{}\PYGZgt{}comm )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_Ith\_P (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.NV_Ith_P}\pysiglinewithargsret{\bfcode{NV\_Ith\_P}}{v, i}{}
This macro gives access to the individual components of the
\emph{local\_data} array of an \code{N\_Vector}.

The assignment \code{r = NV\_Ith\_P(v,i)} sets \code{r} to be the value of
the \code{i}-th component of the local part of \code{v}.

The assignment \code{NV\_Ith\_P(v,i) = r} sets the value of the \code{i}-th
component of the local part of \code{v} to be \code{r}.

Here \code{i} ranges from 0 to \(n-1\), where \(n\) is the
\emph{local\_length}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}P(v,i) ( NV\PYGZus{}DATA\PYGZus{}P(v)[i] )}
\end{Verbatim}

\end{fulllineitems}


The NVECTOR\_PARALLEL module defines parallel implementations of all
vector operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}.  Their
names are obtained from those that section by appending the suffix
\code{\_Parallel} (e.g. \code{N\_VDestroy\_Parallel}).   The module
NVECTOR\_PARALLEL provides the following additional user-callable
routines:
\index{N\_VNew\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VNew_Parallel}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNew\_Parallel}}{MPI\_Comm\emph{ comm}, sunindextype\emph{ local\_length}, sunindextype\emph{ global\_length}}{}
This function creates and allocates memory for a parallel vector
having global length \emph{global\_length}, having processor-local length
\emph{local\_length}, and using the MPI communicator \emph{comm}.

\end{fulllineitems}

\index{N\_VNewEmpty\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VNewEmpty_Parallel}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_Parallel}}{MPI\_Comm\emph{ comm}, sunindextype\emph{ local\_length}, sunindextype\emph{ global\_length}}{}
This function creates a new parallel \code{N\_Vector} with an empty
(\code{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VMake_Parallel}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_Parallel}}{MPI\_Comm\emph{ comm}, sunindextype\emph{ local\_length}, sunindextype\emph{ global\_length}, realtype*\emph{ v\_data}}{}
This function creates and allocates memory for a parallel vector
with user-provided data array.

(This function does \emph{not} allocate memory for \code{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VCloneVectorArray_Parallel}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_Parallel}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} parallel vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VCloneVectorArrayEmpty_Parallel}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_Parallel}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} parallel
vectors, each with an empty (\code{NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VDestroyVectorArray_Parallel}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_Parallel}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_Parallel:c.N_VCloneVectorArray_Parallel]{\emph{\code{N\_VCloneVectorArray\_Parallel()}}}} or with
{\hyperref[nvectors/NVector_Parallel:c.N_VCloneVectorArrayEmpty_Parallel]{\emph{\code{N\_VCloneVectorArrayEmpty\_Parallel()}}}}.

\end{fulllineitems}

\index{N\_VGetLength\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VGetLength_Parallel}\pysiglinewithargsret{sunindextype \bfcode{N\_VGetLength\_Parallel}}{N\_Vector\emph{ v}}{}
This function returns the number of vector elements (global vector length).

\end{fulllineitems}

\index{N\_VGetLocalLength\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VGetLocalLength_Parallel}\pysiglinewithargsret{sunindextype \bfcode{N\_VGetLocalLength\_Parallel}}{N\_Vector\emph{ v}}{}
This function returns the local vector length.

\end{fulllineitems}

\index{N\_VPrint\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VPrint_Parallel}\pysiglinewithargsret{void \bfcode{N\_VPrint\_Parallel}}{N\_Vector\emph{ v}}{}
This function prints the local content of a parallel vector to \code{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Parallel (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Parallel:c.N_VPrintFile_Parallel}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_Parallel}}{N\_Vector\emph{ v}, FILE\emph{ *outfile}}{}
This function prints the local content of a parallel vector to \code{outfile}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \code{N\_Vector v}, it is
more efficient to first obtain the local component array via \code{v\_data
= NV\_DATA\_P(v)} and then access \code{v\_data{[}i{]}} within the loop than it
is to use \code{NV\_Ith\_P(v,i)} within the loop.

\item {} 
{\hyperref[nvectors/NVector_Parallel:c.N_VNewEmpty_Parallel]{\emph{\code{N\_VNewEmpty\_Parallel()}}}}, {\hyperref[nvectors/NVector_Parallel:c.N_VMake_Parallel]{\emph{\code{N\_VMake\_Parallel()}}}}, and
{\hyperref[nvectors/NVector_Parallel:c.N_VCloneVectorArrayEmpty_Parallel]{\emph{\code{N\_VCloneVectorArrayEmpty\_Parallel()}}}} set the field \emph{own\_data} to
\code{SUNFALSE}. The routines \code{N\_VDestroy\_Parallel()} and
{\hyperref[nvectors/NVector_Parallel:c.N_VDestroyVectorArray_Parallel]{\emph{\code{N\_VDestroyVectorArray\_Parallel()}}}} will not attempt to free the
pointer data for any \code{N\_Vector} with \emph{own\_data} set to
\code{SUNFALSE}. In such a case, it is the user's responsibility to
deallocate the data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PARALLEL
implementation that have more than one \code{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user's responsibility to ensure that such routines are called
with \code{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}

For solvers that include a Fortran interface module, the
NVECTOR\_PARALLEL module also includes a Fortran-callable function
\code{FNVINITP(COMM, code, NLOCAL, NGLOBAL, IER)}, to initialize this
NVECTOR\_PARALLEL module.  Here \code{COMM} is the MPI communicator,
\code{code} is an input solver id (1 for CVODE, 2 for IDA, 3 for KINSOL,
4 for ARKode); \code{NLOCAL} and \code{NGLOBAL} are the local and global
vector sizes, respectively (declared so as to match C type \code{long
int}); and \code{IER} is an error return flag equal 0 for success and -1
for failure.

\begin{notice}{note}{Note:}
If the header file \code{sundials\_config.h} defines
\code{SUNDIALS\_MPI\_COMM\_F2C} to be 1 (meaning the MPI implementation
used to build SUNDIALS includes the \code{MPI\_Comm\_f2c} function),
then \code{COMM} can be any valid MPI communicator. Otherwise,
\code{MPI\_COMM\_WORLD} will be used, so just pass an integer value as a
placeholder.
\end{notice}


\section{The NVECTOR\_OPENMP Module}
\label{nvectors/NVector_OpenMP:the-nvector-openmp-module}\label{nvectors/NVector_OpenMP::doc}\label{nvectors/NVector_OpenMP:nvectors-openmp}
In situations where a user has a multi-core processing unit capable of
running multiple parallel threads with shared memory, SUNDIALS provides
an implementation of NVECTOR using OpenMP, called NVECTOR\_OPENMP, and
an implementation using Pthreads, called NVECTOR\_PTHREADS. Testing has
shown that vectors should be of length at least \(100,000\) before
the overhead associated with creating and using the threads is made up
by the parallelism in the vector calculations.

The OpenMP NVECTOR implementation provided with SUNDIALS,
NVECTOR\_OPENMP, defines the \emph{content} field of \code{N\_Vector} to be a structure
containing the length of the vector, a pointer to the beginning of a contiguous
data array, a boolean flag \emph{own\_data} which specifies the ownership of
\emph{data}, and the number of threads.  Operations on the vector are
threaded using OpenMP, the number of threads used is based on the
supplied argument in the vector constructor.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}OpenMP} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{num\PYGZus{}threads}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The header file to be included when using this module is \code{nvector\_openmp.h}.

The following six macros are provided to access the content of an NVECTOR\_OPENMP
vector. The suffix \code{\_OMP} in the names denotes the OpenMP version.
\index{NV\_CONTENT\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.NV_CONTENT_OMP}\pysiglinewithargsret{\bfcode{NV\_CONTENT\_OMP}}{v}{}
This macro gives access to the contents of the OpenMP vector
\code{N\_Vector} \emph{v}.

The assignment \code{v\_cont = NV\_CONTENT\_OMP(v)} sets \code{v\_cont} to be
a pointer to the OpenMP \code{N\_Vector} content structure.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}OMP(v) ( (N\PYGZus{}VectorContent\PYGZus{}OpenMP)(v\PYGZhy{}\PYGZgt{}content) )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.NV_OWN_DATA_OMP}\pysiglinewithargsret{\bfcode{NV\_OWN\_DATA\_OMP}}{v}{}
Access the \emph{own\_data} component of the OpenMP \code{N\_Vector} \emph{v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_DATA\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.NV_DATA_OMP}\pysiglinewithargsret{\bfcode{NV\_DATA\_OMP}}{v}{}
The assignment \code{v\_data = NV\_DATA\_OMP(v)} sets \code{v\_data} to be a
pointer to the first component of the \emph{data} for the \code{N\_Vector}
\code{v}.

Similarly, the assignment \code{NV\_DATA\_OMP(v) = v\_data} sets the component
array of \code{v} to be \code{v\_data} by storing the pointer \code{v\_data}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_LENGTH\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.NV_LENGTH_OMP}\pysiglinewithargsret{\bfcode{NV\_LENGTH\_OMP}}{v}{}
Access the \emph{length} component of the OpenMP \code{N\_Vector} \emph{v}.

The assignment \code{v\_len = NV\_LENGTH\_OMP(v)} sets \code{v\_len} to be the
\emph{length} of \code{v}. On the other hand, the call \code{NV\_LENGTH\_OMP(v) =
len\_v} sets the \emph{length} of \code{v} to be \code{len\_v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LENGTH\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}length )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_NUM\_THREADS\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.NV_NUM_THREADS_OMP}\pysiglinewithargsret{\bfcode{NV\_NUM\_THREADS\_OMP}}{v}{}
Access the \emph{num\_threads} component of the OpenMP \code{N\_Vector} \emph{v}.

The assignment \code{v\_threads = NV\_NUM\_THREADS\_OMP(v)} sets
\code{v\_threads} to be the \emph{num\_threads} of \code{v}. On the other hand,
the call \code{NV\_NUM\_THREADS\_OMP(v) = num\_threads\_v} sets the
\emph{num\_threads} of \code{v} to be \code{num\_threads\_v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}NUM\PYGZus{}THREADS\PYGZus{}OMP(v) ( NV\PYGZus{}CONTENT\PYGZus{}OMP(v)\PYGZhy{}\PYGZgt{}num\PYGZus{}threads )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_Ith\_OMP (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.NV_Ith_OMP}\pysiglinewithargsret{\bfcode{NV\_Ith\_OMP}}{v, i}{}
This macro gives access to the individual components of the \emph{data}
array of an \code{N\_Vector}, using standard 0-based C indexing.

The assignment \code{r = NV\_Ith\_OMP(v,i)} sets \code{r} to be the value of
the \code{i}-th component of \code{v}.

The assignment \code{NV\_Ith\_OMP(v,i) = r} sets the value of the \code{i}-th
component of \code{v} to be \code{r}.

Here \code{i} ranges from 0 to \(n-1\) for a vector of length
\(n\).

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}OMP(v,i) ( NV\PYGZus{}DATA\PYGZus{}OMP(v)[i] )}
\end{Verbatim}

\end{fulllineitems}


The NVECTOR\_OPENMP module defines OpenMP implementations of all vector
operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}.  Their names are
obtained from those in that section by appending the suffix
\code{\_OpenMP} (e.g. \code{N\_VDestroy\_OpenMP}).  The module NVECTOR\_OPENMP
provides the following additional user-callable routines:
\index{N\_VNew\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VNew_OpenMP}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNew\_OpenMP}}{sunindextype\emph{ vec\_length}, int\emph{ num\_threads}}{}
This function creates and allocates memory for a OpenMP
\code{N\_Vector}. Arguments are the vector length and number of threads.

\end{fulllineitems}

\index{N\_VNewEmpty\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VNewEmpty_OpenMP}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_OpenMP}}{sunindextype\emph{ vec\_length}, int\emph{ num\_threads}}{}
This function creates a new OpenMP \code{N\_Vector} with an empty
(\code{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VMake_OpenMP}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_OpenMP}}{sunindextype\emph{ vec\_length}, realtype*\emph{ v\_data}, int\emph{ num\_threads}}{}
This function creates and allocates memory for a OpenMP vector with
user-provided data array, \emph{v\_data}.

(This function does \emph{not} allocate memory for \code{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VCloneVectorArray_OpenMP}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_OpenMP}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} OpenMP
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VCloneVectorArrayEmpty_OpenMP}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_OpenMP}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} OpenMP
vectors, each with an empty (\code{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VDestroyVectorArray_OpenMP}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_OpenMP}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_OpenMP:c.N_VCloneVectorArray_OpenMP]{\emph{\code{N\_VCloneVectorArray\_OpenMP()}}}} or with
{\hyperref[nvectors/NVector_OpenMP:c.N_VCloneVectorArrayEmpty_OpenMP]{\emph{\code{N\_VCloneVectorArrayEmpty\_OpenMP()}}}}.

\end{fulllineitems}

\index{N\_VGetLength\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VGetLength_OpenMP}\pysiglinewithargsret{sunindextype \bfcode{N\_VGetLength\_OpenMP}}{N\_Vector\emph{ v}}{}
This function returns the number of vector elements.

\end{fulllineitems}

\index{N\_VPrint\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VPrint_OpenMP}\pysiglinewithargsret{void \bfcode{N\_VPrint\_OpenMP}}{N\_Vector\emph{ v}}{}
This function prints the content of an OpenMP vector to \code{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_OpenMP (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_OpenMP:c.N_VPrintFile_OpenMP}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_OpenMP}}{N\_Vector\emph{ v}, FILE\emph{ *outfile}}{}
This function prints the content of an OpenMP vector to \code{outfile}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \code{N\_Vector v}, it is more
efficient to first obtain the component array via \code{v\_data =
NV\_DATA\_OMP(v)} and then access \code{v\_data{[}i{]}} within the loop than it
is to use \code{NV\_Ith\_OMP(v,i)} within the loop.

\item {} 
{\hyperref[nvectors/NVector_OpenMP:c.N_VNewEmpty_OpenMP]{\emph{\code{N\_VNewEmpty\_OpenMP()}}}}, {\hyperref[nvectors/NVector_OpenMP:c.N_VMake_OpenMP]{\emph{\code{N\_VMake\_OpenMP()}}}}, and
{\hyperref[nvectors/NVector_OpenMP:c.N_VCloneVectorArrayEmpty_OpenMP]{\emph{\code{N\_VCloneVectorArrayEmpty\_OpenMP()}}}} set the field \emph{own\_data}
to \code{SUNFALSE}.  The functions \code{N\_VDestroy\_OpenMP()} and
{\hyperref[nvectors/NVector_OpenMP:c.N_VDestroyVectorArray_OpenMP]{\emph{\code{N\_VDestroyVectorArray\_OpenMP()}}}} will not attempt to free the
pointer data for any \code{N\_Vector} with \emph{own\_data} set to \code{SUNFALSE}.
In such a case, it is the user's responsibility to deallocate the
data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_OPENMP
implementation that have more than one \code{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user's responsibility to ensure that such routines are called
with \code{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}

For solvers that include a Fortran interface module, the
NVECTOR\_OPENMP module also includes a Fortran-callable function
\code{FNVINITOMP(code, NEQ, NUMTHREADS, IER)}, to initialize this
NVECTOR\_OPENMP module.  Here \code{code} is an input solver id (1 for
CVODE, 2 for IDA, 3 for KINSOL, 4 for ARKode); \code{NEQ} is the problem
size (declared so as to match C type \code{long int}); \code{NUMTHREADS} is
the number of threads; and \code{IER} is an error return flag equal 0 for
success and -1 for failure.


\section{The NVECTOR\_PTHREADS Module}
\label{nvectors/NVector_Pthreads:nvectors-pthreads}\label{nvectors/NVector_Pthreads::doc}\label{nvectors/NVector_Pthreads:the-nvector-pthreads-module}
In situations where a user has a multi-core processing unit capable of
running multiple parallel threads with shared memory, SUNDIALS
provides an implementation of NVECTOR using OpenMP, called
NVECTOR\_OPENMP, and an implementation using Pthreads, called
NVECTOR\_PTHREADS.  Testing has shown that vectors should be of length
at least \(100,000\) before the overhead associated with creating
and using the threads is made up by the parallelism in the vector calculations.

The Pthreads NVECTOR implementation provided with SUNDIALS, denoted
NVECTOR\_PTHREADS, defines the \emph{content} field of \code{N\_Vector} to be a structure
containing the length of the vector, a pointer to the beginning of a contiguous
data array, a boolean flag \emph{own\_data} which specifies the ownership
of \emph{data}, and the number of threads.  Operations on the vector are
threaded using POSIX threads (Pthreads), the number of threads used is
based on the supplied argument in the vector constructor.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Pthreads} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{length}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{num\PYGZus{}threads}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The header file to be included when using this module is \code{nvector\_pthreads.h}.

The following six macros are provided to access the content of an NVECTOR\_PTHREADS
vector. The suffix \code{\_PT} in the names denotes the Pthreads version.
\index{NV\_CONTENT\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.NV_CONTENT_PT}\pysiglinewithargsret{\bfcode{NV\_CONTENT\_PT}}{v}{}
This macro gives access to the contents of the Pthreads vector
\code{N\_Vector} \emph{v}.

The assignment \code{v\_cont = NV\_CONTENT\_PT(v)} sets \code{v\_cont} to be
a pointer to the Pthreads \code{N\_Vector} content structure.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}CONTENT\PYGZus{}PT(v) ( (N\PYGZus{}VectorContent\PYGZus{}Pthreads)(v\PYGZhy{}\PYGZgt{}content) )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_OWN\_DATA\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.NV_OWN_DATA_PT}\pysiglinewithargsret{\bfcode{NV\_OWN\_DATA\_PT}}{v}{}
Access the \emph{own\_data} component of the Pthreads \code{N\_Vector} \emph{v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}OWN\PYGZus{}DATA\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}own\PYGZus{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_DATA\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.NV_DATA_PT}\pysiglinewithargsret{\bfcode{NV\_DATA\_PT}}{v}{}
The assignment \code{v\_data = NV\_DATA\_PT(v)} sets \code{v\_data} to be a
pointer to the first component of the \emph{data} for the \code{N\_Vector}
\code{v}.

Similarly, the assignment \code{NV\_DATA\_PT(v) = v\_data} sets the component
array of \code{v} to be \code{v\_data} by storing the pointer \code{v\_data}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}DATA\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_LENGTH\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.NV_LENGTH_PT}\pysiglinewithargsret{\bfcode{NV\_LENGTH\_PT}}{v}{}
Access the \emph{length} component of the Pthreads \code{N\_Vector} \emph{v}.

The assignment \code{v\_len = NV\_LENGTH\_PT(v)} sets \code{v\_len} to be the
\emph{length} of \code{v}. On the other hand, the call \code{NV\_LENGTH\_PT(v) =
len\_v} sets the \emph{length} of \code{v} to be \code{len\_v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}LENGTH\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}length )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_NUM\_THREADS\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.NV_NUM_THREADS_PT}\pysiglinewithargsret{\bfcode{NV\_NUM\_THREADS\_PT}}{v}{}
Access the \emph{num\_threads} component of the Pthreads \code{N\_Vector} \emph{v}.

The assignment \code{v\_threads = NV\_NUM\_THREADS\_PT(v)} sets
\code{v\_threads} to be the \emph{num\_threads} of \code{v}. On the other hand,
the call \code{NV\_NUM\_THREADS\_PT(v) = num\_threads\_v} sets the
\emph{num\_threads} of \code{v} to be \code{num\_threads\_v}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}NUM\PYGZus{}THREADS\PYGZus{}PT(v) ( NV\PYGZus{}CONTENT\PYGZus{}PT(v)\PYGZhy{}\PYGZgt{}num\PYGZus{}threads )}
\end{Verbatim}

\end{fulllineitems}

\index{NV\_Ith\_PT (C macro)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.NV_Ith_PT}\pysiglinewithargsret{\bfcode{NV\_Ith\_PT}}{v, i}{}
This macro gives access to the individual components of the \emph{data}
array of an \code{N\_Vector}, using standard 0-based C indexing.

The assignment \code{r = NV\_Ith\_PT(v,i)} sets \code{r} to be the value of
the \code{i}-th component of \code{v}.

The assignment \code{NV\_Ith\_PT(v,i) = r} sets the value of the \code{i}-th
component of \code{v} to be \code{r}.

Here \code{i} ranges from 0 to \(n-1\) for a vector of length
\(n\).

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define NV\PYGZus{}Ith\PYGZus{}PT(v,i) ( NV\PYGZus{}DATA\PYGZus{}PT(v)[i] )}
\end{Verbatim}

\end{fulllineitems}


The NVECTOR\_PTHREADS module defines Pthreads implementations of all vector
operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}.  Their names are
obtained from those in that section by appending the suffix
\code{\_Pthreads} (e.g. N\_VDestroy\_Pthreads).  The module NVECTOR\_PTHREADS
provides the following additional user-callable routines:
\index{N\_VNew\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VNew_Pthreads}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNew\_Pthreads}}{sunindextype\emph{ vec\_length}, int\emph{ num\_threads}}{}
This function creates and allocates memory for a Pthreads
\code{N\_Vector}. Arguments are the vector length and number of threads.

\end{fulllineitems}

\index{N\_VNewEmpty\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VNewEmpty_Pthreads}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_Pthreads}}{sunindextype\emph{ vec\_length}, int\emph{ num\_threads}}{}
This function creates a new Pthreads \code{N\_Vector} with an empty
(\code{NULL}) data array.

\end{fulllineitems}

\index{N\_VMake\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VMake_Pthreads}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_Pthreads}}{sunindextype\emph{ vec\_length}, realtype*\emph{ v\_data}, int\emph{ num\_threads}}{}
This function creates and allocates memory for a Pthreads vector with
user-provided data array, \emph{v\_data}.

(This function does \emph{not} allocate memory for \code{v\_data} itself.)

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VCloneVectorArray_Pthreads}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_Pthreads}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} Pthreads
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VCloneVectorArrayEmpty_Pthreads}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_Pthreads}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} Pthreads
vectors, each with an empty (\code{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VDestroyVectorArray_Pthreads}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_Pthreads}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_Pthreads:c.N_VCloneVectorArray_Pthreads]{\emph{\code{N\_VCloneVectorArray\_Pthreads()}}}} or with
{\hyperref[nvectors/NVector_Pthreads:c.N_VCloneVectorArrayEmpty_Pthreads]{\emph{\code{N\_VCloneVectorArrayEmpty\_Pthreads()}}}}.

\end{fulllineitems}

\index{N\_VGetLength\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VGetLength_Pthreads}\pysiglinewithargsret{sunindextype \bfcode{N\_VGetLength\_Pthreads}}{N\_Vector\emph{ v}}{}
This function returns the number of vector elements.

\end{fulllineitems}

\index{N\_VPrint\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VPrint_Pthreads}\pysiglinewithargsret{void \bfcode{N\_VPrint\_Pthreads}}{N\_Vector\emph{ v}}{}
This function prints the content of a Pthreads vector to \code{stdout}.
\end{fulllineitems}

\index{N\_VPrintFile\_Pthreads (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_Pthreads:c.N_VPrintFile_Pthreads}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_Pthreads}}{N\_Vector\emph{ v}, FILE\emph{ *outfile}}{}
This function prints the content of a Pthreads vector to \code{outfile}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When looping over the components of an \code{N\_Vector v}, it is more
efficient to first obtain the component array via \code{v\_data =
NV\_DATA\_PT(v)} and then access \code{v\_data{[}i{]}} within the loop than it
is to use \code{NV\_Ith\_S(v,i)} within the loop.

\item {} 
{\hyperref[nvectors/NVector_Pthreads:c.N_VNewEmpty_Pthreads]{\emph{\code{N\_VNewEmpty\_Pthreads()}}}}, {\hyperref[nvectors/NVector_Pthreads:c.N_VMake_Pthreads]{\emph{\code{N\_VMake\_Pthreads()}}}}, and
{\hyperref[nvectors/NVector_Pthreads:c.N_VCloneVectorArrayEmpty_Pthreads]{\emph{\code{N\_VCloneVectorArrayEmpty\_Pthreads()}}}} set the field \emph{own\_data}
to \code{SUNFALSE}.  The functions \code{N\_VDestroy\_Pthreads()} and
{\hyperref[nvectors/NVector_Pthreads:c.N_VDestroyVectorArray_Pthreads]{\emph{\code{N\_VDestroyVectorArray\_Pthreads()}}}} will not attempt to free the
pointer data for any \code{N\_Vector} with \emph{own\_data} set to \code{SUNFALSE}.
In such a case, it is the user's responsibility to deallocate the
data pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PTHREADS
implementation that have more than one \code{N\_Vector} argument do not
check for consistent internal representation of these vectors. It is
the user's responsibility to ensure that such routines are called
with \code{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}

For solvers that include a Fortran interface module, the
NVECTOR\_PTHREADS module slso includes a Fortran-callable function
\code{FNVINITPTS(code, NEQ, NUMTHREADS, IER)}, to initialize this
NVECTOR\_PTHREADS module.  Here \code{code} is an input solver id
(1 for CVODE, 2 for IDA, 3 for KINSOL, 4 for ARKode); \code{NEQ} is
the problem size (declared so as to match C type \code{long int});
\code{NUMTHREADS} is the number of threads; and \code{IER} is an error
return flag equal 0 for success and -1 for failure.


\section{The NVECTOR\_PARHYP Module}
\label{nvectors/NVector_ParHyp:nvectors-parhyp}\label{nvectors/NVector_ParHyp:the-nvector-parhyp-module}\label{nvectors/NVector_ParHyp::doc}
The NVECTOR\_PARHYP implementation of the NVECTOR  module provided with
SUNDIALS is a wrapper around HYPRE's ParVector class.
Most of the vector kernels simply call HYPRE vector operations.
The implementation defines the \emph{content} field of \code{N\_Vector} to
be a structure containing the global and local lengths of the vector, a
pointer to an object of type \code{hypre\_ParVector}, an MPI communicator,
and a boolean flag \emph{own\_parvector} indicating ownership of the
HYPRE parallel vector object \emph{x}.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}ParHyp} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{local\PYGZus{}length}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{global\PYGZus{}length}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
  \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}parvector}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{comm}\PYG{p}{;}
  \PYG{n}{hypre\PYGZus{}ParVector} \PYG{o}{*}\PYG{n}{x}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The header file to be included when using this module is \code{nvector\_parhyp.h}.
Unlike native SUNDIALS vector types, NVECTOR\_PARHYP does not provide macros
to access its member variables.

The NVECTOR\_PARHYP module defines implementations of all vector
operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}, except for
\code{N\_VSetArrayPointer} and \code{N\_VGetArrayPointer}, because accessing
raw vector data is handled by low-level HYPRE functions.  As such,
this vector is not available for use with SUNDIALS Fortran
interfaces.  When access to raw vector data is needed, one should
extract the HYPRE HYPRE vector first, and then use HYPRE methods to
access the data.  Usage examples of NVECTOR\_PARHYP are provided in
the \code{cvAdvDiff\_non\_ph.c} example programs for CVODE and the
\code{ark\_diurnal\_kry\_ph.c} example program for ARKode.

The names of parhyp methods are obtained from those in the section
{\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}} by appending the suffix \code{\_ParHyp}
(e.g. \code{N\_VDestroy\_ParHyp}).  The module \{nvecph\} provides the
following additional user-callable routines:
\index{N\_VNewEmpty\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VNewEmpty_ParHyp}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_ParHyp}}{MPI\_Comm\emph{ comm}, sunindextype\emph{ local\_length}, sunindextype\emph{ global\_length}}{}
This function creates a new parhyp \code{N\_Vector} with the pointer to the
HYPRE vector set to \code{NULL}.

\end{fulllineitems}

\index{N\_VMake\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VMake_ParHyp}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_ParHyp}}{hypre\_ParVector\emph{ *x}}{}
This function creates an \code{N\_Vector} wrapper around an existing
HYPRE parallel vector.  It does \emph{not} allocate memory for \code{x} itself.

\end{fulllineitems}

\index{N\_VGetVector\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VGetVector_ParHyp}\pysiglinewithargsret{hypre\_ParVector *\bfcode{N\_VGetVector\_ParHyp}}{N\_Vector\emph{ v}}{}
This function returns a pointer to the underlying HYPRE vector.

\end{fulllineitems}

\index{N\_VCloneVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VCloneVectorArray_ParHyp}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_ParHyp}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} parhyp
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VCloneVectorArrayEmpty_ParHyp}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_ParHyp}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} parhyp
vectors, each with an empty (\code{{}`NULL}) data array.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VDestroyVectorArray_ParHyp}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_ParHyp}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_ParHyp:c.N_VCloneVectorArray_ParHyp]{\emph{\code{N\_VCloneVectorArray\_ParHyp()}}}} or with
{\hyperref[nvectors/NVector_ParHyp:c.N_VCloneVectorArrayEmpty_ParHyp]{\emph{\code{N\_VCloneVectorArrayEmpty\_ParHyp()}}}}.

\end{fulllineitems}

\index{N\_VPrint\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VPrint_ParHyp}\pysiglinewithargsret{void \bfcode{N\_VPrint\_ParHyp}}{N\_Vector\emph{ v}}{}
This function prints the local content of a parhyp vector to \code{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_ParHyp (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_ParHyp:c.N_VPrintFile_ParHyp}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_ParHyp}}{N\_Vector\emph{ v}, FILE\emph{ *outfile}}{}
This function prints the local content of a parhyp vector to \code{outfile}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \code{N\_Vector\_ParHyp v},
it is recommended to extract the HYPRE vector via
\code{x\_vec = N\_VGetVector\_ParHyp(v)} and then access components using
appropriate HYPRE functions.

\item {} 
{\hyperref[nvectors/NVector_ParHyp:c.N_VNewEmpty_ParHyp]{\emph{\code{N\_VNewEmpty\_ParHyp()}}}}, {\hyperref[nvectors/NVector_ParHyp:c.N_VMake_ParHyp]{\emph{\code{N\_VMake\_ParHyp()}}}}, and
{\hyperref[nvectors/NVector_ParHyp:c.N_VCloneVectorArrayEmpty_ParHyp]{\emph{\code{N\_VCloneVectorArrayEmpty\_ParHyp()}}}} set the field \emph{own\_parvector}
to \code{SUNFALSE}.  The functions \code{N\_VDestroy\_ParHyp()} and
{\hyperref[nvectors/NVector_ParHyp:c.N_VDestroyVectorArray_ParHyp]{\emph{\code{N\_VDestroyVectorArray\_ParHyp()}}}} will not attempt to delete an
underlying HYPRE vector for any \code{N\_Vector} with \emph{own\_parvector}
set to \code{SUNFALSE}.  In such a case, it is the user's responsibility
to delete the underlying vector.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PARHYP
implementation that have more than one \code{N\_Vector} argument do not
check for consistent internal representations of these vectors. It is
the user's responsibility to ensure that such routines are called
with \code{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}


\section{The NVECTOR\_PETSC Module}
\label{nvectors/NVector_PETSc:nvectors-nvpetsc}\label{nvectors/NVector_PETSc:the-nvector-petsc-module}\label{nvectors/NVector_PETSc::doc}
The NVECTOR\_PETSC module is an NVECTOR wrapper around the PETSc vector. It
defines the \emph{content} field of a \code{N\_Vector} to be a structure
containing the global and local lengths of the vector, a pointer to
the PETSc vector, an MPI communicator, and a boolean flag  \emph{own\_data}
indicating ownership of the wrapped PETSc vector.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Petsc} \PYG{p}{\PYGZob{}}
   \PYG{n}{sunindextype} \PYG{n}{local\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{sunindextype} \PYG{n}{global\PYGZus{}length}\PYG{p}{;}
   \PYG{n}{booleantype} \PYG{n}{own\PYGZus{}data}\PYG{p}{;}
   \PYG{n}{Vec} \PYG{o}{*}\PYG{n}{pvec}\PYG{p}{;}
   \PYG{n}{MPI\PYGZus{}Comm} \PYG{n}{comm}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The header file to be included when using this module is
\code{nvector\_petsc.h}.  Unlike native SUNDIALS vector types,
NVECTOR\_PETSC does not provide macros to access its member variables.
Note that NVECTOR\_PETSC requires SUNDIALS to be built with MPI support.

The NVECTOR\_PETSC module defines implementations of all vector
operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}, except for
\code{N\_VGetArrayPointer} and \code{N\_VSetArrayPointer}.  As such, this
vector cannot be used with SUNDIALS Fortran interfaces.  When access
to raw vector data is needed, it is recommended to extract the PETSc
vector first, and then use PETSc methods to access the data.  Usage
examples of NVECTOR\_PETSC is provided in example programs for IDA.

The names of vector operations are obtained from those in the section
{\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}} by appending the suffice \code{\_Petsc}
(e.g. \code{N\_VDestroy\_Petsc}).  The module NVECTOR\_PETSC provides the
following additional user-callable routines:
\index{N\_VNewEmpty\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VNewEmpty_Petsc}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_Petsc}}{MPI\_Comm\emph{ comm}, sunindextype\emph{ local\_length}, sunindextype\emph{ global\_length}}{}
This function creates a new PETSC \code{N\_Vector} with the pointer to
the wrapped PETSc vector set to \code{NULL}. It is used by the
\code{N\_VMake\_Petsc} and \code{N\_VClone\_Petsc} implementations.  It
should be used only with great caution.

\end{fulllineitems}

\index{N\_VMake\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VMake_Petsc}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_Petsc}}{Vec*\emph{ pvec}}{}
This function creates and allocates memory for an NVECTOR\_PETSC
wrapper with a user-provided PETSc vector.  It does \emph{not} allocate
memory for the vector \code{pvec} itself.

\end{fulllineitems}

\index{N\_VGetVector\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VGetVector_Petsc}\pysiglinewithargsret{Vec *\bfcode{N\_VGetVector\_Petsc}}{N\_Vector\emph{ v}}{}
This function returns a pointer to the underlying PETSc vector.

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VCloneVectorArray_Petsc}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_Petsc}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count}
NVECTOR\_PETSC vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VCloneVectorArrayEmpty_Petsc}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_Petsc}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count}
NVECTOR\_PETSC vectors, each with pointers to PETSc vectors set to \code{NULL}.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VDestroyVectorArray_Petsc}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_Petsc}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_PETSc:c.N_VCloneVectorArray_Petsc]{\emph{\code{N\_VCloneVectorArray\_Petsc()}}}} or with
{\hyperref[nvectors/NVector_PETSc:c.N_VCloneVectorArrayEmpty_Petsc]{\emph{\code{N\_VCloneVectorArrayEmpty\_Petsc()}}}}.

\end{fulllineitems}

\index{N\_VPrint\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VPrint_Petsc}\pysiglinewithargsret{void \bfcode{N\_VPrint\_Petsc}}{N\_Vector\emph{ v}}{}
This function prints the global content of a wrapped PETSc vector to \code{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Petsc (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_PETSc:c.N_VPrintFile_Petsc}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_Petsc}}{N\_Vector\emph{ v}, const char\emph{ fname{[}{]}}}{}
This function prints the global content of a wrapped PETSc vector to \code{fname}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \code{N\_Vector\_Petsc v}, it
is recommeded to extract the PETSc vector via

\code{x\_vec = N\_VGetVector\_Petsc(v);}

and then access components using appropriate PETSc functions.

\item {} 
The functions {\hyperref[nvectors/NVector_PETSc:c.N_VNewEmpty_Petsc]{\emph{\code{N\_VNewEmpty\_Petsc()}}}}, {\hyperref[nvectors/NVector_PETSc:c.N_VMake_Petsc]{\emph{\code{N\_VMake\_Petsc()}}}},
and {\hyperref[nvectors/NVector_PETSc:c.N_VCloneVectorArrayEmpty_Petsc]{\emph{\code{N\_VCloneVectorArrayEmpty\_Petsc()}}}} set the field
\emph{own\_data} to \code{SUNFALSE}. The routines \code{N\_VDestroy\_Petsc()} and
{\hyperref[nvectors/NVector_PETSc:c.N_VDestroyVectorArray_Petsc]{\emph{\code{N\_VDestroyVectorArray\_Petsc()}}}} will not attempt to free the
pointer \code{pvec} for any \code{N\_Vector} with \emph{own\_data} set to
\code{SUNFALSE}. In such a case, it is the user's responsibility to
deallocate the \code{pvec} pointer.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_PETSC
implementation that have more than one \code{N\_Vector} argument do not
check for consistent internal representations of these vectors. It is
the user's responsibility to ensure that such routines are called
with \code{N\_Vector} arguments that were all created with the same
internal representations.

\end{itemize}


\section{The NVECTOR\_CUDA Module}
\label{nvectors/NVector_CUDA:the-nvector-cuda-module}\label{nvectors/NVector_CUDA:nvectors-cuda}\label{nvectors/NVector_CUDA::doc}
The NVECTOR\_CUDA module is an experimental implementation of
\code{N\_Vector} in CUDA language.  It allows for SUNDIALS vector kernels
to run on GPU devices. It is intended for users who are already
familiar with CUDA and GPU programming.  Building this vector
module requires CUDA compiler and, by extension, C++ compiler. Class \code{Vector}
in namespace \code{suncudavec} manages vector data layout.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{I}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Vector} \PYG{p}{\PYGZob{}}
  \PYG{n}{I} \PYG{n}{size\PYGZus{}}\PYG{p}{;}
  \PYG{n}{I} \PYG{n}{mem\PYGZus{}size\PYGZus{}}\PYG{p}{;}
  \PYG{n}{T}\PYG{o}{*} \PYG{n}{h\PYGZus{}vec\PYGZus{}}\PYG{p}{;}
  \PYG{n}{T}\PYG{o}{*} \PYG{n}{d\PYGZus{}vec\PYGZus{}}\PYG{p}{;}
  \PYG{n}{StreamPartitioning}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{I}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{n}{partStream\PYGZus{}}\PYG{p}{;}
  \PYG{n}{ReducePartitioning}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{p}{,} \PYG{n}{I}\PYG{o}{\PYGZgt{}}\PYG{o}{*} \PYG{n}{partReduce\PYGZus{}}\PYG{p}{;}
  \PYG{k+kt}{bool} \PYG{n}{ownPartitioning\PYGZus{}}\PYG{p}{;}

  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The class members are vector size (length), size of the vector data memory block, pointers
to vector data on the host and the device, pointers to classes \code{StreamPartitioning}
and \code{ReducePartitioning}, which handle thread partitioning for streaming and
reduction vector kernels, respectively, and the boolean flag that signals if the
vector owns thread partitioning. The class \code{Vector} inherits from empty structure

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Cuda} \PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

to interface the C++ class with \code{N\_Vector} C code. When
instantiated, the class \code{Vector} will allocate memory on both, host
and device. Due to rapid progress in of CUDA development, we expect
that \code{suncudavec::Vector} class will change frequently in the future
SUNDIALS releases. The code is structured so that it can tolerate
significant changes in the \code{suncudavec::Vector} class without
requiring changes to user API.

The header file to be included when using this module is
\code{nvector/nvector\_cuda.h}.  Unlike other native SUNDIALS vector
types, NVECTOR\_CUDA does not provide macros to access its member
variables. Note that NVECTOR\_CUDA requires SUNDIALS to be built with
MPI support.

The NVECTOR\_CUDA module defines implementations of all vector
operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}, except for
\code{N\_VGetArrayPointer} and \code{N\_VSetArrayPointer}.  As such, this
vector cannot be used with SUNDIALS Fortran interfaces, nor with
SUNDIALS direct solvers and preconditioners. This support will be
added in subsequent SUNDIALS releases.  The NVECTOR\_CUDA module
provides separate functions to access data on the host and on the
device. It also provides methods for copying from the host to the
device and vice versa. Usage examples of NVECTOR\_CUDA are provided in
example programs for CVODE \phantomsection\label{nvectors/NVector_CUDA:id1}{\hyperref[References:hsr2017]{\emph{{[}HSR2017{]}}}}.

The names of vector operations are obtained from those in the section
{\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}} by appending the suffix \code{\_Cuda}
(e.g. \code{N\_VDestroy\_Cuda}).  The module NVECTOR\_CUDA
provides the following additional user-callable routines:
\index{N\_VNew\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VNew_Cuda}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNew\_Cuda}}{sunindextype\emph{ vec\_length}}{}
This function creates and allocates memory for a CUDA
\code{N\_Vector}. The memory is allocated on both, host and device. Its
only argument is the vector length.

\end{fulllineitems}

\index{N\_VNewEmpty\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VNewEmpty_Cuda}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_Cuda}}{sunindextype\emph{ vec\_length}}{}
This function creates a new \code{N\_Vector} wrapper with the pointer
to the wrapped CUDA vector set to \code{NULL}.  It is used by
{\hyperref[nvectors/NVector_CUDA:c.N_VNew_Cuda]{\emph{\code{N\_VNew\_Cuda()}}}}, {\hyperref[nvectors/NVector_CUDA:c.N_VMake_Cuda]{\emph{\code{N\_VMake\_Cuda()}}}}, and
\code{N\_VClone\_Cuda()} implementations.

\end{fulllineitems}

\index{N\_VMake\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VMake_Cuda}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_Cuda}}{N\_VectorContent\_Cuda\emph{ c}}{}
This function creates and allocates memory for an NVECTOR\_CUDA
wrapper around a user-provided \code{suncudavec::Vector} class.
Its only argument is of type \code{N\_VectorContent\_Cuda}, which
is the pointer to the class.

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VCloneVectorArray_Cuda}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_Cuda}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} NVECTOR\_CUDA
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VCloneVectorArrayEmpty_Cuda}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_Cuda}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} NVECTOR\_CUDA
vectors, each with pointers to CUDA vectors set to \code{NULL}.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VDestroyVectorArray_Cuda}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_Cuda}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_CUDA:c.N_VCloneVectorArray_Cuda]{\emph{\code{N\_VCloneVectorArray\_Cuda()}}}} or with
{\hyperref[nvectors/NVector_CUDA:c.N_VCloneVectorArrayEmpty_Cuda]{\emph{\code{N\_VCloneVectorArrayEmpty\_Cuda()}}}}.

\end{fulllineitems}

\index{N\_VGetLength\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VGetLength_Cuda}\pysiglinewithargsret{sunindextype \bfcode{N\_VGetLength\_Cuda}}{N\_Vector\emph{ v}}{}
This function returns the length of the vector.

\end{fulllineitems}

\index{N\_VGetHostArrayPointer\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VGetHostArrayPointer_Cuda}\pysiglinewithargsret{realtype* \bfcode{N\_VGetHostArrayPointer\_Cuda}}{N\_Vector\emph{ v}}{}
This function returns pointer to the vector data on the host.

\end{fulllineitems}

\index{N\_VGetDeviceArrayPointer\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VGetDeviceArrayPointer_Cuda}\pysiglinewithargsret{realtype* \bfcode{N\_VGetDeviceArrayPointer\_Cuda}}{N\_Vector\emph{ v}}{}
This function returns pointer to the vector data on the device.

\end{fulllineitems}

\index{N\_VCopyToDevice\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VCopyToDevice_Cuda}\pysiglinewithargsret{realtype* \bfcode{N\_VCopyToDevice\_Cuda}}{N\_Vector\emph{ v}}{}
This function copies host vector data to the device.

\end{fulllineitems}

\index{N\_VCopyFromDevice\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VCopyFromDevice_Cuda}\pysiglinewithargsret{realtype* \bfcode{N\_VCopyFromDevice\_Cuda}}{N\_Vector\emph{ v}}{}
This function copies vector data from the device to the host.

\end{fulllineitems}

\index{N\_VPrint\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VPrint_Cuda}\pysiglinewithargsret{void \bfcode{N\_VPrint\_Cuda}}{N\_Vector\emph{ v}}{}
This function prints the content of a CUDA vector to \code{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Cuda (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_CUDA:c.N_VPrintFile_Cuda}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_Cuda}}{N\_Vector\emph{ v}, FILE\emph{ *outfile}}{}
This function prints the content of a CUDA vector to \code{outfile}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \code{N\_Vector\_Cuda}, \code{v},
it is recommeded to use functions {\hyperref[nvectors/NVector_CUDA:c.N_VGetDeviceArrayPointer_Cuda]{\emph{\code{N\_VGetDeviceArrayPointer\_Cuda()}}}} or
{\hyperref[nvectors/NVector_CUDA:c.N_VGetHostArrayPointer_Cuda]{\emph{\code{N\_VGetHostArrayPointer\_Cuda()}}}}.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_CUDA implementation
that have more than one \code{N\_Vector} argument do not check for
consistent internal representations of these vectors. It is the user's
responsibility to ensure that such routines are called with \code{N\_Vector}
arguments that were all created with the same internal representations.

\end{itemize}


\section{The NVECTOR\_RAJA Module}
\label{nvectors/NVector_RAJA:the-nvector-raja-module}\label{nvectors/NVector_RAJA:nvectors-raja}\label{nvectors/NVector_RAJA::doc}
The NVECTOR\_RAJA module is an experimental implementation of
\code{N\_Vector} using the RAJA hardware abstraction layer
\href{https://software.llnl.gov/RAJA/}{https://software.llnl.gov/RAJA/}.
In this implementation, RAJA allows for SUNDIALS vector kernels to run
on GPU devices. The module is intended for users who are already
familiar with RAJA and GPU programming. Building this vector module
requires a C++11 compliant compiler and a CUDA software development
toolkit.  Besides the CUDA backend, RAJA has other backends such as
serial, OpenMP and OpenAC. These backends are not used in this SUNDIALS release.
Class \code{Vector} in namespace \code{sunrajavec} manages the vector data layout:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{template} \PYG{o}{\PYGZlt{}}\PYG{k}{class} \PYG{n+nc}{T}\PYG{p}{,} \PYG{k}{class} \PYG{n+nc}{I}\PYG{o}{\PYGZgt{}}
\PYG{k}{class} \PYG{n+nc}{Vector} \PYG{p}{\PYGZob{}}
  \PYG{n}{I} \PYG{n}{size\PYGZus{}}\PYG{p}{;}
  \PYG{n}{I} \PYG{n}{mem\PYGZus{}size\PYGZus{}}\PYG{p}{;}
  \PYG{n}{T}\PYG{o}{*} \PYG{n}{h\PYGZus{}vec\PYGZus{}}\PYG{p}{;}
  \PYG{n}{T}\PYG{o}{*} \PYG{n}{d\PYGZus{}vec\PYGZus{}}\PYG{p}{;}

  \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The class members are: vector size (length), size of the vector data
memory block, and pointers to vector data on the host and on the
device. The class \code{Vector} inherits from an empty structure

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}N\PYGZus{}VectorContent\PYGZus{}Raja} \PYG{p}{\PYGZob{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

to interface the C++ class with the \code{N\_Vector} C code. When
instantiated, the class \code{Vector} will allocate memory on both the host
and the device. Due to the rapid progress of RAJA development, we expect
that the \code{sunrajavec::Vector} class will change frequently in the future
SUNDIALS releases. The code is structured so that it can tolerate
significant changes in the \code{sunrajavec::Vector} class without
requiring changes to the user API.

The header file to be included when using this module is
\code{nvector/nvector\_raja.h}.  Unlike other native SUNDIALS vector
types, NVECTOR\_RAJA does not provide macros to access its member
variables. Note that NVECTOR\_RAJA requires SUNDIALS to be built with
MPI support.

The NVECTOR\_RAJA module defines the implementations of all vector
operations listed in the section {\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}}, except for
\code{N\_VGetArrayPointer} and \code{N\_VSetArrayPointer}.  As such, this
vector cannot be used with SUNDIALS Fortran interfaces, nor with
SUNDIALS direct solvers and preconditioners. The NVECTOR\_RAJA module
provides separate functions to access data on the host and on the
device. It also provides methods for copying from the host to the
device and vice versa. Usage examples of NVECTOR\_RAJA are provided in
some example programs for CVODE \phantomsection\label{nvectors/NVector_RAJA:id1}{\hyperref[References:hsr2017]{\emph{{[}HSR2017{]}}}}.

The names of vector operations are obtained from those in the section
{\hyperref[nvectors/NVector_Operations:nvectors-ops]{\emph{\DUspan{}{Description of the NVECTOR operations}}}} by appending the suffix \code{\_Raja}
(e.g. \code{N\_VDestroy\_Raja}).  The module NVECTOR\_RAJA
provides the following additional user-callable routines:
\index{N\_VNew\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VNew_Raja}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNew\_Raja}}{sunindextype\emph{ vec\_length}}{}
This function creates and allocates memory for a RAJA
\code{N\_Vector}. The memory is allocated on both the host and the
device. Its only argument is the vector length.

\end{fulllineitems}

\index{N\_VNewEmpty\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VNewEmpty_Raja}\pysiglinewithargsret{N\_Vector \bfcode{N\_VNewEmpty\_Raja}}{sunindextype\emph{ vec\_length}}{}
This function creates a new \code{N\_Vector} wrapper with the pointer
to the wrapped RAJA vector set to \code{NULL}.  It is used by
{\hyperref[nvectors/NVector_RAJA:c.N_VNew_Raja]{\emph{\code{N\_VNew\_Raja()}}}}, {\hyperref[nvectors/NVector_RAJA:c.N_VMake_Raja]{\emph{\code{N\_VMake\_Raja()}}}}, and
\code{N\_VClone\_Raja()} implementations.

\end{fulllineitems}

\index{N\_VMake\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VMake_Raja}\pysiglinewithargsret{N\_Vector \bfcode{N\_VMake\_Raja}}{N\_VectorContent\_Raja\emph{ c}}{}
This function creates and allocates memory for an NVECTOR\_RAJA
wrapper around a user-provided \code{sunrajavec::Vector} class.
Its only argument is of type \code{N\_VectorContent\_Raja}, which
is the pointer to the class.

\end{fulllineitems}

\index{N\_VCloneVectorArray\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VCloneVectorArray_Raja}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArray\_Raja}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} NVECTOR\_RAJA
vectors.

\end{fulllineitems}

\index{N\_VCloneVectorArrayEmpty\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VCloneVectorArrayEmpty_Raja}\pysiglinewithargsret{N\_Vector* \bfcode{N\_VCloneVectorArrayEmpty\_Raja}}{int\emph{ count}, N\_Vector\emph{ w}}{}
This function creates (by cloning) an array of \emph{count} NVECTOR\_RAJA
vectors, each with pointers to RAJA vectors set to \code{NULL}.

\end{fulllineitems}

\index{N\_VDestroyVectorArray\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VDestroyVectorArray_Raja}\pysiglinewithargsret{void \bfcode{N\_VDestroyVectorArray\_Raja}}{N\_Vector*\emph{ vs}, int\emph{ count}}{}
This function frees memory allocated for the array of \emph{count}
variables of type \code{N\_Vector} created with
{\hyperref[nvectors/NVector_RAJA:c.N_VCloneVectorArray_Raja]{\emph{\code{N\_VCloneVectorArray\_Raja()}}}} or with
{\hyperref[nvectors/NVector_RAJA:c.N_VCloneVectorArrayEmpty_Raja]{\emph{\code{N\_VCloneVectorArrayEmpty\_Raja()}}}}.

\end{fulllineitems}

\index{N\_VGetLength\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VGetLength_Raja}\pysiglinewithargsret{sunindextype \bfcode{N\_VGetLength\_Raja}}{N\_Vector\emph{ v}}{}
This function returns the length of the vector.

\end{fulllineitems}

\index{N\_VGetHostArrayPointer\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VGetHostArrayPointer_Raja}\pysiglinewithargsret{realtype* \bfcode{N\_VGetHostArrayPointer\_Raja}}{N\_Vector\emph{ v}}{}
This function returns a pointer to the vector data on the host.

\end{fulllineitems}

\index{N\_VGetDeviceArrayPointer\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VGetDeviceArrayPointer_Raja}\pysiglinewithargsret{realtype* \bfcode{N\_VGetDeviceArrayPointer\_Raja}}{N\_Vector\emph{ v}}{}
This function returns a pointer to the vector data on the device.

\end{fulllineitems}

\index{N\_VCopyToDevice\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VCopyToDevice_Raja}\pysiglinewithargsret{realtype* \bfcode{N\_VCopyToDevice\_Raja}}{N\_Vector\emph{ v}}{}
This function copies host vector data to the device.

\end{fulllineitems}

\index{N\_VCopyFromDevice\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VCopyFromDevice_Raja}\pysiglinewithargsret{realtype* \bfcode{N\_VCopyFromDevice\_Raja}}{N\_Vector\emph{ v}}{}
This function copies vector data from the device to the host.

\end{fulllineitems}

\index{N\_VPrint\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VPrint_Raja}\pysiglinewithargsret{void \bfcode{N\_VPrint\_Raja}}{N\_Vector\emph{ v}}{}
This function prints the content of a RAJA vector to \code{stdout}.

\end{fulllineitems}

\index{N\_VPrintFile\_Raja (C function)}

\begin{fulllineitems}
\phantomsection\label{nvectors/NVector_RAJA:c.N_VPrintFile_Raja}\pysiglinewithargsret{void \bfcode{N\_VPrintFile\_Raja}}{N\_Vector\emph{ v}, FILE\emph{ *outfile}}{}
This function prints the content of a RAJA vector to \code{outfile}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When there is a need to access components of an \code{N\_Vector\_Raja}, \code{v},
it is recommeded to use functions {\hyperref[nvectors/NVector_RAJA:c.N_VGetDeviceArrayPointer_Raja]{\emph{\code{N\_VGetDeviceArrayPointer\_Raja()}}}} or
{\hyperref[nvectors/NVector_RAJA:c.N_VGetHostArrayPointer_Raja]{\emph{\code{N\_VGetHostArrayPointer\_Raja()}}}}.

\item {} 
To maximize efficiency, vector operations in the NVECTOR\_RAJA implementation
that have more than one \code{N\_Vector} argument do not check for
consistent internal representations of these vectors. It is the user's
responsibility to ensure that such routines are called with \code{N\_Vector}
arguments that were all created with the same internal representations.

\end{itemize}


\section{NVECTOR Examples}
\label{nvectors/NVector_Examples:nvector-examples}\label{nvectors/NVector_Examples::doc}\label{nvectors/NVector_Examples:nvectors-examples}
There are NVECTOR examples that may be installed for each
implementation: serial, parallel, OpenMP, and Pthreads.  Each
implementation makes use of the functions in \code{test\_nvector.c}.
These example functions show simple usage of the NVECTOR family
of functions. The input to the examples are the vector length, number
of threads (if threaded implementation), and a print timing flag.

The following is a list of the example functions in \code{test\_nvector.c}:
\begin{itemize}
\item {} 
\code{Test\_N\_VClone}: Creates clone of vector and checks validity of clone.

\item {} 
\code{Test\_N\_VCloneEmpty}: Creates clone of empty vector and checks validity of clone.

\item {} 
\code{Test\_N\_VCloneVectorArray}: Creates clone of vector array and checks validity of cloned array.

\item {} 
\code{Test\_N\_VCloneVectorArray}: Creates clone of empty vector array and checks validity of cloned array.

\item {} 
\code{Test\_N\_VGetArrayPointer}: Get array pointer.

\item {} 
\code{Test\_N\_VSetArrayPointer}: Allocate new vector, set pointer to new vector array, and check values.

\item {} 
\code{Test\_N\_VLinearSum} Case 1a: Test y =  x + y

\item {} 
\code{Test\_N\_VLinearSum} Case 1b: Test y = -x + y

\item {} 
\code{Test\_N\_VLinearSum} Case 1c: Test y = ax + y

\item {} 
\code{Test\_N\_VLinearSum} Case 2a: Test x =  x + y

\item {} 
\code{Test\_N\_VLinearSum} Case 2b: Test x =  x - y

\item {} 
\code{Test\_N\_VLinearSum} Case 2c: Test x =  x + by

\item {} 
\code{Test\_N\_VLinearSum} Case 3:  Test z =  x + y

\item {} 
\code{Test\_N\_VLinearSum} Case 4a: Test z =  x - y

\item {} 
\code{Test\_N\_VLinearSum} Case 4b: Test z = -x + y

\item {} 
\code{Test\_N\_VLinearSum} Case 5a: Test z =  x + by

\item {} 
\code{Test\_N\_VLinearSum} Case 5b: Test z = ax + y

\item {} 
\code{Test\_N\_VLinearSum} Case 6a: Test z = -x + by

\item {} 
\code{Test\_N\_VLinearSum} Case 6b: Test z = ax - y

\item {} 
\code{Test\_N\_VLinearSum} Case 7:  Test z = a(x + y)

\item {} 
\code{Test\_N\_VLinearSum} Case 8:  Test z = a(x - y)

\item {} 
\code{Test\_N\_VLinearSum} Case 9:  Test z = ax + by

\item {} 
\code{Test\_N\_VConst}: Fill vector with constant and check result.

\item {} 
\code{Test\_N\_VProd}: Test vector multiply: z = x * y

\item {} 
\code{Test\_N\_VDiv}: Test vector division: z = x / y

\item {} 
\code{Test\_N\_VScale}: Case 1: scale: x = cx

\item {} 
\code{Test\_N\_VScale}: Case 2: copy: z = x

\item {} 
\code{Test\_N\_VScale}: Case 3: negate: z = -x

\item {} 
\code{Test\_N\_VScale}: Case 4: combination: z = cx

\item {} 
\code{Test\_N\_VAbs}: Create absolute value of vector.

\item {} 
\code{Test\_N\_VAddConst}: add constant vector: z = c + x

\item {} 
\code{Test\_N\_VDotProd}: Calculate dot product of two vectors.

\item {} 
\code{Test\_N\_VMaxNorm}: Create vector with known values, find and validate max norm.

\item {} 
\code{Test\_N\_VWrmsNorm}: Create vector of known values, find and validate weighted root mean square.

\item {} 
\code{Test\_N\_VWrmsNormMask}: Case 1: Create vector of known values, find and validate weighted root mean square using all elements.

\item {} 
\code{Test\_N\_VWrmsNormMask}: Case 2: Create vector of known values, find and validate weighted root mean square using no elements.

\item {} 
\code{Test\_N\_VMin}: Create vector, find and validate the min.

\item {} 
\code{Test\_N\_VWL2Norm}: Create vector, find and validate the weighted Euclidean L2 norm.

\item {} 
\code{Test\_N\_VL1Norm}: Create vector, find and validate the L1 norm.

\item {} 
\code{Test\_N\_VCompare}: Compare vector with constant returning and validating comparison vector.

\item {} 
\code{Test\_N\_VInvTest}: Test z{[}i{]} = 1 / x{[}i{]}

\item {} 
\code{Test\_N\_VConstrMask}: Test mask of vector x with vector c.

\item {} 
\code{Test\_N\_VMinQuotient}: Fill two vectors with known values. Calculate and validate minimum quotient.

\end{itemize}


\section{NVECTOR functions required by ARKode}
\label{nvectors/ARKode_requirements::doc}\label{nvectors/ARKode_requirements:nvector-functions-required-by-arkode}\label{nvectors/ARKode_requirements:nvectors-arkode}
In the table below, we list the vector functions in the \code{N\_Vector}
module that are called within the ARKode package.  The table also
shows, for each function, which ARKode module uses the function.
The ARKode column shows function usage within the main integrator
module,  while the remaining columns show function usage within
the ARKode linear solvers, the ARKBANDPRE and ARKBBDPRE
preconditioner modules, and the FARKODE module.  Here ARKDLS stands
for the direct linear solver interface in ARKode, and ARKSPILS stands
for the scaled, preconditioned, iterative linear solver interface in ARKode.

At this point, we should emphasize that the user does not need to know
anything about ARKode's usage of vector functions in order to use
ARKode.  Instead, this information is provided primarily for users
interested in constructing a custom \code{N\_Vector} module.  We note that
a number of \code{N\_Vector} functions from the section
{\hyperref[nvectors/NVector_Description:nvectors-description]{\emph{\DUspan{}{Description of the NVECTOR Modules}}}} are not listed in the above table.
Therefore a user-supplied \code{N\_Vector} module for ARKode could safely
omit these functions from their implementation.

\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline
\textsf{\relax 
Routine
} & \textsf{\relax 
ARKode
} & \textsf{\relax 
ARKDLS
} & \textsf{\relax 
ARKSPILS
} & \textsf{\relax 
ARKBANDPRE
} & \textsf{\relax 
ARKBBDPRE
} & \textsf{\relax 
FARKODE
}\\
\hline
N\_VAbs
 & 
X
 &  &  &  &  & 
X
\\
\hline
N\_VAddConst
 & 
X
 &  &  &  &  & 
X
\\
\hline
N\_VClone
 & 
X
 &  & 
X
 &  &  & 
X
\\
\hline
N\_VCloneEmpty
 &  &  &  &  &  & 
X
\\
\hline
N\_VConst
 & 
X
 & 
X
 & 
X
 &  &  & 
X
\\
\hline
N\_VDestroy
 & 
X
 &  & 
X
 &  &  & 
X
\\
\hline
N\_VDiv
 & 
X
 &  & 
X
 &  &  & 
X
\\
\hline
N\_VDotProd
 & 
X$^{\text{1}}$
 &  & 
X
 &  &  & 
X$^{\text{1}}$
\\
\hline
N\_VGetArrayPointer
 &  & 
X
 &  & 
X
 & 
X
 & 
X
\\
\hline
N\_VGetVectorID
 &  &  &  &  &  & \\
\hline
N\_VInv
 & 
X
 &  &  &  &  & 
X
\\
\hline
N\_VLinearSum
 & 
X
 & 
X
 & 
X
 &  &  & 
X
\\
\hline
N\_VMaxNorm
 & 
X
 &  &  &  &  & 
X
\\
\hline
N\_VMin
 & 
X
 &  &  &  &  & 
X
\\
\hline
N\_VProd
 &  &  & 
X
 &  &  & \\
\hline
N\_VScale
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline
N\_VSetArrayPointer
 &  & 
X
 &  &  &  & 
X
\\
\hline
N\_VSpace
 & 
X$^{\text{2}}$
 &  &  &  &  & 
X$^{\text{2}}$
\\
\hline
N\_VWrmsNorm
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline\end{tabulary}

\begin{enumerate}
\item {} 
The {\hyperref[nvectors/NVector_Operations:c.N_VDotProd]{\emph{\code{N\_VDotProd()}}}} function is only used by the main
ARKode integrator module when the fixed-point nonlinear solver is
specified; when solving an explicit problem or when using a Newton
solver with direct linear solver, it need not be
supplied by the \code{N\_Vector} implementation.

\item {} 
The {\hyperref[nvectors/NVector_Operations:c.N_VSpace]{\emph{\code{N\_VSpace()}}}} function is only informational, and need
not be supplied by the \code{N\_Vector} implementation.

\end{enumerate}


\chapter{Matrix Data Structures}
\label{sunmatrix/index:sunmatrix}\label{sunmatrix/index::doc}\label{sunmatrix/index:matrix-data-structures}
The SUNDIALS library comes packaged with a variety of \code{SUNMatrix}
implementations, designed for simulations requiring direct linear
solvers for problems in serial or shared-memory parallel
environments.  SUNDIALS additionally provides a simple interface for
generic matrices (akin to a C++ \emph{abstract base class}).  All of the
major SUNDIALS packages (CVODE(s), IDA(s), KINSOL, ARKODE), are
constructed to only depend on these generic matrix operations, making
them immediately extensible to new user-defined matrix objects.  For
each of the SUNDIALS-provided matrix types, SUNDIALS also provides at
least two \code{SUNLinearSolver} implementations that factor these
matrix objects and use them in the solution of linear systems.


\section{Description of the SUNMATRIX Modules}
\label{sunmatrix/SUNMatrix_Description:sunmatrix-description}\label{sunmatrix/SUNMatrix_Description::doc}\label{sunmatrix/SUNMatrix_Description:description-of-the-sunmatrix-modules}
For problems that involve direct methods for solving linear systems,
the SUNDIALS solvers not only operate on generic vectors, but also
on generic matrices (of type \code{SUNMatrix}), through a set of
operations defined by the particular SUNMATRIX implementation.
Users can provide their own specific implementation of the
SUNMATRIX module, particularly in cases where they provide their
own \code{N\_Vector} and/or linear solver modules, and require matrices
that are compatible with those implementations.  Alternately, we
provide three SUNMATRIX implementations: dense, banded, and sparse.
The generic operations are described below, and descriptions of the
implementations provided with SUNDIALS follow.

The generic \code{SUNMatrix} type has been modeled after the
object-oriented style of the generic \code{N\_Vector} type.
Specifically, a generic \code{SUNMatrix} is a pointer to a structure
that has an implementation-dependent \emph{content} field containing
the description and actual data of the matrix, and an \emph{ops} field
pointing to a structure with generic matrix operations.
The type \code{SUNMatrix} is defined as:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix} \PYG{o}{*}\PYG{n}{SUNMatrix}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix} \PYG{p}{\PYGZob{}}
    \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
    \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix\PYGZus{}Ops} \PYG{o}{*}\PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

Here, the \code{\_generic\_SUNMatrix\_Ops} structure is essentially a list of
function pointers to the various actual matrix operations, and is
defined as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNMatrix\PYGZus{}Ops} \PYG{p}{\PYGZob{}}
  \PYG{n}{SUNMatrix\PYGZus{}ID} \PYG{p}{(}\PYG{o}{*}\PYG{n}{getid}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{SUNMatrix}    \PYG{p}{(}\PYG{o}{*}\PYG{n}{clone}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{void}         \PYG{p}{(}\PYG{o}{*}\PYG{n}{destroy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{zero}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{copy}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{scaleadd}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{scaleaddi}\PYG{p}{)}\PYG{p}{(}\PYG{n}{realtype}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{matvec}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{p}{(}\PYG{o}{*}\PYG{n}{space}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The generic SUNMATRIX module defines and implements the matrix
operations acting on a \code{SUNMatrix}. These routines are nothing but
wrappers for the matrix operations defined by a particular SUNMATRIX
implementation, which are accessed through the \emph{ops} field of the
\code{SUNMatrix} structure. To illustrate this point we show below the
implementation of a typical matrix operation from the generic
SUNMATRIX module, namely \code{SUNMatZero}, which sets all values of a
matrix \code{A} to zero, returning a flag denoting a successful/failed
operation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{SUNMatZero}\PYG{p}{(}\PYG{n}{SUNMatrix} \PYG{n}{A}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{A}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{zero}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The subsection {\hyperref[sunmatrix/SUNMatrix_Operations:sunmatrix-ops]{\emph{\DUspan{}{Description of the SUNMATRIX operations}}}} contains a complete list of all
matrix operations defined by the generic SUNMATRIX module.  A
particular implementation of the SUNMATRIX module must:
\begin{itemize}
\item {} 
Specify the \emph{content} field of the \code{SUNMatrix} object.

\item {} 
Define and implement a minimal subset of the matrix operations.
See the documentation for each SUNDIALS solver to determine which
SUNMATRIX operations they require.  The list of required
operations for use with ARKode is given in the section
{\hyperref[sunmatrix/ARKode_requirements:sunmatrix-arkode]{\emph{\DUspan{}{SUNMATRIX functions required by ARKode}}}}.

Note that the names of these routines should be unique to that
implementation in order to permit using more than one SUNMATRIX
module (each with different \code{SUNMatrix} internal data
representations) in the same code.

\item {} 
Define and implement user-callable constructor and destructor
routines to create and free a \code{SUNMatrix} with the new \emph{content}
field and with \emph{ops} pointing to the new matrix operations.

\item {} 
Optionally, define and implement additional user-callable routines
acting on the newly defined \code{SUNMatrix} (e.g., a routine to print the
\emph{content} for debugging purposes).

\item {} 
Optionally, provide accessor macros as needed for that particular
implementation to be used to access different parts in the content
field of the newly defined \code{SUNMatrix}.

\end{itemize}

Each SUNMATRIX implementation included in SUNDIALS has a unique
identifier specified in enumeration and shown in the table below.
It is recommended that a user-supplied SUNMATRIX implementation use
the \code{SUNMATRIX\_CUSTOM} identifier.


\subsection{Identifiers associated with matrix kernels supplied with SUNDIALS}
\label{sunmatrix/SUNMatrix_Description:sunmatrix-matrixids}\label{sunmatrix/SUNMatrix_Description:identifiers-associated-with-matrix-kernels-supplied-with-sundials}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Matrix ID
} & \textsf{\relax 
Matrix type
} & \textsf{\relax 
ID Value
}\\
\hline
SUNMATRIX\_DENSE
 & 
Dense \(M\times N\) matrix
 & 
0
\\
\hline
SUNMATRIX\_BAND
 & 
Band \(M\times M\) matrix
 & 
1
\\
\hline
SUNMATRIX\_SPARSE
 & 
Sparse (CSR or CSC) \(M\times N\) matrix
 & 
2
\\
\hline
SUNMATRIX\_CUSTOM
 & 
User-provided custom matrix
 & 
3
\\
\hline\end{tabulary}



\section{Description of the SUNMATRIX operations}
\label{sunmatrix/SUNMatrix_Operations:description-of-the-sunmatrix-operations}\label{sunmatrix/SUNMatrix_Operations:sunmatrix-ops}\label{sunmatrix/SUNMatrix_Operations::doc}
For each of the \code{SUNMatrix} operations, we give the name, usage
of the function, and a description of its mathematical operations
below.
\index{SUNMatGetID (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatGetID}\pysiglinewithargsret{SUNMatrix\_ID \bfcode{SUNMatGetID}}{SUNMatrix\emph{ A}}{}
Returns the type identifier for the matrix \emph{A}.  It is used to determine the
matrix implementation type (e.g. dense, banded, sparse,...) from the abstract
\code{SUNMatrix} interface.  This is used to assess compatibility with
SUNDIALS-provided linear solver implementations.  Returned values
are given in the Table {\hyperref[sunmatrix/SUNMatrix_Description:sunmatrix-matrixids]{\emph{\DUspan{}{Identifiers associated with matrix kernels supplied with SUNDIALS}}}}

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{id} \PYG{o}{=} \PYG{n}{SUNMatGetID}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatClone (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatClone}\pysiglinewithargsret{SUNMatrix \bfcode{SUNMatClone}}{SUNMatrix\emph{ A}}{}
Creates a new \code{SUNMatrix} of the same type as an existing
matrix \emph{A} and sets the \emph{ops} field.  It does not copy the matrix,
but rather allocates storage for the new matrix.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{B} \PYG{o}{=} \PYG{n}{SUNMatClone}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatDestroy (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatDestroy}\pysiglinewithargsret{void \bfcode{SUNMatDestroy}}{SUNMatrix\emph{ A}}{}
Destroys the \code{SUNMatrix} \emph{A} and frees memory allocated for its
internal data.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{SUNMatDestroy}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatSpace}\pysiglinewithargsret{int \bfcode{SUNMatSpace}}{SUNMatrix\emph{ A}, long int\emph{ *lrw}, long int\emph{ *liw}}{}
Returns the storage requirements for the matrix \emph{A}.  \emph{lrw}
contains the number of realtype words and \emph{liw} contains the number
of integer words.  The return value denotes success/failure of the
operation.

This function is advisory only, for use in determining a user's total
space requirements; it could be a dummy function in a user-supplied
\code{SUNMatrix} module if that information is not of interest.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
ier = SUNMatSpace(A, \PYGZbs{}\PYGZam{}lrw, \PYGZbs{}\PYGZam{}liw);
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatZero (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatZero}\pysiglinewithargsret{int \bfcode{SUNMatZero}}{SUNMatrix\emph{ A}}{}
Zeros all entries of the \code{SUNMatrix} \emph{A}.  The return value is an
integer flag denoting success/failure of the operation:
\begin{gather}
\begin{split}A_{i,j} = 0, \quad i=1,\ldots,m, \; j=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatZero}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatCopy (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatCopy}\pysiglinewithargsret{int \bfcode{SUNMatCopy}}{SUNMatrix\emph{ A}, SUNMatrix\emph{ B}}{}
Performs the operation \emph{B = A} for all entries of the matrices \emph{A}
and \emph{B}.  The return value is an integer flag denoting success/failure of
the operation:
\begin{gather}
\begin{split}B_{i,j} = A_{i,j}, \quad i=1,\ldots,m, \; j=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatCopy}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatScaleAdd (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatScaleAdd}\pysiglinewithargsret{\bfcode{SUNMatScaleAdd}}{realtype\emph{ c}, SUNMatrix\emph{ A}, SUNMatrix\emph{ B}}{}
Performs the operation \emph{A = cA + B}.  The return value is an integer
flag denoting success/failure of the operation:
\begin{gather}
\begin{split}A_{i,j} = cA_{i,j} + B_{i,j}, \quad i=1,\ldots,m, \; j=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatScaleAdd}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{A}\PYG{p}{,} \PYG{n}{B}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatScaleAddI (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatScaleAddI}\pysiglinewithargsret{\bfcode{SUNMatScaleAddI}}{realtype\emph{ c}, SUNMatrix\emph{ A}}{}
Performs the operation \emph{A = cA + I}.  The return value is an integer
flag denoting success/failure of the operation:
\begin{gather}
\begin{split}A_{i,j} = cA_{i,j} + \delta_{i,j}, \quad i,j=1,\ldots,n.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatScaleAddI}\PYG{p}{(}\PYG{n}{c}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNMatMatvec (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Operations:c.SUNMatMatvec}\pysiglinewithargsret{\bfcode{SUNMatMatvec}}{SUNMatrix\emph{ A}, N\_Vector\emph{ x}, N\_Vector\emph{ y}}{}
Performs the matrix-vector product \emph{y = Ax}.  It should
only be called with vectors \emph{x} and \emph{y} that are compatible with
the matrix \emph{A} -- both in storage type and dimensions.  The return
value is an integer flag denoting success/failure of the operation:
\begin{gather}
\begin{split}y_i = \sum_{j=1}^n A_{i,j} x_j, \quad i=1,\ldots,m.\end{split}\notag
\end{gather}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNMatMatvec}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}



\section{Compatibility of SUNMATRIX types}
\label{sunmatrix/SUNMatrix_Compatibility:sunmatrix-compatibility}\label{sunmatrix/SUNMatrix_Compatibility::doc}\label{sunmatrix/SUNMatrix_Compatibility:compatibility-of-sunmatrix-types}
We note that not all \code{SUNMatrix} types are compatible with all
\code{N\_Vector} types provided with SUNDIALS.  This is primarily due to
the need for compatibility within the \code{SUNMatMatvec} routine;
however, compatibility between \code{SUNMatrix} and \code{N\_Vector}
implementations is more crucial when considering their interaction
within \code{SUNLinearSolver} objects, as will be described in more detail in
section {\hyperref[sunlinsol/index:sunlinsol]{\emph{\DUspan{}{Linear Solver Data Structures}}}}.  More specifically, in the Table
{\hyperref[sunmatrix/SUNMatrix_Compatibility:sunmatrix-matrix-vector]{\emph{\DUspan{}{SUNDIALS matrix interfaces and vector implementations that can be used for each}}}} we show the matrix interfaces available as
\code{SUNMatrix} modules, and the compatible vector implementations.


\subsection{SUNDIALS matrix interfaces and vector implementations that can be used for each}
\label{sunmatrix/SUNMatrix_Compatibility:sunmatrix-matrix-vector}\label{sunmatrix/SUNMatrix_Compatibility:sundials-matrix-interfaces-and-vector-implementations-that-can-be-used-for-each}
\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|L|L|}
\hline
\textsf{\relax 
Linear Solver
} & \textsf{\relax 
Serial
} & \textsf{\relax 
Parallel (MPI)
} & \textsf{\relax 
OpenMP
} & \textsf{\relax 
pThreads
} & \textsf{\relax 
\emph{hypre} Vec.
} & \textsf{\relax 
PETSc Vec.
} & \textsf{\relax 
CUDA
} & \textsf{\relax 
RAJA
} & \textsf{\relax 
User Suppl.
}\\
\hline
Dense
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
Band
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
Sparse
 & 
X
 &  & 
X
 & 
X
 &  &  &  &  & 
X
\\
\hline
User supplied
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline\end{tabulary}



\section{The SUNMATRIX\_DENSE Module}
\label{sunmatrix/SUNMatrix_Dense:the-sunmatrix-dense-module}\label{sunmatrix/SUNMatrix_Dense:sunmatrix-dense}\label{sunmatrix/SUNMatrix_Dense::doc}
The dense implementation of the \code{SUNMatrix} module provided with
SUNDIALS, SUNMATRIX\_DENSE, defines the \emph{content} field of
\code{SUNMatrix} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMatrixContent\PYGZus{}Dense} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{M}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ldata}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{cols}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following information:
\begin{itemize}
\item {} 
\code{M} - number of rows

\item {} 
\code{N} - number of columns

\item {} 
\code{data} - pointer to a contiguous block of \code{realtype} variables.
The elements of the dense matrix are stored columnwise, i.e. the
\(A_{i,j}\) element of a dense \code{SUNMatrix A}
(with \(0 \le i < M\) and \(0 \le j < N\)) may be accessed
via \code{data{[}j*M+i{]}}.

\item {} 
\code{ldata} - length of the data array (\(= M \cdot N\)).

\item {} 
\code{cols} - array of pointers. \code{cols{[}j{]}} points to the first
element of the j-th column of the matrix in the array \code{data}.
The \(A_{i,j}\) element of a dense \code{SUNMatrix A}
(with \(0 \le i < M\) and \(0 \le j < N\)) may be accessed
may be accessed via \code{cols{[}j{]}{[}i{]}}.

\end{itemize}

The header file to be included when using this module is
\code{sunmatrix/sunmatrix\_dense.h}.

The following macros are provided to access the content of a
SUNMATRIX\_DENSE matrix. The prefix \code{SM\_} in the names denotes that
these macros are for \emph{SUNMatrix} implementations, and the suffix
\code{\_D} denotes that these are specific to the \emph{dense} version.
\index{SM\_CONTENT\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_CONTENT_D}\pysiglinewithargsret{\bfcode{SM\_CONTENT\_D}}{A}{}
This macro gives access to the contents of the dense \code{SUNMatrix} \emph{A}.

The assignment \code{A\_cont = SM\_CONTENT\_D(A)} sets
\code{A\_cont} to be a pointer to the dense \code{SUNMatrix} content
structure.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}CONTENT\PYGZus{}D(A)   ( (SUNMatrixContent\PYGZus{}Dense)(A\PYGZhy{}\PYGZgt{}content) )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_ROWS\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_ROWS_D}\pysiglinewithargsret{\bfcode{SM\_ROWS\_D}}{A}{}
Access the number of rows in the dense \code{SUNMatrix} \emph{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \code{A\_rows = SM\_ROWS\_D(A)} sets \code{A\_rows} to be
the number of rows in the matrix \code{A}.  Similarly, the
assignment \code{SM\_ROWS\_D(A) = A\_rows} sets the number of
columns in \code{A} to equal \code{A\_rows}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ROWS\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}M )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLUMNS\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_COLUMNS_D}\pysiglinewithargsret{\bfcode{SM\_COLUMNS\_D}}{A}{}
Access the number of columns in the dense \code{SUNMatrix} \emph{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \code{A\_columns = SM\_COLUMNS\_D(A)} sets
\code{A\_columns} to be the number of columns in the matrix \code{A}.
Similarly, the assignment \code{SM\_COLUMNS\_D(A) = A\_columns} sets the
number of columns in \code{A} to equal \code{A\_columns}

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMNS\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}N )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_LDATA\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_LDATA_D}\pysiglinewithargsret{\bfcode{SM\_LDATA\_D}}{A}{}
Access the total data length in the dense \code{SUNMatrix} \emph{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \code{A\_ldata = SM\_LDATA\_D(A)} sets
\code{A\_ldata} to be the length of the data array in the matrix \code{A}.
Similarly, the assignment \code{SM\_LDATA\_D(A) = A\_ldata} sets the
parameter for the length of the data array in \code{A} to equal
\code{A\_ldata}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LDATA\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}ldata )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_DATA\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_DATA_D}\pysiglinewithargsret{\bfcode{SM\_DATA\_D}}{A}{}
This macro gives access to the \code{data} pointer for the matrix entries.

The assignment \code{A\_data = SM\_DATA\_D(A)} sets \code{A\_data} to be
a pointer to the first component of the data array for the dense
\code{SUNMatrix A}.  The assignment \code{SM\_DATA\_D(A) = A\_data}
sets the data array of \code{A} to be \code{A\_data} by storing the
pointer \code{A\_data}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}DATA\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLS\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_COLS_D}\pysiglinewithargsret{\bfcode{SM\_COLS\_D}}{A}{}
This macro gives access to the \code{cols} pointer for the matrix entries.

The assignment \code{A\_cols = SM\_COLS\_D(A)} sets \code{A\_cols} to be
a pointer to the array of column pointers for the dense \code{SUNMatrix A}.
The assignment \code{SM\_COLS\_D(A) = A\_cols} sets the column pointer
array of \code{A} to be \code{A\_cols} by storing the pointer
\code{A\_cols}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLS\PYGZus{}D(A)   ( SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}cols )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLUMN\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_COLUMN_D}\pysiglinewithargsret{\bfcode{SM\_COLUMN\_D}}{A}{}
This macros gives access to the individual columns of the data
array of a dense \code{SUNMatrix}.

The assignment \code{col\_j = SM\_COLUMN\_D(A,j)} sets \code{col\_j} to be
a pointer to the first entry of the \code{j}-th column of the \(M \times N\)
dense matrix \code{A} (with \(0 \le j < N\)).  The type of the
expression \code{SM\_COLUMN\_D(A,j)} is \code{realtype *}.  The pointer
returned by the call \code{SM\_COLUMN\_D(A,j)} can be treated as
an array which is indexed from 0 to \code{M-1}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMN\PYGZus{}D(A,j)    ( (SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}cols)[j] )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_ELEMENT\_D (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SM_ELEMENT_D}\pysiglinewithargsret{\bfcode{SM\_ELEMENT\_D}}{A}{}
This macro gives access to the individual entries of the data array
of a dense \code{SUNMatrix}.

The assignments \code{SM\_ELEMENT\_D(A,i,j) = a\_ij} and \code{a\_ij =
SM\_ELEMENT\_D(A,i,j)} reference the \(A_{i,j}\) element of the
\(M \times N\) dense matrix \code{A} (with \(0 \le i < M\) and
\(0 \le j < N\)).

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ELEMENT\PYGZus{}D(A,i,j) ( (SM\PYGZus{}CONTENT\PYGZus{}D(A)\PYGZhy{}\PYGZgt{}cols)[j][i] )}
\end{Verbatim}

\end{fulllineitems}


The SUNMATRIX\_DENSE module defines dense implementations of all matrix
operations listed in the section {\hyperref[sunmatrix/SUNMatrix_Operations:sunmatrix-ops]{\emph{\DUspan{}{Description of the SUNMATRIX operations}}}}. Their names are obtained
from those in that section by appending the suffix \code{\_Dense}
(e.g. \code{SUNMatCopy\_Dense}).  The module SUNMATRIX\_DENSE provides the
following additional user-callable routines:
\index{SUNDenseMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix}\pysiglinewithargsret{SUNMatrix \bfcode{SUNDenseMatrix}}{sunindextype\emph{ M}, sunindextype\emph{ N}}{}
This constructor function creates and allocates memory for a dense
\code{SUNMatrix}.  Its arguments are the number of rows, \code{M}, and
columns, \code{N}, for the dense matrix.

\end{fulllineitems}

\index{SUNDenseMatrix\_Print (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Print}\pysiglinewithargsret{void \bfcode{SUNDenseMatrix\_Print}}{SUNMatrix\emph{ A}, FILE*\emph{ outfile}}{}
This function prints the content of a dense \code{SUNMatrix} to the
output stream specified by \code{outfile}.  Note: \code{stdout}
or \code{stderr} may be used as arguments for \code{outfile} to print
directly to standard output or standard error, respectively.

\end{fulllineitems}

\index{SUNDenseMatrix\_Rows (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Rows}\pysiglinewithargsret{sunindextype \bfcode{SUNDenseMatrix\_Rows}}{SUNMatrix\emph{ A}}{}
This function returns the number of rows in the dense \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Columns (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Columns}\pysiglinewithargsret{sunindextype \bfcode{SUNDenseMatrix\_Columns}}{SUNMatrix\emph{ A}}{}
This function returns the number of columns in the dense \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_LData (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_LData}\pysiglinewithargsret{sunindextype \bfcode{SUNDenseMatrix\_LData}}{SUNMatrix\emph{ A}}{}
This function returns the length of the data array for the dense \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Data (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Data}\pysiglinewithargsret{realtype* \bfcode{SUNDenseMatrix\_Data}}{SUNMatrix\emph{ A}}{}
This function returns a pointer to the data array for the dense \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Cols (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Cols}\pysiglinewithargsret{realtype** \bfcode{SUNDenseMatrix\_Cols}}{SUNMatrix\emph{ A}}{}
This function returns a pointer to the cols array for the dense \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNDenseMatrix\_Column (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:c.SUNDenseMatrix_Column}\pysiglinewithargsret{realtype* \bfcode{SUNDenseMatrix\_Column}}{SUNMatrix\emph{ A}, sunindextype\emph{ j}}{}
This function returns a pointer to the first entry of the jth
column of the dense \code{SUNMatrix}.  The resulting pointer should
be indexed over the range \code{0} to \code{M-1}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When looping over the components of a dense \code{SUNMatrix A},
the most efficient approaches are to:
\begin{itemize}
\item {} 
First obtain the component array via \code{A\_data = SM\_DATA\_D(A)} or
\code{A\_data = SUNDenseMatrix\_Data(A)} and then access \code{A\_data{[}i{]}}
within the loop.

\item {} 
First obtain the array of column pointers via \code{A\_cols = SM\_COLS\_D(A)} or
\code{A\_cols = SUNDenseMatrix\_Cols(A)}, and then access
\code{A\_cols{[}j{]}{[}i{]}} within the loop.

\item {} 
Within a loop over the columns, access the column pointer via
\code{A\_colj = SUNDenseMatrix\_Column(A,j)} and then to access the
entries within that column using \code{A\_colj{[}i{]}} within the loop.

\end{itemize}

All three of these are more efficient than
using \code{SM\_ELEMENT\_D(A,i,j)} within a double loop.

\item {} 
Within the \code{SUNMatMatvec\_Dense} routine, internal consistency
checks are performed to ensure that the matrix is called with
consistent \code{N\_Vector} implementations.  These are currently
limited to: NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS.
As additional compatible vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

\end{itemize}

For solvers that include a Fortran interface module, the SUNMATRIX\_DENSE
module also includes the Fortran-callable function
{\hyperref[sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMatInit]{\emph{\code{FSUNDenseMatInit()}}}} to initialize this SUNMATRIX\_DENSE module
for a given SUNDIALS solver.
\index{FSUNDenseMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMatInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNDenseMatInit}}{\emph{CODE}, \emph{M}, \emph{N}, \emph{IER}}{}
Initializes a dense \code{SUNMatrix} structure for use in a SUNDIALS solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{M} (\code{long int}, input) -- number of matrix rows.

\item {} 
\emph{N} (\code{long int}, input) -- number of matrix columns.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMassMatInit]{\emph{\code{FSUNDenseMassMatInit()}}}} initializes
this SUNMATRIX\_DENSE module for storing the mass matrix.
\index{FSUNDenseMassMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Dense:f/_/FSUNDenseMassMatInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNDenseMassMatInit}}{\emph{M}, \emph{N}, \emph{IER}}{}
Initializes a dense \code{SUNMatrix} structure for use as a mass
matrix in ARKode.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{M} (\code{long int}, input) -- number of matrix rows.

\item {} 
\emph{N} (\code{long int}, input) -- number of matrix columns.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNMATRIX\_BAND Module}
\label{sunmatrix/SUNMatrix_Band::doc}\label{sunmatrix/SUNMatrix_Band:sunmatrix-band}\label{sunmatrix/SUNMatrix_Band:the-sunmatrix-band-module}
The banded implementation of the \code{SUNMatrix} module provided with
SUNDIALS, SUNMATRIX\_BAND, defines the \emph{content} field of
\code{SUNMatrix} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMatrixContent\PYGZus{}Band} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{M}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{mu}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ml}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{smu}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ldim}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{ldata}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{cols}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

A diagram of the underlying data representation in a banded matrix is
shown in Figure {\hyperref[sunmatrix/SUNMatrix_Band:sunbandmatrix]{\emph{\DUspan{}{SUNBandMatrix Diagram}}}}.  A more
complete description of the parts of this \emph{content} field is given below:
\begin{itemize}
\item {} 
\code{M} - number of rows

\item {} 
\code{N} - number of columns (\code{N} = \code{M})

\item {} 
\code{mu} - upper half-bandwidth, \(0 \le \text{mu} < N\)

\item {} 
\code{ml} - lower half-bandwidth, \(0 \le \text{ml} < N\)

\item {} 
\code{smu} - storage upper bandwidth, \(\text{mu} \le \text{smu} < N\).
The LU decomposition routines in the associated SUNLINSOL\_BAND
and SUNLINSOL\_LAPACKBAND modules write the LU factors into the
existing storage for the band matrix. The upper triangular factor
U, however, may have an upper bandwidth as big as
\code{min(N-1, mu+ml)} because of partial pivoting. The \code{smu} field
holds the upper half-bandwidth allocated for the band matrix.

\item {} 
\code{ldim} - leading dimension (\(\text{ldim} \ge smu\))

\item {} 
\code{data} - pointer to a contiguous block of \code{realtype} variables.
The elements of the banded matrix are stored columnwise
(i.e. columns are stored one on top of the other in memory). Only
elements within the specified half-bandwidths are stored.  \code{data}
is a pointer to \code{ldata} contiguous locations which hold the
elements within the banded matrix.

\item {} 
\code{ldata} - length of the data array (\(= \text{ldim} \cdot (\text{smu}+\text{ml}+1\)))

\item {} 
\code{cols} - array of pointers. \code{cols{[}j{]}} is a pointer to the
uppermost element within the band in the j-th column. This pointer
may be treated as an array indexed from
\code{smu-mu} (to access the uppermost element within the band in the
j-th column) to \code{smu+ml} (to access the lowest element within the
band in the j-th column). Indices from 0 to \code{smu-mu-1} give access
to extra storage elements required by the LU decomposition function.
Finally, \code{cols{[}j{]}{[}i-j+smu{]}} is the (\(i,j\))-th element with
\(j-\text{mu} \le i \le j+\text{ml}\).

\end{itemize}
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{bandmat1.png}
\caption{Diagram of the storage for the SUNMATRIX\_BAND module. Here \code{A} is an
\(N \times N\) band matrix with upper and lower half-bandwidths \code{mu}
and \code{ml}, respectively. The rows and columns of \code{A} are
numbered from 0 to \code{N-1} and the (\(i,j\))-th element of \code{A} is
denoted \code{A(i,j)}. The greyed out areas of the underlying
component storage are used by the associated SUNLINSOL\_BAND or
SUNLINSOL\_LAPACKBAND linear solver.}\label{sunmatrix/SUNMatrix_Band:sunbandmatrix}\end{figure}

The header file to be included when using this module is
\code{sunmatrix/sunmatrix\_band.h}.

The following macros are provided to access the
content of a SUNMATRIX\_BAND matrix. The prefix \code{SM\_} in the names
denotes that these macros are for \emph{SUNMatrix} implementations,
and the suffix \code{\_B} denotes that these are specific to
the \emph{banded} version.
\index{SM\_CONTENT\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_CONTENT_B}\pysiglinewithargsret{\bfcode{SM\_CONTENT\_B}}{A}{}
This macro gives access to the contents of the banded \code{SUNMatrix} \emph{A}.

The assignment \code{A\_cont = SM\_CONTENT\_B(A)} sets
\code{A\_cont} to be a pointer to the banded \code{SUNMatrix} content
structure.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}CONTENT\PYGZus{}B(A)   ( (SUNMatrixContent\PYGZus{}Band)(A\PYGZhy{}\PYGZgt{}content) )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_ROWS\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_ROWS_B}\pysiglinewithargsret{\bfcode{SM\_ROWS\_B}}{A}{}
Access the number of rows in the banded \code{SUNMatrix} \emph{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \code{A\_rows = SM\_ROWS\_B(A)} sets \code{A\_rows} to be
the number of rows in the matrix \code{A}.  Similarly, the
assignment \code{SM\_ROWS\_B(A) = A\_rows} sets the number of
columns in \code{A} to equal \code{A\_rows}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ROWS\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}M )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLUMNS\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_COLUMNS_B}\pysiglinewithargsret{\bfcode{SM\_COLUMNS\_B}}{A}{}
Access the number of columns in the banded \code{SUNMatrix} \emph{A}.  As
with \code{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMNS\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}N )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_UBAND\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_UBAND_B}\pysiglinewithargsret{\bfcode{SM\_UBAND\_B}}{A}{}
Access the \code{mu} parameter in the banded \code{SUNMatrix} \emph{A}.  As
with \code{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}UBAND\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}mu )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_LBAND\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_LBAND_B}\pysiglinewithargsret{\bfcode{SM\_LBAND\_B}}{A}{}
Access the \code{ml} parameter in the banded \code{SUNMatrix} \emph{A}.  As
with \code{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LBAND\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}ml )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_SUBAND\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_SUBAND_B}\pysiglinewithargsret{\bfcode{SM\_SUBAND\_B}}{A}{}
Access the \code{smu} parameter in the banded \code{SUNMatrix} \emph{A}.  As
with \code{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}SUBAND\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}smu )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_LDIM\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_LDIM_B}\pysiglinewithargsret{\bfcode{SM\_LDIM\_B}}{A}{}
Access the \code{ldim} parameter in the banded \code{SUNMatrix} \emph{A}.  As
with \code{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LDIM\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}ldim )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_LDATA\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_LDATA_B}\pysiglinewithargsret{\bfcode{SM\_LDATA\_B}}{A}{}
Access the \code{ldata} parameter in the banded \code{SUNMatrix} \emph{A}.  As
with \code{SM\_ROWS\_B}, this may be used either to retrieve or to set
the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}LDATA\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}ldata )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_DATA\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_DATA_B}\pysiglinewithargsret{\bfcode{SM\_DATA\_B}}{A}{}
This macro gives access to the \code{data} pointer for the matrix entries.

The assignment \code{A\_data = SM\_DATA\_B(A)} sets \code{A\_data} to be
a pointer to the first component of the data array for the banded
\code{SUNMatrix A}.  The assignment \code{SM\_DATA\_B(A) = A\_data}
sets the data array of \code{A} to be \code{A\_data} by storing the
pointer \code{A\_data}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}DATA\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLS\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_COLS_B}\pysiglinewithargsret{\bfcode{SM\_COLS\_B}}{A}{}
This macro gives access to the \code{cols} pointer for the matrix entries.

The assignment \code{A\_cols = SM\_COLS\_B(A)} sets \code{A\_cols} to be
a pointer to the array of column pointers for the banded \code{SUNMatrix A}.
The assignment \code{SM\_COLS\_B(A) = A\_cols} sets the column pointer
array of \code{A} to be \code{A\_cols} by storing the pointer
\code{A\_cols}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLS\PYGZus{}B(A)   ( SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}cols )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLUMN\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_COLUMN_B}\pysiglinewithargsret{\bfcode{SM\_COLUMN\_B}}{A}{}
This macros gives access to the individual columns of the data
array of a banded \code{SUNMatrix}.

The assignment \code{col\_j = SM\_COLUMN\_B(A,j)} sets \code{col\_j} to be
a pointer to the diagonal element of the j-th column of the
\(N \times N\) band matrix \code{A}, \(0 \le j \le N-1\).
The type of the expression \code{SM\_COLUMN\_B(A,j)} is \code{realtype *}.
The pointer returned by the call \code{SM\_COLUMN\_B(A,j)} can be treated as
an array which is indexed from \code{-mu} to \code{ml}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMN\PYGZus{}B(A,j)   ( ((SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}cols)[j])+SM\PYGZus{}SUBAND\PYGZus{}B(A) )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_ELEMENT\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_ELEMENT_B}\pysiglinewithargsret{\bfcode{SM\_ELEMENT\_B}}{A}{}
This macro gives access to the individual entries of the data array
of a banded \code{SUNMatrix}.

The assignments \code{SM\_ELEMENT\_B(A,i,j) = a\_ij} and \code{a\_ij =
SM\_ELEMENT\_B(A,i,j)} reference the (\(i,j\))-th element of the
\(N \times N\) band matrix \code{A}, where \(0 \le i,j \le N-1\).
The location (\(i,j\)) should further satisfy
\(j-\text{mu} \le i \le j+\text{ml}\).

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ELEMENT\PYGZus{}B(A,i,j)   ( (SM\PYGZus{}CONTENT\PYGZus{}B(A)\PYGZhy{}\PYGZgt{}cols)[j][(i)\PYGZhy{}(j)+SM\PYGZus{}SUBAND\PYGZus{}B(A)] )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLUMN\_ELEMENT\_B (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SM_COLUMN_ELEMENT_B}\pysiglinewithargsret{\bfcode{SM\_COLUMN\_ELEMENT\_B}}{A}{}
This macro gives access to the individual entries of the data array
of a banded \code{SUNMatrix}.

The assignments \code{SM\_COLUMN\_ELEMENT\_B(col\_j,i,j) = a\_ij} and
\code{a\_ij = SM\_COLUMN\_ELEMENT\_B(col\_j,i,j)} reference the
(\(i,j\))-th entry of the band matrix \code{A} when used in
conjunction with \code{SM\_COLUMN\_B} to reference the j-th column
through \code{col\_j}. The index (\(i,j\)) should satisfy
\(j-\text{mu} \le i \le j+\text{ml}\).

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMN\PYGZus{}ELEMENT\PYGZus{}B(col\PYGZus{}j,i,j)   (col\PYGZus{}j[(i)\PYGZhy{}(j)])}
\end{Verbatim}

\end{fulllineitems}


The SUNMATRIX\_BAND module defines banded implementations of all matrix
operations listed in the section {\hyperref[sunmatrix/SUNMatrix_Operations:sunmatrix-ops]{\emph{\DUspan{}{Description of the SUNMATRIX operations}}}}. Their names are
obtained from those in that section by appending the suffix \code{\_Band}
(e.g. \code{SUNMatCopy\_Band}).  The module SUNMATRIX\_BAND provides the
following additional user-callable routines:
\index{SUNBandMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix}\pysiglinewithargsret{SUNMatrix \bfcode{SUNBandMatrix}}{sunindextype\emph{ N}, sunindextype\emph{ mu}, sunindextype\emph{ ml}, sunindextype\emph{ smu}}{}
This constructor function creates and allocates memory for a banded \code{SUNMatrix}.
Its arguments are the matrix size, \code{N}, the upper and lower
half-bandwidths of the matrix, \code{mu} and \code{ml}, and the stored
upper bandwidth, \code{smu}.  When creating a band \code{SUNMatrix}, if
the matrix will be used by the SUNLINSOL\_BAND or
SUNLINSOL\_LAPACKBAND module then \code{smu} should be at least
\code{min(N-1,mu+ml)}; otherwise \code{smu} should be at least \code{mu}.

\end{fulllineitems}

\index{SUNBandMatrix\_Print (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Print}\pysiglinewithargsret{void \bfcode{SUNBandMatrix\_Print}}{SUNMatrix\emph{ A}, FILE*\emph{ outfile}}{}
This function prints the content of a banded \code{SUNMatrix} to the
output stream specified by \code{outfile}.  Note: \code{stdout}
or \code{stderr} may be used as arguments for \code{outfile} to print
directly to standard output or standard error, respectively.

\end{fulllineitems}

\index{SUNBandMatrix\_Rows (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Rows}\pysiglinewithargsret{sunindextype \bfcode{SUNBandMatrix\_Rows}}{SUNMatrix\emph{ A}}{}
This function returns the number of rows in the banded \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Columns (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Columns}\pysiglinewithargsret{sunindextype \bfcode{SUNBandMatrix\_Columns}}{SUNMatrix\emph{ A}}{}
This function returns the number of columns in the banded \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_LowerBandwidth (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_LowerBandwidth}\pysiglinewithargsret{sunindextype \bfcode{SUNBandMatrix\_LowerBandwidth}}{SUNMatrix\emph{ A}}{}
This function returns the lower half-bandwidth for the banded \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_UpperBandwidth (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_UpperBandwidth}\pysiglinewithargsret{sunindextype \bfcode{SUNBandMatrix\_UpperBandwidth}}{SUNMatrix\emph{ A}}{}
This function returns the upper half-bandwidth of the banded \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_StoredUpperBandwidth (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_StoredUpperBandwidth}\pysiglinewithargsret{sunindextype \bfcode{SUNBandMatrix\_StoredUpperBandwidth}}{SUNMatrix\emph{ A}}{}
This function returns the stored upper half-bandwidth of the banded \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_LDim (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_LDim}\pysiglinewithargsret{sunindextype \bfcode{SUNBandMatrix\_LDim}}{SUNMatrix\emph{ A}}{}
This function returns the length of the leading dimension of the banded \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Data (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Data}\pysiglinewithargsret{realtype* \bfcode{SUNBandMatrix\_Data}}{SUNMatrix\emph{ A}}{}
This function returns a pointer to the data array for the banded \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Cols (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Cols}\pysiglinewithargsret{realtype** \bfcode{SUNBandMatrix\_Cols}}{SUNMatrix\emph{ A}}{}
This function returns a pointer to the cols array for the band \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNBandMatrix\_Column (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:c.SUNBandMatrix_Column}\pysiglinewithargsret{realtype* \bfcode{SUNBandMatrix\_Column}}{SUNMatrix\emph{ A}, sunindextype\emph{ j}}{}
This function returns a pointer to the diagonal entry of the j-th
column of the banded \code{SUNMatrix}.  The resulting pointer should
be indexed over the range \code{-mu} to \code{ml}.

\end{fulllineitems}


\textbf{Notes}
\begin{itemize}
\item {} 
When looping over the components of a banded \code{SUNMatrix A},
the most efficient approaches are to:
\begin{itemize}
\item {} 
First obtain the component array via \code{A\_data = SM\_DATA\_B(A)} or
\code{A\_data = SUNBandMatrix\_Data(A)} and then
access \code{A\_data{[}i{]}} within the loop.

\item {} 
First obtain the array of column pointers via \code{A\_cols = SM\_COLS\_B(A)} or
\code{A\_cols = SUNBandMatrix\_Cols(A)}, and then
access \code{A\_cols{[}j{]}{[}i{]}} within the loop.

\item {} 
Within a loop over the columns, access the column pointer via
\code{A\_colj = SUNBandMatrix\_Column(A,j)} and then to access the
entries within that column using \code{SM\_COLUMN\_ELEMENT\_B(A\_colj,i,j)}.

\end{itemize}

All three of these are more efficient than
using \code{SM\_ELEMENT\_B(A,i,j)} within a double loop.

\item {} 
Within the \code{SUNMatMatvec\_Band} routine, internal consistency
checks are performed to ensure that the matrix is called with
consistent \code{N\_Vector} implementations.  These are currently
limited to: NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS.
As additional compatible vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

\end{itemize}

For solvers that include a Fortran interface module, the SUNMATRIX\_BAND
module also includes the Fortran-callable function
{\hyperref[sunmatrix/SUNMatrix_Band:f/_/FSUNBandMatInit]{\emph{\code{FSUNBandMatInit()}}}} to initialize this SUNMATRIX\_BAND module
for a given SUNDIALS solver.
\index{FSUNBandMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:f/_/FSUNBandMatInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNBandMatInit}}{\emph{CODE}, \emph{N}, \emph{MU}, \emph{ML}, \emph{SMU}, \emph{IER}}{}
Initializes a band \code{SUNMatrix} structure for use in a SUNDIALS solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{N} (\code{long int}, input) -- number of matrix rows (and columns).

\item {} 
\emph{MU} (\code{long int}, input) -- upper half-bandwidth.

\item {} 
\emph{ML} (\code{long int}, input) -- lower half-bandwidth.

\item {} 
\emph{SMU} (\code{long int}, input) -- storage upper half-bandwidth.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunmatrix/SUNMatrix_Band:f/_/FSUNBandMassMatInit]{\emph{\code{FSUNBandMassMatInit()}}}} initializes
this SUNMATRIX\_BAND module for storing the mass matrix.
\index{FSUNBandMassMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Band:f/_/FSUNBandMassMatInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNBandMassMatInit}}{\emph{N}, \emph{MU}, \emph{ML}, \emph{SMU}, \emph{IER}}{}
Initializes a band \code{SUNMatrix} structure for use as a mass
matrix in ARKode.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{N} (\code{long int}, input) -- number of matrix rows (and columns).

\item {} 
\emph{MU} (\code{long int}, input) -- upper half-bandwidth.

\item {} 
\emph{ML} (\code{long int}, input) -- lower half-bandwidth.

\item {} 
\emph{SMU} (\code{long int}, input) -- storage upper half-bandwidth.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNMATRIX\_SPARSE Module}
\label{sunmatrix/SUNMatrix_Sparse:sunmatrix-sparse}\label{sunmatrix/SUNMatrix_Sparse::doc}\label{sunmatrix/SUNMatrix_Sparse:the-sunmatrix-sparse-module}
The sparse implementation of the \code{SUNMatrix} module provided with
SUNDIALS, SUNMATRIX\_SPARSE, is designed to work with either
\emph{compressed-sparse-column} (CSC) or \emph{compressed-sparse-row}
(CSR) sparse matrix formats.  To this end, it defines the \emph{content}
field of \code{SUNMatrix} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNMatrixContent\PYGZus{}Sparse} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{M}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{NNZ}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{NP}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{data}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{sparsetype}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{indexvals}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{indexptrs}\PYG{p}{;}
  \PYG{c+cm}{/* CSC indices */}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{rowvals}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{colptrs}\PYG{p}{;}
  \PYG{c+cm}{/* CSR indices */}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{colvals}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{rowptrs}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

A diagram of the underlying data representation in a sparse matrix is
shown in Figure {\hyperref[sunmatrix/SUNMatrix_Sparse:sunsparsematrix]{\emph{\DUspan{}{SUNSparseMatrix Diagram}}}}.  A more
complete description of the parts of this \emph{content} field is given below:
\begin{itemize}
\item {} 
\code{M} - number of rows

\item {} 
\code{N} - number of columns

\item {} 
\code{NNZ} - maximum number of nonzero entries in the matrix
(allocated length of \code{data} and \code{indexvals} arrays)

\item {} 
\code{NP} - number of index pointers (e.g. number of column pointers
for CSC matrix). For CSC matrices \code{NP=N}, and for CSR matrices
\code{NP=M}. This value is set automatically at construction based the
input choice for \code{sparsetype}.

\item {} 
\code{data} - pointer to a contiguous block of \code{realtype}
variables (of length \code{NNZ}), containing the values of the
nonzero entries in the matrix

\item {} 
\code{sparsetype} - type of the sparse matrix (\code{CSC\_MAT} or \code{CSR\_MAT})

\item {} 
\code{indexvals} - pointer to a contiguous block of \code{int} variables
(of length \code{NNZ}), containing the row indices (if CSC) or column
indices (if CSR) of each nonzero matrix entry held in \code{data}

\item {} 
\code{indexptrs} - pointer to a contiguous block of \code{int}
variables (of length \code{NP+1}). For CSC matrices each entry provides
the index of the first column entry into the \code{data} and
\code{indexvals} arrays, e.g. if \code{indexptr{[}3{]}=7}, then the first
nonzero entry in the fourth column of the matrix is located in
\code{data{[}7{]}}, and is located in row \code{indexvals{[}7{]}} of the matrix.
The last entry contains the total number of nonzero values in the
matrix and hence points one past the end of the active data in the
\code{data} and \code{indexvals} arrays. For CSR matrices, each entry
provides the index of the first row entry into the \code{data} and
\code{indexvals} arrays.

\end{itemize}

The following pointers are added to the SUNMATRIX\_SPARSE content
structure for user convenience, to provide a more intuitive interface
to the CSC and CSR sparse matrix data structures. They are set
automatically when creating a sparse \code{SUNMatrix}, based on the
sparse matrix storage type.
\begin{itemize}
\item {} 
\code{rowvals} - pointer to \code{indexvals} when \code{sparsetype} is
\code{CSC\_MAT}, otherwise set to \code{NULL}.

\item {} 
\code{colptrs} - pointer to \code{indexptrs} when \code{sparsetype} is
\code{CSC\_MAT}, otherwise set to \code{NULL}.

\item {} 
\code{colvals} - pointer to \code{indexvals} when \code{sparsetype} is
\code{CSR\_MAT}, otherwise set to \code{NULL}.

\item {} 
\code{rowptrs} - pointer to \code{indexptrs} when \code{sparsetype} is
\code{CSR\_MAT}, otherwise set to \code{NULL}.

\end{itemize}

For example, the \(5\times 4\) matrix
\begin{gather}
\begin{split}\left[\begin{array}{cccc}
  0 & 3 & 1 & 0\\
  3 & 0 & 0 & 2\\
  0 & 7 & 0 & 0\\
  1 & 0 & 0 & 9\\
  0 & 0 & 0 & 5
\end{array}\right]\end{split}\notag
\end{gather}
could be stored as a CSC matrix in this structure as either

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n}{NNZ} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}
\PYG{n}{NP} \PYG{o}{=} \PYG{n}{N}\PYG{p}{;}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{sparsetype} \PYG{o}{=} \PYG{n}{CSC\PYGZus{}MAT}\PYG{p}{;}
\PYG{n}{indexvals} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{indexptrs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

or

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n}{NNZ} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{n}{NP} \PYG{o}{=} \PYG{n}{N}\PYG{p}{;}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{,} \PYG{o}{*}\PYG{p}{,} \PYG{o}{*}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{sparsetype} \PYG{o}{=} \PYG{n}{CSC\PYGZus{}MAT}\PYG{p}{;}
\PYG{n}{indexvals} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{o}{*}\PYG{p}{,} \PYG{o}{*}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{indexptrs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

where the first has no unused space, and the second has additional
storage (the entries marked with \code{*} may contain any values).
Note in both cases that the final value in \code{indexptrs} is 8,
indicating the total number of nonzero entries in the matrix.

Similarly, in CSR format, the same matrix could be stored as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{M} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{n}{NNZ} \PYG{o}{=} \PYG{l+m+mi}{8}\PYG{p}{;}
\PYG{n}{NP} \PYG{o}{=} \PYG{n}{N}\PYG{p}{;}
\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{3.0}\PYG{p}{,} \PYG{l+m+mf}{2.0}\PYG{p}{,} \PYG{l+m+mf}{7.0}\PYG{p}{,} \PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{l+m+mf}{9.0}\PYG{p}{,} \PYG{l+m+mf}{5.0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{sparsetype} \PYG{o}{=} \PYG{n}{CSR\PYGZus{}MAT}\PYG{p}{;}
\PYG{n}{indexvals} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{indexptrs} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{,} \PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}
\begin{figure}[htbp]
\centering
\capstart

\includegraphics{cscmat1.png}
\caption{Diagram of the storage for a compressed-sparse-column matrix of
type SUNMATRIX\_SPARSE: Here \code{A} is an \(M \times N\) sparse
CSC matrix with storage for up to \code{NNZ} nonzero entries (the
allocated length of both \code{data} and \code{indexvals}).  The entries
in \code{indexvals} may assume values from \code{0} to \code{M-1},
corresponding to the row index (zero-based) of
each nonzero value.  The entries in \code{data} contain the values of
the nonzero entries, with the row \code{i}, column \code{j} entry of
\code{A} (again, zero-based) denoted as \code{A(i,j)}.  The \code{indexptrs}
array contains \code{N+1} entries; the first \code{N} denote the starting
index of each column within the \code{indexvals} and \code{data} arrays,
while the final entry points one past the final nonzero entry.
Here, although \code{NNZ} values are allocated, only \code{nz} are
actually filled in; the greyed-out portions of \code{data} and
\code{indexvals} indicate extra allocated space.}\label{sunmatrix/SUNMatrix_Sparse:sunsparsematrix}\end{figure}

The header file to be included when using this module is
\code{sunmatrix/sunmatrix\_sparse.h}.

The following macros are provided to access the content of a
SUNMATRIX\_SPARSE matrix. The prefix \code{SM\_} in the names
denotes that these macros are for \emph{SUNMatrix} implementations,
and the suffix \code{\_S} denotes that these are specific to
the \emph{sparse} version.
\index{SM\_CONTENT\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_CONTENT_S}\pysiglinewithargsret{\bfcode{SM\_CONTENT\_S}}{A}{}
This macro gives access to the contents of the sparse \code{SUNMatrix} \emph{A}.

The assignment \code{A\_cont = SM\_CONTENT\_S(A)} sets
\code{A\_cont} to be a pointer to the sparse \code{SUNMatrix} content
structure.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}CONTENT\PYGZus{}S(A)   ( (SUNMatrixContent\PYGZus{}Sparse)(A\PYGZhy{}\PYGZgt{}content) )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_ROWS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_ROWS_S}\pysiglinewithargsret{\bfcode{SM\_ROWS\_S}}{A}{}
Access the number of rows in the sparse \code{SUNMatrix} \emph{A}.

This may be used either to retrieve or to set the value.  For
example, the assignment \code{A\_rows = SM\_ROWS\_S(A)} sets \code{A\_rows}
to be the number of rows in the matrix \emph{A}.  Similarly, the
assignment \code{SM\_ROWS\_S(A) = A\_rows} sets the number of
columns in \emph{A} to equal \code{A\_rows}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}ROWS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}M )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_COLUMNS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_COLUMNS_S}\pysiglinewithargsret{\bfcode{SM\_COLUMNS\_S}}{A}{}
Access the number of columns in the sparse \code{SUNMatrix} \emph{A}.  As
with \code{SM\_ROWS\_S}, this may be used either to retrieve or to set
the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}COLUMNS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}N )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_NNZ\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_NNZ_S}\pysiglinewithargsret{\bfcode{SM\_NNZ\_S}}{A}{}
Access the allocated number of nonzeros in the sparse \code{SUNMatrix}
\emph{A}.  As with \code{SM\_ROWS\_S}, this may be used either to retrieve or
to set the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}NNZ\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}NNZ )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_NP\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_NP_S}\pysiglinewithargsret{\bfcode{SM\_NP\_S}}{A}{}
Access the number of index pointers \code{NP} in the sparse
\code{SUNMatrix} \emph{A}.  As with \code{SM\_ROWS\_S}, this may be used either
to retrieve or to set the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}NP\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}NP )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_SPARSETYPE\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_SPARSETYPE_S}\pysiglinewithargsret{\bfcode{SM\_SPARSETYPE\_S}}{A}{}
Access the sparsity type parameter in the sparse \code{SUNMatrix} \emph{A}.
As with \code{SM\_ROWS\_S}, this may be used either to retrieve or to
set the value.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}SPARSETYPE\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}sparsetype )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_DATA\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_DATA_S}\pysiglinewithargsret{\bfcode{SM\_DATA\_S}}{A}{}
This macro gives access to the \code{data} pointer for the matrix
entries.

The assignment \code{A\_data = SM\_DATA\_S(A)} sets \code{A\_data} to be
a pointer to the first component of the data array for the sparse
\code{SUNMatrix A}.  The assignment \code{SM\_DATA\_S(A) = A\_data}
sets the data array of \emph{A} to be \code{A\_data} by storing the
pointer \code{A\_data}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}DATA\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}data )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_INDEXVALS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_INDEXVALS_S}\pysiglinewithargsret{\bfcode{SM\_INDEXVALS\_S}}{A}{}
This macro gives access to the \code{indexvals} pointer for the matrix
entries.

The assignment \code{A\_indexvals = SM\_INDEXVALS\_S(A)}
sets \code{A\_indexvals} to be a pointer to the array of index values
(i.e. row indices for a CSC matrix, or column indices for a CSR
matrix) for the sparse \code{SUNMatrix} \emph{A}.

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}INDEXVALS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}indexvals )}
\end{Verbatim}

\end{fulllineitems}

\index{SM\_INDEXPTRS\_S (C macro)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SM_INDEXPTRS_S}\pysiglinewithargsret{\bfcode{SM\_INDEXPTRS\_S}}{A}{}
This macro gives access to the \code{indexptrs} pointer for the matrix entries.

The assignment \code{A\_indexptrs = SM\_INDEXPTRS\_S(A)}
sets \code{A\_indexptrs} to be a pointer to the array of index
pointers (i.e. the starting indices in the data/indexvals arrays for
each row or column in CSR or CSC formats, respectively).

Implementation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define SM\PYGZus{}INDEXPTRS\PYGZus{}S(A)   ( SM\PYGZus{}CONTENT\PYGZus{}S(A)\PYGZhy{}\PYGZgt{}indexptrs )}
\end{Verbatim}

\end{fulllineitems}


The SUNMATRIX\_SPARSE module defines sparse implementations of all matrix
operations listed in the section {\hyperref[sunmatrix/SUNMatrix_Operations:sunmatrix-ops]{\emph{\DUspan{}{Description of the SUNMATRIX operations}}}}. Their names are
obtained from those in that section by appending the suffix \code{\_Sparse}
(e.g. \code{SUNMatCopy\_Sparse}).  The module SUNMATRIX\_SPARSE provides the
following additional user-callable routines:
\index{SUNSparseMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix}\pysiglinewithargsret{SUNMatrix \bfcode{SUNSparseMatrix}}{sunindextype\emph{ M}, sunindextype\emph{ N}, sunindextype\emph{ NNZ}, int\emph{ sparsetype}}{}
This constructor function creates and allocates memory for a sparse
\code{SUNMatrix}.  Its arguments are the number of rows and columns of
the matrix, \emph{M} and \emph{N}, the maximum number of nonzeros to be
stored in the matrix, \emph{NNZ}, and a flag \emph{sparsetype} indicating
whether to use CSR or CSC format (valid choices are \code{CSR\_MAT} or
\code{CSC\_MAT}).

\end{fulllineitems}

\index{SUNSparseFromDenseMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseFromDenseMatrix}\pysiglinewithargsret{SUNMatrix \bfcode{SUNSparseFromDenseMatrix}}{SUNMatrix\emph{ A}, realtype\emph{ droptol}, int\emph{ sparsetype}}{}
This constructor function creates a new sparse matrix from an
existing SUNMATRIX\_DENSE object by copying all values with
magnitude larger than \emph{droptol} into the sparse matrix structure.

Requirements:
\begin{itemize}
\item {} 
\emph{A} must have type \code{SUNMATRIX\_DENSE}

\item {} 
\emph{droptol} must be non-negative

\item {} 
\emph{sparsetype} must be either \code{CSC\_MAT} or \code{CSR\_MAT}

\end{itemize}

The function returns \code{NULL} if any requirements are violated, or if
the matrix storage request cannot be satisfied.

\end{fulllineitems}

\index{SUNSparseFromBandMatrix (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseFromBandMatrix}\pysiglinewithargsret{SUNMatrix \bfcode{SUNSparseFromBandMatrix}}{SUNMatrix\emph{ A}, realtype\emph{ droptol}, int\emph{ sparsetype}}{}
This constructor function creates a new sparse matrix from an
existing SUNMATRIX\_BAND object by copying all values with
magnitude larger than \emph{droptol} into the sparse matrix structure.

Requirements:
\begin{itemize}
\item {} 
\emph{A} must have type \code{SUNMATRIX\_BAND}

\item {} 
\emph{droptol} must be non-negative

\item {} 
\emph{sparsetype} must be either \code{CSC\_MAT} or \code{CSR\_MAT}.

\end{itemize}

The function returns \code{NULL} if any requirements are violated, or if
the matrix storage request cannot be satisfied.

\end{fulllineitems}

\index{SUNSparseMatrix\_Realloc (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Realloc}\pysiglinewithargsret{int \bfcode{SUNSparseMatrix\_Realloc}}{SUNMatrix\emph{ A}}{}
This function reallocates internal storage arrays in a sparse matrix
so that the resulting sparse matrix has no wasted space (i.e. the
space allocated for nonzero entries equals the actual number of
nonzeros, \code{indexptrs{[}NP{]}}). Returns 0 on success and
1 on failure (e.g. if the input matrix is not sparse).

\end{fulllineitems}

\index{SUNSparseMatrix\_Print (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Print}\pysiglinewithargsret{void \bfcode{SUNSparseMatrix\_Print}}{SUNMatrix\emph{ A}, FILE*\emph{ outfile}}{}
This function prints the content of a sparse \code{SUNMatrix} to the
output stream specified by \code{outfile}.  Note: \code{stdout}
or \code{stderr} may be used as arguments for \code{outfile} to print
directly to standard output or standard error, respectively.

\end{fulllineitems}

\index{SUNSparseMatrix\_Rows (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Rows}\pysiglinewithargsret{sunindextype \bfcode{SUNSparseMatrix\_Rows}}{SUNMatrix\emph{ A}}{}
This function returns the number of rows in the sparse \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_Columns (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Columns}\pysiglinewithargsret{sunindextype \bfcode{SUNSparseMatrix\_Columns}}{SUNMatrix\emph{ A}}{}
This function returns the number of columns in the sparse \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_NNZ (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NNZ}\pysiglinewithargsret{sunindextype \bfcode{SUNSparseMatrix\_NNZ}}{SUNMatrix\emph{ A}}{}
This function returns the number of entries allocated for nonzero
storage for the sparse \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_NP (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_NP}\pysiglinewithargsret{sunindextype \bfcode{SUNSparseMatrix\_NP}}{SUNMatrix\emph{ A}}{}
This function returns the number of index pointers for the
sparse \code{SUNMatrix} (the \code{indexptrs} array has \code{NP+1}
entries).

\end{fulllineitems}

\index{SUNSparseMatrix\_SparseType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_SparseType}\pysiglinewithargsret{int \bfcode{SUNSparseMatrix\_SparseType}}{SUNMatrix\emph{ A}}{}
This function returns the storage type (\code{CSR\_MAT}
or \code{CSC\_MAT}) for the sparse  \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_Data (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_Data}\pysiglinewithargsret{realtype* \bfcode{SUNSparseMatrix\_Data}}{SUNMatrix\emph{ A}}{}
This function returns a pointer to the data array for the
sparse \code{SUNMatrix}.

\end{fulllineitems}

\index{SUNSparseMatrix\_IndexValues (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_IndexValues}\pysiglinewithargsret{sunindextype* \bfcode{SUNSparseMatrix\_IndexValues}}{SUNMatrix\emph{ A}}{}
This function returns a pointer to index value array for the sparse
\code{SUNMatrix}: for CSR format this is the column index for each nonzero
entry, for CSC format this is the row index for each nonzero entry.

\end{fulllineitems}

\index{SUNSparseMatrix\_IndexPointers (C function)}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:c.SUNSparseMatrix_IndexPointers}\pysiglinewithargsret{sunindextype* \bfcode{SUNSparseMatrix\_IndexPointers}}{SUNMatrix\emph{ A}}{}
This function returns a pointer to the index pointer array for the
sparse \code{SUNMatrix}: for CSR format this is the location of the first
entry of each row in the \code{data} and \code{indexvalues} arrays, for
CSC format this is the location of the first entry of each column.

\end{fulllineitems}


\begin{notice}{note}{Note:}
Within the \code{SUNMatMatvec\_Sparse} routine, internal
consistency checks are performed to ensure that the matrix
is called with consistent \code{N\_Vector} implementations.
These are currently limited to: NVECTOR\_SERIAL,
NVECTOR\_OPENMP, and NVECTOR\_PTHREADS.  As additional
compatible vector implementations are added to SUNDIALS,
these will be included within this compatibility check.
\end{notice}

For solvers that include a Fortran interface module, the SUNMATRIX\_SPARSE
module also includes the Fortran-callable function
{\hyperref[sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMatInit]{\emph{\code{FSUNSparseMatInit()}}}} to initialize this SUNMATRIX\_SPARSE module
for a given SUNDIALS solver.
\index{FSUNSparseMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMatInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSparseMatInit}}{\emph{CODE}, \emph{M}, \emph{N}, \emph{NNZ}, \emph{SPARSETYPE}, \emph{IER}}{}
Initializes a sparse \code{SUNMatrix} structure for use in a SUNDIALS solver.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{M} (\code{long int}, input) -- number of matrix rows.

\item {} 
\emph{N} (\code{long int}, input) -- number of matrix columns.

\item {} 
\emph{NNZ} (\code{long int}, input) -- amount of nonzero storage to allocate.

\item {} 
\emph{SPARSETYPE} (\code{int}, input) -- matrix sparsity type
(\code{CSC\_MAT} or \code{CSR\_MAT})

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMassMatInit]{\emph{\code{FSUNSparseMassMatInit()}}}} initializes
this SUNMATRIX\_SPARSE module for storing the mass matrix.
\index{FSUNSparseMassMatInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunmatrix/SUNMatrix_Sparse:f/_/FSUNSparseMassMatInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSparseMassMatInit}}{\emph{M}, \emph{N}, \emph{NNZ}, \emph{SPARSETYPE}, \emph{IER}}{}
Initializes a sparse \code{SUNMatrix} structure for use as a mass
matrix in ARKode.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{M} (\code{long int}, input) -- number of matrix rows.

\item {} 
\emph{N} (\code{long int}, input) -- number of matrix columns.

\item {} 
\emph{NNZ} (\code{long int}, input) -- amount of nonzero storage to allocate.

\item {} 
\emph{SPARSETYPE} (\code{int}, input) -- matrix sparsity type
(\code{CSC\_MAT} or \code{CSR\_MAT})

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{SUNMATRIX Examples}
\label{sunmatrix/SUNMatrix_Examples::doc}\label{sunmatrix/SUNMatrix_Examples:sunmatrix-examples}\label{sunmatrix/SUNMatrix_Examples:id1}
There are \code{SUNMatrix} examples that may be installed for each
implementation: dense, banded, and sparse.  Each implementation
makes use of the functions in \code{test\_sunmatrix.c}.
These example functions show simple usage of the \code{SUNMatrix} family
of functions.  The inputs to the examples depend on the matrix type,
and are output to \code{stdout} if the example is run without the
appropriate number of command-line arguments.

The following is a list of the example functions in \code{test\_sunmatrix.c}:
\begin{itemize}
\item {} 
\code{Test\_SUNMatGetID}: Verifies the returned matrix ID against
the value that should be returned.

\item {} 
\code{Test\_SUNMatClone}: Creates clone of an existing matrix,
copies the data, and checks that their values match.

\item {} 
\code{Test\_SUNMatZero}: Zeros out an existing matrix and checks
that each entry equals 0.0.

\item {} 
\code{Test\_SUNMatCopy}: Clones an input matrix, copies its data
to a clone, and verifies that all values match.

\item {} 
\code{Test\_SUNMatScaleAdd}: Given an input matrix \(A\) and an
input identity matrix \(I\), this test clones and copies
\(A\) to a new matrix \(B\), computes \(B = -B+B\), and
verifies that the resulting matrix entries equal 0.  Additionally,
if the matrix is square, this test clones and copies \(A\) to a
new matrix \(D\), clones and copies \(I\) to a new matrix
\(C\), computes \(D = D+I\) and \(C = C+A\) using
\code{SUNMatScaleAdd}, and then verifies that \(C=D\).

\item {} 
\code{Test\_SUNMatScaleAddI}: Given an input matrix \(A\) and an
input identity matrix \(I\), this clones and copies \(I\) to
a new matrix \(B\), computes \(B = -B+I\) using
\code{SUNMatScaleAddI}, and verifies that the resulting matrix entries
equal 0.

\item {} 
\code{Test\_SUNMatMatvec} Given an input matrix \(A\) and input
vectors \(x\) and \(y\) such that \(y=Ax\), this test
has different behavior depending on whether \(A\) is square.  If
it is square, it clones and copies \(A\) to a new matrix
\(B\), computes \(B = 3B+I\) using \code{SUNMatScaleAddI},
clones \(y\) to new vectors \(w\) and \(z\), computes
\(z = Bx\) using \code{SUNMatMatvec}, computes \(w = 3y+x\)
using \code{N\_VLinearSum}, and verifies that \(w==z\).  If
\(A\) is not square, it just clones \(y\) to a new vector
\(z\), \emph{computes :math:{}`z=Ax} using \code{SUNMatMatvec}, and
verifies that \(y=z\).

\item {} 
\code{Test\_SUNMatSpace}: verifies that \code{SUNMatSpace} can be
called, and outputs the results to \code{stdout}.

\end{itemize}


\section{SUNMATRIX functions required by ARKode}
\label{sunmatrix/ARKode_requirements:sunmatrix-arkode}\label{sunmatrix/ARKode_requirements:sunmatrix-functions-required-by-arkode}\label{sunmatrix/ARKode_requirements::doc}
In Table {\hyperref[sunmatrix/ARKode_requirements:sunmatrix-arkode-use]{\emph{\DUspan{}{List of matrix functions usage by ARKode code modules}}}}, we list the matrix functions in
the \code{SUNMatrix} module used within the ARKode package.  The table
also shows, for each function, which of the code modules uses the
function.  Neither the main ARKode integrator or the ARKSPILS
interface call \code{SUNMatrix} functions directly, so the table columns
are specific to the ARKDLS direct solver interface and the
ARKBANDPRE and ARKBBDPRE preconditioner modules.

At this point, we should emphasize that the ARKode user does not need
to know anything about the usage of matrix functions by the ARKode
code modules in order to use ARKode.  The information is presented as
an implementation detail for the interested reader.


\subsection{List of matrix functions usage by ARKode code modules}
\label{sunmatrix/ARKode_requirements:list-of-matrix-functions-usage-by-arkode-code-modules}\label{sunmatrix/ARKode_requirements:sunmatrix-arkode-use}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Routine
} & \textsf{\relax 
ARKDLS
} & \textsf{\relax 
ARKBANDPRE
} & \textsf{\relax 
ARKBBDPRE
}\\
\hline
SUNMatGetID
 & 
X
 &  & \\
\hline
SUNMatClone
 & 
X
 &  & \\
\hline
SUNMatDestroy
 & 
X
 & 
X
 & 
X
\\
\hline
SUNMatZero
 & 
X
 & 
X
 & 
X
\\
\hline
SUNMatCopy
 & 
X
 & 
X
 & 
X
\\
\hline
SUNMatScaleAddI
 & 
X
 & 
X
 & 
X
\\
\hline
SUNMatScaleAdd
 & 
1
 &  & \\
\hline
SUNMatMatvec
 & 
1
 &  & \\
\hline
SUNMatSpace
 & 
2
 & 
2
 & 
2
\\
\hline\end{tabulary}

\begin{enumerate}
\item {} 
These matrix functions are only used for problems involving a
non-identity mass matrix.

\item {} 
These matrix functions are optionally used, in that these are only
called if they are implemented in the \code{SUNMatrix} module that is
being used (i.e. their function pointers are non-\code{NULL}).

\end{enumerate}


\chapter{Linear Solver Data Structures}
\label{sunlinsol/index:linear-solver-data-structures}\label{sunlinsol/index::doc}\label{sunlinsol/index:sunlinsol}
The SUNDIALS library comes packaged with a variety of
\code{SUNLinearSolver} implementations, designed for simulations
requiring either direct or matrix-free iterative linear solvers for
problems in serial or shared-memory parallel environments.  SUNDIALS
additionally provides a simple interface for generic linear solvers
(akin to a C++ \emph{abstract base class}).  All of the major SUNDIALS
packages (CVODE(s), IDA(s), KINSOL, ARKODE), are constructed to only
depend on these generic linear solver operations, making them
immediately extensible to new user-defined linear solver objects.


\section{Description of the SUNLinearSolver Module}
\label{sunlinsol/SUNLinSol_Description:sunlinsol-description}\label{sunlinsol/SUNLinSol_Description::doc}\label{sunlinsol/SUNLinSol_Description:description-of-the-sunlinearsolver-module}
For problems that involve the solution of linear systems of equations,
the SUNDIALS solvers operate using generic linear solver modules
(of type \code{SUNLinearSolver}), through a set of operations defined by
the particular \code{SUNLinearSolver} implementation.  These work in coordination
with the SUNDIALS generic \code{N\_Vector} and \code{SUNMatrix} modules to
provide a set of compatible data structures and solvers for the
solution of linear systems using direct or iterative
methods. Moreover, users can provide their own specific
\code{SUNLinearSolver} implementation to each SUNDIALS solver,
particularly in cases where they provide their own \code{N\_Vector} and/or
\code{SUNMatrix} modules, and the customized linear solver leverages
these additional data structures to create highly efficient and/or
scalable solvers for their particular problem.  Additionally, SUNDIALS
provides native implementations \code{SUNLinearSolver} modules, as well
as \code{SUNLinearSolver} modules that interface between SUNDIALS and
external linear solver libraries.

The various SUNDIALS solvers have been designed to specifically
leverage the use of either \emph{direct linear solvers}
or matrix-free, \emph{scaled, preconditioned, iterative linear solvers},
through their ``Dls'' and ``Spils'' interfaces, respectively.
Additionally, SUNDIALS solvers can make use of user-supplied custom
linear solvers, whether these are problem-specific or come from
external solver libraries.

For iterative (and possibly custom) linear solvers, the SUNDIALS
solvers leverage scaling and preconditioning, as applicable, to
balance error between solution components and to accelerate
convergence of the linear solver.  To this end, instead of solving the
linear system \(Ax = b\) directly, we apply the underlying
iterative algorithm to the transformed system
\phantomsection\label{sunlinsol/SUNLinSol_Description:equation-eq:transformed_linear_system}\begin{gather}
\begin{split}\tilde{A} \tilde{x} = \tilde{b}\end{split}\label{sunlinsol/SUNLinSol_Description-eq:transformed_linear_system}
\end{gather}
where
\phantomsection\label{sunlinsol/SUNLinSol_Description:equation-eq:transformed_linear_system_components}\begin{gather}
\begin{split}\tilde{A} &= S_1 P_1^{-1} A P_2^{-1} S_2^{-1},\\
\tilde{b} &= S_1 P_1^{-1} b,\\
\tilde{x} &= S_2 P_2 x,\end{split}\label{sunlinsol/SUNLinSol_Description-eq:transformed_linear_system_components}
\end{gather}
and where
\begin{itemize}
\item {} 
\(P_1\) is the left preconditioner,

\item {} 
\(P_2\) is the right preconditioner,

\item {} 
\(S_1\) is a diagonal matrix of scale factors for
\(P_1^{-1} b\),

\item {} 
\(S_2\) is a diagonal matrix of scale factors for \(P_2 x\).

\end{itemize}

The SUNDIALS solvers request that iterative linear solvers stop
based on the 2-norm of the scaled preconditioned residual meeting a
prescribed tolerance
\begin{gather}
\begin{split}\left\| \tilde{b} - \tilde{A} \tilde{x} \right\|_2  <  \text{tol}.\end{split}\notag
\end{gather}
We note that not all of the iterative linear solvers implemented in
SUNDIALS support the full range of the above options.  Similarly,
some of the SUNDIALS integrators only utilize a subset of these
options.  Exceptions to the operators shown above are described in
the documentation for each \code{SUNLinearSolver} implementation, or for each
SUNDIALS solver ``Spils'' interface.

The generic \code{SUNLinearSolver} type has been modeled after the
object-oriented style of the generic \code{N\_Vector} type.
Specifically, a generic \code{SUNLinearSolver} is a pointer to a structure
that has an implementation-dependent \emph{content} field containing
the description and actual data of the linear solver, and an \emph{ops}
field pointing to a structure with generic linear solver operations.
The type \code{SUNLinearSolver} is defined as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver} \PYG{o}{*}\PYG{n}{SUNLinearSolver}\PYG{p}{;}

\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{content}\PYG{p}{;}
  \PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver\PYGZus{}Ops} \PYG{o}{*}\PYG{n}{ops}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The \code{\_generic\_SUNLinearSolver\_Ops} structure is essentially a
list of pointers to the various actual linear solver operations, and
is defined as

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}generic\PYGZus{}SUNLinearSolver\PYGZus{}Ops} \PYG{p}{\PYGZob{}}
  \PYG{n}{SUNLinearSolver\PYGZus{}Type} \PYG{p}{(}\PYG{o}{*}\PYG{n}{gettype}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setatimes}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{,} \PYG{n}{ATimesFn}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setpreconditioner}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{,}
                                            \PYG{n}{PSetupFn}\PYG{p}{,} \PYG{n}{PSolveFn}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setscalingvectors}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,}
                                            \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{initialize}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{setup}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{solve}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{n}{SUNMatrix}\PYG{p}{,} \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,}
                                \PYG{n}{N\PYGZus{}Vector}\PYG{p}{,} \PYG{n}{realtype}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{numiters}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{realtype}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{resnorm}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{n+nf}{int}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{lastflag}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{space}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{,} \PYG{k+kt}{long} \PYG{k+kt}{int}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector}             \PYG{p}{(}\PYG{o}{*}\PYG{n}{resid}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
  \PYG{k+kt}{int}                  \PYG{p}{(}\PYG{o}{*}\PYG{n}{free}\PYG{p}{)}\PYG{p}{(}\PYG{n}{SUNLinearSolver}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

The generic \code{SUNLinearSolver} module defines and implements the
linear solver operations acting on \code{SUNLinearSolver} objects.
These routines are in fact only wrappers for the linear solver operations
defined by a particular \code{SUNLinearSolver} implementation, which are
accessed through the \{em ops\} field of the \code{SUNLinearSolver}
structure. To illustrate this point we show below the implementation
of a typical linear solver operation from the generic \code{SUNLinearSolver}
module, namely \code{SUNLinSolInitialize}, which initializes a
\code{SUNLinearSolver} object for use after it has been created and configured,
and returns a flag denoting a successful/failed operation:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{SUNLinSolInitialize}\PYG{p}{(}\PYG{n}{SUNLinearSolver} \PYG{n}{S}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
  \PYG{k}{return} \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)} \PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ops}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{initialize}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

The subsection {\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}} contains a complete list of all
linear solver operations defined by the generic \code{SUNLinearSolver}
module.  In order to support both direct and iterative linear solver
types, the generic \code{SUNLinearSolver} module defines linear solver
routines (or arguments) that may be specific to individual use cases.
As such, for each routine we specify its intended use.  If a custom
\code{SUNLinearSolver} module is provided, the function pointers for
non-required routines may be set to \code{NULL} to indicate that they
are not provided.

A particular implementation of the \code{SUNLinearSolver} module must:
\begin{itemize}
\item {} 
Specify the \emph{content} field of the \code{SUNLinearSolver} object.

\item {} 
Define and implement a minimal subset of the linear solver
operations. See the documentation for each SUNDIALS linear solver
interface to determine which \code{SUNLinearSolver} operations they
require.

Note that the names of these routines should be unique to that
implementation in order to permit using more than one
\code{SUNLinearSolver} module (each with different \code{SUNLinearSolver}
internal data representations) in the same code.

\item {} 
Define and implement user-callable constructor and destructor
routines to create and free a \code{SUNLinearSolver} with
the new \emph{content} field and with \emph{ops} pointing to the
new linear solver operations.

\item {} 
Optionally, define and implement additional user-callable routines
acting on the newly defined \code{SUNLinearSolver} (e.g., routines to
set various configuration options for tuning the linear solver to a
particular problem).

\item {} 
Optionally, provide functions as needed for that particular
implementation to access different parts in the \emph{content} field of
the newly defined \code{SUNLinearSolver} object (e.g., routines to
return various statistics from the solver).

\end{itemize}

Each \code{SUNLinearSolver} implementation included in SUNDIALS has a ``type''
identifier specified in enumeration and shown in Table {\hyperref[sunlinsol/SUNLinSol_Description:sunlinsol-linsolids]{\emph{\DUspan{}{Identifiers associated with linear solver kernels supplied with SUNDIALS}}}}.
It is recommended that a user-supplied \code{SUNLinearSolver} implementation set
this identifier based on the SUNDIALS solver interface they intend
to use: ``Dls'' interfaces require the \code{SUNLINEARSOLVER\_DIRECT}
\code{SUNLinearSolver} objects, ``Spils'' interfaces require the
\code{SUNLINEARSOLVER\_ITERATIVE} objects.


\subsection{Identifiers associated with linear solver kernels supplied with SUNDIALS}
\label{sunlinsol/SUNLinSol_Description:sunlinsol-linsolids}\label{sunlinsol/SUNLinSol_Description:identifiers-associated-with-linear-solver-kernels-supplied-with-sundials}
\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
Linear Solver ID
} & \textsf{\relax 
Solver type
} & \textsf{\relax 
ID Value
}\\
\hline
SUNLINEARSOLVER\_DIRECT
 & 
Direct solvers
 & 
0
\\
\hline
SUNLINEARSOLVER\_ITERATIVE
 & 
Iterative solvers
 & 
1
\\
\hline
SUNLINEARSOLVER\_CUSTOM
 & 
Custom solvers
 & 
2
\\
\hline\end{tabulary}



\section{Description of the SUNLinearSolver operations}
\label{sunlinsol/SUNLinSol_Operations:sunlinsol-ops}\label{sunlinsol/SUNLinSol_Operations::doc}\label{sunlinsol/SUNLinSol_Operations:description-of-the-sunlinearsolver-operations}
For each of the \code{SUNLinearSolver} operations, we give the name,
usage of the function, and a description of its mathematical
operations below.
\index{SUNLinSolGetType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolGetType}\pysiglinewithargsret{SUNLinearSolver\_Type \bfcode{SUNLinSolGetType}}{SUNLinearSolver\emph{ LS}}{}
Returns the type identifier for the linear solver \emph{LS}. It is used
to determine the solver type (direct, iterative, or custom) from
the abstract \code{SUNLinearSolver} interface.  This is used to
assess compatibility with SUNDIALS-provided linear solver
interfaces.  Returned values are given in the Table
{\hyperref[sunlinsol/SUNLinSol_Description:sunlinsol-linsolids]{\emph{\DUspan{}{Identifiers associated with linear solver kernels supplied with SUNDIALS}}}}.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{type} \PYG{o}{=} \PYG{n}{SUNLinSolGetType}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolInitialize (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolInitialize}\pysiglinewithargsret{int \bfcode{SUNLinSolInitialize}}{SUNLinearSolver\emph{ LS}}{}
Performs linear solver initialization (assumes that all
solver-specific options have been set).  This should return zero for a
successful call, and a negative value for a failure, ideally
returning one of the generic error codes listed in section
{\hyperref[sunlinsol/SUNLinSol_ErrorCodes:sunlinsol-errorcodes]{\emph{\DUspan{}{Error Codes returned from SUNLinearSolver implementations}}}}.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNLinSolInitialize}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolSetup (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolSetup}\pysiglinewithargsret{int \bfcode{SUNLinSolSetup}}{SUNLinearSolver\emph{ LS}, SUNMatrix\emph{ A}}{}
Performs any linear solver setup needed, based on an updated system
\code{SUNMatrix} \emph{A}.  This may be called frequently (e.g. with a full
Newton method) or infrequently (for a modified Newton method), based
on the type of integrator and/or nonlinear solver requesting the
solves.  This should return zero for a successful call, a positive
value for a recoverable failure and a negative value for an
unrecoverable failure, ideally returning one of the generic error
codes listed in section {\hyperref[sunlinsol/SUNLinSol_ErrorCodes:sunlinsol-errorcodes]{\emph{\DUspan{}{Error Codes returned from SUNLinearSolver implementations}}}}.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNLinSolSetup}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{A}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolSolve (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolSolve}\pysiglinewithargsret{int \bfcode{SUNLinSolSolve}}{SUNLinearSolver\emph{ LS}, SUNMatrix\emph{ A}, N\_Vector\emph{ x}, N\_Vector\emph{ b}, realtype\emph{ tol}}{}
Solves a linear system \(Ax = b\).  This should return zero for
a successful call, a positive value for a recoverable failure and a
negative value for an unrecoverable failure, ideally returning one
of the generic error codes listed in section {\hyperref[sunlinsol/SUNLinSol_ErrorCodes:sunlinsol-errorcodes]{\emph{\DUspan{}{Error Codes returned from SUNLinearSolver implementations}}}}.

\textbf{Direct solvers:} can ignore the  \emph{tol} argument.

\textbf{Iterative solvers:} can ignore the \code{SUNMatrix} input \emph{A} since
a \code{NULL} argument will be passed (these should instead rely on
the matrix-vector product function supplied through the routine
{\hyperref[sunlinsol/SUNLinSol_Operations:c.SUNLinSolSetATimes]{\emph{\code{SUNLinSolSetATimes()}}}}).  These should attempt to solve to
the specified \code{realtype} tolerance \emph{tol} in a weighted 2-norm.
If the solver does not support scaling then it should just use a
2-norm.

\textbf{Custom solvers:} all arguments will be supplied, and if the
solver is approximate then it should attempt to solve to the
specified \code{realtype} tolerance \emph{tol} in a weighted 2-norm. If the
solver does not support scaling then it should just use a 2-norm.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNLinSolSolve}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{A}\PYG{p}{,} \PYG{n}{x}\PYG{p}{,} \PYG{n}{b}\PYG{p}{,} \PYG{n}{tol}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolFree (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolFree}\pysiglinewithargsret{int \bfcode{SUNLinSolFree}}{SUNLinearSolver\emph{ LS}}{}
Frees memory allocated by the linear solver.  This should return
zero for a successful call, and a negative value for a failure.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNLinSolFree}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolSetATimes (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolSetATimes}\pysiglinewithargsret{int \bfcode{SUNLinSolSetATimes}}{SUNLinearSolver\emph{ LS}, void*\emph{ A\_data}, {\hyperref[sunlinsol/SUNLinSol_Operations:c.ATimesFn]{\emph{ATimesFn}}}\emph{ ATimes}}{}
Provides {\hyperref[sunlinsol/SUNLinSol_Operations:c.ATimesFn]{\emph{\code{ATimesFn}}}} function pointer, as well as a \code{void *}
pointer to a data structure used by this routine, to a linear
solver object.  SUNDIALS solvers will call this function to set the
matrix-vector product function to either a solver-provided
difference-quotient via vector operations or a user-supplied
solver-specific routine.  This routine should return zero for a
successful call, and a negative value for a failure, ideally
returning one of the generic error codes listed in section
{\hyperref[sunlinsol/SUNLinSol_ErrorCodes:sunlinsol-errorcodes]{\emph{\DUspan{}{Error Codes returned from SUNLinearSolver implementations}}}}.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
ier = SUNLinSolSetATimes(LS, A\PYGZbs{}\PYGZus{}data, ATimes);
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolSetPreconditioner (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolSetPreconditioner}\pysiglinewithargsret{int \bfcode{SUNLinSolSetPreconditioner}}{SUNLinearSolver\emph{ LS}, void*\emph{ P\_data}, {\hyperref[sunlinsol/SUNLinSol_Operations:c.PSetupFn]{\emph{PSetupFn}}}\emph{ Pset}, {\hyperref[sunlinsol/SUNLinSol_Operations:c.PSolveFn]{\emph{PSolveFn}}}\emph{ Psol}}{}
(Optional; Iterative/Custom linear solvers only)

Provides {\hyperref[sunlinsol/SUNLinSol_Operations:c.PSetupFn]{\emph{\code{PSetupFn}}}} and {\hyperref[sunlinsol/SUNLinSol_Operations:c.PSolveFn]{\emph{\code{PSolveFn}}}} function
pointers that implement the preconditioner solves \(P_1^{-1}\)
and \(P_2^{-1}\). This routine will be called by a SUNDIALS
solver, which will provide translation between the generic
\emph{Pset} and \emph{Psol} calls and the integrator-specific and
integrator- or user-supplied routines.  This routine should return
zero for a successful call, and a negative value for a failure,
ideally returning one of the generic error codes listed in section
{\hyperref[sunlinsol/SUNLinSol_ErrorCodes:sunlinsol-errorcodes]{\emph{\DUspan{}{Error Codes returned from SUNLinearSolver implementations}}}}.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNLinSolSetPreconditioner}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{Pdata}\PYG{p}{,} \PYG{n}{Pset}\PYG{p}{,} \PYG{n}{Psol}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolSetScalingVectors (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolSetScalingVectors}\pysiglinewithargsret{int \bfcode{SUNLinSolSetScalingVectors}}{SUNLinearSolver\emph{ LS}, N\_Vector\emph{ s1}, N\_Vector\emph{ s2}}{}
(Optional; Iterative/Custom linear solvers only)

Sets pointers to left/right scaling vectors for the linear system
solve.  Here, \emph{s1} is an \code{N\_Vector} of positive scale factors
containing the diagonal of the \(S_1\) scaling matrix.
Similarly, \emph{s2} is an \code{N\_Vector} containing the diagonal of
the \(S_2\) scaling matrix.  Neither of these vectors are
tested for positivity, and a \code{NULL} argument for either indicates
that the corresponding scaling matrix is the identity. This routine
should return zero for a successful call, and a negative value for
a failure, ideally returning one of the generic error codes listed
in section {\hyperref[sunlinsol/SUNLinSol_ErrorCodes:sunlinsol-errorcodes]{\emph{\DUspan{}{Error Codes returned from SUNLinearSolver implementations}}}}.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNLinSolSetScalingVectors}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolNumIters (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolNumIters}\pysiglinewithargsret{int \bfcode{SUNLinSolNumIters}}{SUNLinearSolver\emph{ LS}}{}
(Optional; Iterative/Custom linear solvers only)

Should return the number of linear iterations performed in the last
``solve'' call.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{its} \PYG{o}{=} \PYG{n}{SUNLinSolNumIters}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolResNorm (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolResNorm}\pysiglinewithargsret{realtype \bfcode{SUNLinSolResNorm}}{SUNLinearSolver\emph{ LS}}{}
(Optional; Iterative/Custom linear solvers only)

Should return the final residual norm from the last ``solve'' call.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rnorm} \PYG{o}{=} \PYG{n}{SUNLinSolResNorm}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolResid (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolResid}\pysiglinewithargsret{N\_Vector \bfcode{SUNLinSolResid}}{SUNLinearSolver\emph{ LS}}{}
(Optional; Iterative/Custom linear solvers only)

If an iterative method computes the preconditioned initial residual
and returns with a successful solve without performing any
iterations (i.e. either the initial guess or the preconditioner is
sufficiently accurate), then this function may be called by the
SUNDIALS solver.  This routine should return the \code{N\_Vector}
containing the preconditioned initial residual vector.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rvec} \PYG{o}{=} \PYG{n}{SUNLinSolResid}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolLastFlag (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolLastFlag}\pysiglinewithargsret{long int \bfcode{SUNLinSolLastFlag}}{SUNLinearSolver\emph{ LS}}{}
(Optional)

Should return the last error flag encountered within the linear
solver. This is not called by the SUNDIALS solvers directly; it
allows the user to investigate linear solver issues after a failed
solve.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{lflag} \PYG{o}{=} \PYG{n}{SUNLinLastFlag}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{SUNLinSolSpace (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.SUNLinSolSpace}\pysiglinewithargsret{int \bfcode{SUNLinSolSpace}}{SUNLinearSolver\emph{ LS}, long int\emph{ *lenrwLS}, long int\emph{ *leniwLS}}{}
(Optional)

Returns the storage requirements for the linear solver \emph{LS}.
\emph{lrw} is a \code{long int} containing the number of realtype words
and \emph{liw} is a \code{long int} containing the number of integer
words.  The return value is an integer flag denoting
success/failure of the operation.

This function is advisory only, for use in determining a user's
total space requirements.

Usage:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{ier} \PYG{o}{=} \PYG{n}{SUNLinSolSpace}\PYG{p}{(}\PYG{n}{LS}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{lrw}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{liw}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}



\section{Description of the client-supplied SUNLinearSolver routines}
\label{sunlinsol/SUNLinSol_Operations:sunlinsol-supplied}\label{sunlinsol/SUNLinSol_Operations:description-of-the-client-supplied-sunlinearsolver-routines}
The SUNDIALS packages provide the \emph{ATimes}, \emph{Pset} and \emph{Psol} routines
utilized by the \code{SUNLinearSolver} modules.  These function types are
defined in the header file \code{sundials/sundials\_iterative.h}, and
are described here in case a user wishes to interact directly with an
iterative \code{SUNLinearSolver} object.
\index{ATimesFn (C type)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.ATimesFn}\pysiglinewithargsret{typedef int \bfcode{(*ATimesFn)}}{void\emph{ *A\_data}, N\_Vector\emph{ v}, N\_Vector\emph{ z}}{}
These functions compute the action of a matrix on a vector,
performing the operation \(z = Av\).  Memory for \emph{z} should already be
allocted prior to calling this function.  The parameter \emph{A\_data} is
a pointer to any information about \(A\) which the function
needs in order to do its job. The vector \(v\) should be left
unchanged.  This routine should return 0 if successful and a
non-zero value if unsuccessful.

\end{fulllineitems}

\index{PSetupFn (C type)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.PSetupFn}\pysiglinewithargsret{typedef int \bfcode{(*PSetupFn)}}{void\emph{ *P\_data}}{}
These functions set up any requisite problem data in preparation
for calls to the corresponding {\hyperref[sunlinsol/SUNLinSol_Operations:c.PSolveFn]{\emph{\code{PSolveFn}}}}. This routine
should return 0 if successful and a non-zero value if
unsuccessful.

\end{fulllineitems}

\index{PSolveFn (C type)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Operations:c.PSolveFn}\pysiglinewithargsret{typedef int \bfcode{(*PSolveFn)}}{void\emph{ *P\_data}, N\_Vector\emph{ r}, N\_Vector\emph{ z}, realtype\emph{ tol}, int\emph{ lr}}{}
These functions solve the preconditioner equation \(Pz = r\)
for the vector \(z\).  Memory for \emph{z} should already be
allocted prior to calling this function.  The parameter \emph{P\_data} is
a pointer to any information about \(P\) which the function
needs in order to do its job (set up by the corresponding
{\hyperref[sunlinsol/SUNLinSol_Operations:c.PSetupFn]{\emph{\code{PSetupFn}}}}. The parameter \emph{lr} is input, and indicates
whether \(P\) is to be taken as the left preconditioner or the
right preconditioner: \emph{lr} = 1 for left and \emph{lr} = 2 for right.  If
preconditioning is on one side only, \emph{lr} can be ignored.  If the
preconditioner is iterative, then it should strive to solve the
preconditioner equation so that
\begin{gather}
\begin{split}\| Pz - r \|_{\text{wrms}} < tol\end{split}\notag
\end{gather}
where the weight vector for the WRMS norm may be accessed from the
main package memory structure.  The vector \emph{r} should not be
modified by the \emph{PSolveFn}.  This routine should return 0 if
successful and a non-zero value if unsuccessful.  On a failure, a
negative return value indicates an unrecoverable condition, while a
positive value indicates a recoverable one, in which the calling
routine may reattempt the solution after updating preconditioner
data.

\end{fulllineitems}



\section{Compatibility of SUNLinearSolver modules}
\label{sunlinsol/SUNLinSol_Compatibility:compatibility-of-sunlinearsolver-modules}\label{sunlinsol/SUNLinSol_Compatibility::doc}\label{sunlinsol/SUNLinSol_Compatibility:sunlinsol-compatibility}
We note that not all \code{SUNLinearSolver} types are compatible with all
\code{SUNMatrix} and \code{N\_Vector} types provided with SUNDIALS.  In Table
{\hyperref[sunlinsol/SUNLinSol_Compatibility:sunlinsol-linsol-matrix]{\emph{\DUspan{}{Compatible SUNLinearSolver and SUNMatrix implementations}}}} we show the direct linear solvers
available as \code{SUNLinearSolver} modules, and the compatible matrix
implementations.  Recall that Table {\hyperref[c_interface/Skeleton:cinterface-solver-vector]{\emph{\DUspan{}{SUNDIALS linear solver interfaces and vector implementations that can be used for each}}}} shows the
compatibility between all \code{SUNLinearSolver} modules and vector
implementations.


\subsection{Compatible SUNLinearSolver and SUNMatrix implementations}
\label{sunlinsol/SUNLinSol_Compatibility:compatible-sunlinearsolver-and-sunmatrix-implementations}\label{sunlinsol/SUNLinSol_Compatibility:sunlinsol-linsol-matrix}
\begin{tabulary}{\linewidth}{|L|L|L|L|L|}
\hline
\textsf{\relax 
Linear Solver
} & \textsf{\relax 
Dense
} & \textsf{\relax 
Banded
} & \textsf{\relax 
Sparse
} & \textsf{\relax 
User Supplied
}\\
\hline
Dense
 & 
X
 &  &  & 
X
\\
\hline
Band
 &  & 
X
 &  & 
X
\\
\hline
LapackDense
 & 
X
 &  &  & 
X
\\
\hline
LapackBand
 &  & 
X
 &  & 
X
\\
\hline
KLU
 &  &  & 
X
 & 
X
\\
\hline
SuperLU\_MT
 &  &  & 
X
 & 
X
\\
\hline
User supplied
 & 
X
 & 
X
 & 
X
 & 
X
\\
\hline\end{tabulary}



\section{Error Codes returned from SUNLinearSolver implementations}
\label{sunlinsol/SUNLinSol_ErrorCodes:sunlinsol-errorcodes}\label{sunlinsol/SUNLinSol_ErrorCodes:error-codes-returned-from-sunlinearsolver-implementations}\label{sunlinsol/SUNLinSol_ErrorCodes::doc}
The functions within the SUNDIALS-provided \code{SUNLinearSolver}
implementations return a common set of error codes, listed here:
\begin{itemize}
\item {} 
\code{SUNLS\_SUCCESS} (0) -- successful call or converged solve

\item {} 
\code{SUNLS\_MEM\_NULL} (-1) -- the memory argument to the function is \code{NULL}

\item {} 
\code{SUNLS\_ILL\_INPUT} (-2) -- an illegal input has been provided to the function

\item {} 
\code{SUNLS\_MEM\_FAIL} (-3) -- failed memory access or allocation

\item {} 
\code{SUNLS\_ATIMES\_FAIL\_UNREC} (-4) -- an unrecoverable failure occurred in the \code{ATimes} routine

\item {} 
\code{SUNLS\_PSET\_FAIL\_UNREC} (-5) -- an unrecoverable failure occurred in the \code{Pset} routine

\item {} 
\code{SUNLS\_PSOLVE\_FAIL\_UNREC} (-6) -- an unrecoverable failure occurred in the \code{Psolve} routine

\item {} 
\code{SUNLS\_PACKAGE\_FAIL\_UNREC} (-7) -- an unrecoverable failure occurred in an external linear solver package

\item {} 
\code{SUNLS\_GS\_FAIL} (-8) -- a failure occurred during Gram-Schmidt orthogonalization (SPGMR/SPFGMR)

\item {} 
\code{SUNLS\_QRSOL\_FAIL} (-9) -- a singular \$R\$ matrix was encountered in a QR factorization (SPGMR/SPFGMR)

\item {} 
\code{SUNLS\_RES\_REDUCED} (1) -- an iterative solver reduced the residual, but did not converge to the desired tolerance

\item {} 
\code{SUNLS\_CONV\_FAIL} (2) -- an iterative solver did not converge (and the residual was not reduced)

\item {} 
\code{SUNLS\_ATIMES\_FAIL\_REC} (3) -- a recoverable failure occurred in the \code{ATimes} routine

\item {} 
\code{SUNLS\_PSET\_FAIL\_REC} (4) -- a recoverable failure occurred in the \code{Pset} routine

\item {} 
\code{SUNLS\_PSOLVE\_FAIL\_REC} (5) -- a recoverable failure occurred in the \code{Psolve} routine

\item {} 
\code{SUNLS\_PACKAGE\_FAIL\_REC} (6) -- a recoverable failure occurred in an external linear solver package

\item {} 
\code{SUNLS\_QRFACT\_FAIL} (7) -- a singular matrix was encountered during a QR factorization (SPGMR/SPFGMR)

\item {} 
\code{SUNLS\_LUFACT\_FAIL} (8) -- a singular matrix was encountered during a LU factorization

\end{itemize}


\section{The SUNLINSOL\_DENSE Module}
\label{sunlinsol/SUNLinSol_Dense:the-sunlinsol-dense-module}\label{sunlinsol/SUNLinSol_Dense::doc}\label{sunlinsol/SUNLinSol_Dense:sunlinsol-dense}
The dense implementation of the \code{SUNLinearSolver} module provided with
SUNDIALS, SUNLINSOL\_DENSE, is designed to be used with the
corresponding SUNMATRIX\_DENSE matrix type, and one of the serial or
shared-memory \code{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP or
NVECTOR\_PTHREADS).  The SUNLINSOL\_DENSE module defines the \emph{content}
field of a \code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Dense} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{N} - size of the linear system,

\item {} 
\code{pivots} - index array for partial pivoting in LU factorization,

\item {} 
\code{last\_flag} - last error return flag from internal function evaluations.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The ``setup'' call performs a \(LU\) factorization with
partial (row) pivoting (\(\mathcal O(N^3)\) cost),
\(PA=LU\), where \(P\) is a permutation matrix, \(L\) is
a lower triangular matrix with 1's on the diagonal, and \(U\) is
an upper triangular matrix.  This factorization is stored in-place
on the input SUNMATRIX\_DENSE object \(A\), with pivoting
information encoding \(P\) stored in the \code{pivots} array.

\item {} 
The ``solve'' call performs pivoting and forward and
backward substitution using the stored \code{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_DENSE object
(\(\mathcal O(N^2)\) cost).

\end{itemize}

The header file to be included when using this module is
\code{sunlinsol/sunlinsol\_dense.h}.

The SUNLINSOL\_DENSE module defines dense implementations of all
``direct'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_Dense}

\item {} 
\code{SUNLinSolInitialize\_Dense} -- this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\code{SUNLinSolSetup\_Dense} -- this performs the \(LU\) factorization.

\item {} 
\code{SUNLinSolSolve\_Dense} -- this uses the \(LU\) factors
and \code{pivots} array to perform the solve.

\item {} 
\code{SUNLinSolLastFlag\_Dense}

\item {} 
\code{SUNLinSolSpace\_Dense} -- this only returns information for
the storage \emph{within} the solver object, i.e. storage
for \code{N}, \code{last\_flag}, and \code{pivots}.

\item {} 
\code{SUNLinSolFree\_Dense}

\end{itemize}

The module SUNLINSOL\_DENSE provides the following additional
user-callable constructor routine:
\index{SUNDenseLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Dense:c.SUNDenseLinearSolver}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNDenseLinearSolver}}{N\_Vector\emph{ y}, SUNMatrix\emph{ A}}{}
This function creates and allocates memory for a dense \code{SUNLinearSolver}.
Its arguments are an \code{N\_Vector} and \code{SUNMatrix}, that it uses to
determine the linear system size and to assess compatibility with
the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \code{N\_Vector} and \code{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_DENSE matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector types.  As
additional compatible matrix and vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

If either \code{A} or \code{y} are incompatible then this routine will
return \code{NULL}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_DENSE module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_Dense:f/_/FSUNDenseLinSolInit]{\emph{\code{FSUNDenseLinSolInit()}}}} to initialize
this SUNLINSOL\_DENSE module for a given SUNDIALS solver.
\index{FSUNDenseLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Dense:f/_/FSUNDenseLinSolInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNDenseLinSolInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a dense \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_Dense:f/_/FSUNMassDenseLinSolInit]{\emph{\code{FSUNMassDenseLinSolInit()}}}}
initializes this SUNLINSOL\_DENSE module for solving mass matrix linear
systems.
\index{FSUNMassDenseLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Dense:f/_/FSUNMassDenseLinSolInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassDenseLinSolInit}}{\emph{IER}}{}
Initializes a dense \code{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNLINSOL\_BAND Module}
\label{sunlinsol/SUNLinSol_Band:the-sunlinsol-band-module}\label{sunlinsol/SUNLinSol_Band:sunlinsol-band}\label{sunlinsol/SUNLinSol_Band::doc}
The band implementation of the \code{SUNLinearSolver} module provided with
SUNDIALS, SUNLINSOL\_BAND, is designed to be used with the
corresponding SUNMATRIX\_BAND matrix type, and one of the serial or
shared-memory \code{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP or
NVECTOR\_PTHREADS).  The SUNLINSOL\_BAND module defines the \emph{content}
field of a \code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Band} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{N} - size of the linear system,

\item {} 
\code{pivots} - index array for partial pivoting in LU factorization,

\item {} 
\code{last\_flag} - last error return flag from internal function evaluations.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The ``setup'' call performs a \(LU\) factorization with
partial (row) pivoting, \(PA=LU\), where \(P\) is a permutation matrix,
\(L\) is a lower triangular matrix with 1's on the diagonal, and \(U\)
is an upper triangular matrix.  This factorization is stored
in-place on the input SUNMATRIX\_BAND object \(A\), with pivoting
information encoding \(P\) stored in the \code{pivots} array.

\item {} 
The ``solve'' call performs pivoting and forward and
backward substitution using the stored \code{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_BAND object.

\item {} 
\(A\) must be allocated to accommodate the increase in upper
bandwidth that occurs during factorization.  More precisely, if \(A\)
is a band matrix with upper bandwidth \code{mu} and lower bandwidth
\code{ml}, then the upper triangular factor \(U\) can have upper
bandwidth as big as \code{smu = MIN(N-1,mu+ml)}. The lower triangular
factor \(L\) has lower bandwidth \code{ml}.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_band.h}.

The SUNLINSOL\_BAND module defines band implementations of all
``direct'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_Band}

\item {} 
\code{SUNLinSolInitialize\_Band} -- this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\code{SUNLinSolSetup\_Band} -- this performs the \(LU\) factorization.

\item {} 
\code{SUNLinSolSolve\_Band} -- this uses the \(LU\) factors
and \code{pivots} array to perform the solve.

\item {} 
\code{SUNLinSolLastFlag\_Band}

\item {} 
\code{SUNLinSolSpace\_Band} -- this only returns information for
the storage \emph{within} the solver object, i.e. storage
for \code{N}, \code{last\_flag}, and \code{pivots}.

\item {} 
\code{SUNLinSolFree\_Band}

\end{itemize}

The module SUNLINSOL\_BAND provides the following additional
user-callable constructor routine:
\index{SUNBandLinearSolver (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Band:c.SUNBandLinearSolver}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNBandLinearSolver}}{N\_Vector\emph{ y}, SUNMatrix\emph{ A}}{}
This function creates and allocates memory for a band \code{SUNLinearSolver}.
Its arguments are an \code{N\_Vector} and \code{SUNMatrix}, that it uses to
determine the linear system size and to assess compatibility with
the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \code{N\_Vector} and \code{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_BAND matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector types.  As
additional compatible matrix and vector implementations are added to
SUNDIALS, these will be included within this compatibility check.

Additionally, this routine will verify that the input matrix \code{A}
is allocated with appropriate upper bandwidth storage for the \(LU\)
factorization.

If either \code{A} or \code{y} are incompatible then this routine will
return \code{NULL}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_BAND module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_Band:f/_/FSUNBandLinSolInit]{\emph{\code{FSUNBandLinSolInit()}}}} to initialize
this SUNLINSOL\_BAND module for a given SUNDIALS solver.
\index{FSUNBandLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Band:f/_/FSUNBandLinSolInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNBandLinSolInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a banded \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_Band:f/_/FSUNMassBandLinSolInit]{\emph{\code{FSUNMassBandLinSolInit()}}}}
initializes this SUNLINSOL\_BAND module for solving mass matrix linear
systems.
\index{FSUNMassBandLinSolInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_Band:f/_/FSUNMassBandLinSolInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassBandLinSolInit}}{\emph{IER}}{}
Initializes a banded \code{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNLINSOL\_LAPACKDENSE Module}
\label{sunlinsol/SUNLinSol_LapackDense:the-sunlinsol-lapackdense-module}\label{sunlinsol/SUNLinSol_LapackDense::doc}\label{sunlinsol/SUNLinSol_LapackDense:sunlinsol-lapackdense}
The LAPACK dense implementation of the \code{SUNLinearSolver} module provided
with SUNDIALS, SUNLINSOL\_LAPACKDENSE, is designed to be used with the
corresponding SUNMATRIX\_DENSE matrix type, and one of the serial or
shared-memory \code{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP, or
NVECTOR\_PTHREADS).  The SUNLINSOL\_LAPACKDENSE module defines the
\emph{content} field of a \code{SUNLinearSolver} to be the following
structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Dense} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{N} - size of the linear system,

\item {} 
\code{pivots} - index array for partial pivoting in LU
factorization,

\item {} 
\code{last\_flag} - last error return flag from internal function
evaluations.

\end{itemize}

The SUNLINSOL\_LAPACKDENSE module is a \code{SUNLinearSolver} wrapper for
the LAPACK dense matrix factorization and solve routines, \code{*GETRF}
and \code{*GETRS}, where \code{*} is either \code{D} or \code{S}, depending on
whether SUNDIALS was configured to have \code{realtype} set to
\code{double} or \code{single}, respectively (see section
{\hyperref[c_interface/General:cinterface-datatypes]{\emph{\DUspan{}{Data Types}}}} for details).  In order to use the
SUNLINSOL\_LAPACKDENSE module it is assumed that LAPACK has been
installed on the system prior to installation of
SUNDIALS, and that SUNDIALS has been configured appropriately to
link with LAPACK (see section
{\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}} for details).
We note that since there do not exist 128-bit floating-point
factorization and solve routines in LAPACK, this interface cannot be
compiled when using \code{extended} precision for \code{realtype}.
Similarly, since there do not exist 64-bit integer LAPACK routines,
the SUNLINSOL\_LAPACKDENSE module also cannot be compiled when using
\code{int64\_t} for the \code{sunindextype}.

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The ``setup'' call performs a \(LU\) factorization with
partial (row) pivoting (\(\mathcal O(N^3)\) cost),
\(PA=LU\), where \(P\) is a permutation matrix, \(L\) is
a lower triangular matrix with 1's on the diagonal, and \(U\) is
an upper triangular matrix.  This factorization is stored in-place
on the input SUNMATRIX\_DENSE object \(A\), with pivoting
information encoding \(P\) stored in the \code{pivots} array.

\item {} 
The ``solve'' call performs pivoting and forward and
backward substitution using the stored \code{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_DENSE object
(\(\mathcal O(N^2)\) cost).

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_lapackdense.h}.

The SUNLINSOL\_LAPACKDENSE module defines dense implementations of all
``direct'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_LapackDense}

\item {} 
\code{SUNLinSolInitialize\_LapackDense} -- this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\code{SUNLinSolSetup\_LapackDense} -- this calls either
\code{DGETRF} or \code{SGETRF} to perform the \(LU\) factorization.

\item {} 
\code{SUNLinSolSolve\_LapackDense} -- this calls either
\code{DGETRS} or \code{SGETRS} to use the \(LU\) factors and
\code{pivots} array to perform the solve.

\item {} 
\code{SUNLinSolLastFlag\_LapackDense}

\item {} 
\code{SUNLinSolSpace\_LapackDense} -- this only returns information for
the storage \emph{within} the solver object, i.e. storage
for \code{N}, \code{last\_flag}, and \code{pivots}.

\item {} 
\code{SUNLinSolFree\_LapackDense}

\end{itemize}

The module SUNLINSOL\_LAPACKDENSE provides the following additional
user-callable constructor routine:
\index{SUNLapackDense (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_LapackDense:c.SUNLapackDense}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNLapackDense}}{N\_Vector\emph{ y}, SUNMatrix\emph{ A}}{}
This function creates and allocates memory for a LAPACK dense
\code{SUNLinearSolver}.  Its arguments are an \code{N\_Vector} and
\code{SUNMatrix}, that it uses to determine the linear system size and
to assess compatibility with the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \code{N\_Vector} and \code{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_DENSE matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector
types.  As additional compatible matrix and vector implementations
are added to SUNDIALS, these will be included within this
compatibility check.

If either \code{A} or \code{y} are incompatible then this routine will
return \code{NULL}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_LAPACKDENSE module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_LapackDense:f/_/FSUNLapackDenseInit]{\emph{\code{FSUNLapackDenseInit()}}}} to initialize
this SUNLINSOL\_LAPACKDENSE module for a given SUNDIALS solver.
\index{FSUNLapackDenseInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_LapackDense:f/_/FSUNLapackDenseInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNLapackDenseInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a dense LAPACK \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_LapackDense:f/_/FSUNMassLapackDenseInit]{\emph{\code{FSUNMassLapackDenseInit()}}}}
initializes this SUNLINSOL\_LAPACKDENSE module for solving mass matrix
linear systems.
\index{FSUNMassLapackDenseInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_LapackDense:f/_/FSUNMassLapackDenseInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassLapackDenseInit}}{\emph{IER}}{}
Initializes a dense LAPACK \code{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNLINSOL\_LAPACKBAND Module}
\label{sunlinsol/SUNLinSol_LapackBand:the-sunlinsol-lapackband-module}\label{sunlinsol/SUNLinSol_LapackBand::doc}\label{sunlinsol/SUNLinSol_LapackBand:sunlinsol-lapackband}
The LAPACK band implementation of the \code{SUNLinearSolver} module provided
with SUNDIALS, SUNLINSOL\_LAPACKBAND, is designed to be used with the
corresponding SUNMATRIX\_BAND matrix type, and one of the serial or
shared-memory \code{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP, or
NVECTOR\_PTHREADS).  The SUNLINSOL\_LAPACKBAND module defines the
\emph{content} field of a \code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}Band} \PYG{p}{\PYGZob{}}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{pivots}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{N} - size of the linear system,

\item {} 
\code{pivots} - index array for partial pivoting in LU
factorization,

\item {} 
\code{last\_flag} - last error return flag from internal function
evaluations.

\end{itemize}

The SUNLINSOL\_LAPACKBAND module is a \code{SUNLinearSolver} wrapper for
the LAPACK band matrix factorization and solve routines, \code{*GBTRF}
and \code{*GBTRS}, where \code{*} is either \code{D} or \code{S}, depending on
whether SUNDIALS was configured to have \code{realtype} set to
\code{double} or \code{single}, respectively (see section
{\hyperref[c_interface/General:cinterface-datatypes]{\emph{\DUspan{}{Data Types}}}} for details).
In order to use the SUNLINSOL\_LAPACKBAND module it is assumed
that LAPACK has been installed on the system prior to installation of
SUNDIALS, and that SUNDIALS has been configured appropriately to
link with LAPACK (see section
{\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}} for details).  We note
that since there do not exist 128-bit floating-point factorization and
solve routines in LAPACK, this interface cannot be compiled when
using \code{extended} precision for \code{realtype}.  Similarly, since
there do not exist 64-bit integer LAPACK routines, the
SUNLINSOL\_LAPACKBAND module also cannot be compiled when using
\code{int64\_t} for the \code{sunindextype}.

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
The ``setup'' call performs a \(LU\) factorization with
partial (row) pivoting, \(PA=LU\), where \(P\) is a
permutation matrix, \(L\) is a lower triangular matrix with 1's
on the diagonal, and \(U\) is an upper triangular matrix.  This
factorization is stored in-place on the input SUNMATRIX\_BAND object
\(A\), with pivoting information encoding \(P\) stored in
the \code{pivots} array.

\item {} 
The ``solve'' call performs pivoting and forward and
backward substitution using the stored \code{pivots} array and the
\(LU\) factors held in the SUNMATRIX\_BAND object.

\item {} 
\(A\) must be allocated to accommodate the increase in upper
bandwidth that occurs during factorization.  More precisely, if
\(A\) is a band matrix with upper bandwidth \code{mu} and lower
bandwidth \code{ml}, then the upper triangular factor \(U\) can
have upper bandwidth as big as \code{smu = MIN(N-1,mu+ml)}. The lower
triangular factor \(L\) has lower bandwidth \code{ml}.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_lapackband.h}.

The SUNLINSOL\_LAPACKBAND module defines band implementations of all
``direct'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_LapackBand}

\item {} 
\code{SUNLinSolInitialize\_LapackBand} -- this does nothing, since all
consistency checks are performed at solver creation.

\item {} 
\code{SUNLinSolSetup\_LapackBand} -- this calls either
\code{DGBTRF} or \code{SGBTRF} to perform the \(LU\) factorization.

\item {} 
\code{SUNLinSolSolve\_LapackBand} -- this calls either
\code{DGBTRS} or \code{SGBTRS} to use the \(LU\) factors and
\code{pivots} array to perform the solve.

\item {} 
\code{SUNLinSolLastFlag\_LapackBand}

\item {} 
\code{SUNLinSolSpace\_LapackBand} -- this only returns information for
the storage \emph{within} the solver object, i.e. storage for \code{N},
\code{last\_flag}, and \code{pivots}.

\item {} 
\code{SUNLinSolFree\_LapackBand}

\end{itemize}

The module SUNLINSOL\_LAPACKBAND provides the following additional
user-callable routine:
\index{SUNLapackBand (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_LapackBand:c.SUNLapackBand}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNLapackBand}}{N\_Vector\emph{ y}, SUNMatrix\emph{ A}}{}
This function creates and allocates memory for a LAPACK band
\code{SUNLinearSolver}.  Its arguments are an \code{N\_Vector} and
\code{SUNMatrix}, that it uses to determine the linear system size and
to assess compatibility with the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \code{N\_Vector} and \code{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_BAND matrix type and
the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector
types.  As additional compatible matrix and vector implementations
are added to SUNDIALS, these will be included within this
compatibility check.

Additionally, this routine will verify that the input matrix \code{A}
is allocated with appropriate upper bandwidth storage for the
\(LU\) factorization.

If either \code{A} or \code{y} are incompatible then this routine will
return \code{NULL}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_LAPACKBAND module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_LapackBand:f/_/FSUNLapackBandInit]{\emph{\code{FSUNLapackBandInit()}}}} to initialize this
SUNLINSOL\_LAPACKBAND module for a given SUNDIALS solver.
\index{FSUNLapackBandInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_LapackBand:f/_/FSUNLapackBandInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNLapackBandInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a banded LAPACK \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_LapackBand:f/_/FSUNMassLapackBandInit]{\emph{\code{FSUNMassLapackBandInit()}}}}
initializes this SUNLINSOL\_LAPACKBAND module for solving mass matrix
linear systems.
\index{FSUNMassLapackBandInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_LapackBand:f/_/FSUNMassLapackBandInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassLapackBandInit}}{\emph{IER}}{}
Initializes a banded LAPACK \code{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}



\section{The SUNLINSOL\_KLU Module}
\label{sunlinsol/SUNLinSol_KLU::doc}\label{sunlinsol/SUNLinSol_KLU:the-sunlinsol-klu-module}\label{sunlinsol/SUNLinSol_KLU:sunlinsol-klu}
The KLU implementation of the \code{SUNLinearSolver} module provided with
SUNDIALS, SUNLINSOL\_KLU, is designed to be used with the
corresponding SUNMATRIX\_SPARSE matrix type, and one of the serial or
shared-memory \code{N\_Vector} implementations (NVECTOR\_SERIAL, NVECTOR\_OPENMP, or
NVECTOR\_PTHREADS).  The SUNLINSOL\_KLU module defines the \emph{content}
field of a \code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}KLU} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{long} \PYG{k+kt}{int}         \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{k+kt}{int}              \PYG{n}{first\PYGZus{}factorize}\PYG{p}{;}
  \PYG{n}{sun\PYGZus{}klu\PYGZus{}symbolic} \PYG{o}{*}\PYG{n}{symbolic}\PYG{p}{;}
  \PYG{n}{sun\PYGZus{}klu\PYGZus{}numeric}  \PYG{o}{*}\PYG{n}{numeric}\PYG{p}{;}
  \PYG{n}{sun\PYGZus{}klu\PYGZus{}common}   \PYG{n}{common}\PYG{p}{;}
  \PYG{n}{sunindextype}     \PYG{p}{(}\PYG{o}{*}\PYG{n}{klu\PYGZus{}solver}\PYG{p}{)}\PYG{p}{(}\PYG{n}{sun\PYGZus{}klu\PYGZus{}symbolic}\PYG{o}{*}\PYG{p}{,} \PYG{n}{sun\PYGZus{}klu\PYGZus{}numeric}\PYG{o}{*}\PYG{p}{,}
                                 \PYG{n}{sunindextype}\PYG{p}{,} \PYG{n}{sunindextype}\PYG{p}{,}
                                 \PYG{k+kt}{double}\PYG{o}{*}\PYG{p}{,} \PYG{n}{sun\PYGZus{}klu\PYGZus{}common}\PYG{o}{*}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{last\_flag} - last error return flag from internal function
evaluations,

\item {} 
\code{first\_factorize} - flag indicating whether the factorization
has ever been performed,

\item {} 
\code{Symbolic} - KLU storage structure for symbolic
factorization components,

\item {} 
\code{Numeric} - KLU storage structure for numeric factorization
components,

\item {} 
\code{Common} - storage structure for common KLU solver
components,

\item {} 
\code{klu\_solver} -- pointer to the appropriate KLU solver function
(depending on whether it is using a CSR or CSC sparse matrix).

\end{itemize}

The SUNLINSOL\_KLU module is a \code{SUNLinearSolver} wrapper for
the KLU sparse matrix factorization and solver library written by Tim
Davis (\phantomsection\label{sunlinsol/SUNLinSol_KLU:id1}{\hyperref[References:klu]{\emph{{[}KLU{]}}}}, \phantomsection\label{sunlinsol/SUNLinSol_KLU:id2}{\hyperref[References:dp2010]{\emph{{[}DP2010{]}}}}).  In order to use the
SUNLINSOL\_KLU interface to KLU, it is assumed that KLU has
been installed on the system prior to installation of SUNDIALS, and
that SUNDIALS has been configured appropriately to link with KLU
(see section {\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}} for details).
Additionally, this wrapper only supports double-precision
calculations, and therefore cannot be compiled if SUNDIALS is
configured to have \code{realtype} set to either \code{extended} or
\code{single} (see section {\hyperref[c_interface/General:cinterface-datatypes]{\emph{\DUspan{}{Data Types}}}} for
details). Since the KLU library supports both 32-bit and 64-bit
integers, this interface will be compiled for either of the available
\code{sunindextype} options.

The KLU library has a symbolic factorization routine that computes
the permutation of the linear system matrix to block triangular form
and the permutations that will pre-order the diagonal blocks (the only
ones that need to be factored) to reduce fill-in (using AMD, COLAMD,
CHOLAMD, natural, or an ordering given by the user).  Of these
ordering choices, the default value in the SUNLINSOL\_KLU
module is the COLAMD ordering.

KLU breaks the factorization into two separate parts.  The first is
a symbolic factorization and the second is a numeric factorization
that returns the factored matrix along with final pivot information.
KLU also has a refactor routine that can be called instead of the numeric
factorization.  This routine will reuse the pivot information.  This routine
also returns diagnostic information that a user can examine to determine if
numerical stability is being lost and a full numerical factorization should
be done instead of the refactor.

Since the linear systems that arise within the context of SUNDIALS
calculations will typically have identical sparsity patterns, the
SUNLINSOL\_KLU module is constructed to perform the
following operations:
\begin{itemize}
\item {} 
The first time that the ``setup'' routine is called, it
performs the symbolic factorization, followed by an initial
numerical factorization.

\item {} 
On subsequent calls to the ``setup'' routine, it calls the
appropriate KLU ``refactor'' routine, followed by estimates of
the numerical conditioning using the relevant ``rcond'', and if
necessary ``condest'', routine(s).  If these estimates of the
condition number are larger than \(\varepsilon^{-2/3}\) (where
\(\varepsilon\) is the double-precision unit roundoff), then a new
factorization is performed.

\item {} 
The module includes the routine \code{SUNKLUReInit}, that
can be called by the user to force a full refactorization at the
next ``setup'' call.

\item {} 
The ``solve'' call performs pivoting and forward and
backward substitution using the stored KLU data structures.  We
note that in this solve KLU operates on the native data arrays
for the right-hand side and solution vectors, without requiring
costly data copies.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_klu.h}.

The SUNLINSOL\_KLU module defines implementations of all
``direct'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_KLU}

\item {} 
\code{SUNLinSolInitialize\_KLU} -- this sets the
\code{first\_factorize} flag to 1, forcing both symbolic and numerical
factorizations on the subsequent ``setup'' call.

\item {} 
\code{SUNLinSolSetup\_KLU} -- this performs either a \(LU\)
factorization or refactorization of the input matrix.

\item {} 
\code{SUNLinSolSolve\_KLU} -- this calls the appropriate KLU
solve routine to utilize the \(LU\) factors to solve the linear
system.

\item {} 
\code{SUNLinSolLastFlag\_KLU}

\item {} 
\code{SUNLinSolSpace\_KLU} -- this only returns information for
the storage within the solver \emph{interface}, i.e. storage for the
integers \code{last\_flag} and \code{first\_factorize}.  For additional
space requirements, see the KLU documentation.

\item {} 
\code{SUNLinSolFree\_KLU}

\end{itemize}

The module SUNLINSOL\_KLU provides the following additional
user-callable routines:
\index{SUNKLU (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:c.SUNKLU}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNKLU}}{N\_Vector\emph{ y}, SUNMatrix\emph{ A}}{}
This constructor function creates and allocates memory for a SUNLINSOL\_KLU
object.  Its arguments are an \code{N\_Vector} and \code{SUNMatrix}, that it
uses to determine the linear system size and to assess compatibility
with the linear solver implementation.

This routine will perform consistency checks to ensure that it is
called with consistent \code{N\_Vector} and \code{SUNMatrix} implementations.
These are currently limited to the SUNMATRIX\_SPARSE matrix type
(using either CSR or CSC storage formats) and the NVECTOR\_SERIAL,
NVECTOR\_OPENMP, and NVECTOR\_PTHREADS vector types.  As additional
compatible matrix and vector implementations are added to
SUNDIALS, these will be included within this compatibility
check.

If either \code{A} or \code{y} are incompatible then this routine will
return \code{NULL}.

\end{fulllineitems}

\index{SUNKLUReInit (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:c.SUNKLUReInit}\pysiglinewithargsret{int \bfcode{SUNKLUReInit}}{SUNLinearSolver\emph{ S}, SUNMatrix\emph{ A}, sunindextype\emph{ nnz}, int\emph{ reinit\_type}}{}
This function reinitializes memory and flags for a new factorization
(symbolic and numeric) to be conducted at the next solver setup
call.  This routine is useful in the cases where the number of
nonzeroes has changed or if the structure of the linear system has
changed which would require a new symbolic (and numeric
factorization).

The \code{reinit\_type} argument governs the level of
reinitialization.  The allowed values are:
\begin{enumerate}
\item {} 
The Jacobian matrix will be destroyed and a new one will be
allocated based on the \code{nnz} value passed to this call.  New
symbolic and numeric factorizations will be completed at the next
solver setup.

\item {} 
Only symbolic and numeric factorizations will be completed.
It is assumed that the Jacobian size has not exceeded the size of
\code{nnz} given in the sparse matrix provided to the original
constructor routine (or the previous \code{SUNKLUReInit} call).

\end{enumerate}

This routine assumes no other changes to solver use are necessary.

The return values from this function are \code{SUNLS\_MEM\_NULL}
(either \code{S} or \code{A} are \code{NULL}), \code{SUNLS\_ILL\_INPUT}
(\code{A} does not have type \code{SUNMATRIX\_SPARSE} or
\code{reinit\_type} is invalid), \code{SUNLS\_MEM\_FAIL} (reallocation
of the sparse matrix failed) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNKLUSetOrdering (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:c.SUNKLUSetOrdering}\pysiglinewithargsret{int \bfcode{SUNKLUSetOrdering}}{SUNLinearSolver\emph{ S}, int\emph{ ordering\_choice}}{}
This function sets the ordering used by KLU for reducing fill in
the linear solve.  Options for \code{ordering\_choice} are:
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
AMD,

\item {} 
COLAMD, and

\item {} 
the natural ordering.

\end{enumerate}

The default is 1 for COLAMD.

The return values from this function are \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}), \code{SUNLS\_ILL\_INPUT}
(invalid \code{ordering\_choice}), or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_KLU module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit]{\emph{\code{FSUNKLUInit()}}}} to initialize this SUNLINSOL\_KLU
module for a given SUNDIALS solver.
\index{FSUNKLUInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNKLUInit}}{\emph{CODE}, \emph{IER}}{}
Initializes a KLU sparse \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit]{\emph{\code{FSUNMassKLUInit()}}}} initializes this
SUNLINSOL\_KLU module for solving mass matrix linear systems.
\index{FSUNMassKLUInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassKLUInit}}{\emph{IER}}{}
Initializes a KLU sparse \code{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[sunlinsol/SUNLinSol_KLU:c.SUNKLUReInit]{\emph{\code{SUNKLUReInit()}}}} and {\hyperref[sunlinsol/SUNLinSol_KLU:c.SUNKLUSetOrdering]{\emph{\code{SUNKLUSetOrdering()}}}}
routines also support Fortran interfaces for the system and mass
matrix solvers:
\index{FSUNKLUReInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUReInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNKLUReInit}}{\emph{CODE}, \emph{NNZ}, \emph{REINIT\_TYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_KLU:c.SUNKLUReInit]{\emph{\code{SUNKLUReInit()}}}} for system
linear solvers.

This routine must be called \emph{after}
{\hyperref[sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit]{\emph{\code{FSUNKLUInit()}}}} has been called.

\textbf{Arguments:} \emph{NNZ} should have type \code{long int}, all others
should have type \code{int}; all arguments have meanings identical to
those listed above.

\end{fulllineitems}

\index{FSUNMassKLUReInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUReInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassKLUReInit}}{\emph{NNZ}, \emph{REINIT\_TYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_KLU:c.SUNKLUReInit]{\emph{\code{SUNKLUReInit()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after}
{\hyperref[sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit]{\emph{\code{FSUNMassKLUInit()}}}} has been called.

\textbf{Arguments:} \emph{NNZ} should have type \code{long int}, all others
should have type \code{int}; all arguments have meanings identical to
those listed above.

\end{fulllineitems}

\index{FSUNKLUSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUSetOrdering}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNKLUSetOrdering}}{\emph{CODE}, \emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_KLU:c.SUNKLUSetOrdering]{\emph{\code{SUNKLUSetOrdering()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_KLU:f/_/FSUNKLUInit]{\emph{\code{FSUNKLUInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassKLUSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUSetOrdering}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassKLUSetOrdering}}{\emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_KLU:c.SUNKLUSetOrdering]{\emph{\code{SUNKLUSetOrdering()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_KLU:f/_/FSUNMassKLUInit]{\emph{\code{FSUNMassKLUInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\section{The SUNLINSOL\_SUPERLUMT Module}
\label{sunlinsol/SUNLinSol_SuperLUMT:sunlinsol-superlumt}\label{sunlinsol/SUNLinSol_SuperLUMT:the-sunlinsol-superlumt-module}\label{sunlinsol/SUNLinSol_SuperLUMT::doc}
The SuperLU\_MT implementation of the \code{SUNLinearSolver} module
provided with SUNDIALS, SUNLINSOL\_SUPERLUMT, is designed to be used
with the corresponding SUNMATRIX\_SPARSE matrix type, and one of the
serial or shared-memory \code{N\_Vector} implementations (NVECTOR\_SERIAL,
NVECTOR\_OPENMP, or NVECTOR\_PTHREADS).  While these are compatible, it
is not recommended to use a threaded vector module with
SUNLINSOL\_SUPERLUMT unless it is the NVECTOR\_OPENMP module and the
SuperLU\_MT library has also been compiled with OpenMP. The
SUNLINSOL\_SUPERLUMT module defines the \emph{content} field of a
\code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SuperLUMT} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{long} \PYG{k+kt}{int}     \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{first\PYGZus{}factorize}\PYG{p}{;}
  \PYG{n}{SuperMatrix}  \PYG{o}{*}\PYG{n}{A}\PYG{p}{,} \PYG{o}{*}\PYG{n}{AC}\PYG{p}{,} \PYG{o}{*}\PYG{n}{L}\PYG{p}{,} \PYG{o}{*}\PYG{n}{U}\PYG{p}{,} \PYG{o}{*}\PYG{n}{B}\PYG{p}{;}
  \PYG{n}{Gstat\PYGZus{}t}      \PYG{o}{*}\PYG{n}{Gstat}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{o}{*}\PYG{n}{perm\PYGZus{}r}\PYG{p}{,} \PYG{o}{*}\PYG{n}{perm\PYGZus{}c}\PYG{p}{;}
  \PYG{n}{sunindextype} \PYG{n}{N}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{num\PYGZus{}threads}\PYG{p}{;}
  \PYG{n}{realtype}     \PYG{n}{diag\PYGZus{}pivot\PYGZus{}thresh}\PYG{p}{;}
  \PYG{k+kt}{int}          \PYG{n}{ordering}\PYG{p}{;}
  \PYG{k+kt}{superlumt\PYGZus{}options\PYGZus{}t} \PYG{o}{*}\PYG{n}{options}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{last\_flag} - last error return flag from internal function
evaluations,

\item {} 
\code{first\_factorize} - flag indicating whether the factorization
has ever been performed,

\item {} 
\code{A, AC, L, U, B} - \code{SuperMatrix} pointers used in solve,

\item {} 
\code{Gstat} - \code{GStat\_t} object used in solve,

\item {} 
\code{perm\_r, perm\_c} - permutation arrays used in solve,

\item {} 
\code{N} - size of the linear system,

\item {} 
\code{num\_threads} - number of OpenMP/Pthreads threads to use,

\item {} 
\code{diag\_pivot\_thresh} - threshold on diagonal pivoting,

\item {} 
\code{ordering} - flag for which reordering algorithm to use,

\item {} 
\code{options} - pointer to SuperLU\_MT options structure.

\end{itemize}

The SUNLINSOL\_SUPERLUMT module is a \code{SUNLinearSolver} wrapper for
the SuperLU\_MT sparse matrix factorization and solver library
written by X. Sherry Li (\phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:id1}{\hyperref[References:superlumt]{\emph{{[}SuperLUMT{]}}}}, \phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:id2}{\hyperref[References:l2005]{\emph{{[}L2005{]}}}}, \phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:id3}{\hyperref[References:dgl1999]{\emph{{[}DGL1999{]}}}}).  The
package performs matrix factorization using threads to enhance
efficiency in shared memory parallel environments.  It should be noted
that threads are only used in the factorization step.  In
order to use the SUNLINSOL\_SUPERLUMT interface to SuperLU\_MT, it is
assumed that SuperLU\_MT has been installed on the system prior to
installation of SUNDIALS, and that SUNDIALS has been configured
appropriately to link with SuperLU\_MT (see section
{\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}} for details).
Additionally, this wrapper only supports single- and
double-precision calculations, and therefore cannot be compiled if
SUNDIALS is configured to have \code{realtype} set to \code{extended}
(see section {\hyperref[c_interface/General:cinterface-datatypes]{\emph{\DUspan{}{Data Types}}}} for details).  Moreover,
since the SuperLU\_MT library may be installed to support either 32-bit
or 64-bit integers, it is assumed that the SuperLU\_MT library is
installed using the same integer precision as the SUNDIALS
\code{sunindextype} option.

The SuperLU\_MT library has a symbolic factorization routine that
computes the permutation of the linear system matrix to reduce fill-in
on subsequent \(LU\) factorizations (using COLAMD, minimal degree
ordering on \(A^T*A\), minimal degree ordering on \(A^T+A\),
or natural ordering).  Of these ordering choices, the default value in
the SUNLINSOL\_SUPERLUMT module is the COLAMD ordering.

Since the linear systems that arise within the context of SUNDIALS
calculations will typically have identical sparsity patterns, the
SUNLINSOL\_SUPERLUMT module is constructed to perform the
following operations:
\begin{itemize}
\item {} 
The first time that the ``setup'' routine is called, it
performs the symbolic factorization, followed by an initial
numerical factorization.

\item {} 
On subsequent calls to the ``setup'' routine, it skips the
symbolic factorization, and only refactors the input matrix.

\item {} 
The ``solve'' call performs pivoting and forward and
backward substitution using the stored SuperLU\_MT data
structures.  We note that in this solve SuperLU\_MT operates on the
native data arrays for the right-hand side and solution vectors,
without requiring costly data copies.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_superlumt.h}.

The SUNLINSOL\_SUPERLUMT module defines implementations of all
``direct'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_SuperLUMT}

\item {} 
\code{SUNLinSolInitialize\_SuperLUMT} -- this sets the
\code{first\_factorize} flag to 1 and resets the internal SuperLU\_MT
statistics variables.

\item {} 
\code{SUNLinSolSetup\_SuperLUMT} -- this performs either a \(LU\)
factorization or refactorization of the input matrix.

\item {} 
\code{SUNLinSolSolve\_SuperLUMT} -- this calls the appropriate
SuperLU\_MT solve routine to utilize the \(LU\) factors to solve the
linear system.

\item {} 
\code{SUNLinSolLastFlag\_SuperLUMT}

\item {} 
\code{SUNLinSolSpace\_SuperLUMT} -- this only returns information for
the storage within the solver \emph{interface}, i.e. storage for the
integers \code{last\_flag} and \code{first\_factorize}.  For additional
space requirements, see the SuperLU\_MT documentation.

\item {} 
\code{SUNLinSolFree\_SuperLUMT}

\end{itemize}

The module SUNLINSOL\_SUPERLUMT provides the following additional
user-callable routines:
\index{SUNSuperLUMT (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMT}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNSuperLUMT}}{N\_Vector\emph{ y}, SUNMatrix\emph{ A}, int\emph{ num\_threads}}{}
This constructor function creates and allocates memory for a
SUNLINSOL\_SUPERLUMT object.  Its arguments are an \code{N\_Vector}, a
\code{SUNMatrix}, and a desired number of threads (OpenMP or Pthreads,
depending on how SuperLU\_MT was installed) to use during the
factorization steps. This routine analyzes the input matrix and
vector to determine the linear system size and to assess
compatibility with the SuperLU\_MT library.

This routine will perform consistency checks to ensure that it is
called with consistent \code{N\_Vector} and \code{SUNMatrix}
implementations.  These are currently limited to the
SUNMATRIX\_SPARSE matrix type (using either CSR or CSC storage
formats) and the NVECTOR\_SERIAL, NVECTOR\_OPENMP, and
NVECTOR\_PTHREADS vector types.  As additional compatible matrix and
vector implementations are added to SUNDIALS, these will be
included within this compatibility check.

If either \code{A} or \code{y} are incompatible then this routine will
return \code{NULL}.  The \code{num\_threads} argument is not checked
and is passed directly to SuperLU\_MT routines.

\end{fulllineitems}

\index{SUNSuperLUMTSetOrdering (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMTSetOrdering}\pysiglinewithargsret{int \bfcode{SUNSuperLUMTSetOrdering}}{SUNLinearSolver\emph{ S}, int\emph{ ordering\_choice}}{}
This function sets the ordering used by SuperLU\_MT for reducing fill in
the linear solve.  Options for \code{ordering\_choice} are:
\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
natural ordering

\item {} 
minimal degree ordering on \(A^TA\)

\item {} 
minimal degree ordering on \(A^T+A\)

\item {} 
COLAMD ordering for unsymmetric matrices

\end{enumerate}

The default is 3 for COLAMD.

The return values from this function are \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}), \code{SUNLS\_ILL\_INPUT}
(invalid \code{ordering\_choice}), or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_SUPERLUMT module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTInit]{\emph{\code{FSUNSuperLUMTInit()}}}} to initialize this
SUNLINSOL\_SUPERLUMT module for a given SUNDIALS solver.
\index{FSUNSuperLUMTInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSuperLUMTInit}}{\emph{CODE}, \emph{NUM\_THREADS}, \emph{IER}}{}
Initializes a SuperLU\_MT sparse \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} both the \code{N\_Vector} and
\code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{NUM\_THREADS} (\code{int}, input) -- desired number of
OpenMP/Pthreads threads to use in the factorization.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTInit]{\emph{\code{FSUNMassSuperLUMTInit()}}}}
initializes this SUNLINSOL\_SUPERLUMT module for solving mass matrix
linear systems.
\index{FSUNMassSuperLUMTInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSuperLUMTInit}}{\emph{NUM\_THREADS}, \emph{IER}}{}
Initializes a SuperLU\_MT sparse \code{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \emph{after} both the \code{N\_Vector} and
the mass \code{SUNMatrix} objects have been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{NUM\_THREADS} (\code{int}, input) -- desired number of
OpenMP/Pthreads threads to use in the factorization.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMTSetOrdering]{\emph{\code{SUNSuperLUMTSetOrdering()}}}} routine also supports Fortran
interfaces for the system and mass matrix solvers:
\index{FSUNSuperLUMTSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTSetOrdering}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSuperLUMTSetOrdering}}{\emph{CODE}, \emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMTSetOrdering]{\emph{\code{SUNSuperLUMTSetOrdering()}}}} for system
linear solvers.

This routine must be called \emph{after}
{\hyperref[sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNSuperLUMTInit]{\emph{\code{FSUNSuperLUMTInit()}}}} has been called

\textbf{Arguments:} all should have type \code{int} and have meanings
identical to those listed above

\end{fulllineitems}

\index{FSUNMassSuperLUMTSetOrdering() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTSetOrdering}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSuperLUMTSetOrdering}}{\emph{ORDERING}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SuperLUMT:c.SUNSuperLUMTSetOrdering]{\emph{\code{SUNSuperLUMTSetOrdering()}}}} for mass
matrix linear solves in ARKode.

This routine must be called \emph{after}
{\hyperref[sunlinsol/SUNLinSol_SuperLUMT:f/_/FSUNMassSuperLUMTInit]{\emph{\code{FSUNMassSuperLUMTInit()}}}} has been called

\textbf{Arguments:} all should have type \code{int} and have meanings
identical to those listed above

\end{fulllineitems}



\section{The SUNLINSOL\_SPGMR Module}
\label{sunlinsol/SUNLinSol_SPGMR::doc}\label{sunlinsol/SUNLinSol_SPGMR:the-sunlinsol-spgmr-module}\label{sunlinsol/SUNLinSol_SPGMR:sunlinsol-spgmr}
The SPGMR (Scaled, Preconditioned, Generalized Minimum
Residual \phantomsection\label{sunlinsol/SUNLinSol_SPGMR:id1}{\hyperref[References:ss1986]{\emph{{[}SS1986{]}}}}) implementation of the \code{SUNLinearSolver} module
provided with SUNDIALS, SUNLINSOL\_SPGMR, is an iterative linear
solver that is designed to be compatible with any \code{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[nvectors/NVector_Operations:c.N_VClone]{\emph{\code{N\_VClone()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VDotProd]{\emph{\code{N\_VDotProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VScale]{\emph{\code{N\_VScale()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VLinearSum]{\emph{\code{N\_VLinearSum()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VProd]{\emph{\code{N\_VProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VConst]{\emph{\code{N\_VConst()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VDiv]{\emph{\code{N\_VDiv()}}}}, and {\hyperref[nvectors/NVector_Operations:c.N_VDestroy]{\emph{\code{N\_VDestroy()}}}}).

The SUNLINSOL\_SPGMR module defines the \emph{content} field of a
\code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPGMR} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{gstype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{max\PYGZus{}restarts}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{V}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{Hes}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{givens}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{xcor}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{yg}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{maxl} - number of GMRES basis vectors to use (default is 5),

\item {} 
\code{pretype} - flag for type of preconditioning to employ
(default is none),

\item {} 
\code{gstype} - flag for type of Gram-Schmidt orthogonalization
(default is modified Gram-Schmidt),

\item {} 
\code{max\_restarts} - number of GMRES restarts to allow
(default is 0),

\item {} 
\code{numiters} - number of iterations from the most-recent solve,

\item {} 
\code{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\code{last\_flag} - last error return flag from an internal
function,

\item {} 
\code{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\code{ATData} - pointer to structure for \code{ATimes},

\item {} 
\code{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\code{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\code{PData} - pointer to structure for \code{Psetup} and \code{Psolve},

\item {} 
\code{s1, s2} - vector pointers for supplied scaling matrices
(default is \code{NULL}),

\item {} 
\code{V} - the array of Krylov basis vectors
\(v_1, \ldots, v_{\text{maxl}+1}\), stored in
\code{V{[}0{]}, ... V{[}maxl{]}}. Each \(v_i\) is a vector of type
\code{N\_Vector},

\item {} 
\code{Hes} - the \((\text{maxl}+1)\times\text{maxl}\)
Hessenberg matrix. It is stored row-wise so that the (i,j)th
element is given by \code{Hes{[}i{]}{[}j{]}},

\item {} 
\code{givens} - a length \(2\,\text{maxl}\) array which represents
the Givens rotation matrices that arise in the GMRES
algorithm. These matrices are \(F_0, F_1, \ldots, F_j\), where
\begin{gather}
\begin{split}F_i = \begin{bmatrix}
   1 &        &   &     &      &   &        &   \\
     & \ddots &   &     &      &   &        &   \\
     &        & 1 &     &      &   &        &   \\
     &        &   & c_i & -s_i &   &        &   \\
     &        &   & s_i &  c_i &   &        &   \\
     &        &   &     &      & 1 &        &   \\
     &        &   &     &      &   & \ddots &   \\
     &        &   &     &      &   &        & 1\end{bmatrix},\end{split}\notag
\end{gather}
are represented in the \code{givens} vector as
\code{givens{[}0{]}} \(= c_0\),
\code{givens{[}1{]}} \(= s_0\),
\code{givens{[}2{]}} \(= c_1\),
\code{givens{[}3{]}} \(= s_1\), \(\ldots\),
\code{givens{[}2j{]}} \(= c_j\),
\code{givens{[}2j+1{]}} \(= s_j\),

\item {} 
\code{xcor} - a vector which holds the scaled, preconditioned
correction to the initial guess,

\item {} 
\code{yg} - a length \((\text{maxl}+1)\) array of \code{realtype}
values used to hold ``short'' vectors (e.g. \(y\) and \(g\)),

\item {} 
\code{vtemp} - temporary vector storage.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction, the \code{xcor} and \code{vtemp} arrays are
cloned from a template \code{N\_Vector} that is input, and default
solver parameters are set.

\item {} 
User-facing ``set'' routines may be called to modify default
solver parameters.

\item {} 
Additional ``set'' routines are called by the SUNDIALS solver
that interfaces with SUNLINSOL\_SPGMR to supply the
\code{ATimes}, \code{PSetup}, and \code{Psolve} function pointers and
\code{s1} and \code{s2} scaling vectors.

\item {} 
In the ``initialize'' call, the remaining solver data is
allocated (\code{V}, \code{Hes}, \code{givens}, and \code{yg} )

\item {} 
In the ``setup'' call, any non-\code{NULL}
\code{PSetup} function is called.  Typically, this is provided by
the SUNDIALS solver itself, that translates between the generic
\code{PSetup} function and the solver-specific routine (solver-supplied
or user-supplied).

\item {} 
In the ``solve'' call, the GMRES iteration is performed.  This
will include scaling, preconditioning, and restarts if those options
have been supplied.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_spgmr.h}.

The SUNLINSOL\_SPGMR module defines implementations of all
``iterative'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_SPGMR}

\item {} 
\code{SUNLinSolInitialize\_SPGMR}

\item {} 
\code{SUNLinSolSetATimes\_SPGMR}

\item {} 
\code{SUNLinSolSetPreconditioner\_SPGMR}

\item {} 
\code{SUNLinSolSetScalingVectors\_SPGMR}

\item {} 
\code{SUNLinSolSetup\_SPGMR}

\item {} 
\code{SUNLinSolSolve\_SPGMR}

\item {} 
\code{SUNLinSolNumIters\_SPGMR}

\item {} 
\code{SUNLinSolResNorm\_SPGMR}

\item {} 
\code{SUNLinSolResid\_SPGMR}

\item {} 
\code{SUNLinSolLastFlag\_SPGMR}

\item {} 
\code{SUNLinSolSpace\_SPGMR}

\item {} 
\code{SUNLinSolFree\_SPGMR}

\end{itemize}

The module SUNLINSOL\_SPGMR provides the following additional
user-callable routines:
\index{SUNSPGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMR}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNSPGMR}}{N\_Vector\emph{ y}, int\emph{ pretype}, int\emph{ maxl}}{}
This constructor function creates and allocates memory for a SPGMR
\code{SUNLinearSolver}.  Its arguments are an \code{N\_Vector}, the desired
type of preconditioning, and the number of Krylov basis vectors to use.

This routine will perform consistency checks to ensure that it is
called with a consistent \code{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \code{y} is
incompatible, then this routine will return \code{NULL}.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

Allowable inputs for \code{pretype} are \code{PREC\_NONE} (0),
\code{PREC\_LEFT} (1), \code{PREC\_RIGHT} (2) and \code{PREC\_BOTH} (3);
any other integer input will result in the default (no
preconditioning).  We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS) and others
with only right preconditioning (KINSOL). While it is possible to
configure a SUNLINSOL\_SPGMR object to use any of the
preconditioning options with these solvers, this use mode is not
supported and may result in inferior performance.

\end{fulllineitems}

\index{SUNSPGMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetPrecType}\pysiglinewithargsret{int \bfcode{SUNSPGMRSetPrecType}}{SUNLinearSolver\emph{ S}, int\emph{ pretype}}{}
This function updates the type of preconditioning to use.  Supported
values are \code{PREC\_NONE} (0), \code{PREC\_LEFT} (1),
\code{PREC\_RIGHT} (2) and \code{PREC\_BOTH} (3).

This routine will return with one of the error codes
\code{SUNLS\_ILL\_INPUT} (illegal \code{pretype}), \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNSPGMRSetGSType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetGSType}\pysiglinewithargsret{int \bfcode{SUNSPGMRSetGSType}}{SUNLinearSolver\emph{ S}, int\emph{ gstype}}{}
This function sets the type of Gram-Schmidt orthogonalization to
use.  Supported values are \code{MODIFIED\_GS} (1) and
\code{CLASSICAL\_GS} (2).  Any other integer input will result in a
failure, returning error code \code{SUNLS\_ILL\_INPUT}.

This routine will return with one of the error codes
\code{SUNLS\_ILL\_INPUT} (illegal \code{gstype}), \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNSPGMRSetMaxRestarts (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetMaxRestarts}\pysiglinewithargsret{int \bfcode{SUNSPGMRSetMaxRestarts}}{SUNLinearSolver\emph{ S}, int\emph{ maxrs}}{}
This function sets the number of GMRES restarts to
allow.  A negative input will result in the default of 0.

This routine will return with one of the error codes
\code{SUNLS\_MEM\_NULL} (\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_SPGMR module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit]{\emph{\code{FSUNSPGMRInit()}}}} to initialize
this SUNLINSOL\_SPGMR module for a given SUNDIALS solver.
\index{FSUNSPGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPGMRInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPGMR \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of GMRES basis vectors to use.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit]{\emph{\code{FSUNMassSPGMRInit()}}}} initializes
this SUNLINSOL\_SPGMR module for solving mass matrix linear systems.
\index{FSUNMassSPGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPGMRInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPGMR \code{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of GMRES basis vectors to use.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetGSType]{\emph{\code{SUNSPGMRSetGSType()}}}}, {\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetPrecType]{\emph{\code{SUNSPGMRSetPrecType()}}}} and
{\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetMaxRestarts]{\emph{\code{SUNSPGMRSetMaxRestarts()}}}} routines also support Fortran
interfaces for the system and mass matrix solvers:
\index{FSUNSPGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRSetGSType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPGMRSetGSType}}{\emph{CODE}, \emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetGSType]{\emph{\code{SUNSPGMRSetGSType()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit]{\emph{\code{FSUNSPGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRSetGSType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPGMRSetGSType}}{\emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetGSType]{\emph{\code{SUNSPGMRSetGSType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit]{\emph{\code{FSUNMassSPGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPGMRSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetPrecType]{\emph{\code{SUNSPGMRSetPrecType()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit]{\emph{\code{FSUNSPGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPGMRSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPGMR:c.SUNSPGMRSetPrecType]{\emph{\code{SUNSPGMRSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit]{\emph{\code{FSUNMassSPGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRSetMaxRS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPGMRSetMaxRS}}{\emph{CODE}, \emph{MAXRS}, \emph{IER}}{}
Fortran interface to \code{SUNSPGMRSetMaxRS()} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNSPGMRInit]{\emph{\code{FSUNSPGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRSetMaxRS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPGMRSetMaxRS}}{\emph{MAXRS}, \emph{IER}}{}
Fortran interface to \code{SUNSPGMRSetMaxRS()} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPGMR:f/_/FSUNMassSPGMRInit]{\emph{\code{FSUNMassSPGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\section{The SUNLINSOL\_SPFGMR Module}
\label{sunlinsol/SUNLinSol_SPFGMR:the-sunlinsol-spfgmr-module}\label{sunlinsol/SUNLinSol_SPFGMR::doc}\label{sunlinsol/SUNLinSol_SPFGMR:sunlinsol-spfgmr}
The SPFGMR (Scaled, Preconditioned, Flexible, Generalized Minimum
Residual \phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:id1}{\hyperref[References:s1993]{\emph{{[}S1993{]}}}}) implementation of the \code{SUNLinearSolver} module
provided with SUNDIALS, SUNLINSOL\_SPFGMR, is an iterative linear
solver that is designed to be compatible with any \code{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[nvectors/NVector_Operations:c.N_VClone]{\emph{\code{N\_VClone()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VDotProd]{\emph{\code{N\_VDotProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VScale]{\emph{\code{N\_VScale()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VLinearSum]{\emph{\code{N\_VLinearSum()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VProd]{\emph{\code{N\_VProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VConst]{\emph{\code{N\_VConst()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VDiv]{\emph{\code{N\_VDiv()}}}}, and {\hyperref[nvectors/NVector_Operations:c.N_VDestroy]{\emph{\code{N\_VDestroy()}}}}).  Unlike the other
Krylov iterative linear solvers supplied with SUNDIALS, FGMRES is
specifically designed to work with a changing preconditioner
(e.g. from an iterative method).

The SUNLINSOL\_SPFGMR module defines the \emph{content} field of a
\code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPFGMR} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{gstype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{max\PYGZus{}restarts}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{V}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{Z}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{o}{*}\PYG{n}{Hes}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{givens}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{xcor}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{o}{*}\PYG{n}{yg}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{maxl} - number of FGMRES basis vectors to use (default is 5),

\item {} 
\code{pretype} - flag for use of preconditioning (default is none),

\item {} 
\code{gstype} - flag for type of Gram-Schmidt orthogonalization
(default is modified Gram-Schmidt),

\item {} 
\code{max\_restarts} - number of FGMRES restarts to allow
(default is 0),

\item {} 
\code{numiters} - number of iterations from the most-recent solve,

\item {} 
\code{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\code{last\_flag} - last error return flag from an internal
function,

\item {} 
\code{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\code{ATData} - pointer to structure for \code{ATimes},

\item {} 
\code{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\code{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\code{PData} - pointer to structure for \code{Psetup} and \code{Psolve},

\item {} 
\code{s1, s2} - vector pointers for supplied scaling matrices
(default is \code{NULL}),

\item {} 
\code{V} - the array of Krylov basis vectors
\(v_1, \ldots, v_{\text{maxl}+1}\), stored in
\code{V{[}0{]}, ..., V{[}maxl{]}}. Each \(v_i\) is a vector of type \code{N\_Vector},

\item {} 
\code{Z} - the array of preconditioned Krylov basis vectors
\(z_1, \ldots, z_{\text{maxl}+1}\), stored in
\code{Z{[}0{]}, ..., Z{[}maxl{]}}. Each \(z_i\) is a vector of type \code{N\_Vector},

\item {} 
\code{Hes} - the \((\text{maxl}+1)\times\text{maxl}\)
Hessenberg matrix. It is stored row-wise so that the (i,j)th
element is given by \code{Hes{[}i{]}{[}j{]}},

\item {} 
\code{givens} - a length \(2\,\text{maxl}\) array which represents
the Givens rotation matrices that arise in the FGMRES
algorithm. These matrices are \(F_0, F_1, \ldots, F_j\), where
\begin{gather}
\begin{split}F_i = \begin{bmatrix}
   1 &        &   &     &      &   &        &   \\
     & \ddots &   &     &      &   &        &   \\
     &        & 1 &     &      &   &        &   \\
     &        &   & c_i & -s_i &   &        &   \\
     &        &   & s_i &  c_i &   &        &   \\
     &        &   &     &      & 1 &        &   \\
     &        &   &     &      &   & \ddots &   \\
     &        &   &     &      &   &        & 1\end{bmatrix},\end{split}\notag
\end{gather}
are represented in the \code{givens} vector as
\code{givens{[}0{]}} \(= c_0\),
\code{givens{[}1{]}} \(= s_0\),
\code{givens{[}2{]}} \(= c_1\),
\code{givens{[}3{]}} \(= s_1\), \(\ldots\),
\code{givens{[}2j{]}} \(= c_j\),
\code{givens{[}2j+1{]}} \(= s_j\),

\item {} 
\code{xcor} - a vector which holds the scaled, preconditioned
correction to the initial guess,

\item {} 
\code{yg} - a length \((\text{maxl}+1)\) array of \code{realtype}
values used to hold ``short'' vectors (e.g. \(y\) and \(g\)),

\item {} 
\code{vtemp} - temporary vector storage.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction, the \code{xcor} and \code{vtemp} arrays are cloned
from a template \code{N\_Vector} that is input, and default solver
parameters are set.

\item {} 
User-facing ``set'' routines may be called to modify default
solver parameters.

\item {} 
Additional ``set'' routines are called by the SUNDIALS solver
that interfaces with SUNLINSOL\_SPFGMR to supply the
\code{ATimes}, \code{PSetup}, and \code{Psolve} function pointers and
\code{s1} and \code{s2} scaling vectors.

\item {} 
In the ``initialize'' call, the remaining solver data is
allocated (\code{V}, \code{Hes}, \code{givens}, and \code{yg} )

\item {} 
In the ``setup'' call, any non-\code{NULL} \code{PSetup} function is called.
Typically, this is provided by the SUNDIALS solver itself, that
translates between the generic \code{PSetup} function and the
solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the ``solve'' call, the FGMRES iteration is performed.  This
will include scaling, preconditioning, and restarts if those options
have been supplied.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_spfgmr.h}.

The SUNLINSOL\_SPFGMR module defines implementations of all
``iterative'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_SPFGMR}

\item {} 
\code{SUNLinSolInitialize\_SPFGMR}

\item {} 
\code{SUNLinSolSetATimes\_SPFGMR}

\item {} 
\code{SUNLinSolSetPreconditioner\_SPFGMR}

\item {} 
\code{SUNLinSolSetScalingVectors\_SPFGMR}

\item {} 
\code{SUNLinSolSetup\_SPFGMR}

\item {} 
\code{SUNLinSolSolve\_SPFGMR}

\item {} 
\code{SUNLinSolNumIters\_SPFGMR}

\item {} 
\code{SUNLinSolResNorm\_SPFGMR}

\item {} 
\code{SUNLinSolResid\_SPFGMR}

\item {} 
\code{SUNLinSolLastFlag\_SPFGMR}

\item {} 
\code{SUNLinSolSpace\_SPFGMR}

\item {} 
\code{SUNLinSolFree\_SPFGMR}

\end{itemize}

The module SUNLINSOL\_SPFGMR provides the following additional
user-callable routines:
\index{SUNSPFGMR (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMR}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNSPFGMR}}{N\_Vector\emph{ y}, int\emph{ pretype}, int\emph{ maxl}}{}
This constructor function creates and allocates memory for a SPFGMR
\code{SUNLinearSolver}.  Its arguments are an \code{N\_Vector}, a flag
indicating to use preconditioning, and the number of Krylov basis
vectors to use.

This routine will perform consistency checks to ensure that it is
called with a consistent \code{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \code{y} is
incompatible, then this routine will return \code{NULL}.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

Since the FGMRES algorithm is designed to only support right
preconditioning, then any of the \code{pretype}
inputs \code{PREC\_LEFT} (1), \code{PREC\_RIGHT} (2), or \code{PREC\_BOTH}
(3) will result in use of \code{PREC\_RIGHT};  any other integer input
will result in the default (no preconditioning).
We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS). While it is
possible to use a right-preconditioned SUNLINSOL\_SPFGMR object for
these packages, this use mode is not supported and may result in
inferior performance.

\end{fulllineitems}

\index{SUNSPFGMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetPrecType}\pysiglinewithargsret{int \bfcode{SUNSPFGMRSetPrecType}}{SUNLinearSolver\emph{ S}, int\emph{ pretype}}{}
This function updates the flag indicating use of preconditioning.
Since the FGMRES algorithm is designed to only support right
preconditioning, then any of the \code{pretype}
inputs \code{PREC\_LEFT} (1), \code{PREC\_RIGHT} (2), or \code{PREC\_BOTH}
(3) will result in use of \code{PREC\_RIGHT};  any other integer input
will result in the default (no preconditioning).

This routine will return with one of the error codes
\code{SUNLS\_MEM\_NULL} (\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNSPFGMRSetGSType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetGSType}\pysiglinewithargsret{int \bfcode{SUNSPFGMRSetGSType}}{SUNLinearSolver\emph{ S}, int\emph{ gstype}}{}
This function sets the type of Gram-Schmidt orthogonalization to
use.  Supported values are \code{MODIFIED\_GS} (1) and
\code{CLASSICAL\_GS} (2).  Any other integer input will result in a
failure, returning error code \code{SUNLS\_ILL\_INPUT}.

This routine will return with one of the error codes
\code{SUNLS\_ILL\_INPUT} (illegal \code{gstype}), \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}), or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNSPFGMRSetMaxRestarts (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetMaxRestarts}\pysiglinewithargsret{int \bfcode{SUNSPFGMRSetMaxRestarts}}{SUNLinearSolver\emph{ S}, int\emph{ maxrs}}{}
This function sets the number of FGMRES restarts to
allow.  A negative input will result in the default of 0.

This routine will return with one of the error codes
\code{SUNLS\_MEM\_NULL} (\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_SPFGMR module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit]{\emph{\code{FSUNSPFGMRInit()}}}} to initialize this
SUNLINSOL\_SPFGMR module for a given SUNDIALS solver.
\index{FSUNSPFGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPFGMRInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPFGMR \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting whether to use
preconditioning: no=0, yes=1.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of FGMRES basis vectors to use.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit]{\emph{\code{FSUNMassSPFGMRInit()}}}} initializes
this SUNLINSOL\_SPFGMR module for solving mass matrix linear systems.
\index{FSUNMassSPFGMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPFGMRInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPFGMR \code{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting whether to use
preconditioning: no=0, yes=1.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of FGMRES basis vectors to use.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetGSType]{\emph{\code{SUNSPFGMRSetGSType()}}}}, {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetPrecType]{\emph{\code{SUNSPFGMRSetPrecType()}}}}
and {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetMaxRestarts]{\emph{\code{SUNSPFGMRSetMaxRestarts()}}}} routines also support Fortran
interfaces for the system and mass matrix solvers:
\index{FSUNSPFGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRSetGSType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPFGMRSetGSType}}{\emph{CODE}, \emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetGSType]{\emph{\code{SUNSPFGMRSetGSType()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit]{\emph{\code{FSUNSPFGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPFGMRSetGSType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRSetGSType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPFGMRSetGSType}}{\emph{GSTYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetGSType]{\emph{\code{SUNSPFGMRSetGSType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit]{\emph{\code{FSUNMassSPFGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPFGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPFGMRSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetPrecType]{\emph{\code{SUNSPFGMRSetPrecType()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit]{\emph{\code{FSUNSPFGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPFGMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPFGMRSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPFGMR:c.SUNSPFGMRSetPrecType]{\emph{\code{SUNSPFGMRSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit]{\emph{\code{FSUNMassSPFGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPFGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRSetMaxRS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPFGMRSetMaxRS}}{\emph{CODE}, \emph{MAXRS}, \emph{IER}}{}
Fortran interface to \code{SUNSPFGMRSetMaxRS()} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNSPFGMRInit]{\emph{\code{FSUNSPFGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPFGMRSetMaxRS() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRSetMaxRS}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPFGMRSetMaxRS}}{\emph{MAXRS}, \emph{IER}}{}
Fortran interface to \code{SUNSPFGMRSetMaxRS()} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPFGMR:f/_/FSUNMassSPFGMRInit]{\emph{\code{FSUNMassSPFGMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\section{The SUNLINSOL\_SPBCGS Module}
\label{sunlinsol/SUNLinSol_SPBCGS::doc}\label{sunlinsol/SUNLinSol_SPBCGS:the-sunlinsol-spbcgs-module}\label{sunlinsol/SUNLinSol_SPBCGS:sunlinsol-spbcgs}
The SPBCGS (Scaled, Preconditioned, Bi-Conjugate Gradient,
Stabilized \phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:id1}{\hyperref[References:v1992]{\emph{{[}V1992{]}}}}) implementation of the \code{SUNLinearSolver} module
provided with SUNDIALS, SUNLINSOL\_SPBCGS, is an iterative linear
solver that is designed to be compatible with any \code{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[nvectors/NVector_Operations:c.N_VClone]{\emph{\code{N\_VClone()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VDotProd]{\emph{\code{N\_VDotProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VScale]{\emph{\code{N\_VScale()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VLinearSum]{\emph{\code{N\_VLinearSum()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VProd]{\emph{\code{N\_VProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VDiv]{\emph{\code{N\_VDiv()}}}}, and
{\hyperref[nvectors/NVector_Operations:c.N_VDestroy]{\emph{\code{N\_VDestroy()}}}}).  Unlike the SPGMR and SPFGMR algorithms,
SPBCGS requires a fixed amount of memory that does not increase with
the number of allowed iterations.

The SUNLINSOL\_SPBCGS module defines the \emph{content} field of a
\code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPBCGS} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r\PYGZus{}star}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{p}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{q}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{u}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{Ap}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{maxl} - number of SPBCGS iterations to allow (default is 5),

\item {} 
\code{pretype} - flag for type of preconditioning to employ
(default is none),

\item {} 
\code{numiters} - number of iterations from the most-recent solve,

\item {} 
\code{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\code{last\_flag} - last error return flag from an internal
function,

\item {} 
\code{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\code{ATData} - pointer to structure for \code{ATimes},

\item {} 
\code{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\code{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\code{PData} - pointer to structure for \code{Psetup} and \code{Psolve},

\item {} 
\code{s1, s2} - vector pointers for supplied scaling matrices
(default is \code{NULL}),

\item {} 
\code{r} - a \code{N\_Vector} which holds the current scaled,
preconditioned linear system residual,

\item {} 
\code{r\_star} - a \code{N\_Vector} which holds the initial scaled,
preconditioned linear system residual,

\item {} 
\code{p, q, u, Ap, vtemp} - \code{N\_Vector} used for workspace by the
SPBCGS algorithm.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction all \code{N\_Vector} solver data is allocated, with
vectors cloned from a template \code{N\_Vector} that is input, and
default solver parameters are set.

\item {} 
User-facing ``set'' routines may be called to modify default
solver parameters.

\item {} 
Additional ``set'' routines are called by the SUNDIALS solver
that interfaces with SUNLINSOL\_SPBCGS to supply the \code{ATimes},
\code{PSetup}, and \code{Psolve} function pointers and \code{s1} and \code{s2}
scaling vectors.

\item {} 
In the ``initialize'' call, the solver parameters are checked
for validity.

\item {} 
In the ``setup'' call, any non-\code{NULL} \code{PSetup} function is
called.  Typically, this is provided by the SUNDIALS solver itself,
that translates between the generic \code{PSetup} function and the
solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the ``solve'' call the SPBCGS iteration is performed.  This
will include scaling and preconditioning if those options have been
supplied.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_spbcgs.h}.

The SUNLINSOL\_SPBCGS module defines implementations of all
``iterative'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_SPBCGS}

\item {} 
\code{SUNLinSolInitialize\_SPBCGS}

\item {} 
\code{SUNLinSolSetATimes\_SPBCGS}

\item {} 
\code{SUNLinSolSetPreconditioner\_SPBCGS}

\item {} 
\code{SUNLinSolSetScalingVectors\_SPBCGS}

\item {} 
\code{SUNLinSolSetup\_SPBCGS}

\item {} 
\code{SUNLinSolSolve\_SPBCGS}

\item {} 
\code{SUNLinSolNumIters\_SPBCGS}

\item {} 
\code{SUNLinSolResNorm\_SPBCGS}

\item {} 
\code{SUNLinSolResid\_SPBCGS}

\item {} 
\code{SUNLinSolLastFlag\_SPBCGS}

\item {} 
\code{SUNLinSolSpace\_SPBCGS}

\item {} 
\code{SUNLinSolFree\_SPBCGS}

\end{itemize}

The module SUNLINSOL\_SPBCGS provides the following additional
user-callable routines:
\index{SUNSPBCGS (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGS}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNSPBCGS}}{N\_Vector\emph{ y}, int\emph{ pretype}, int\emph{ maxl}}{}
This constructor function creates and allocates memory for a SPBCGS
\code{SUNLinearSolver}.  Its arguments are an \code{N\_Vector}, the desired
type of preconditioning, and the number of linear iterations to allow.

This routine will perform consistency checks to ensure that it is
called with a consistent \code{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \code{y} is
incompatible, then this routine will return \code{NULL}.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

Allowable inputs for \code{pretype} are \code{PREC\_NONE} (0),
\code{PREC\_LEFT} (1), \code{PREC\_RIGHT} (2) and \code{PREC\_BOTH} (3);
any other integer input will result in the default (no
preconditioning).  We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS) and others
with only right preconditioning (KINSOL). While it is possible to
configure a SUNLINSOL\_SPBCGS object to use any of the
preconditioning options with these solvers, this use mode is not
supported and may result in inferior performance.

\end{fulllineitems}

\index{SUNSPBCGSSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetPrecType}\pysiglinewithargsret{int \bfcode{SUNSPBCGSSetPrecType}}{SUNLinearSolver\emph{ S}, int\emph{ pretype}}{}
This function updates the type of preconditioning to use.  Supported
values are \code{PREC\_NONE} (0), \code{PREC\_LEFT} (1),
\code{PREC\_RIGHT} (2), and \code{PREC\_BOTH} (3).

This routine will return with one of the error codes
\code{SUNLS\_ILL\_INPUT} (illegal \code{pretype}), \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}), or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNSPBCGSSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetMaxl}\pysiglinewithargsret{int \bfcode{SUNSPBCGSSetMaxl}}{SUNLinearSolver\emph{ S}, int\emph{ maxl}}{}
This function updates the number of linear solver iterations to allow.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

This routine will return with one of the error codes
\code{SUNLS\_MEM\_NULL} (\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_SPBCGS module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit]{\emph{\code{FSUNSPBCGSInit()}}}} to initialize this
SUNLINSOL\_SPBCGS module for a given SUNDIALS solver.
\index{FSUNSPBCGSInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPBCGSInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPBCGS \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of SPBCGS iterations to allow.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function {\hyperref[sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit]{\emph{\code{FSUNMassSPBCGSInit()}}}} initializes
this SUNLINSOL\_SPBCGS module for solving mass matrix linear systems.
\index{FSUNMassSPBCGSInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPBCGSInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPBCGS \code{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of SPBCGS iterations to allow.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetPrecType]{\emph{\code{SUNSPBCGSSetPrecType()}}}} and {\hyperref[sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetMaxl]{\emph{\code{SUNSPBCGSSetMaxl()}}}}
routines also support Fortran interfaces for the system and mass
matrix solvers:
\index{FSUNSPBCGSSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPBCGSSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetPrecType]{\emph{\code{SUNSPBCGSSetPrecType()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit]{\emph{\code{FSUNSPBCGSInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPBCGSSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPBCGSSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetPrecType]{\emph{\code{SUNSPBCGSSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit]{\emph{\code{FSUNMassSPBCGSInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPBCGSSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSSetMaxl}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPBCGSSetMaxl}}{\emph{CODE}, \emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetMaxl]{\emph{\code{SUNSPBCGSSetMaxl()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNSPBCGSInit]{\emph{\code{FSUNSPBCGSInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPBCGSSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSSetMaxl}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPBCGSSetMaxl}}{\emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPBCGS:c.SUNSPBCGSSetMaxl]{\emph{\code{SUNSPBCGSSetMaxl()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPBCGS:f/_/FSUNMassSPBCGSInit]{\emph{\code{FSUNMassSPBCGSInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\section{The SUNLINSOL\_SPTFQMR Module}
\label{sunlinsol/SUNLinSol_SPTFQMR:sunlinsol-sptfqmr}\label{sunlinsol/SUNLinSol_SPTFQMR::doc}\label{sunlinsol/SUNLinSol_SPTFQMR:the-sunlinsol-sptfqmr-module}
The SPTFQMR (Scaled, Preconditioned, Transpose-Free Quasi-Minimum
Residual \phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:id1}{\hyperref[References:f1993]{\emph{{[}F1993{]}}}}) implementation of the \code{SUNLinearSolver} module
provided with SUNDIALS, SUNLINSOL\_SPTFQMR, is an iterative linear
solver that is designed to be compatible with any \code{N\_Vector}
implementation (serial, threaded, parallel, and user-supplied) that
supports a minimal subset of operations ({\hyperref[nvectors/NVector_Operations:c.N_VClone]{\emph{\code{N\_VClone()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VDotProd]{\emph{\code{N\_VDotProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VScale]{\emph{\code{N\_VScale()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VLinearSum]{\emph{\code{N\_VLinearSum()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VProd]{\emph{\code{N\_VProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VConst]{\emph{\code{N\_VConst()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VDiv]{\emph{\code{N\_VDiv()}}}}, and {\hyperref[nvectors/NVector_Operations:c.N_VDestroy]{\emph{\code{N\_VDestroy()}}}}).  Unlike the SPGMR and
SPFGMR algorithms, SPTFQMR requires a fixed amount of memory that does
not increase with the number of allowed iterations.

The SUNLINSOL\_SPTFQMR module defines the \emph{content} field of a
\code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}SPTFQMR} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r\PYGZus{}star}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{q}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{d}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{v}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{p}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{o}{*}\PYG{n}{r}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{u}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp1}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp2}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{vtemp3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{maxl} - number of TFQMR iterations to allow (default is 5),

\item {} 
\code{pretype} - flag for type of preconditioning to employ
(default is none),

\item {} 
\code{numiters} - number of iterations from the most-recent solve,

\item {} 
\code{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\code{last\_flag} - last error return flag from an internal
function,

\item {} 
\code{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\code{ATData} - pointer to structure for \code{ATimes},

\item {} 
\code{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\code{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\code{PData} - pointer to structure for \code{Psetup} and \code{Psolve},

\item {} 
\code{s1, s2} - vector pointers for supplied scaling matrices
(default is \code{NULL}),

\item {} 
\code{r\_star} - a \code{N\_Vector} which holds the initial scaled,
preconditioned linear system residual,

\item {} 
\code{q, d, v, p, u} - \code{N\_Vector} used for workspace by the SPTFQMR
algorithm,

\item {} 
\code{r} - array of two \code{N\_Vector} used for workspace within the
SPTFQMR algorithm,

\item {} 
\code{vtemp1, vtemp2, vtemp3} - temporary vector storage.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction all \code{N\_Vector} solver data is allocated,
with vectors cloned from a template \code{N\_Vector} that is input, and
default solver parameters are set.

\item {} 
User-facing ``set'' routines may be called to modify default
solver parameters.

\item {} 
Additional ``set'' routines are called by the SUNDIALS solver
that interfaces with SUNLINSOL\_SPTFQMR to supply the
\code{ATimes}, \code{PSetup}, and \code{Psolve} function pointers and
\code{s1} and \code{s2} scaling vectors.

\item {} 
In the ``initialize'' call, the solver parameters are checked
for validity.

\item {} 
In the ``setup'' call, any non-\code{NULL} \code{PSetup} function is
called.  Typically, this is provided by the SUNDIALS solver itself,
that translates between the generic \code{PSetup} function and the
solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the ``solve'' call the TFQMR iteration is performed.  This
will include scaling and preconditioning if those options have been
supplied.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_sptfqmr.h}.

The SUNLINSOL\_SPTFQMR module defines implementations of all
``iterative'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_SPTFQMR}

\item {} 
\code{SUNLinSolInitialize\_SPTFQMR}

\item {} 
\code{SUNLinSolSetATimes\_SPTFQMR}

\item {} 
\code{SUNLinSolSetPreconditioner\_SPTFQMR}

\item {} 
\code{SUNLinSolSetScalingVectors\_SPTFQMR}

\item {} 
\code{SUNLinSolSetup\_SPTFQMR}

\item {} 
\code{SUNLinSolSolve\_SPTFQMR}

\item {} 
\code{SUNLinSolNumIters\_SPTFQMR}

\item {} 
\code{SUNLinSolResNorm\_SPTFQMR}

\item {} 
\code{SUNLinSolResid\_SPTFQMR}

\item {} 
\code{SUNLinSolLastFlag\_SPTFQMR}

\item {} 
\code{SUNLinSolSpace\_SPTFQMR}

\item {} 
\code{SUNLinSolFree\_SPTFQMR}

\end{itemize}

The module SUNLINSOL\_SPTFQMR provides the following additional
user-callable routines:
\index{SUNSPTFQMR (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMR}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNSPTFQMR}}{N\_Vector\emph{ y}, int\emph{ pretype}, int\emph{ maxl}}{}
This constructor function creates and allocates memory for a SPTFQMR
\code{SUNLinearSolver}.  Its arguments are an \code{N\_Vector}, the desired
type of preconditioning, and the number of linear iterations to
allow.

This routine will perform consistency checks to ensure that it is
called with a consistent \code{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \code{y} is
incompatible, then this routine will return \code{NULL}.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

Allowable inputs for \code{pretype} are \code{PREC\_NONE} (0),
\code{PREC\_LEFT} (1), \code{PREC\_RIGHT} (2) and \code{PREC\_BOTH} (3);
any other integer input will result in the default (no
preconditioning).  We note that some SUNDIALS solvers are designed
to only work with left preconditioning (IDA and IDAS) and others
with only right preconditioning (KINSOL). While it is possible to
configure a SUNLINSOL\_SPTFQMR object to use any of the
preconditioning options with these solvers, this use mode is not
supported and may result in inferior performance.

\end{fulllineitems}

\index{SUNSPTFQMRSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetPrecType}\pysiglinewithargsret{int \bfcode{SUNSPTFQMRSetPrecType}}{SUNLinearSolver\emph{ S}, int\emph{ pretype}}{}
This function updates the type of preconditioning to use.  Supported
values are \code{PREC\_NONE} (0), \code{PREC\_LEFT} (1),
\code{PREC\_RIGHT} (2), and \code{PREC\_BOTH} (3).

This routine will return with one of the error codes
\code{SUNLS\_ILL\_INPUT} (illegal \code{pretype}), \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}), or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNSPTFQMRSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetMaxl}\pysiglinewithargsret{int \bfcode{SUNSPTFQMRSetMaxl}}{SUNLinearSolver\emph{ S}, int\emph{ maxl}}{}
This function updates the number of linear solver iterations to
allow.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

This routine will return with one of the error codes
\code{SUNLS\_MEM\_NULL} (\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_SPTFQMR module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit]{\emph{\code{FSUNSPTFQMRInit()}}}} to initialize
this SUNLINSOL\_SPTFQMR module for a given SUNDIALS solver.
\index{FSUNSPTFQMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPTFQMRInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPTFQMR \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of SPTFQMR iterations to allow.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity mass matrix, the
Fortran-callable function  {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit]{\emph{\code{FSUNMassSPTFQMRInit()}}}} initializes
this SUNLINSOL\_SPTFQMR module for solving mass matrix linear systems.
\index{FSUNMassSPTFQMRInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPTFQMRInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a SPTFQMR \code{SUNLinearSolver} structure for use in
solving mass matrix systems in ARKode.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting type of
preconditioning to use: none=0, left=1, right=2, both=3.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of SPTFQMR iterations to allow.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetPrecType]{\emph{\code{SUNSPTFQMRSetPrecType()}}}} and
{\hyperref[sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetMaxl]{\emph{\code{SUNSPTFQMRSetMaxl()}}}} routines also support Fortran interfaces
for the system and mass matrix solvers:
\index{FSUNSPTFQMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPTFQMRSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetPrecType]{\emph{\code{SUNSPTFQMRSetPrecType()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit]{\emph{\code{FSUNSPTFQMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPTFQMRSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPTFQMRSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetPrecType]{\emph{\code{SUNSPTFQMRSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit]{\emph{\code{FSUNMassSPTFQMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNSPTFQMRSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRSetMaxl}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNSPTFQMRSetMaxl}}{\emph{CODE}, \emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetMaxl]{\emph{\code{SUNSPTFQMRSetMaxl()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNSPTFQMRInit]{\emph{\code{FSUNSPTFQMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassSPTFQMRSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRSetMaxl}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassSPTFQMRSetMaxl}}{\emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:c.SUNSPTFQMRSetMaxl]{\emph{\code{SUNSPTFQMRSetMaxl()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_SPTFQMR:f/_/FSUNMassSPTFQMRInit]{\emph{\code{FSUNMassSPTFQMRInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\section{The SUNLINSOL\_PCG Module}
\label{sunlinsol/SUNLinSol_PCG:sunlinsol-pcg}\label{sunlinsol/SUNLinSol_PCG::doc}\label{sunlinsol/SUNLinSol_PCG:the-sunlinsol-pcg-module}
The PCG (Preconditioned Conjugate Gradient \phantomsection\label{sunlinsol/SUNLinSol_PCG:id1}{\hyperref[References:hs1952]{\emph{{[}HS1952{]}}}} implementation of
the \code{SUNLinearSolver} module provided with SUNDIALS, SUNLINSOL\_PCG,
is an iterative linear solver that is designed to be compatible with
any \code{N\_Vector} implementation (serial, threaded, parallel, and
user-supplied) that supports a minimal subset of operations
({\hyperref[nvectors/NVector_Operations:c.N_VClone]{\emph{\code{N\_VClone()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VDotProd]{\emph{\code{N\_VDotProd()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VScale]{\emph{\code{N\_VScale()}}}},
{\hyperref[nvectors/NVector_Operations:c.N_VLinearSum]{\emph{\code{N\_VLinearSum()}}}}, {\hyperref[nvectors/NVector_Operations:c.N_VProd]{\emph{\code{N\_VProd()}}}}, and
{\hyperref[nvectors/NVector_Operations:c.N_VDestroy]{\emph{\code{N\_VDestroy()}}}}).  Unlike the SPGMR and SPFGMR algorithms, PCG
requires a fixed amount of memory that does not increase with the
number of allowed iterations.

Unlike all of the other iterative linear solvers supplied with
SUNDIALS, PCG should only be used on \emph{symmetric} linear
systems (e.g. mass matrix linear systems encountered in
ARKode). As a result, the explanation of the role of scaling and
preconditioning matrices given in general must be modified in this
scenario.  The PCG algorithm solves a linear system \(Ax = b\) where
\(A\) is a symmetric (\(A^T=A\)), real-valued matrix.  Preconditioning is
allowed, and is applied in a symmetric fashion on both the right and
left.  Scaling is also allowed and is applied symmetrically.  We
denote the preconditioner and scaling matrices as follows:
\begin{itemize}
\item {} 
\(P\) is the preconditioner (assumed symmetric),

\item {} 
\(S\) is a diagonal matrix of scale factors.

\end{itemize}

The matrices \(A\) and \(P\) are not required explicitly; only routines
that provide \(A\) and \(P^{-1}\) as operators are required.  The diagonal
of the matrix \(S\) is held in a single \code{N\_Vector}, supplied by the user.

In this notation, PCG applies the underlying CG algorithm to the
equivalent transformed system
\phantomsection\label{sunlinsol/SUNLinSol_PCG:equation-eq:transformed_linear_systemPCG}\begin{gather}
\begin{split}\tilde{A} \tilde{x} = \tilde{b}\end{split}\label{sunlinsol/SUNLinSol_PCG-eq:transformed_linear_systemPCG}
\end{gather}
where
\phantomsection\label{sunlinsol/SUNLinSol_PCG:equation-eq:transformed_linear_system_componentsPCG}\begin{gather}
\begin{split}\tilde{A} &= S P^{-1} A P^{-1} S,\\
\tilde{b} &= S P^{-1} b,\\
\tilde{x} &= S^{-1} P x.\end{split}\label{sunlinsol/SUNLinSol_PCG-eq:transformed_linear_system_componentsPCG}
\end{gather}
The scaling matrix must be chosen so that the vectors \(SP^{-1}b\) and
\(S^{-1}Px\) have dimensionless components.

The stopping test for the PCG iterations is on the L2 norm of the
scaled preconditioned residual:
\begin{gather}
\begin{split}&\| \tilde{b} - \tilde{A} \tilde{x} \|_2  <  \delta\\
\Leftrightarrow\quad &\\
&\| S P^{-1} b - S P^{-1} A x \|_2  <  \delta\\
\Leftrightarrow\quad &\\
&\| P^{-1} b - P^{-1} A x \|_S  <  \delta\end{split}\notag
\end{gather}
where \(\| v \|_S = \sqrt{v^T S^T S v}\), with an input tolerance
\(\delta\).

The SUNLINSOL\_PCG module defines the \emph{content} field of a
\code{SUNLinearSolver} to be the following structure:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{\PYGZus{}SUNLinearSolverContent\PYGZus{}PCG} \PYG{p}{\PYGZob{}}
  \PYG{k+kt}{int} \PYG{n}{maxl}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{pretype}\PYG{p}{;}
  \PYG{k+kt}{int} \PYG{n}{numiters}\PYG{p}{;}
  \PYG{n}{realtype} \PYG{n}{resnorm}\PYG{p}{;}
  \PYG{k+kt}{long} \PYG{k+kt}{int} \PYG{n}{last\PYGZus{}flag}\PYG{p}{;}
  \PYG{n}{ATimesFn} \PYG{n}{ATimes}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{ATData}\PYG{p}{;}
  \PYG{n}{PSetupFn} \PYG{n}{Psetup}\PYG{p}{;}
  \PYG{n}{PSolveFn} \PYG{n}{Psolve}\PYG{p}{;}
  \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{PData}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{s}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{r}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{p}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{z}\PYG{p}{;}
  \PYG{n}{N\PYGZus{}Vector} \PYG{n}{Ap}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

These entries of the \emph{content} field contain the following
information:
\begin{itemize}
\item {} 
\code{maxl} - number of PCG iterations to allow (default is 5),

\item {} 
\code{pretype} - flag for use of preconditioning (default is none),

\item {} 
\code{numiters} - number of iterations from the most-recent solve,

\item {} 
\code{resnorm} - final linear residual norm from the most-recent
solve,

\item {} 
\code{last\_flag} - last error return flag from an internal
function,

\item {} 
\code{ATimes} - function pointer to perform \(Av\) product,

\item {} 
\code{ATData} - pointer to structure for \code{ATimes},

\item {} 
\code{Psetup} - function pointer to preconditioner setup routine,

\item {} 
\code{Psolve} - function pointer to preconditioner solve routine,

\item {} 
\code{PData} - pointer to structure for \code{Psetup} and \code{Psolve},

\item {} 
\code{s} - vector pointer for supplied scaling matrix
(default is \code{NULL}),

\item {} 
\code{r} - a \code{N\_Vector} which holds the preconditioned linear system
residual,

\item {} 
\code{p, z, Ap} - \code{N\_Vector} used for workspace by the
PCG algorithm.

\end{itemize}

This solver is constructed to perform the following operations:
\begin{itemize}
\item {} 
During construction all \code{N\_Vector} solver data is allocated, with
vectors cloned from a template \code{N\_Vector} that is input, and
default solver parameters are set.

\item {} 
User-facing ``set'' routines may be called to modify default
solver parameters.

\item {} 
Additional ``set'' routines are called by the SUNDIALS solver
that interfaces with SUNLINSOL\_PCG to supply the
\code{ATimes}, \code{PSetup}, and \code{Psolve} function pointers and
\code{s} scaling vector.

\item {} 
In the ``initialize'' call, the solver parameters are checked
for validity.

\item {} 
In the ``setup'' call, any non-\code{NULL} \code{PSetup} function is
called.  Typically, this is provided by the SUNDIALS solver
itself, that translates between the generic \code{PSetup} function and
the solver-specific routine (solver-supplied or user-supplied).

\item {} 
In the ``solve'' call the PCG iteration is performed.  This
will include scaling and preconditioning if those options have been
supplied.

\end{itemize}

The header file to be included when using this module
is \code{sunlinsol/sunlinsol\_pcg.h}.

The SUNLINSOL\_PCG module defines implementations of all
``iterative'' linear solver operations listed in the section
{\hyperref[sunlinsol/SUNLinSol_Operations:sunlinsol-ops]{\emph{\DUspan{}{Description of the SUNLinearSolver operations}}}}:
\begin{itemize}
\item {} 
\code{SUNLinSolGetType\_PCG}

\item {} 
\code{SUNLinSolInitialize\_PCG}

\item {} 
\code{SUNLinSolSetATimes\_PCG}

\item {} 
\code{SUNLinSolSetPreconditioner\_PCG}

\item {} 
\code{SUNLinSolSetScalingVectors\_PCG} -- since PCG only supports
symmetric scaling, the second \code{N\_Vector} argument to this function
is ignored

\item {} 
\code{SUNLinSolSetup\_PCG}

\item {} 
\code{SUNLinSolSolve\_PCG}

\item {} 
\code{SUNLinSolNumIters\_PCG}

\item {} 
\code{SUNLinSolResNorm\_PCG}

\item {} 
\code{SUNLinSolResid\_PCG}

\item {} 
\code{SUNLinSolLastFlag\_PCG}

\item {} 
\code{SUNLinSolSpace\_PCG}

\item {} 
\code{SUNLinSolFree\_PCG}

\end{itemize}

The module SUNLINSOL\_PCG provides the following additional
user-callable routines:
\index{SUNPCG (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:c.SUNPCG}\pysiglinewithargsret{SUNLinearSolver \bfcode{SUNPCG}}{N\_Vector\emph{ y}, int\emph{ pretype}, int\emph{ maxl}}{}
This constructor function creates and allocates memory for a PCG
\code{SUNLinearSolver}.  Its arguments are an \code{N\_Vector}, a flag
indicating to use preconditioning, and the number of linear
iterations to allow.

This routine will perform consistency checks to ensure that it is
called with a consistent \code{N\_Vector} implementation (i.e. that it
supplies the requisite vector operations).  If \code{y} is
incompatible then this routine will return \code{NULL}.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

Since the PCG algorithm is designed to only support symmetric
preconditioning, then any of the \code{pretype} inputs \code{PREC\_LEFT}
(1), \code{PREC\_RIGHT} (2), or \code{PREC\_BOTH} (3) will result in use
of the symmetric preconditioner;  any other integer input will
result in the default (no preconditioning).  Although some SUNDIALS
solvers are designed to only work with left preconditioning (IDA
and IDAS) and others with only right preconditioning (KINSOL), PCG
should \emph{only} be used with these packages when the linear systems
are known to be \emph{symmetric}.  Since the scaling of matrix rows and
columns must be identical in a symmetric matrix, symmetric
preconditioning should work appropriately even for packages
designed with one-sided preconditioning in mind.

\end{fulllineitems}

\index{SUNPCGSetPrecType (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:c.SUNPCGSetPrecType}\pysiglinewithargsret{int \bfcode{SUNPCGSetPrecType}}{SUNLinearSolver\emph{ S}, int\emph{ pretype}}{}
This function updates the flag indicating use of preconditioning.
As above, any one of the input values, \code{PREC\_LEFT} (1),
\code{PREC\_RIGHT} (2), or \code{PREC\_BOTH} (3) will enable
preconditioning; \code{PREC\_NONE} (0) disables preconditioning.

This routine will return with one of the error codes
\code{SUNLS\_ILL\_INPUT} (illegal \code{pretype}), \code{SUNLS\_MEM\_NULL}
(\code{S} is \code{NULL}), or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}

\index{SUNPCGSetMaxl (C function)}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:c.SUNPCGSetMaxl}\pysiglinewithargsret{int \bfcode{SUNPCGSetMaxl}}{SUNLinearSolver\emph{ S}, int\emph{ maxl}}{}
This function updates the number of linear solver iterations to
allow.

A \code{maxl} argument that is \(\le0\) will result in the default
value (5).

This routine will return with one of the error codes
\code{SUNLS\_MEM\_NULL} (\code{S} is \code{NULL}) or \code{SUNLS\_SUCCESS}.

\end{fulllineitems}


For solvers that include a Fortran interface module, the
SUNLINSOL\_PCG module also includes the Fortran-callable
function {\hyperref[sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit]{\emph{\code{FSUNPCGInit()}}}} to initialize
this SUNLINSOL\_PCG module for a given SUNDIALS solver.
\index{FSUNPCGInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNPCGInit}}{\emph{CODE}, \emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a PCG \code{SUNLinearSolver} structure for
use in a SUNDIALS package.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{CODE} (\code{int}, input) -- flag denoting the SUNDIALS solver
this matrix will be used for: CVODE=1, IDA=2, KINSOL=3, ARKode=4.

\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting whether to use
symmetric preconditioning: no=0, yes=1.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of PCG iterations to allow.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


Additionally, when using ARKode with a non-identity
mass matrix, the Fortran-callable function
{\hyperref[sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit]{\emph{\code{FSUNMassPCGInit()}}}} initializes this
SUNLINSOL\_PCG module for solving mass matrix linear systems.
\index{FSUNMassPCGInit() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassPCGInit}}{\emph{PRETYPE}, \emph{MAXL}, \emph{IER}}{}
Initializes a PCG \code{SUNLinearSolver} structure for
use in solving mass matrix systems in ARKode.

This routine must be called \emph{after} the \code{N\_Vector} object has
been initialized.
\begin{description}
\item[{\textbf{Arguments:}}] \leavevmode\begin{itemize}
\item {} 
\emph{PRETYPE} (\code{int}, input) -- flag denoting whether to use
symmetric preconditioning: no=0, yes=1.

\item {} 
\emph{MAXL} (\code{int}, input) -- number of PCG iterations to allow.

\item {} 
\emph{IER} (\code{int}, output) -- return flag (0 success, -1 for failure).

\end{itemize}

\end{description}

\end{fulllineitems}


The {\hyperref[sunlinsol/SUNLinSol_PCG:c.SUNPCGSetPrecType]{\emph{\code{SUNPCGSetPrecType()}}}} and {\hyperref[sunlinsol/SUNLinSol_PCG:c.SUNPCGSetMaxl]{\emph{\code{SUNPCGSetMaxl()}}}}
routines also support Fortran interfaces for the system and mass
matrix solvers:
\index{FSUNPCGSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNPCGSetPrecType}}{\emph{CODE}, \emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_PCG:c.SUNPCGSetPrecType]{\emph{\code{SUNPCGSetPrecType()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit]{\emph{\code{FSUNPCGInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassPCGSetPrecType() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGSetPrecType}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassPCGSetPrecType}}{\emph{PRETYPE}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_PCG:c.SUNPCGSetPrecType]{\emph{\code{SUNPCGSetPrecType()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit]{\emph{\code{FSUNMassPCGInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNPCGSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGSetMaxl}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNPCGSetMaxl}}{\emph{CODE}, \emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_PCG:c.SUNPCGSetMaxl]{\emph{\code{SUNPCGSetMaxl()}}}} for system
linear solvers.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_PCG:f/_/FSUNPCGInit]{\emph{\code{FSUNPCGInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}

\index{FSUNMassPCGSetMaxl() (fortran subroutine)|textbf}

\begin{fulllineitems}
\phantomsection\label{sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGSetMaxl}\pysiglinewithargsret{\strong{subroutine  }\bfcode{FSUNMassPCGSetMaxl}}{\emph{MAXL}, \emph{IER}}{}
Fortran interface to {\hyperref[sunlinsol/SUNLinSol_PCG:c.SUNPCGSetMaxl]{\emph{\code{SUNPCGSetMaxl()}}}} for mass matrix
linear solvers in ARKode.

This routine must be called \emph{after} {\hyperref[sunlinsol/SUNLinSol_PCG:f/_/FSUNMassPCGInit]{\emph{\code{FSUNMassPCGInit()}}}} has
been called.

\textbf{Arguments:} all should have type \code{int}, and have meanings
identical to those listed above.

\end{fulllineitems}



\section{SUNLinearSolver Examples}
\label{sunlinsol/SUNLinSol_Examples:sunlinearsolver-examples}\label{sunlinsol/SUNLinSol_Examples::doc}\label{sunlinsol/SUNLinSol_Examples:sunlinsol-examples}
There are \code{SUNLinearSolver} examples that may be installed for each
implementation; these make use of the functions in \code{test\_sunlinsol.c}.
These example functions show simple usage of the \code{SUNLinearSolver} family
of modules.  The inputs to the examples depend on the linear solver type,
and are output to \code{stdout} if the example is run without the
appropriate number of command-line arguments.

The following is a list of the example functions in \code{test\_sunlinsol.c}:
\begin{itemize}
\item {} 
\code{Test\_SUNLinSolGetType}: Verifies the returned solver type against
the value that should be returned.

\item {} 
\code{Test\_SUNLinSolInitialize}: Verifies that \code{SUNLinSolInitialize}
can be called and returns successfully.

\item {} 
\code{Test\_SUNLinSolSetup}: Verifies that \code{SUNLinSolSetup} can
be called and returns successfully.

\item {} 
\code{Test\_SUNLinSolSolve}: Given a \code{SUNMatrix} object \(A\),
\code{N\_Vector} objects \(x\) and \(b\) (where \(Ax=b\))
and a desired solution tolerance texttt\{tol\}, this routine clones
\(x\) into a new vector \(y\), calls \code{SUNLinSolSolve} to
fill \(y\) as the solution to \(Ay=b\) (to the input
tolerance), verifies that each entry in \(x\) and \(y\)
match to within \code{10*tol}, and overwrites \(x\) with \(y\)
prior to returning (in case the calling routine would like to
investigate further).

\item {} 
\code{Test\_SUNLinSolSetATimes} (iterative solvers only): Verifies that
\code{SUNLinSolSetATimes} can be called and returns successfully.

\item {} 
\code{Test\_SUNLinSolSetPreconditioner} (iterative solvers only):
Verifies that \code{SUNLinSolSetPreconditioner} can be called and
returns successfully.

\item {} 
\code{Test\_SUNLinSolSetScalingVectors} (iterative solvers only):
Verifies that \code{SUNLinSolSetScalingVectors} can be called and
returns successfully.

\item {} 
\code{Test\_SUNLinSolLastFlag}: Verifies that \code{SUNLinSolLastFlag} can
be called, and outputs the result to \code{stdout}.

\item {} 
\code{Test\_SUNLinSolNumIters} (iterative solvers only): Verifies that
\code{SUNLinSolNumIters} can be called, and outputs the result to
\code{stdout}.

\item {} 
\code{Test\_SUNLinSolResNorm} (iterative solvers only): Verifies that
\code{SUNLinSolResNorm} can be called, and that the result is
non-negative.

\item {} 
\code{Test\_SUNLinSolResid} (iterative solvers only): Verifies that
\code{SUNLinSolResid} can be called.

\item {} 
\code{Test\_SUNLinSolSpace} verifies that \code{SUNLinSolSpace} can be
called, and outputs the results to \code{stdout}.

\end{itemize}

We'll note that these tests should be performed in a particular
order.  For either direct or iterative linear
solvers, \code{Test\_SUNLinSolInitialize} must be called
before \code{Test\_SUNLinSolSetup}, which must be called
before \code{Test\_SUNLinSolSolve}.  Additionally, for iterative linear
solvers \code{Test\_SUNLinSolSetATimes}, \code{Test\_SUNLinSolSetPreconditioner}
and \code{Test\_SUNLinSolSetScalingVectors} should be called
before \code{Test\_SUNLinSolInitialize};
similarly \code{Test\_SUNLinSolNumIters}, \code{Test\_SUNLinSolResNorm}
and \code{Test\_SUNLinSolResid} should be called
after \code{Test\_SUNLinSolSolve}.  These are called in the appropriate
order in all of the example problems.


\section{SUNLinearSolver functions required by ARKode}
\label{sunlinsol/ARKode_requirements:sunlinearsolver-functions-required-by-arkode}\label{sunlinsol/ARKode_requirements::doc}\label{sunlinsol/ARKode_requirements:sunlinsol-arkode}
In the table below, we list the linear solver functions in the
\code{SUNLinearSolver} module used within the ARKode package.
The table also shows, for each function, which of the code modules uses
the function.  In general, the main ARKode integrator considers
three categories of linear solvers, \emph{direct}, \emph{iterative}
and \emph{custom}, with interfaces accessible in the ARKode header
files \code{arkode/arkode\_direct.h} (ARKDLS), \code{arkode/arkode\_spils.h}
(ARKSPILS) and \code{arkode/arkode\_customls.h} (ARKCLS), respectively.
Hence, the the table columns reference the use of \code{SUNLinearSolver}
functions by each of these solver interfaces.

As with the \code{SUNMatrix} module, we emphasize that the ARKode user
does not need to know detailed usage of linear solver functions by the
ARKode code modules in order to use ARKode. The information is
presented as an implementation detail for the interested reader.
vector functions in the \code{N\_Vector}

\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Routine
} & \textsf{\relax 
ARKDLS
} & \textsf{\relax 
ARKSPILS
} & \textsf{\relax 
ARKCLS
}\\
\hline
SUNLinSolGetType
 & 
X
 & 
X
 & 
O
\\
\hline
SUNLinSolSetATimes
 &  & 
X
 & 
O
\\
\hline
SUNLinSolSetPreconditioner
 &  & 
X
 & 
O
\\
\hline
SUNLinSolSetScalingVectors
 &  & 
X
 & 
O
\\
\hline
SUNLinSolInitialize
 & 
X
 & 
X
 & 
X
\\
\hline
SUNLinSolSetup
 & 
X
 & 
X
 & 
X
\\
\hline
SUNLinSolSolve
 & 
X
 & 
X
 & 
X
\\
\hline
SUNLinSolNumIters
 &  & 
X
 & 
O
\\
\hline
SUNLinSolResNorm
 &  & 
X
 & 
O
\\
\hline
SUNLinSolResid
 &  &  & \\
\hline
SUNLinSolLastFlag
 &  &  & \\
\hline
SUNLinSolFree
 & 
X
 & 
X
 & 
X
\\
\hline
SUNLinSolSpace
 & 
O
 & 
O
 & 
O
\\
\hline\end{tabulary}


The linear solver functions listed above with a ``O'' are optionally
used, in that these are only called if they are implemented in the
\code{SUNLinearSolver} module that is being used  (i.e. their function
pointers are non-\code{NULL}).  Also, although ARKode does not call
{\hyperref[sunlinsol/SUNLinSol_Operations:c.SUNLinSolLastFlag]{\emph{\code{SUNLinSolLastFlag()}}}} directly, this routine is available for
users to query linear solver issues directly.


\chapter{ARKode Installation Procedure}
\label{Install:installation}\label{Install:arkode-installation-procedure}\label{Install::doc}
The installation of any SUNDIALS package is accomplished by installing
the SUNDIALS suite as a whole, according to the instructions that
follow.  The same procedure applies whether or not the downloaded
file contains one or all solvers in SUNDIALS.

The SUNDIALS suite (or individual solvers) are distributed as
compressed archives (\code{.tar.gz}).  The name of the distribution
archive is of the form \code{SOLVER-X.Y.Z.tar.gz}, where \code{SOLVER} is
one of: \code{sundials}, \code{cvode}, \code{cvodes}, \code{arkode}, \code{ida},
\code{idas}, or \code{kinsol}, and \code{X.Y.Z} represents the version number
(of the SUNDIALS suite or of the individual solver).
To begin the installation, first uncompress and expand the sources, by
issuing

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} tar \PYGZhy{}zxf SOLVER\PYGZhy{}X.Y.Z.tar.gz
\end{Verbatim}

This will extract source files under a directory \code{SOLVER-X.Y.Z}.

Starting with version 2.6.0 of SUNDIALS, CMake is the only supported
method of installation.  The explanations of the installation
procedure begins with a few common observations:
\begin{itemize}
\item {} 
The remainder of this chapter will follow these conventions:
\begin{description}
\item[{\code{SRCDIR}}] \leavevmode
is the directory \code{SOLVER-X.Y.Z} created above; i.e. the
directory containing the SUNDIALS sources.

\item[{\code{BUILDDIR}}] \leavevmode
is the (temporary) directory under which SUNDIALS is built.

\item[{\code{INSTDIR}}] \leavevmode
is the directory under which the SUNDIALS exported header files
and libraries will be installed. Typically, header files are
exported under a directory \code{INSTDIR/include} while libraries
are installed under \code{INSTDIR/lib}, with \code{INSTDIR}
specified at configuration time.

\end{description}

\item {} 
For SUNDIALS' CMake-based installation, in-source builds are prohibited;
in other words, the build directory \code{BUILDDIR} can \textbf{not} be the
same as \code{SRCDIR} and such an attempt will lead to an error.  This
prevents ``polluting'' the source tree and allows efficient builds for
different configurations and/or options.

\item {} 
The installation directory \code{INSTDIR} can not be the same as
the source directory \code{SRCDIR}.

\item {} 
By default, only the libraries and header files are exported to the
installation directory \code{INSTDIR}.  If enabled by the user (with the
appropriate toggle for CMake), the
examples distributed with SUNDIALS will be built together with
the solver libraries but the installation step will result in
exporting (by default in a subdirectory of the installation
directory) the example sources and sample outputs together with
automatically generated configuration files that reference the
\emph{installed} SUNDIALS headers and libraries.  As such, these
configuration files for the SUNDIALS examples can be used as
``templates'' for your own problems. CMake installs
\code{CMakeLists.txt} files and also (as an option available only under
Unix/Linux) \code{Makefile} files. Note this installation approach also
allows the option of building the SUNDIALS examples without having
to install them.  (This can be used as a sanity check for the
freshly built libraries.)

\item {} 
Even if generation of shared libraries is enabled, only static
libraries are created for the FCMIX modules.  Because of the use of
fixed names for the Fortran user-provided subroutines, FCMIX shared
libraries would result in ``undefined symbol'' errors at link time.

\end{itemize}

Further details on the CMake-based installation procedures,
instructions for manual compilation, and a roadmap of the resulting
installed libraries and exported header files, are provided in the
following subsections:
\begin{itemize}
\item {} 
{\hyperref[Install:installation-cmake]{\emph{\DUspan{}{CMake-based installation}}}}

\item {} 
{\hyperref[Install:installation-results]{\emph{\DUspan{}{Installed libraries and exported header files}}}}

\end{itemize}


\section{CMake-based installation}
\label{Install:installation-cmake}\label{Install:cmake-based-installation}
CMake-based installation provides a platform-independent build system. CMake can generate
Unix and Linux Makefiles, as well as KDevelop, Visual Studio, and
(Apple) XCode project files from the same configuration file.
In addition, CMake also provides a GUI front end and which allows an interactive build and
installation process.

The SUNDIALS build process requires CMake version 2.8.1 or
higher and a working C compiler.  On Unix-like operating systems, it
also requires Make (and \code{curses}, including its development libraries,
for the GUI front end to CMake, \code{ccmake} or \code{cmake-gui}), while on
Windows it requires Visual Studio.  While many Linux distributions offer CMake,
the version included may be out of date.  Many new CMake
features have been added recently, and you should download the latest
version from \href{http://www.cmake.org}{http://www.cmake.org}.  Build instructions for CMake
(only necessary for Unix-like systems) can be found on the CMake website.
Once CMake is installed, Linux/Unix users will be able to use
\code{ccmake} or \code{cmake-gui} (depending on the version of CMake),
while Windows users will be able to use \code{CMakeSetup}.

As previously noted, when using CMake to configure, build and install
SUNDIALS, it is always required to use a separate build
directory. While in-source builds are possible, they are explicitly
prohibited by the SUNDIALS CMake scripts (one of the reasons being
that, unlike autotools, CMake does not provide a \code{make distclean}
procedure and it is therefore difficult to clean-up the source tree
after an in-source build). By ensuring a separate build directory, it
is an easy task for the user to clean-up all traces of the build by
simply removing the build directory. CMake does generate a \code{make
clean} which will remove files generated by the compiler and linker.

\index{ccmake}

\subsection{Configuring, building, and installing on Unix-like systems}
\label{Install:installation-cmake-unix}\label{Install:index-0}\label{Install:configuring-building-and-installing-on-unix-like-systems}
The default CMake configuration will build all included solvers and
associated examples and will build static and shared libraries. The
INSTDIR defaults to \code{/usr/local} and can be changed by setting
the \code{CMAKE\_INSTALL\_PREFIX} variable. Support for FORTRAN and all
other options are disabled.

CMake can be used from the command line with the \code{cmake} command, or
from a \code{curses}-based GUI by using the \code{ccmake} command, or from
a wxWidgets or QT based GUI by using the \code{cmake-gui}
command. Examples for using both text and graphical methods will be
presented.  For the examples shown it is assumed that there is a top
level SUNDIALS directory with appropriate source, build and install
directories:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }mkdir \PYG{o}{(}...\PYG{o}{)}/INSTDIR
\PYG{n+nv}{\PYGZdl{} }mkdir \PYG{o}{(}...\PYG{o}{)}/BUILDDIR
\PYG{n+nv}{\PYGZdl{} }\PYG{n+nb}{cd} \PYG{o}{(}...\PYG{o}{)}/BUILDDIR
\end{Verbatim}

\index{cmake-gui}
\index{ccmake}

\subsubsection{Building with the GUI}
\label{Install:building-with-the-gui}\label{Install:index-2}
Using CMake with the \code{ccmake} GUI follows the general process:
\begin{itemize}
\item {} 
Select and modify values, run configure (\code{c} key)

\item {} 
New values are denoted with an asterisk

\item {} 
To set a variable, move the cursor to the variable and press enter
\begin{itemize}
\item {} 
If it is a boolean (ON/OFF) it will toggle the value

\item {} 
If it is string or file, it will allow editing of the string

\item {} 
For file and directories, the \code{\textless{}tab\textgreater{}} key can be used to complete

\end{itemize}

\item {} 
Repeat until all values are set as desired and the generate option
is available (\code{g} key)

\item {} 
Some variables (advanced variables) are not visible right away

\item {} 
To see advanced variables, toggle to advanced mode (\code{t} key)

\item {} 
To search for a variable press \code{/} key, and to repeat the search,
press the \code{n} key

\end{itemize}

Using CMake with the \code{cmake-gui} GUI follows a similar process:
\begin{itemize}
\item {} 
Select and modify values, click \code{Configure}

\item {} 
The first time you click \code{Configure}, make sure to pick the
appropriate generator (the following will ssume generation of Unix
Makfiles).

\item {} 
New values are highlighted in red

\item {} 
To set a variable, click on or move the cursor to the variable and press enter
\begin{itemize}
\item {} 
If it is a boolean (\code{ON/OFF}) it will check/uncheck the box

\item {} 
If it is string or file, it will allow editing of the string.
Additionally, an ellipsis button will appear \code{...} on the far
right of the entry.  Clicking this button will bring up the file
or directory selection dialog.

\item {} 
For files and directories, the \code{\textless{}tab\textgreater{}} key can be used to
complete

\end{itemize}

\item {} 
Repeat until all values are set as desired and click the
\code{Generate} button

\item {} 
Some variables (advanced variables) are not visible right away

\item {} 
To see advanced variables, click the \code{advanced} button

\end{itemize}

To build the default configuration using the curses GUI, from the
BUILDDIR enter the \code{ccmake} command and point to the SRCDIR:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }ccmake \PYG{o}{(}...\PYG{o}{)}/SRCDIR
\end{Verbatim}

Similarly, to build the default configuration using the wxWidgets GUI,
from the BUILDDIR enter the \code{cmake-gui} command and point to the
SRCDIR:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }cmake\PYGZhy{}gui \PYG{o}{(}...\PYG{o}{)}/SRCDIR
\end{Verbatim}

The default curses configuration screen is shown in
the following figure.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.750000}{\includegraphics{ccmakedefault.png}}
\caption{Default configuration screen. Note: Initial screen is empty.
To get this default configuration, press `c' repeatedly (accepting
default values denoted with asterisk) until the `g' option is
available.}\label{Install:ccmakedefault}\end{figure}

The default INSTDIR for both SUNDIALS and corresponding examples
can be changed by setting the \code{CMAKE\_INSTALL\_PREFIX} and
the \code{EXAMPLES\_INSTALL\_PATH} as shown in the following figure.
\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.750000}{\includegraphics{ccmakeprefix.png}}
\caption{Changing the INSTDIR for SUNDIALS and corresponding EXAMPLES.}\label{Install:ccmakeprefix}\end{figure}

Pressing the \code{g} key or clicking \code{generate} will generate
makefiles including all dependencies and all rules to build SUNDIALS
on this system.  Back at the command prompt, you can now run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }make
\end{Verbatim}

or for a faster parallel build (e.g. using 4 threads), you can run

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }make \PYGZhy{}j 4
\end{Verbatim}

To install SUNDIALS in the installation directory specified in the configuration, simply run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }make install
\end{Verbatim}

\index{cmake}

\subsubsection{Building from the command line}
\label{Install:building-from-the-command-line}\label{Install:index-3}
Using CMake from the command line is simply a matter of specifying
CMake variable settings with the \code{cmake} command.  The following
will build the default configuration:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }cmake \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{}  \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{}  ../srcdir
\PYG{n+nv}{\PYGZdl{} }make
\PYG{n+nv}{\PYGZdl{} }make install
\end{Verbatim}


\subsection{Configuration options (Unix/Linux)}
\label{Install:installation-cmake-options}\label{Install:configuration-options-unix-linux}
A complete list of all available options for a CMake-based SUNDIALS
configuration is provide below.  Note that the default values shown
are for a typical configuration on a Linux system and are provided as
illustration only.
\begin{description}
\item[{\index{BLAS\_ENABLE (CMake option)}BLAS\_ENABLE}] \leavevmode
Enable BLAS support

Default: \code{OFF}

\begin{notice}{note}{Note:}
Setting this option to ON will trigger additional CMake
options. See additional information on building with BLAS
enabled in {\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}}.
\end{notice}

\item[{\index{BLAS\_LIBRARIES (CMake option)}BLAS\_LIBRARIES}] \leavevmode
BLAS library

Default: \code{/usr/lib/libblas.so}

\begin{notice}{note}{Note:}
CMake will search for libraries in your
\code{LD\_LIBRARY\_PATH} prior to searching default system
paths.
\end{notice}

\item[{\index{BUILD\_ARKODE (CMake option)}BUILD\_ARKODE}] \leavevmode
Build the ARKODE library

Default: \code{ON}

\item[{\index{BUILD\_CVODE (CMake option)}BUILD\_CVODE}] \leavevmode
Build the CVODE library

Default: \code{ON}

\item[{\index{BUILD\_CVODES (CMake option)}BUILD\_CVODES}] \leavevmode
Build the CVODES library

Default: \code{ON}

\item[{\index{BUILD\_IDA (CMake option)}BUILD\_IDA}] \leavevmode
Build the IDA library

Default: \code{ON}

\item[{\index{BUILD\_IDAS (CMake option)}BUILD\_IDAS}] \leavevmode
Build the IDAS library

Default: \code{ON}

\item[{\index{BUILD\_KINSOL (CMake option)}BUILD\_KINSOL}] \leavevmode
Build the KINSOL library

Default: \code{ON}

\item[{\index{BUILD\_SHARED\_LIBS (CMake option)}BUILD\_SHARED\_LIBS}] \leavevmode
Build shared libraries

Default: \code{ON}

\item[{\index{BUILD\_STATIC\_LIBS (CMake option)}BUILD\_STATIC\_LIBS}] \leavevmode
Build static libraries

Default: \code{ON}

\item[{\index{CMAKE\_BUILD\_TYPE (CMake option)}CMAKE\_BUILD\_TYPE}] \leavevmode
Choose the type of build, options are:
\code{None} (\code{CMAKE\_C\_FLAGS} used), \code{Debug}, \code{Release},
\code{RelWithDebInfo}, and \code{MinSizeRel}

Default:

\begin{notice}{note}{Note:}
Specifying a build type will trigger the corresponding
build type specific compiler flag options below which
will be appended to the flags set by
\code{CMAKE\_\textless{}language\textgreater{}\_FLAGS}.
\end{notice}

\item[{\index{CMAKE\_C\_COMPILER (CMake option)}CMAKE\_C\_COMPILER}] \leavevmode
C compiler

Default: \code{/usr/bin/cc}

\item[{\index{CMAKE\_C\_FLAGS (CMake option)}CMAKE\_C\_FLAGS}] \leavevmode
Flags for C compiler

Default:

\item[{\index{CMAKE\_C\_FLAGS\_DEBUG (CMake option)}CMAKE\_C\_FLAGS\_DEBUG}] \leavevmode
Flags used by the C compiler during debug
builds

Default: \code{-g}

\item[{\index{CMAKE\_C\_FLAGS\_MINSIZEREL (CMake option)}CMAKE\_C\_FLAGS\_MINSIZEREL}] \leavevmode
Flags used by the C compiler during release minsize builds

Default: \code{-Os -DNDEBUG}

\item[{\index{CMAKE\_C\_FLAGS\_RELEASE (CMake option)}CMAKE\_C\_FLAGS\_RELEASE}] \leavevmode
Flags used by the C compiler during release
builds

Default: \code{-O3 -DNDEBUG}

\item[{\index{CMAKE\_CXX\_COMPILER (CMake option)}CMAKE\_CXX\_COMPILER}] \leavevmode
C++ compiler

Default: \code{/usr/bin/c++}

\begin{notice}{note}{Note:}
A C++ compiler (and all related options) are only are
triggered if C++ examples are enabled
(\code{EXAMPLES\_ENABLE\_CXX} is ON). All SUNDIALS solvers can
be used from C++ applications by default without setting
any additional configuration options.
\end{notice}

\item[{\index{CMAKE\_CXX\_FLAGS (CMake option)}CMAKE\_CXX\_FLAGS}] \leavevmode
Flags for C++ compiler

Default:

\item[{\index{CMAKE\_CXX\_FLAGS\_DEBUG (CMake option)}CMAKE\_CXX\_FLAGS\_DEBUG}] \leavevmode
Flags used by the C++ compiler during debug builds

Default: \code{-g}

\item[{\index{CMAKE\_CXX\_FLAGS\_MINSIZEREL (CMake option)}CMAKE\_CXX\_FLAGS\_MINSIZEREL}] \leavevmode
Flags used by the C++ compiler during release minsize builds

Default: \code{-Os -DNDEBUG}

\item[{\index{CMAKE\_CXX\_FLAGS\_RELEASE (CMake option)}CMAKE\_CXX\_FLAGS\_RELEASE}] \leavevmode
Flags used by the C++ compiler during release builds

Default: \code{-O3 -DNDEBUG}

\item[{\index{CMAKE\_Fortran\_COMPILER (CMake option)}CMAKE\_Fortran\_COMPILER}] \leavevmode
Fortran compiler

Default: \code{/usr/bin/gfortran}

\begin{notice}{note}{Note:}
Fortran support (and all related options) are triggered only if
either Fortran-C support is (\code{FCMIX\_ENABLE} is ON) or
BLAS/LAPACK support is enabled (\code{BLAS\_ENABLE} or
\code{LAPACK\_ENABLE} is \code{ON}).
\end{notice}

\item[{\index{CMAKE\_Fortran\_FLAGS (CMake option)}CMAKE\_Fortran\_FLAGS}] \leavevmode
Flags for Fortran compiler

Default:

\item[{\index{CMAKE\_Fortran\_FLAGS\_DEBUG (CMake option)}CMAKE\_Fortran\_FLAGS\_DEBUG}] \leavevmode
Flags used by the Fortran compiler during debug builds

Default: \code{-g}

\item[{\index{CMAKE\_Fortran\_FLAGS\_MINSIZEREL (CMake option)}CMAKE\_Fortran\_FLAGS\_MINSIZEREL}] \leavevmode
Flags used by the Fortran compiler during release minsize builds

Default: \code{-Os}

\item[{\index{CMAKE\_Fortran\_FLAGS\_RELEASE (CMake option)}CMAKE\_Fortran\_FLAGS\_RELEASE}] \leavevmode
Flags used by the Fortran compiler during release builds

Default: \code{-O3}

\item[{\index{CMAKE\_INSTALL\_PREFIX (CMake option)}CMAKE\_INSTALL\_PREFIX}] \leavevmode
Install path prefix, prepended onto install directories

Default: \code{/usr/local}

\begin{notice}{note}{Note:}
The user must have write access to the location specified
through this option. Exported SUNDIALS header files and libraries
will be installed under subdirectories \code{include} and \code{lib} of
\code{CMAKE\_INSTALL\_PREFIX}, respectively.
\end{notice}

\item[{\index{CXX\_ENABLE (CMake option)}CXX\_ENABLE}] \leavevmode
Flag to enable C++ ARKode examples (if examples are enabled)

Default: \code{OFF}

\item[{\index{CUDA\_ENABLE (CMake option)}CUDA\_ENABLE}] \leavevmode
Build the SUNDIALS CUDA vector module.

Default: \code{OFF}

\item[{\index{EXAMPLES\_ENABLE\_C (CMake option)}EXAMPLES\_ENABLE\_C}] \leavevmode
Build the SUNDIALS C examples

Default: \code{ON}

\item[{\index{EXAMPLES\_ENABLE\_CUDA (CMake option)}EXAMPLES\_ENABLE\_CUDA}] \leavevmode
Build the SUNDIALS CUDA examples

Default: \code{OFF}

\begin{notice}{note}{Note:}
You need to enable CUDA support to build these examples.
\end{notice}

\item[{\index{EXAMPLES\_ENABLE\_CXX (CMake option)}EXAMPLES\_ENABLE\_CXX}] \leavevmode
Build the SUNDIALS C++ examples

Default: \code{OFF}

\item[{\index{EXAMPLES\_ENABLE\_RAJA (CMake option)}EXAMPLES\_ENABLE\_RAJA}] \leavevmode
Build the SUNDIALS RAJA examples

Default: \code{OFF}

\begin{notice}{note}{Note:}
You need to enable CUDA and RAJA support to build these
examples.
\end{notice}

\item[{\index{EXAMPLES\_ENABLE\_F77 (CMake option)}EXAMPLES\_ENABLE\_F77}] \leavevmode
Build the SUNDIALS Fortran77 examples

Default: \code{ON} (if \code{FCMIX\_ENABLE} is \code{ON})

\item[{\index{EXAMPLES\_ENABLE\_F90 (CMake option)}EXAMPLES\_ENABLE\_F90}] \leavevmode
Build the SUNDIALS Fortran90 examples

Default: \code{OFF}

\item[{\index{EXAMPLES\_INSTALL (CMake option)}EXAMPLES\_INSTALL}] \leavevmode
Install example files

Default: \code{ON}

\begin{notice}{note}{Note:}
This option is triggered when any of the SUNDIALS
example programs are enabled
(\code{EXAMPLES\_ENABLE\_\textless{}language\textgreater{}} is \code{ON}). If the user
requires installation of example programs then the
sources and sample output files for all SUNDIALS modules
that are currently enabled will be exported to the
directory specified by \code{EXAMPLES\_INSTALL\_PATH}. A CMake
configuration script will also be automatically generated
and exported to the same directory. Additionally, if the
configuration is done under a Unix-like system, makefiles
for the compilation of the example programs (using the
installed SUNDIALS libraries) will be automatically
generated and exported to the directory specified by
\code{EXAMPLES\_INSTALL\_PATH}.
\end{notice}

\item[{\index{EXAMPLES\_INSTALL\_PATH (CMake option)}EXAMPLES\_INSTALL\_PATH}] \leavevmode
Output directory for installing example
files

Default: \code{/usr/local/examples}

\begin{notice}{note}{Note:}
The actual default value for this option will be an
\code{examples} subdirectory created under \code{CMAKE\_INSTALL\_PREFIX}.
\end{notice}

\item[{\index{FCMIX\_ENABLE (CMake option)}FCMIX\_ENABLE}] \leavevmode
Enable Fortran-C support

Default: \code{OFF}

\item[{\index{F90\_ENABLE (CMake option)}F90\_ENABLE}] \leavevmode
Flag to enable Fortran 90 ARKode examples (if examples are enabled)

Default: \code{OFF}

\item[{\index{HYPRE\_ENABLE (CMake option)}HYPRE\_ENABLE}] \leavevmode
Flag to enable \emph{hypre} support

Default: \code{OFF}

\begin{notice}{note}{Note:}
See additional information on building with \emph{hypre}
enabled in  {\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}}.
\end{notice}

\item[{\index{HYPRE\_INCLUDE\_DIR (CMake option)}HYPRE\_INCLUDE\_DIR}] \leavevmode
Path to \emph{hypre} header files

Default: none

\item[{\index{HYPRE\_LIBRARY (CMake option)}HYPRE\_LIBRARY}] \leavevmode
Path to \emph{hypre} installed library files

Default: none

\item[{\index{F90\_ENABLE (CMake option)}KLU\_ENABLE}] \leavevmode
Enable KLU support

Default: \code{OFF}

\begin{notice}{note}{Note:}
See additional information on building with KLU
enabled in {\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}}.
\end{notice}

\item[{\index{KLU\_INCLUDE\_DIR (CMake option)}KLU\_INCLUDE\_DIR}] \leavevmode
Path to SuiteSparse header files

Default: none

\item[{\index{KLU\_LIBRARY\_DIR (CMake option)}KLU\_LIBRARY\_DIR}] \leavevmode
Path to SuiteSparse installed library files

Default: none

\item[{\index{LAPACK\_ENABLE (CMake option)}LAPACK\_ENABLE}] \leavevmode
Enable LAPACK support

Default: \code{OFF}

\begin{notice}{note}{Note:}
Setting this option to \code{ON} will trigger additional CMake
options. See additional information on building with
LAPACK enabled in {\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}}.
\end{notice}

\item[{\index{LAPACK\_LIBRARIES (CMake option)}LAPACK\_LIBRARIES}] \leavevmode
LAPACK (and BLAS) libraries

Default: \code{/usr/lib/liblapack.so;/usr/lib/libblas.so}

\begin{notice}{note}{Note:}
CMake will search for libraries in your
\code{LD\_LIBRARY\_PATH} prior to searching default system
paths.
\end{notice}

\item[{\index{MPI\_ENABLE (CMake option)}MPI\_ENABLE}] \leavevmode
Enable MPI support (build the parallel nvector).

Default: \code{OFF}

\begin{notice}{note}{Note:}
Setting this option to \code{ON} will trigger several additional
options related to MPI.
\end{notice}

\item[{\index{MPI\_MPICC (CMake option)}MPI\_MPICC}] \leavevmode
\code{mpicc} program

Default:

\item[{\index{MPI\_MPICXX (CMake option)}MPI\_MPICXX}] \leavevmode
\code{mpicxx} program

Default:

\begin{notice}{note}{Note:}
This option is triggered only if MPI is enabled
(\code{MPI\_ENABLE} is \code{ON}) and C++ examples are enabled
(\code{EXAMPLES\_ENABLE\_CXX} is \code{ON}). All SUNDIALS
solvers can be used from C++ MPI applications by default
without setting any additional configuration options
other than \code{MPI\_ENABLE}.
\end{notice}

\item[{\index{MPI\_MPIF77 (CMake option)}MPI\_MPIF77}] \leavevmode
\code{mpif77} program

Default:

\begin{notice}{note}{Note:}
This option is triggered only if MPI is enabled
(\code{MPI\_ENABLE} is \code{ON}) and Fortran-C support is
enabled (\code{FCMIX\_ENABLE} is \code{ON}).
\end{notice}

\item[{\index{MPI\_MPIF90 (CMake option)}MPI\_MPIF90}] \leavevmode
\code{mpif90} program

Default:

\begin{notice}{note}{Note:}
This option is triggered only if MPI is enabled
(\code{MPI\_ENABLE} is \code{ON}), Fortran-C support is enabled
(\code{FCMIX\_ENABLE} is \code{ON}), and Fortran90 examples are enabled
(\code{EXAMPLES\_ENABLE\_F90} is \code{ON}).
\end{notice}

\item[{\index{MPI\_RUN\_COMMAND (CMake option)}MPI\_RUN\_COMMAND}] \leavevmode
Specify run command for MPI

Default: \code{mpirun}

\begin{notice}{note}{Note:}
This option is triggered only if MPI is enabled (\code{MPI\_ENABLE} is \code{ON}).
\end{notice}

\item[{\index{OPENMP\_ENABLE (CMake option)}OPENMP\_ENABLE}] \leavevmode
Enable OpenMP support (build the OpenMP NVector)

Default: \code{OFF}

\item[{\index{PETSC\_ENABLE (CMake option)}PETSC\_ENABLE}] \leavevmode
Enable PETSc support

Default: \code{OFF}

\begin{notice}{note}{Note:}
See additional information on building with
PETSc enabled in {\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}}.
\end{notice}

\item[{\index{PETSC\_INCLUDE\_DIR (CMake option)}PETSC\_INCLUDE\_DIR}] \leavevmode
Path to PETSc header files

Default: none

\item[{\index{PETSC\_LIBRARY\_DIR (CMake option)}PETSC\_LIBRARY\_DIR}] \leavevmode
Path to PETSc installed library files

Default: none

\item[{\index{PTHREAD\_ENABLE (CMake option)}PTHREAD\_ENABLE}] \leavevmode
Enable Pthreads support (build the Pthreads NVector)

Default: \code{OFF}

\item[{\index{RAJA\_ENABLE (CMake option)}RAJA\_ENABLE}] \leavevmode
Enable RAJA support (build the RAJA NVector).

Default: OFF

\begin{notice}{note}{Note:}
You need to enable CUDA in order to build the RAJA vector
module.
\end{notice}

\item[{\index{SUNDIALS\_INDEX\_TYPE (CMake option)}SUNDIALS\_INDEX\_TYPE}] \leavevmode
Integer type used for SUNDIALS indices, options are: \code{int32\_t} or \code{int64\_t}

Default: \code{int64\_t}

\item[{\index{SUNDIALS\_PRECISION (CMake option)}SUNDIALS\_PRECISION}] \leavevmode
Precision used in SUNDIALS, options are: \code{double}, \code{single} or
\code{extended}

Default: \code{double}

\item[{\index{SUPERLUMT\_ENABLE (CMake option)}SUPERLUMT\_ENABLE}] \leavevmode
Enable SuperLU\_MT support

Default: \code{OFF}

\begin{notice}{note}{Note:}
See additional information on building with
SuperLU\_MT enabled in {\hyperref[Install:installation-cmake-externallibraries]{\emph{\DUspan{}{Working with external Libraries}}}}.
\end{notice}

\item[{\index{SUPERLUMT\_INCLUDE\_DIR (CMake option)}SUPERLUMT\_INCLUDE\_DIR}] \leavevmode
Path to SuperLU\_MT header files (under a typical SuperLU\_MT
install, this is typically the SuperLU\_MT \code{SRC} directory)

Default: none

\item[{\index{SUPERLUMT\_LIBRARY\_DIR (CMake option)}SUPERLUMT\_LIBRARY\_DIR}] \leavevmode
Path to SuperLU\_MT installed library files

Default: none

\item[{\index{SUPERLUMT\_THREAD\_TYPE (CMake option)}SUPERLUMT\_THREAD\_TYPE}] \leavevmode
Must be set to Pthread or OpenMP, depending on how SuperLU\_MT was compiled.

Default: Pthread

\item[{\index{USE\_GENERIC\_MATH (CMake option)}USE\_GENERIC\_MATH}] \leavevmode
Use generic (\code{stdc}) math libraries

Default: \code{ON}

\end{description}


\subsubsection{xSDK Configuration Options}
\label{Install:installation-cmake-xsdk}\label{Install:xsdk-configuration-options}
SUNDIALS supports CMake configuration options defined by the
Extreme-scale Scientific Software Development Kit (xSDK) community
policies (see \href{https://xsdk.info}{https://xsdk.info} for more
information). xSDK CMake options are unused by default but may be
activated by setting \code{USE\_XSDK\_DEFAULTS} to \code{ON}.

\begin{notice}{note}{Note:}
When xSDK options are active, they will overwrite the
corresponding SUNDIALS option and may have different
default values (see details below). As such the equivalent
SUNDIALS options should not be used when configuring with
xSDK options. In the GUI front end to CMake (\code{ccmake} or
\code{cmake-gui}), setting \code{USE\_XSDK\_DEFAULTS} to ON will
hide the corresponding SUNDIALS options as advanced CMake
variables. During configuration, messages are output
detailing which xSDK flags are active and the equivalent
SUNDIALS options that are replaced. Below is a complete list
xSDK options and the corresponding SUNDIALS options if
applicable.
\end{notice}
\begin{description}
\item[{\index{TPL\_BLAS\_LIBRARIES (xSDK CMake option)}TPL\_BLAS\_LIBRARIES}] \leavevmode
BLAS library

Default: \code{/usr/lib/libblas.so}

SUNDIALS equivalent: \code{BLAS\_LIBRARIES}

\begin{notice}{note}{Note:}
CMake will search for libraries in your
\code{LD\_LIBRARY\_PATH} prior to searching default system
paths.
\end{notice}

\item[{\index{TPL\_ENABLE\_BLAS (xSDK CMake option)}TPL\_ENABLE\_BLAS}] \leavevmode
Enable BLAS support

Default: \code{OFF}

SUNDIALS equivalent: \code{BLAS\_ENABLE}

\item[{\index{TPL\_ENABLE\_HYPRE (xSDK CMake option)}TPL\_ENABLE\_HYPRE}] \leavevmode
Enable \emph{hypre} support

Default: \code{OFF}

SUNDIALS equivalent: \code{HYPRE\_ENABLE}

\item[{\index{TPL\_ENABLE\_KLU (xSDK CMake option)}TPL\_ENABLE\_KLU}] \leavevmode
Enable KLU support

Default: \code{OFF}

SUNDIALS equivalent: \code{KLU\_ENABLE}

\item[{\index{TPL\_ENABLE\_PETSC (xSDK CMake option)}TPL\_ENABLE\_PETSC}] \leavevmode
Enable PETSc support

Default: \code{OFF}

SUNDIALS equivalent: \code{PETSC\_ENABLE}

\item[{\index{TPL\_ENABLE\_LAPACK (xSDK CMake option)}TPL\_ENABLE\_LAPACK}] \leavevmode
Enable LAPACK support

Default: \code{OFF}

SUNDIALS equivalent: \code{LAPACK\_ENABLE}

\item[{\index{TPL\_ENABLE\_SUPERLUMT (xSDK CMake option)}TPL\_ENABLE\_SUPERLUMT}] \leavevmode
Enable SuperLU\_MT support

Default: \code{OFF}

SUNDIALS equivalent: \code{SUPERLUMT\_ENABLE}

\item[{\index{TPL\_HYPRE\_INCLUDE\_DIRS (xSDK CMake option)}TPL\_HYPRE\_INCLUDE\_DIRS}] \leavevmode
Path to \emph{hypre} header files

SUNDIALS equivalent: \code{HYPRE\_INCLUDE\_DIR}

\item[{\index{TPL\_HYPRE\_LIBRARIES (xSDK CMake option)}TPL\_HYPRE\_LIBRARIES}] \leavevmode
\emph{hypre} library

SUNDIALS equivalent: N/A

\item[{\index{TPL\_KLU\_INCLUDE\_DIRS (xSDK CMake option)}TPL\_KLU\_INCLUDE\_DIRS}] \leavevmode
Path to KLU header files

SUNDIALS equivalent: \code{KLU\_INCLUDE\_DIR}

\item[{\index{TPL\_KLU\_LIBRARIES (xSDK CMake option)}TPL\_KLU\_LIBRARIES}] \leavevmode
KLU library

SUNDIALS equivalent: N/A

\item[{\index{TPL\_LAPACK\_LIBRARIES (xSDK CMake option)}TPL\_LAPACK\_LIBRARIES}] \leavevmode
LAPACK (and BLAS) libraries

Default: \code{/usr/lib/liblapack.so;/usr/lib/libblas.so}

SUNDIALS equivalent: \code{LAPACK\_LIBRARIES}

\begin{notice}{note}{Note:}
CMake will search for libraries in your
\code{LD\_LIBRARY\_PATH} prior to searching default system paths.
\end{notice}

\item[{\index{TPL\_PETSC\_INCLUDE\_DIRS (xSDK CMake option)}TPL\_PETSC\_INCLUDE\_DIRS}] \leavevmode
Path to PETSc header files

SUNDIALS equivalent: \code{PETSC\_INCLUDE\_DIR}

\item[{\index{TPL\_PETSC\_LIBRARIES (xSDK CMake option)}TPL\_PETSC\_LIBRARIES}] \leavevmode
PETSc library

SUNDIALS equivalent: N/A

\item[{\index{TPL\_SUPERLUMT\_INCLUDE\_DIRS (xSDK CMake option)}TPL\_SUPERLUMT\_INCLUDE\_DIRS}] \leavevmode
Path to SuperLU\_MT header files

SUNDIALS equivalent: \code{SUPERLUMT\_INCLUDE\_DIR}

\item[{\index{TPL\_SUPERLUMT\_LIBRARIES (xSDK CMake option)}TPL\_SUPERLUMT\_LIBRARIES}] \leavevmode
SuperLU\_MT library

SUNDIALS equivalent: N/A

\item[{\index{TPL\_SUPERLUMT\_THREAD\_TYPE (xSDK CMake option)}TPL\_SUPERLUMT\_THREAD\_TYPE}] \leavevmode
SuperLU\_MT library thread type

SUNDIALS equivalent: \code{SUPERLUMT\_THREAD\_TYPE}

\item[{\index{USE\_XSDK\_DEFAULTS (xSDK CMake option)}USE\_XSDK\_DEFAULTS}] \leavevmode
Enable xSDK default configuration settings

Default: \code{OFF}

SUNDIALS equivalent: N/A

\begin{notice}{note}{Note:}
Enabling xSDK defaults also sets \code{CMAKE\_BUILD\_TYPE} to \code{Debug}
\end{notice}

\item[{\index{XSDK\_ENABLE\_FORTRAN (xSDK CMake option)}XSDK\_ENABLE\_FORTRAN}] \leavevmode
Enable SUNDIALS Fortran interface

Default: \code{OFF}

SUNDIALS equivalent: \code{FCMIX\_ENABLE}

\item[{\index{XSDK\_INDEX\_SIZE (xSDK CMake option)}XSDK\_INDEX\_SIZE}] \leavevmode
Integer size (bits) used for indices in SUNDIALS, options are: \code{32} or \code{64}

Default: \code{32}

SUNDIALS equivalent: \code{SUNDIALS\_INDEX\_TYPE}

\item[{\index{XSDK\_PRECISION (xSDK CMake option)}XSDK\_PRECISION}] \leavevmode
Precision used in SUNDIALS, options are: \code{double}, \code{single}, or \code{quad}

Default: \code{double}

SUNDIALS equivalent: \code{SUNDIALS\_PRECISION}

\end{description}


\subsection{Configuration examples}
\label{Install:configuration-examples}\label{Install:installation-cmake-examples}
The following examples will help demonstrate usage of the CMake
configure options.

To configure SUNDIALS using the default C and Fortran compilers,
and default \code{mpicc} and \code{mpif77} parallel compilers,
enable compilation of examples, and install libraries, headers, and
example sources under subdirectories of \code{/home/myname/sundials/}, use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} cmake \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DMPI\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DFCMIX\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} /home/myname/sundials/srcdir

\PYGZpc{} make install
\end{Verbatim}

To disable installation of the examples, use:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} cmake \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DMPI\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DFCMIX\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYG{o}{=}OFF \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} /home/myname/sundials/srcdir

\PYGZpc{} make install
\end{Verbatim}


\subsection{Working with external Libraries}
\label{Install:installation-cmake-externallibraries}\label{Install:working-with-external-libraries}
The SUNDIALS suite contains many options to enable implementation
flexibility when developing solutions. The following are some notes
addressing specific configurations when using the supported third
party libraries.


\subsubsection{Building with BLAS}
\label{Install:building-with-blas}\label{Install:installation-cmake-externallibraries-blas}
SUNDIALS does not utilize BLAS directly but it may be needed by other
external libraries that SUNDIALS can be build with (e.g. LAPACK,
PETSc, SuperLU\_MT, etc.). To enable BLAS, set the \code{BLAS\_ENABLE}
option to \code{ON}. If the directory containing the BLAS library is in
the \code{LD\_LIBRARY\_PATH} environment variable, CMake will set the
\code{BLAS\_LIBRARIES} variable accordingly, otherwise CMake will
attempt to find the BLAS library in standard system locations. To
explicitly tell CMake what libraries to use, the \code{BLAS\_LIBRARIES}
variable can be set to the desired library. Example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} cmake \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DBLAS\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DBLAS\PYGZus{}LIBRARIES\PYG{o}{=}/myblaspath/lib/libblas.so \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DSUPERLUMT\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DSUPERLUMT\PYGZus{}INCLUDE\PYGZus{}DIR\PYG{o}{=}/mysuperlumtpath/SRC
\PYGZgt{} \PYGZhy{}DSUPERLUMT\PYGZus{}LIBRARY\PYGZus{}DIR\PYG{o}{=}/mysuperlumtpath/lib
\PYGZgt{} /home/myname/sundials/srcdir

\PYGZpc{} make install
\end{Verbatim}

\begin{notice}{note}{Note:}
If enabling LAPACK and allowing CMake to automatically
locate the LAPACK library, it is not necessary to also
enable BLAS as CMake will find the corresponding BLAS
library and include it when searching for LAPACK.
\end{notice}


\subsubsection{Building with LAPACK}
\label{Install:building-with-lapack}\label{Install:installation-cmake-externallibraries-lapack}
To enable LAPACK, set the \code{LAPACK\_ENABLE} option to \code{ON}.
If the directory containing the LAPACK library is in the
\code{LD\_LIBRARY\_PATH} environment variable, CMake will set the
\code{LAPACK\_LIBRARIES} variable accordingly, otherwise CMake will
attempt to find the LAPACK library in standard system locations. To
explicitly tell CMake what library to use, the \code{LAPACK\_LIBRARIES}
variable can be set to the desired libraries.

\begin{notice}{note}{Note:}
When setting the LAPACK location explicitly the location of
the corresponding BLAS library will also need to be
set. Example:
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} cmake \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DCMAKE\PYGZus{}INSTALL\PYGZus{}PREFIX\PYG{o}{=}/home/myname/sundials/instdir \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DEXAMPLES\PYGZus{}INSTALL\PYGZus{}PATH\PYG{o}{=}/home/myname/sundials/instdir/examples \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DBLAS\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DBLAS\PYGZus{}LIBRARIES\PYG{o}{=}/mylapackpath/lib/libblas.so \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DLAPACK\PYGZus{}ENABLE\PYG{o}{=}ON \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} \PYGZhy{}DLAPACK\PYGZus{}LIBRARIES\PYG{o}{=}/mylapackpath/lib/liblapack.so \PYG{l+s+se}{\PYGZbs{}}
\PYGZgt{} /home/myname/sundials/srcdir

\PYGZpc{} make install
\end{Verbatim}

\begin{notice}{note}{Note:}
If enabling LAPACK and allowing CMake to automatically
locate the LAPACK library, it is not necessary to also
enable BLAS as CMake will find the corresponding BLAS
library and include it when searching for LAPACK.
\end{notice}


\subsubsection{Building with KLU}
\label{Install:installation-cmake-externallibraries-klu}\label{Install:building-with-klu}
The KLU libraries are part of SuiteSparse, a suite of sparse matrix
software, available from the Texas A\&M University website:
\href{http://faculty.cse.tamu.edu/davis/suitesparse.html}{http://faculty.cse.tamu.edu/davis/suitesparse.html} .

SUNDIALS has been tested with SuiteSparse version 4.5.3.  To enable
KLU, set \code{KLU\_ENABLE} to \code{ON}, set \code{KLU\_INCLUDE\_DIR} to the
\code{include} path of the KLU installation and set \code{KLU\_LIBRARY\_DIR}
to the \code{lib} path of the KLU installation.  The CMake configure will
result in populating the following variables: \code{AMD\_LIBRARY},
\code{AMD\_LIBRARY\_DIR},  \code{BTF\_LIBRARY}, \code{BTF\_LIBRARY\_DIR},
\code{COLAMD\_LIBRARY}, \code{COLAMD\_LIBRARY\_DIR}, and \code{KLU\_LIBRARY}.


\subsubsection{Building with SuperLU\_MT}
\label{Install:building-with-superlu-mt}\label{Install:installation-cmake-externallibraries-superlu-mt}
The SuperLU\_MT libraries are available for download from the Lawrence
Berkeley National Laboratory website:
\href{http://crd-legacy.lbl.gov/\$sim\$xiaoye/SuperLU/}{http://crd-legacy.lbl.gov/\$sim\$xiaoye/SuperLU/}\#superlu\_mt .

SUNDIALS has been tested with SuperLU\_MT version 3.1.  To enable
SuperLU\_MT, set  \code{SUPERLUMT\_ENABLE} to \code{ON}, set
\code{SUPERLUMT\_INCLUDE\_DIR} to the \code{SRC} path of the SuperLU\_MT
installation, and set the variable \code{SUPERLUMT\_LIBRARY\_DIR} to the
\code{lib} path of the SuperLU\_MT installation.  At the same time, the
variable \code{SUPERLUMT\_THREAD\_TYPE} must be set to either \code{Pthread}
or \code{OpenMP}.

Do not mix thread types when building SUNDIALS solvers.
If threading is enabled for SUNDIALS by having either
\code{OPENMP\_ENABLE} or \code{PTHREAD\_ENABLE} set to \code{ON} then SuperLU\_MT
should be set to use the same threading type.


\subsubsection{Building with PETSc}
\label{Install:building-with-petsc}\label{Install:installation-cmake-externallibraries-petsc}
The PETSc libraries are available for download from the Argonne
National Laboratory website:
\href{http://www.mcs.anl.gov/petsc}{http://www.mcs.anl.gov/petsc} .

SUNDIALS has been tested with PETSc version 3.7.2.  To enable PETSc,
set \code{PETSC\_ENABLE} to \code{ON}, set \code{PETSC\_INCLUDE\_DIR} to the
\code{include} path of the PETSc installation, and set the variable
\code{PETSC\_LIBRARY\_DIR} to the \code{lib} path of the PETSc installation.


\subsubsection{Building with \emph{hypre}}
\label{Install:building-with-hypre}\label{Install:installation-cmake-externallibraries-hypre}
The \emph{hypre} libraries are available for download from the Lawrence
Livermore National Laboratory website:
\href{http://computation.llnl.gov/projects/hypre}{http://computation.llnl.gov/projects/hypre}.
SUNDIALS has been tested with \emph{hypre} version 2.11.1.
To enable \emph{hypre}, set  \code{HYPRE\_ENABLE} to \code{ON}, set \code{HYPRE\_INCLUDE\_DIR}
to the \code{include} path of the \emph{hypre} installation, and set the variable
\code{HYPRE\_LIBRARY\_DIR} to the \code{lib} path of the \emph{hypre} installation.


\subsubsection{Building with CUDA}
\label{Install:installation-cmake-externallibraries-cuda}\label{Install:building-with-cuda}
SUNDIALS CUDA modules and examples are tested with version 8.0 of the
CUDA toolkit. To build them, you need to install the Toolkit and compatible
NVIDIA drivers. Both are available for download from NVIDIA website:
\href{https://developer.nvidia.com/cuda-downloads}{https://developer.nvidia.com/cuda-downloads}. To enable CUDA,
set \code{CUDA\_ENABLE} to \code{ON}. If you installed CUDA in a nonstandard
location, you may be prompted to set the variable
\code{CUDA\_TOOLKIT\_ROOT\_DIR} with your CUDA Toolkit installation
path. To enable CUDA examples, set \code{EXAMPLES\_ENABLE\_CUDA} to \code{ON}.


\subsubsection{Building with RAJA}
\label{Install:building-with-raja}\label{Install:installation-cmake-externallibraries-raja}
To build SUNDIALS RAJA modules you need to enable SUNDIALS CUDA
support, first. You also need a CUDA-enabled RAJA installation on your
system. RAJA is free software, developed by Lawrence Livermore
National Laboratory, and can be obtained from
\href{https://github.com/LLNL/RAJA}{https://github.com/LLNL/RAJA}.
Next you need to set \code{RAJA\_ENABLE} to \code{ON}, to enable building the
RAJA vector module, and  \code{EXAMPLES\_ENABLE\_RAJA} to \code{ON} to build
the RAJA examples. If you installed RAJA to a nonstandard location you will be
prompted to set the variable \code{RAJA\_DIR} with the path to the RAJA
CMake configuration file. SUNDIALS was tested with RAJA version 0.3.


\subsection{Testing the build and installation}
\label{Install:testing-the-build-and-installation}\label{Install:installation-cmake-testing}
If SUNDIALS was configured with \code{EXAMPLES\_ENABLE\_\textless{}language\textgreater{}} options
to \code{ON}, then a set of regression tests can be run after building
with the \code{make} command by running:
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} make \PYG{n+nb}{test}
\end{Verbatim}
Additionally, if \code{EXAMPLES\_INSTALL} was also set to \code{ON}, then a
set of smoke tests can be run after installing with the \code{make install}
command by running:
\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} make test\PYGZus{}install
\end{Verbatim}


\subsection{Building and Running Examples}
\label{Install:building-and-running-examples}\label{Install:installation-cmake-buildrunexamples}
Each of the SUNDIALS solvers is distributed with a set of examples
demonstrating basic usage. To build and install the examples, set at
least of the \code{EXAMPLES\_ENABLE\_\textless{}language\textgreater{}} options to \code{ON}, and
set \code{EXAMPLES\_INSTALL} to \code{ON}. Specify
the installation path for the examples with the variable
\code{EXAMPLES\_INSTALL\_PATH}. CMake will generate \code{CMakeLists.txt}
configuration files (and \code{Makefile} files if on Linux/Unix) that
reference the \emph{installed} SUNDIALS headers and libraries.

Either the \code{CMakeLists.txt} file or the traditional \code{Makefile} may
be used to build the examples as well as serve as a template for
creating user developed solutions.  To use the supplied \code{Makefile}
simply run \code{make} to compile and generate the executables.  To use
CMake from within the installed example directory, run \code{cmake} (or
\code{ccmake} or \code{cmake-gui} to use the GUI) followed by \code{make} to
compile the example code.  Note that if CMake is used, it will
overwrite the traditional \code{Makefile} with a new CMake-generated
\code{Makefile}.

The resulting output from running the examples can be compared with
example output bundled in the SUNDIALS distribution.

NOTE: There will potentially be differences in the output due to
machine architecture, compiler versions, use of third party libraries etc.


\subsection{Configuring, building, and installing on Windows}
\label{Install:installation-cmake-windows}\label{Install:configuring-building-and-installing-on-windows}
CMake can also be used to build SUNDIALS on Windows. To build SUNDIALS
for use with Visual Studio the following steps should be performed:
\begin{enumerate}
\item {} 
Unzip the downloaded tar file(s) into a directory. This will be the
\code{SRCDIR}

\item {} 
Create a separate \code{BUILDDIR}

\item {} 
Open a Visual Studio Command Prompt and cd to \code{BUILDDIR}

\item {} 
Run \code{cmake-gui ../SRCDIR}
\begin{enumerate}
\item {} 
Hit Configure

\item {} 
Check/Uncheck solvers to be built

\item {} 
Change \code{CMAKE\_INSTALL\_PREFIX} to \code{INSTDIR}

\item {} 
Set other options as desired

\item {} 
Hit Generate

\end{enumerate}

\item {} 
Back in the VS Command Window:
\begin{enumerate}
\item {} 
Run \code{msbuild ALL\_BUILD.vcxproj}

\item {} 
Run \code{msbuild INSTALL.vcxproj}

\end{enumerate}

\end{enumerate}

The resulting libraries will be in the \code{INSTDIR}.

The SUNDIALS project can also now be opened in Visual Studio.
Double click on the \code{ALL\_BUILD.vcxproj} file to open the project.
Build the whole \emph{solution} to create the SUNDIALS libraries.
To use the SUNDIALS libraries in your own projects, you must
set the include directories for your project,
add the SUNDIALS libraries to your project solution,
and set the SUNDIALS libraries as dependencies for your project.


\section{Installed libraries and exported header files}
\label{Install:installation-results}\label{Install:installed-libraries-and-exported-header-files}
Using the CMake SUNDIALS build system, the command

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv}{\PYGZdl{} }make install
\end{Verbatim}

will install the libraries under \code{LIBDIR} and the public header
files under \code{INCLUDEDIR}. The values for these directories
are \code{INSTDIR/lib} and \code{INSTDIR/include}, respectively.  The
location can be changed by setting the CMake variable
\code{CMAKE\_INSTALL\_PREFIX}.  Although all installed libraries reside
under \code{LIBDIR/lib}, the public header files are further organized
into subdirectories under \code{INCLUDEDIR/include}.

The installed libraries and exported header files are listed for
reference in the {\hyperref[Install:installation-table]{\emph{\DUspan{}{Table: SUNDIALS libraries and header files}}}}. The file extension \code{.LIB} is typically \code{.so}
for shared libraries and \code{.a} for static libraries. Note that, in
this table names are relative to \code{LIBDIR} for libraries and to
\code{INCLUDEDIR} for header files.

A typical user program need not explicitly include any of the shared
SUNDIALS header files from under the \code{INCLUDEDIR/include/sundials}
directory since they are explicitly included by the appropriate solver
header files (e.g., \code{cvode\_dense.h} includes
\code{sundials\_dense.h}). However, it is both legal and safe to do so,
and would be useful, for example, if the functions declared in
\code{sundials\_dense.h} are to be used in building a preconditioner.


\subsection{Table: SUNDIALS libraries and header files}
\label{Install:installation-table}\label{Install:table-sundials-libraries-and-header-files}
\begin{longtable}{|l|l|l|}
\hline
\endfirsthead

\multicolumn{3}{c}%
{{\textsf{\tablename\ \thetable{} -- continued from previous page}}} \\
\hline
\endhead

\hline \multicolumn{3}{|r|}{{\textsf{Continued on next page}}} \\ \hline
\endfoot

\endlastfoot


Shared
 & 
Header files
 & 
\code{sundials/sundials\_band.h},
\code{sundials/sundials\_config.h},
\code{sundials/sundials\_dense.h},
\code{sundials/sundials\_direct.h},
\code{sundials/sundials\_fconfig.h},
\code{sundials/sundials\_fnvector.h},
\code{sundials/sundials\_iterative.h},
\code{sundials/sundials\_linearsolver.h},
\code{sundials/sundials\_matrix.h},
\code{sundials/sundials\_math.h},
\code{sundials/sundials\_nvector.h},
\code{sundials/sundials\_types.h},
\code{sundials/sundials\_version.h}
\\
\hline
NVECTOR\_SERIAL
 & 
Libraries
 & 
\code{libsundials\_nvecserial.LIB},
\code{libsundials\_fnvecserial.a}
\\
\hline
NVECTOR\_SERIAL
 & 
Header files
 & 
\code{nvector/nvector\_serial.h}
\\
\hline
NVECTOR\_PARALLEL
 & 
Libraries
 & 
\code{libsundials\_nvecparallel.LIB},
\code{libsundials\_fnvecparallel.a}
\\
\hline
NVECTOR\_PARALLEL
 & 
Header files
 & 
\code{nvector/nvector\_parallel.h}
\\
\hline
NVECTOR\_OPENMP
 & 
Libraries
 & 
\code{libsundials\_nvecopenmp.LIB},
\code{libsundials\_fnvecopenmp.a}
\\
\hline
NVECTOR\_OPENMP
 & 
Header files
 & 
\code{nvector/nvector\_openmp.h}
\\
\hline
NVECTOR\_PTHREADS
 & 
Libraries
 & 
\code{libsundials\_nvecpthreads.LIB},
\code{libsundials\_fnvecpthreads.a}
\\
\hline
NVECTOR\_PTHREADS
 & 
Header files
 & 
\code{nvector/nvector\_pthreads.h}
\\
\hline
SUNMATRIX\_BAND
 & 
Libraries
 & 
\code{libsundials\_sunmatrixband.LIB},
\code{libsundials\_fsunmatrixband.a}
\\
\hline
SUNMATRIX\_BAND
 & 
Header files
 & 
\code{sunmatrix/sunmatrix\_band.h}
\\
\hline
SUNMATRIX\_DENSE
 & 
Libraries
 & 
\code{libsundials\_sunmatrixdense.LIB},
\code{libsundials\_fsunmatrixdense.a}
\\
\hline
SUNMATRIX\_DENSE
 & 
Header files
 & 
\code{sunmatrix/sunmatrix\_dense.h}
\\
\hline
SUNMATRIX\_SPARSE
 & 
Libraries
 & 
\code{libsundials\_sunmatrixsparse.LIB},
\code{libsundials\_fsunmatrixsparse.a}
\\
\hline
SUNMATRIX\_SPARSE
 & 
Header files
 & 
\code{sunmatrix/sunmatrix\_sparse.h}
\\
\hline
SUNLINSOL\_BAND
 & 
Libraries
 & 
\code{libsundials\_sunlinsolband.LIB},
\code{libsundials\_fsunlinsolband.a}
\\
\hline
SUNLINSOL\_BAND
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_band.h}
\\
\hline
SUNLINSOL\_DENSE
 & 
Libraries
 & 
\code{libsundials\_sunlinsoldense.LIB},
\code{libsundials\_fsunlinsoldense.a}
\\
\hline
SUNLINSOL\_DENSE
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_dense.h}
\\
\hline
SUNLINSOL\_KLU
 & 
Libraries
 & 
\code{libsundials\_sunlinsolklu.LIB},
\code{libsundials\_fsunlinsolklu.a}
\\
\hline
SUNLINSOL\_KLU
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_klu.h}
\\
\hline
SUNLINSOL\_LAPACKBAND
 & 
Libraries
 & 
\code{libsundials\_sunlinsollapackband.LIB},
\code{libsundials\_fsunlinsollapackband.a}
\\
\hline
SUNLINSOL\_LAPACKBAND
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_lapackband.h}
\\
\hline
SUNLINSOL\_LAPACKDENSE
 & 
Libraries
 & 
\code{libsundials\_sunlinsollapackdense.LIB},
\code{libsundials\_fsunlinsollapackdense.a}
\\
\hline
SUNLINSOL\_LAPACKDENSE
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_lapackdense.h}
\\
\hline
SUNLINSOL\_PCG
 & 
Libraries
 & 
\code{libsundials\_sunlinsolpcg.LIB},
\code{libsundials\_fsunlinsolpcg.a}
\\
\hline
SUNLINSOL\_PCG
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_pcg.h}
\\
\hline
SUNLINSOL\_SPBCGS
 & 
Libraries
 & 
\code{libsundials\_sunlinsolspbcgs.LIB},
\code{libsundials\_fsunlinsolspbcgs.a}
\\
\hline
SUNLINSOL\_SPBCGS
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_spbcgs.h}
\\
\hline
SUNLINSOL\_SPFGMR
 & 
Libraries
 & 
\code{libsundials\_sunlinsolspfgmr.LIB},
\code{libsundials\_fsunlinsolspfgmr.a}
\\
\hline
SUNLINSOL\_SPFGMR
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_spfgmr.h}
\\
\hline
SUNLINSOL\_SPGMR
 & 
Libraries
 & 
\code{libsundials\_sunlinsolspgmr.LIB},
\code{libsundials\_fsunlinsolspgmr.a}
\\
\hline
SUNLINSOL\_SPGMR
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_spgmr.h}
\\
\hline
SUNLINSOL\_SPTFQMR
 & 
Libraries
 & 
\code{libsundials\_sunlinsolsptfqmr.LIB},
\code{libsundials\_fsunlinsolsptfqmr.a}
\\
\hline
SUNLINSOL\_SPTFQMR
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_sptfqmr.h}
\\
\hline
SUNLINSOL\_SUPERLUMT
 & 
Libraries
 & 
\code{libsundials\_sunlinsolsuperlumt.LIB},
\code{libsundials\_fsunlinsolsuperlumt.a}
\\
\hline
SUNLINSOL\_SUPERLUMT
 & 
Header files
 & 
\code{sunlinsol/sunlinsol\_superlumt.h}
\\
\hline
CVODE
 & 
Libraries
 & 
\code{libsundials\_cvode.LIB},
\code{libsundials\_fcvode.a}
\\
\hline
CVODE
 & 
Header files
 & 
\code{cvode/cvode.h},
\code{cvode/cvode\_bandpre.h},
\code{cvode/cvode\_bbdpre.h},
\code{cvode/cvode\_diag.h},
\code{cvode/cvode\_direct.h},
\code{cvode/cvode\_impl.h},
\code{cvode/cvode\_spils.h},
\\
\hline
CVODES
 & 
Libraries
 & 
\code{libsundials\_cvodes.LIB}
\\
\hline
CVODES
 & 
Header files
 & 
\code{cvodes/cvodes.h},
\code{cvodes/cvodes\_bandpre.h},
\code{cvodes/cvodes\_bbdpre.h},
\code{cvodes/cvodes\_diag.h},
\code{cvodes/cvodes\_direct.h},
\code{cvodes/cvodes\_impl.h},
\code{cvodes/cvodes\_spils.h},
\\
\hline
ARKODE
 & 
Libraries
 & 
\code{libsundials\_arkode.LIB},
\code{libsundials\_farkode.a}
\\
\hline
ARKODE
 & 
Header files
 & 
\code{arkode/arkode.h},
\code{arkode/arkode\_bandpre.h},
\code{arkode/arkode\_bbdpre.h},
\code{arkode/arkode\_direct.h},
\code{arkode/arkode\_impl.h},
\code{arkode/arkode\_spils.h},
\\
\hline
IDA
 & 
Libraries
 & 
\code{libsundials\_ida.LIB},
\code{libsundials\_fida.a}
\\
\hline
IDA
 & 
Header files
 & 
\code{ida/ida.h},
\code{ida/ida\_bbdpre.h},
\code{ida/ida\_direct.h},
\code{ida/ida\_impl.h},
\code{ida/ida\_spils.h},
\\
\hline
IDAS
 & 
Libraries
 & 
\code{libsundials\_idas.LIB}
\\
\hline
IDAS
 & 
Header files
 & 
\code{idas/idas.h},
\code{idas/idas\_bbdpre.h}
\code{idas/idas\_direct.h},
\code{idas/idas\_impl.h},
\code{idas/idas\_spils.h},
\\
\hline
KINSOL
 & 
Libraries
 & 
\code{libsundials\_kinsol.LIB},
\code{libsundials\_fkinsol.a}
\\
\hline
KINSOL
 & 
Header files
 & 
\code{kinsol/kinsol.h},
\code{kinsol/kinsol\_bbdpre.h},
\code{kinsol/kinsol\_direct.h},
\code{kinsol/kinsol\_impl.h},
\code{kinsol/kinsol\_spils.h},
\\
\hline\end{longtable}



\chapter{Appendix: ARKode Constants}
\label{Constants:appendix-arkode-constants}\label{Constants::doc}\label{Constants:constants}
Below we list all input and output constants used by the main solver
and linear solver modules, together with their numerical values and a
short description of their meaning.


\section{ARKode input constants}
\label{Constants:arkode-input-constants}

\subsection{ARKode main solver module}
\label{Constants:arkode-main-solver-module}\begin{description}
\item[{\index{ARK\_NORMAL}ARK\_NORMAL (1):}] \leavevmode
Solver returns at a specified output time.

\item[{\index{ARK\_ONE\_STEP}ARK\_ONE\_STEP  (2):}] \leavevmode
Solver returns after each successful step.

\end{description}


\subsection{Explicit Butcher table specification}
\label{Constants:explicit-butcher-table-specification}\begin{description}
\item[{\index{Heun-Euler-2-1-2 ERK method}HEUN\_EULER\_2\_1\_2  (0):}] \leavevmode
Use the Heun-Euler-2-1-2 ERK method

\item[{\index{Bogacki-Shampine-4-2-3 ERK method}BOGACKI\_SHAMPINE\_4\_2\_3  (1):}] \leavevmode
Use the Bogacki-Shampine-4-2-3 ERK method

\item[{\index{ARK-4-2-3 ERK method}ARK324L2SA\_ERK\_4\_2\_3  (2):}] \leavevmode
Use the ARK-4-2-3 ERK method

\item[{\index{Zonneveld-5-3-4 ERK method}ZONNEVELD\_5\_3\_4  (3):}] \leavevmode
Use the Zonneveld-5-3-4 ERK method

\item[{\index{ARK-6-3-4 ERK method}ARK436L2SA\_ERK\_6\_3\_4  (4):}] \leavevmode
Use the ARK-6-3-4 ERK method

\item[{\index{Sayfy-Aburub-6-3-4 ERK method}SAYFY\_ABURUB\_6\_3\_4  (5):}] \leavevmode
Use the Sayfy-Aburub-6-3-4 ERK method

\item[{\index{Cash-Karp-6-4-5 ERK method}CASH\_KARP\_6\_4\_5  (6):}] \leavevmode
Use the Cash-Karp-6-4-5 ERK method

\item[{\index{Fehlberg-6-4-5 ERK method}FEHLBERG\_6\_4\_5  (7):}] \leavevmode
Use the Fehlberg-6-4-5 ERK method

\item[{\index{Dormand-Prince-7-4-5 ERK method}DORMAND\_PRINCE\_7\_4\_5  (8):}] \leavevmode
Use the Dormand-Prince-7-4-5 ERK method

\item[{\index{ARK-8-4-5 ERK method}ARK548L2SA\_ERK\_8\_4\_5  (9):}] \leavevmode
Use the ARK-8-4-5 ERK method

\item[{\index{Verner-8-5-6 ERK method}VERNER\_8\_5\_6  (10):}] \leavevmode
Use the Verner-8-5-6 ERK method

\item[{\index{Fehlberg-13-7-8 ERK method}FEHLBERG\_13\_7\_8  (11):}] \leavevmode
Use the Fehlberg-13-7-8 ERK method

\item[{\index{DEFAULT\_ERK\_2}DEFAULT\_ERK\_2  (HEUN\_EULER\_2\_1\_2):}] \leavevmode
Use the default second-order ERK method

\item[{\index{DEFAULT\_ERK\_3}DEFAULT\_ERK\_3  (BOGACKI\_SHAMPINE\_4\_2\_3):}] \leavevmode
Use the default third-order ERK method

\item[{\index{DEFAULT\_ERK\_4}DEFAULT\_ERK\_4  (ZONNEVELD\_5\_3\_4):}] \leavevmode
Use the default fourth-order ERK method

\item[{\index{DEFAULT\_ERK\_5}DEFAULT\_ERK\_5  (CASH\_KARP\_6\_4\_5):}] \leavevmode
Use the default fifth-order ERK method

\item[{\index{DEFAULT\_ERK\_6}DEFAULT\_ERK\_6  (VERNER\_8\_5\_6):}] \leavevmode
Use the default sixth-order ERK method

\item[{\index{DEFAULT\_ERK\_8}DEFAULT\_ERK\_8  (FEHLBERG\_13\_7\_8):}] \leavevmode
Use the default eighth-order ERK method

\end{description}


\subsection{Implicit Butcher table specification}
\label{Constants:implicit-butcher-table-specification}\begin{description}
\item[{\index{SDIRK-2-1-2 method}SDIRK\_2\_1\_2  (12):}] \leavevmode
Use the SDIRK-2-1-2 SDIRK method

\item[{\index{Billington-3-3-2 SDIRK method}BILLINGTON\_3\_3\_2  (13):}] \leavevmode
Use the Billington-3-3-2 SDIRK method

\item[{\index{TRBDF2-3-3-2 ESDIRK method}TRBDF2\_3\_3\_2  (14):}] \leavevmode
Use the TRBDF2-3-3-2 ESDIRK method

\item[{\index{Kvaerno-4-2-3 ESDIRK method}KVAERNO\_4\_2\_3  (15):}] \leavevmode
Use the Kvaerno-4-2-3 ESDIRK method

\item[{\index{ARK-4-2-3 ESDIRK method}ARK324L2SA\_DIRK\_4\_2\_3  (16):}] \leavevmode
Use the ARK-4-2-3 ESDIRK method

\item[{\index{Cash-5-2-4 SDIRK method}CASH\_5\_2\_4  (17):}] \leavevmode
Use the Cash-5-2-4 SDIRK method

\item[{\index{Cash-5-3-4 SDIRK method}CASH\_5\_3\_4  (18):}] \leavevmode
Use the Cash-5-3-4 SDIRK method

\item[{\index{SDIRK-5-3-4 method}SDIRK\_5\_3\_4  (19):}] \leavevmode
Use the SDIRK-5-3-4 SDIRK method

\item[{\index{Kvaerno-5-3-4 ESDIRK method}KVAERNO\_5\_3\_4  (20):}] \leavevmode
Use the Kvaerno-5-3-4 ESDIRK method

\item[{\index{ARK-6-3-4 ESDIRK method}ARK436L2SA\_DIRK\_6\_3\_4  (21):}] \leavevmode
Use the ARK-6-3-4 ESDIRK method

\item[{\index{Kvaerno-7-4-5 ESDIRK method}KVAERNO\_7\_4\_5  (22):}] \leavevmode
Use the Kvaerno-7-4-5 ESDIRK method

\item[{\index{ARK-8-4-5 ESDIRK method}ARK548L2SA\_DIRK\_8\_4\_5  (23):}] \leavevmode
Use the ARK-8-4-5 ESDIRK method

\item[{\index{DEFAULT\_DIRK\_2}DEFAULT\_DIRK\_2  (SDIRK\_2\_1\_2):}] \leavevmode
Use the default second-order DIRK method

\item[{\index{DEFAULT\_DIRK\_3}DEFAULT\_DIRK\_3  (ARK324L2SA\_DIRK\_4\_2\_3):}] \leavevmode
Use the default third-order DIRK method

\item[{\index{DEFAULT\_DIRK\_4}DEFAULT\_DIRK\_4  (SDIRK\_5\_3\_4):}] \leavevmode
Use the default fourth-order DIRK method

\item[{\index{DEFAULT\_DIRK\_5}DEFAULT\_DIRK\_5  (ARK548L2SA\_DIRK\_8\_4\_5):}] \leavevmode
Use the default fifth-order DIRK method

\end{description}


\subsection{ImEx Butcher table specification}
\label{Constants:imex-butcher-table-specification}\begin{description}
\item[{\index{ARK-4-2-3 ARK method}ARK324L2SA\_ERK\_4\_2\_3 and ARK324L2SA\_DIRK\_4\_2\_3 (2 and 16):}] \leavevmode
Use the ARK-4-2-3 ARK method

\item[{\index{ARK-6-3-4 ARK method}ARK436L2SA\_ERK\_6\_3\_4 and ARK436L2SA\_DIRK\_6\_3\_4 (4 and 21):}] \leavevmode
Use the ARK-6-3-4 ARK method

\item[{\index{ARK-8-4-5 ARK method}ARK548L2SA\_ERK\_8\_4\_5 and ARK548L2SA\_DIRK\_8\_4\_5 (9 and 23):}] \leavevmode
Use the ARK-8-4-5 ARK method

\item[{\index{DEFAULT\_ARK\_ETABLE\_3}DEFAULT\_ARK\_ETABLE\_3 and \index{DEFAULT\_ARK\_ITABLE\_3}DEFAULT\_ARK\_ITABLE\_3 (ARK324L2SA\_{[}ERK,DIRK{]}\_4\_2\_3):}] \leavevmode
Use the default third-order ARK method

\item[{\index{DEFAULT\_ARK\_ETABLE\_4}DEFAULT\_ARK\_ETABLE\_4 and \index{DEFAULT\_ARK\_ITABLE\_4}DEFAULT\_ARK\_ITABLE\_4 (ARK436L2SA\_{[}ERK,DIRK{]}\_6\_3\_4):}] \leavevmode
Use the default fourth-order ARK method

\item[{\index{DEFAULT\_ARK\_ETABLE\_5}DEFAULT\_ARK\_ETABLE\_5 and \index{DEFAULT\_ARK\_ITABLE\_5}DEFAULT\_ARK\_ITABLE\_5 (ARK548L2SA\_{[}ERK,DIRK{]}\_8\_4\_5):}] \leavevmode
Use the default fifth-order ARK method

\end{description}


\section{ARKode output constants}
\label{Constants:arkode-output-constants}

\subsection{ARKode main solver module}
\label{Constants:id1}\begin{description}
\item[{\index{ARK\_SUCCESS}ARK\_SUCCESS  (0):}] \leavevmode
Successful function return.

\item[{\index{ARK\_TSTOP\_RETURN}ARK\_TSTOP\_RETURN  (1):}] \leavevmode
ARKode succeeded by reachign the specified
stopping point.

\item[{\index{ARK\_ROOT\_RETURN}ARK\_ROOT\_RETURN  (2):}] \leavevmode
ARKode succeeded and found one more more roots.

\item[{\index{ARK\_WARNING}ARK\_WARNING  (99):}] \leavevmode
ARKode succeeded but an unusual situation occurred.

\item[{\index{ARK\_TOO\_MUCH\_WORK}ARK\_TOO\_MUCH\_WORK  (-1):}] \leavevmode
The solver took \code{mxstep} internal steps
but could not reach \code{tout}.

\item[{\index{ARK\_TOO\_MUCH\_ACC}ARK\_TOO\_MUCH\_ACC  (-2):}] \leavevmode
The solver could not satisfy the accuracy
demanded by the user for some internal step.

\item[{\index{ARK\_ERR\_FAILURE}ARK\_ERR\_FAILURE  (-3):}] \leavevmode
Error test failures occurred too many times
during one internal time step, or the minimum step size was
reached.

\item[{\index{ARK\_CONV\_FAILURE}ARK\_CONV\_FAILURE  (-4):}] \leavevmode
Convergence test failures occurred too many
times during one internal time step, or the minimum step size was
reached.

\item[{\index{ARK\_LINIT\_FAIL}ARK\_LINIT\_FAIL  (-5):}] \leavevmode
The linear solver's initialization function failed.

\item[{\index{ARK\_LSETUP\_FAIL}ARK\_LSETUP\_FAIL  (-6):}] \leavevmode
The linear solver's setup function failed in
an unrecoverable manner.

\item[{\index{ARK\_LSOLVE\_FAIL}ARK\_LSOLVE\_FAIL  (-7):}] \leavevmode
The linear solver's solve function failed in
an unrecoverable manner.

\item[{\index{ARK\_RHSFUNC\_FAIL}ARK\_RHSFUNC\_FAIL  (-8):}] \leavevmode
The right-hand side function failed in an
unrecoverable manner.

\item[{\index{ARK\_FIRST\_RHSFUNC\_ERR}ARK\_FIRST\_RHSFUNC\_ERR  (-9):}] \leavevmode
The right-hand side function failed
at the first call.

\item[{\index{ARK\_REPTD\_RHSFUNC\_ERR}ARK\_REPTD\_RHSFUNC\_ERR  (-10):}] \leavevmode
The right-hand side function had
repeated recoverable errors.

\item[{\index{ARK\_UNREC\_RHSFUNC\_ERR}ARK\_UNREC\_RHSFUNC\_ERR  (-11):}] \leavevmode
The right-hand side function had a
recoverable error, but no recovery is possible.

\item[{\index{ARK\_RTFUNC\_FAIL}ARK\_RTFUNC\_FAIL  (-12):}] \leavevmode
The rootfinding function failed in an
unrecoverable manner.

\item[{\index{ARK\_LFREE\_FAIL}ARK\_LFREE\_FAIL  (-13):}] \leavevmode
The linear solver's memory deallocation function failed.

\item[{\index{ARK\_MASSINIT\_FAIL}ARK\_MASSINIT\_FAIL  (-14):}] \leavevmode
The mass matrix linear solver's initialization function failed.

\item[{\index{ARK\_MASSSETUP\_FAIL}ARK\_MASSSETUP\_FAIL  (-15):}] \leavevmode
The mass matrix linear solver's setup function failed in
an unrecoverable manner.

\item[{\index{ARK\_MASSSOLVE\_FAIL}ARK\_MASSSOLVE\_FAIL  (-16):}] \leavevmode
The mass matrix linear solver's solve function failed in
an unrecoverable manner.

\item[{\index{ARK\_MASSFREE\_FAIL}ARK\_MASSFREE\_FAIL  (-17):}] \leavevmode
The mass matrix linear solver's memory deallocation function failed.

\item[{\index{ARK\_MASSMULT\_FAIL}ARK\_MASSMULT\_FAIL  (-17):}] \leavevmode
The mass matrix-vector product function failed.

\item[{\index{ARK\_MEM\_FAIL}ARK\_MEM\_FAIL  (-20):}] \leavevmode
A memory allocation failed.

\item[{\index{ARK\_MEM\_NULL}ARK\_MEM\_NULL  (-21):}] \leavevmode
The \code{arkode\_mem} argument was \code{NULL}.

\item[{\index{ARK\_ILL\_INPUT}ARK\_ILL\_INPUT  (-22):}] \leavevmode
One of the function inputs is illegal.

\item[{\index{ARK\_NO\_MALLOC}ARK\_NO\_MALLOC  (-23):}] \leavevmode
The ARKode memory block was not allocated by
a call to \code{ARKodeMalloc()}.

\item[{\index{ARK\_BAD\_K}ARK\_BAD\_K  (-24):}] \leavevmode
The derivative order \(k\) is larger than allowed.

\item[{\index{ARK\_BAD\_T}ARK\_BAD\_T  (-25):}] \leavevmode
The time \(t\) is outside the last step taken.

\item[{\index{ARK\_BAD\_DKY}ARK\_BAD\_DKY  (-26):}] \leavevmode
The output derivative vector is \code{NULL}.

\item[{\index{ARK\_TOO\_CLOSE}ARK\_TOO\_CLOSE  (-27):}] \leavevmode
The output and initial times are too close to
each other.

\end{description}


\subsection{ARKDLS linear solver modules}
\label{Constants:arkdls-linear-solver-modules}\begin{description}
\item[{\index{ARKDLS\_SUCCESS}ARKDLS\_SUCCESS  (0):}] \leavevmode
Successful function return.

\item[{\index{ARKDLS\_MEM\_NULL}ARKDLS\_MEM\_NULL  (-1):}] \leavevmode
The \code{arkode\_mem} argument was \code{NULL}.

\item[{\index{ARKDLS\_LMEM\_NULL}ARKDLS\_LMEM\_NULL  (-2):}] \leavevmode
The ARKDLS linear solver has not been initialized.

\item[{\index{ARKDLS\_ILL\_INPUT}ARKDLS\_ILL\_INPUT  (-3):}] \leavevmode
The ARKDLS solver is not compatible with
the current NVECTOR module.

\item[{\index{ARKDLS\_MEM\_FAIL}ARKDLS\_MEM\_FAIL  (-4):}] \leavevmode
A memory allocation request failed.

\item[{\index{ARKDLS\_MASSMEM\_FAIL}ARKDLS\_MASSMEM\_FAIL  (-5):}] \leavevmode
A memory allocation request failed for the mass matrix solver.

\item[{\index{ARKDLS\_JACFUNC\_UNRECVR}ARKDLS\_JACFUNC\_UNRECVR  (-6):}] \leavevmode
The Jacobian function failed in an
unrecoverable manner.

\item[{\index{ARKDLS\_JACFUNC\_RECVR}ARKDLS\_JACFUNC\_RECVR  (-7):}] \leavevmode
The Jacobian function had a recoverable error.

\item[{\index{ARKDLS\_MASSFUNC\_UNRECVR}ARKDLS\_MASSFUNC\_UNRECVR  (-8):}] \leavevmode
The mass matrix function failed in an
unrecoverable manner.

\item[{\index{ARKDLS\_MASSFUNC\_RECVR}ARKDLS\_MASSFUNC\_RECVR  (-9):}] \leavevmode
The mass matrix function had a recoverable error.

\item[{\index{ARKDLS\_SUNMAT\_FAIL}ARKDLS\_SUNMAT\_FAIL  (-10):}] \leavevmode
An error occurred with the current SUNMATRIX module.

\end{description}


\subsection{ARKSPILS linear solver modules}
\label{Constants:arkspils-linear-solver-modules}\begin{description}
\item[{\index{ARKSPILS\_SUCCESS}ARKSPILS\_SUCCESS  (0):}] \leavevmode
Successful function return.

\item[{\index{ARKSPILS\_MEM\_NULL}ARKSPILS\_MEM\_NULL  (-1):}] \leavevmode
The \code{arkode\_mem} argument was \code{NULL}.

\item[{\index{ARKSPILS\_LMEM\_NULL}ARKSPILS\_LMEM\_NULL  (-2):}] \leavevmode
The ARKSPILS linear solver has not been initialized.

\item[{\index{AKRSPILS\_ILL\_INPUT}AKRSPILS\_ILL\_INPUT  (-3):}] \leavevmode
The ARKSPILS solver is not compatible with
the current NVECTOR module, or an input value was illegal.

\item[{\index{ARKSPILS\_MEM\_FAIL}ARKSPILS\_MEM\_FAIL  (-4):}] \leavevmode
A memory allocation request failed.

\item[{\index{ARKSPILS\_PMEM\_FAIL}ARKSPILS\_PMEM\_FAIL  (-5):}] \leavevmode
The preconditioner module has not been initialized.

\item[{\index{ARKSPILS\_MASSMEM\_FAIL}ARKSPILS\_MASSMEM\_FAIL  (-6):}] \leavevmode
A memory allocation request failed in the mass matrix solver.

\item[{\index{ARKSPILS\_SUNLS\_FAIL}ARKSPILS\_SUNLS\_FAIL  (-10):}] \leavevmode
An error occurred with the current SUNLINSOL module.

\end{description}


\chapter{Appendix: Butcher tables}
\label{Butcher::doc}\label{Butcher:appendix-butcher-tables}\label{Butcher:butcher}
Here we catalog the full set of Butcher tables included in ARKode.
We group these into three categories: \emph{explicit}, \emph{implicit} and
\emph{additive}.  However, since the methods that comprise an additive
Runge Kutta method are themselves explicit and implicit, their
component Butcher tables are listed within their separate
sections, but are referenced together in the additive section.

In each of the following tables, we use the following notation (shown
for a 3-stage method):
\begin{gather}
\begin{split}\begin{array}{r|ccc}
  c_1 & a_{1,1} & a_{1,2} & a_{1,3} \\
  c_2 & a_{2,1} & a_{2,2} & a_{2,3} \\
  c_3 & a_{3,1} & a_{3,2} & a_{3,3} \\
  \hline
  q & b_1 & b_2 & b_3 \\
  p & \tilde{b}_1 & \tilde{b}_2 & \tilde{b}_3
\end{array}\end{split}\notag
\end{gather}
where here the method and embedding share stage \(A\) and
\(c\) values, but use their stages \(z_i\) differently through
the coefficients \(b\) and \(\tilde{b}\) to generate methods
of orders \(q\) (the main method) and \(p\) (the embedding,
typically \(q = p+1\), though sometimes this is reversed).

Method authors often use different naming conventions to categorize
their methods.  For each of the methods below, we follow a uniform
naming convention:

\begin{Verbatim}[commandchars=\\\{\}]
NAME\PYGZhy{}S\PYGZhy{}P\PYGZhy{}Q
\end{Verbatim}

where here
\begin{itemize}
\item {} 
\code{NAME} is the author or the name provided by the author (if applicable),

\item {} 
\code{S} is the number of stages in the method,

\item {} 
\code{P} is the global order of accuracy for the embedding,

\item {} 
\code{Q} is the global order of accuracy for the method.

\end{itemize}

In the code, unique integer IDs are defined inside \code{arkode.h} for
each method, which may be used by calling routines to specify the
desired method.  These names are specified in \code{fixed width font} at
the start of each method's section below.

Additionally, for each method we provide a plot of the linear
stability region in the complex plane.  These have been computed via
the following approach.  For any Runge Kutta method as defined above,
we may define the stability function
\begin{gather}
\begin{split}R(\eta) = 1 + \eta b [I - \eta A]^{-1} e,\end{split}\notag
\end{gather}
where \(e\in\mathbb{R}^s\) is a column vector of all ones, \(\eta =
h\lambda\) and \(h\) is the time step size.  If the stability
function satisfies \(|R(\eta)| \le 1\) for all eigenvalues,
\(\lambda\), of \(\frac{\partial }{\partial y}f(t,y)\) for a
given IVP, then the method will be linearly stable for that problem
and step size.  The stability region
\begin{gather}
\begin{split}S = \{ \eta\in\mathbb{C}\; :\; \left| R(\eta) \right| \le 1\}\end{split}\notag
\end{gather}
is typically given by an enclosed region of the complex plane, so it
is standard to search for the border of that region in order to
understand the method.  Since all complex numbers with unit magnitude
may be written as \(e^{i\theta}\) for some value of \(\theta\),
we perform the following algorithm to trace out this boundary.
\begin{enumerate}
\item {} 
Define an array of values \code{Theta}.  Since we wish for a
smooth curve, and since we wish to trace out the entire boundary,
we choose 10,000 linearly-spaced points from 0 to \(16\pi\).
Since some angles will correspond to multiple locations on the
stability boundary, by going beyond \(2\pi\) we ensure that all
boundary locations are plotted, and by using such a fine
discretization the Newton method (next step) is more likely to
converge to the root closest to the previous boundary point,
ensuring a smooth plot.

\item {} 
For each value \(\theta \in\) \code{Theta}, we solve the nonlinear
equation
\begin{gather}
\begin{split}0 = f(\eta) = R(\eta) - e^{i\theta}\end{split}\notag
\end{gather}
using a finite-difference Newton iteration, using tolerance
\(10^{-7}\), and differencing parameter
\(\sqrt{\varepsilon}\) (\(\approx 10^{-8}\)).

In this iteration, we use as initial guess the solution from the
previous value of \(\theta\), starting with an initial-initial
guess of \(\eta=0\) for \(\theta=0\).

\item {} 
We then plot the resulting \(\eta\) values that trace the
stability region boundary.

\end{enumerate}

We note that for any stable IVP method, the value \(\eta_0 =
-\varepsilon + 0i\) is always within the stability region.  So in each
of the following pictures, the interior of the stability region is the
connected region that includes \(\eta_0\).  Resultingly, methods
whose linear stability boundary is located entirely in the right
half-plane indicate an \emph{A-stable} method.


\section{Explicit Butcher tables}
\label{Butcher:explicit-butcher-tables}\label{Butcher:butcher-explicit}
In the category of explicit Runge-Kutta methods, ARKode includes
methods that have orders 2 through 6, with embeddings that are of
orders 1 through 5.


\subsection{Heun-Euler-2-1-2}
\label{Butcher:butcher-heun-euler}\label{Butcher:heun-euler-2-1-2}
\index{Heun-Euler-2-1-2 ERK method}
\code{HEUN\_EULER\_2\_1\_2} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.  This is
the default 2nd order explicit method.
\begin{gather}
\begin{split}\begin{array}{r|cc}
  0 & 0 & 0 \\
  1 & 1 & 0 \\
  \hline
  2 & \frac{1}{2} & \frac{1}{2} \\
  1 & 1 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_0.png}}
\caption{Linear stability region for the Heun-Euler method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Bogacki-Shampine-4-2-3}
\label{Butcher:bogacki-shampine-4-2-3}\label{Butcher:butcher-bogacki-shampine}
\index{Bogacki-Shampine-4-2-3 ERK method}
\code{BOGACKI\_SHAMPINE\_4\_2\_3} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.  This
is the default 3rd order explicit method (from \phantomsection\label{Butcher:id1}{\hyperref[References:bs1989]{\emph{{[}BS1989{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccc}
  0 &   0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{2} & 0 & 0 & 0 \\
  \frac{3}{4} & 0 & \frac{3}{4} & 0 & 0 \\
  1   & \frac{2}{9} & \frac{1}{3} & \frac{4}{9} & 0 \\
  \hline
  3 & \frac{2}{9} & \frac{1}{3} & \frac{4}{9} \\
  2 & \frac{7}{24} & \frac{1}{4} & \frac{1}{3} & \frac{1}{8}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_1.png}}
\caption{Linear stability region for the Bogacki-Shampine method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{ARK-4-2-3 (explicit)}
\label{Butcher:butcher-ark-4-2-3-e}\label{Butcher:ark-4-2-3-explicit}
\index{ARK-4-2-3 ERK method}
\code{ARK324L2SA\_ERK\_4\_2\_3} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.
This is the explicit portion of the default 3rd order additive method
(from \phantomsection\label{Butcher:id2}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccc}
  0 & 0 & 0 & 0 & 0 \\
  \frac{1767732205903}{2027836641118} & \frac{1767732205903}{2027836641118} & 0 & 0 & 0 \\
  \frac{3}{5} & \frac{5535828885825}{10492691773637} & \frac{788022342437}{10882634858940} & 0 & 0 \\
  1 & \frac{6485989280629}{16251701735622} & -\frac{4246266847089}{9704473918619} & \frac{10755448449292}{10357097424841} & 0 \\
  \hline
  3 & \frac{1471266399579}{7840856788654} & -\frac{4482444167858}{7529755066697} & \frac{11266239266428}{11593286722821} & \frac{1767732205903}{4055673282236} \\
  2 & \frac{2756255671327}{12835298489170} & -\frac{10771552573575}{22201958757719} & \frac{9247589265047}{10645013368117} & \frac{2193209047091}{5459859503100}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_2.png}}
\caption{Linear stability region for the explicit ARK-4-2-3 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Zonneveld-5-3-4}
\label{Butcher:butcher-zonneveld}\label{Butcher:zonneveld-5-3-4}
\index{Zonneveld-5-3-4 ERK method}
\code{ZONNEVELD\_5\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.  This is
the default 4th order explicit method (from \phantomsection\label{Butcher:id3}{\hyperref[References:z1963]{\emph{{[}Z1963{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|ccccc}
    0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{2} & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & 0 & \frac{1}{2} & 0 & 0 & 0 \\
    1 & 0 & 0 & 1 & 0 & 0 \\
  \frac{3}{4} & \frac{5}{32} & \frac{7}{32} & \frac{13}{32} & -\frac{1}{32} & 0 \\
  \hline
  4 & \frac{1}{6} & \frac{1}{3} & \frac{1}{3} & \frac{1}{6} & 0 \\
  3 & -\frac{1}{2} & \frac{7}{3} & \frac{7}{3} & \frac{13}{6} & -\frac{16}{3}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_3.png}}
\caption{Linear stability region for the Zonneveld method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{ARK-6-3-4 (explicit)}
\label{Butcher:butcher-ark-6-3-4-e}\label{Butcher:ark-6-3-4-explicit}
\index{ARK-6-3-4 ERK method}
\code{ARK436L2SA\_ERK\_6\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.  This is
the explicit portion of the default 4th order additive method (from \phantomsection\label{Butcher:id4}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac12 & \frac12 & 0 & 0 & 0 & 0 & 0 \\
  \frac{83}{250} & \frac{13861}{62500} & \frac{6889}{62500} & 0 & 0 & 0 & 0 \\
  \frac{31}{50} & -\frac{116923316275}{2393684061468} & -\frac{2731218467317}{15368042101831} & \frac{9408046702089}{11113171139209} & 0 & 0 & 0 \\
  \frac{17}{20} & -\frac{451086348788}{2902428689909} & -\frac{2682348792572}{7519795681897} & \frac{12662868775082}{11960479115383} & \frac{3355817975965}{11060851509271} & 0 & 0 \\
  1 & \frac{647845179188}{3216320057751} & \frac{73281519250}{8382639484533} & \frac{552539513391}{3454668386233} & \frac{3354512671639}{8306763924573} & \frac{4040}{17871} & 0 \\
  \hline
  4 & \frac{82889}{524892} & 0 & \frac{15625}{83664} & \frac{69875}{102672} & -\frac{2260}{8211} & \frac14 \\
  3 & \frac{4586570599}{29645900160} & 0 & \frac{178811875}{945068544} & \frac{814220225}{1159782912} & -\frac{3700637}{11593932} & \frac{61727}{225920}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_4.png}}
\caption{Linear stability region for the explicit ARK-6-3-4 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Sayfy-Aburub-6-3-4}
\label{Butcher:butcher-sayfy-aburub}\label{Butcher:sayfy-aburub-6-3-4}
\index{Sayfy-Aburub-6-3-4 ERK method}
\code{SAYFY\_ABURUB\_6\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}} (from \phantomsection\label{Butcher:id5}{\hyperref[References:sa2002]{\emph{{[}SA2002{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{2} & 0 & 0 & 0 & 0 & 0 \\
  1 & -1 & 2 & 0 & 0 & 0 & 0 \\
  1 & \frac{1}{6} & \frac{2}{3} & \frac{1}{6} & 0 & 0 & 0 \\
  \frac{1}{2} & 0.137 & 0.226 & 0.137 & 0 & 0 & 0 \\
  1 & 0.452 & -0.904 & -0.548 & 0 & 2 & 0 \\
  \hline
  4 & \frac{1}{6} & \frac{1}{3} & \frac{1}{12} & 0 & \frac{1}{3} & \frac{1}{12} \\
  3 & \frac{1}{6} & \frac{2}{3} & \frac{1}{6} & 0 & 0 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_5.png}}
\caption{Linear stability region for the Sayfy-Aburub-6-3-4 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Cash-Karp-6-4-5}
\label{Butcher:cash-karp-6-4-5}\label{Butcher:butcher-cash-karp}
\index{Cash-Karp-6-4-5 ERK method}
\code{CASH\_KARP\_6\_4\_5} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.  This is
the default 5th order explicit method (from \phantomsection\label{Butcher:id6}{\hyperref[References:ck1990]{\emph{{[}CK1990{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{5} & \frac{1}{5} & 0 & 0 & 0 & 0 & 0 \\
  \frac{3}{10} & \frac{3}{40} & \frac{9}{40} & 0 & 0 & 0 & 0 \\
  \frac{3}{5} & \frac{3}{10} & -\frac{9}{10} & \frac{6}{5} & 0 & 0 & 0 \\
  1 & -\frac{11}{54} & \frac{5}{2} & -\frac{70}{27} & \frac{35}{27} & 0 & 0 \\
  \frac{7}{8} & \frac{1631}{55296} & \frac{175}{512} & \frac{575}{13824} & \frac{44275}{110592} & \frac{253}{4096} & 0 \\
  \hline
  5 & \frac{37}{378} & 0 & \frac{250}{621} & \frac{125}{594} & 0 & \frac{512}{1771} \\
  4 & \frac{2825}{27648} & 0 & \frac{18575}{48384} & \frac{13525}{55296} & \frac{277}{14336} & \frac{1}{4}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_6.png}}
\caption{Linear stability region for the Cash-Karp method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Fehlberg-6-4-5}
\label{Butcher:butcher-fehlberg}\label{Butcher:fehlberg-6-4-5}
\index{Fehlberg-6-4-5 ERK method}
\code{FEHLBERG\_6\_4\_5} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}} (from \phantomsection\label{Butcher:id7}{\hyperref[References:f1969]{\emph{{[}F1969{]}}}})
\begin{gather}
\begin{split}\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{4} & \frac{1}{4} & 0 & 0 & 0 & 0 & 0 \\
  \frac{3}{8} & \frac{3}{32} & \frac{9}{32} & 0 & 0 & 0 & 0 \\
  \frac{12}{13} & \frac{1932}{2197} & -\frac{7200}{2197} & \frac{7296}{2197} & 0 & 0 & 0 \\
  1 & \frac{439}{216} & -8 & \frac{3680}{513} & -\frac{845}{4104} & 0 & 0 \\
  \frac{1}{2} & -\frac{8}{27} & 2 & -\frac{3544}{2565} & \frac{1859}{4104} & -\frac{11}{40} & 0 \\
  \hline
  5 & \frac{16}{135} & 0 & \frac{6656}{12825} & \frac{28561}{56430} & -\frac{9}{50} & \frac{2}{55} \\
  4 & \frac{25}{216} & 0 & \frac{1408}{2565} & \frac{2197}{4104} & -\frac{1}{5} & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_7.png}}
\caption{Linear stability region for the Fehlberg method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Dormand-Prince-7-4-5}
\label{Butcher:dormand-prince-7-4-5}\label{Butcher:butcher-dormand-prince}
\index{Dormand-Prince-7-4-5 ERK method}
\code{DORMAND\_PRINCE\_7\_4\_5} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}} (from \phantomsection\label{Butcher:id8}{\hyperref[References:dp1980]{\emph{{[}DP1980{]}}}})
\begin{gather}
\begin{split}\begin{array}{r|ccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{5} & \frac{1}{5} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{3}{10} & \frac{3}{40} & \frac{9}{40} & 0 & 0 & 0 & 0 & 0 \\
  \frac{4}{5} & \frac{44}{45} & -\frac{56}{15} & \frac{32}{9} & 0 & 0 & 0 & 0 \\
  \frac{8}{9} & \frac{19372}{6561} & -\frac{25360}{2187} & \frac{64448}{6561} & -\frac{212}{729} & 0 & 0 & 0 \\
  1 & \frac{9017}{3168} & -\frac{355}{33} & \frac{46732}{5247} & \frac{49}{176} & -\frac{5103}{18656} & 0 & 0 \\
  1 & \frac{35}{384} & 0 & \frac{500}{1113} & \frac{125}{192} & -\frac{2187}{6784} & \frac{11}{84} & 0 \\
  \hline
  5 & \frac{35}{384} & 0 & \frac{500}{1113} & \frac{125}{192} & -\frac{2187}{6784} & \frac{11}{84} & 0 \\
  4 & \frac{5179}{57600} & 0 & \frac{7571}{16695} & \frac{393}{640} & -\frac{92097}{339200} & \frac{187}{2100} & \frac{1}{40}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_8.png}}
\caption{Linear stability region for the Dormand-Prince method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{ARK-8-4-5 (explicit)}
\label{Butcher:butcher-ark-8-4-5-e}\label{Butcher:ark-8-4-5-explicit}
\index{ARK-8-4-5 ERK method}
\code{ARK548L2SA\_ERK\_8\_4\_5} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.  This is
the explicit portion of the default 5th order additive method (from \phantomsection\label{Butcher:id9}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{41}{100} & \frac{41}{100} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{2935347310677}{11292855782101} & \frac{367902744464}{2072280473677} & \frac{677623207551}{8224143866563} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1426016391358}{7196633302097} & \frac{1268023523408}{10340822734521} & 0 & \frac{1029933939417}{13636558850479} & 0 & 0 & 0 & 0 & 0 \\
  \frac{92}{100} & \frac{14463281900351}{6315353703477} & 0 & \frac{66114435211212}{5879490589093} & -\frac{54053170152839}{4284798021562} & 0 & 0 & 0 & 0 \\
  \frac{24}{100} & \frac{14090043504691}{34967701212078} & 0 & \frac{15191511035443}{11219624916014} & -\frac{18461159152457}{12425892160975} & -\frac{281667163811}{9011619295870} & 0 & 0 & 0 \\
  \frac{3}{5} & \frac{19230459214898}{13134317526959} & 0 & \frac{21275331358303}{2942455364971} & -\frac{38145345988419}{4862620318723} & -\frac{1}{8} & -\frac{1}{8} & 0 & 0 \\
  1 & -\frac{19977161125411}{11928030595625} & 0 & -\frac{40795976796054}{6384907823539} & \frac{177454434618887}{12078138498510} & \frac{782672205425}{8267701900261} & -\frac{69563011059811}{9646580694205} & \frac{7356628210526}{4942186776405} & 0 \\
  \hline
  5 & -\frac{872700587467}{9133579230613} & 0 & 0 & \frac{22348218063261}{9555858737531} & -\frac{1143369518992}{8141816002931} & -\frac{39379526789629}{19018526304540} & \frac{32727382324388}{42900044865799} & \frac{41}{200} \\
  4 & -\frac{975461918565}{9796059967033} & 0 & 0 & \frac{78070527104295}{32432590147079} & -\frac{548382580838}{3424219808633} & -\frac{33438840321285}{15594753105479} & \frac{3629800801594}{4656183773603} & \frac{4035322873751}{18575991585200}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_9.png}}
\caption{Linear stability region for the explicit ARK-8-4-5 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Verner-8-5-6}
\label{Butcher:butcher-verner-6-5}\label{Butcher:verner-8-5-6}
\index{Verner-8-5-6 ERK method}
\code{VERNER\_8\_5\_6} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.  This is
the default 6th order explicit method (from \phantomsection\label{Butcher:id10}{\hyperref[References:v1978]{\emph{{[}V1978{]}}}})
\begin{gather}
\begin{split}\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{6} & \frac{1}{6} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{4}{15} & \frac{4}{75} & \frac{16}{75} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{2}{3} & \frac{5}{6} & -\frac{8}{3} & \frac{5}{2} & 0 & 0 & 0 & 0 & 0 \\
  \frac{5}{6} & -\frac{165}{64} & \frac{55}{6} & -\frac{425}{64} & \frac{85}{96} & 0 & 0 & 0 & 0 \\
  1 & \frac{12}{5} & -8 & \frac{4015}{612} & -\frac{11}{36} & \frac{88}{255} & 0 & 0 & 0 \\
  \frac{1}{15} & -\frac{8263}{15000} & \frac{124}{75} & -\frac{643}{680} & -\frac{81}{250} & \frac{2484}{10625} & 0 & 0 & 0 \\
  1 & \frac{3501}{1720} & -\frac{300}{43} & \frac{297275}{52632} & -\frac{319}{2322} & \frac{24068}{84065} & 0 & \frac{3850}{26703} & 0 \\
  \hline
  6 & \frac{3}{40} & 0 & \frac{875}{2244} & \frac{23}{72} & \frac{264}{1955} & 0 & \frac{125}{11592} & \frac{43}{616} \\
  5 & \frac{13}{160} & 0 & \frac{2375}{5984} & \frac{5}{16} & \frac{12}{85} & \frac{3}{44} & 0 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_10.png}}
\caption{Linear stability region for the Verner-8-5-6 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Fehlberg-13-7-8}
\label{Butcher:butcher-fehlberg-8-7}\label{Butcher:fehlberg-13-7-8}
\index{Fehlberg-13-7-8 ERK method}
\code{FEHLBERG\_13\_7\_8} for {\hyperref[c_interface/User_callable:c.ARKodeSetERKTableNum]{\emph{\code{ARKodeSetERKTableNum()}}}}.
This is the default 8th order explicit method (from \phantomsection\label{Butcher:id11}{\hyperref[References:b2008]{\emph{{[}B2008{]}}}})
\begin{gather}
\begin{split}\begin{array}{r|ccccccccccccc}
  0&   0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{2}{27}&   \frac{2}{27}& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{9}&   \frac{1}{36}& \frac{1}{12}& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{6}&   \frac{1}{24}& 0& \frac{1}{8}& 0& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{5}{12}&   \frac{5}{12}& 0& -\frac{25}{16}& \frac{25}{16}& 0& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{2}&   \frac{1}{20}& 0& 0& \frac{1}{4}& \frac{1}{5}& 0& 0& 0& 0& 0& 0& 0& 0\\
  \frac{5}{6}&   -\frac{25}{108}& 0& 0& \frac{125}{108}& -\frac{65}{27}& \frac{125}{54}& 0& 0& 0& 0& 0& 0& 0\\
  \frac{1}{6}&   \frac{31}{300}& 0& 0& 0& \frac{61}{225}& -\frac{2}{9}& \frac{13}{900}& 0& 0& 0& 0& 0& 0\\
  \frac{2}{3}&   2& 0& 0& -\frac{53}{6}& \frac{704}{45}& -\frac{107}{9}& \frac{67}{90}& 3& 0& 0& 0& 0& 0\\
  \frac{1}{3}&   -\frac{91}{108}& 0& 0& \frac{23}{108}& -\frac{976}{135}& \frac{311}{54}& -\frac{19}{60}& \frac{17}{6}& -\frac{1}{12}& 0& 0& 0& 0\\
  1&   \frac{2383}{4100}& 0& 0& -\frac{341}{164}& \frac{4496}{1025}& -\frac{301}{82}& \frac{2133}{4100}& \frac{45}{82}& \frac{45}{164}& \frac{18}{41}& 0& 0& 0\\
  0&   \frac{3}{205}& 0& 0& 0& 0& -\frac{6}{41}& -\frac{3}{205}& -\frac{3}{41}& \frac{3}{41}& \frac{6}{41}& 0& 0& 0\\
  1&   -\frac{1777}{4100}& 0& 0& -\frac{341}{164}& \frac{4496}{1025}& -\frac{289}{82}& \frac{2193}{4100}& \frac{51}{82}& \frac{33}{164}& \frac{12}{41}& 0& 1& 0\\
  \hline
  8& 0& 0& 0& 0& 0& \frac{34}{105}& \frac{9}{35}& \frac{9}{35}& \frac{9}{280}& \frac{9}{280}& 0& \frac{41}{840}& \frac{41}{840} \\
  7& \frac{41}{840}& 0& 0& 0& 0& \frac{34}{105}& \frac{9}{35}& \frac{9}{35}& \frac{9}{280}& \frac{9}{280}& \frac{41}{840}& 0& 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_23.png}}
\caption{Linear stability region for the Fehlberg-13-7-8 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\section{Implicit Butcher tables}
\label{Butcher:implicit-butcher-tables}\label{Butcher:butcher-implicit}
In the category of diagonally implicit Runge-Kutta methods, ARKode
includes methods that have orders 2 through 5, with embeddings that are of
orders 1 through 4.


\subsection{SDIRK-2-1-2}
\label{Butcher:sdirk-2-1-2}\label{Butcher:butcher-sdirk-2-1}
\index{SDIRK-2-1-2 method}
\code{SDIRK\_2\_1\_2} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  This is
the default 2nd order implicit method.  Both the method and embedding
are A- and B-stable.
\begin{gather}
\begin{split}\begin{array}{r|cc}
  1 & 1 & 0 \\
  0 & -1 & 1 \\
  \hline
  2 & \frac{1}{2} & \frac{1}{2} \\
  1 & 1 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_11.png}}
\caption{Linear stability region for the SDIRK-2-1-2 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Billington-3-3-2}
\label{Butcher:butcher-billington}\label{Butcher:billington-3-3-2}
\index{Billington-3-3-2 SDIRK method}
\code{BILLINGTON\_3\_3\_2} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  Here, the
higher-order embedding is less stable than the lower-order method
(from \phantomsection\label{Butcher:id12}{\hyperref[References:b1983]{\emph{{[}B1983{]}}}})
\begin{gather}
\begin{split}\begin{array}{r|ccc}
  0.292893218813 & 0.292893218813 & 0 & 0 \\
  1.091883092037 & 0.798989873223 & 0.292893218813 & 0 \\
  1.292893218813 & 0.740789228841 & 0.259210771159 & 0.292893218813 \\
  \hline
  2 & 0.740789228840 & 0.259210771159 & 0 \\
  3 & 0.691665115992 & 0.503597029883 & -0.195262145876
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_12.png}}
\caption{Linear stability region for the Billington method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{TRBDF2-3-3-2}
\label{Butcher:butcher-trbdf2}\label{Butcher:trbdf2-3-3-2}
\index{TRBDF2-3-3-2 ESDIRK method}
\code{TRBDF2\_3\_3\_2} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  As with
Billington, here the higher-order embedding is less stable than the
lower-order method (from \phantomsection\label{Butcher:id13}{\hyperref[References:b1985]{\emph{{[}B1985{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|ccc}
  0 & 0 & 0 & 0 \\
  2-\sqrt{2} & \frac{2-\sqrt{2}}{2} & \frac{2-\sqrt{2}}{2} & 0 \\
  1 & \frac{\sqrt{2}}{4} & \frac{\sqrt{2}}{4} & \frac{2-\sqrt{2}}{2} \\
  \hline
  2 & \frac{\sqrt{2}}{4} & \frac{\sqrt{2}}{4} & \frac{2-\sqrt{2}}{2} \\
  3 & \frac{1-\frac{\sqrt{2}}{4}}{3} & \frac{\frac{3\sqrt{2}}{4}+1}{3} & \frac{2-\sqrt{2}}{6}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_13.png}}
\caption{Linear stability region for the TRBDF2 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Kvaerno-4-2-3}
\label{Butcher:butcher-kvaerno-4-2-3}\label{Butcher:kvaerno-4-2-3}
\index{Kvaerno-4-2-3 ESDIRK method}
\code{KVAERNO\_4\_2\_3} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  Both the
method and embedding are A-stable; additionally the method is L-stable
(from \phantomsection\label{Butcher:id14}{\hyperref[References:k2004]{\emph{{[}K2004{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccc}
  0 & 0 & 0 & 0 & 0 \\
  0.871733043 & 0.4358665215 & 0.4358665215 & 0 & 0 \\
  1 & 0.490563388419108 & 0.073570090080892 & 0.4358665215 & 0 \\
  1 & 0.308809969973036 & 1.490563388254106 & -1.235239879727145 & 0.4358665215 \\
  \hline
  3 & 0.308809969973036 & 1.490563388254106 & -1.235239879727145 & 0.4358665215 \\
  2 & 0.490563388419108 & 0.073570090080892 & 0.4358665215 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_14.png}}
\caption{Linear stability region for the Kvaerno-4-2-3 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{ARK-4-2-3 (implicit)}
\label{Butcher:ark-4-2-3-implicit}\label{Butcher:butcher-ark-4-2-3-i}
\index{ARK-4-2-3 ESDIRK method}
\code{ARK324L2SA\_DIRK\_4\_2\_3} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  This
is the default 3rd order implicit method, and the implicit portion of
the default 3rd order additive method.  Both the method and embedding
are A-stable; additionally the method is L-stable (from \phantomsection\label{Butcher:id15}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccc}
  0 & 0 & 0 & 0 & 0 \\
  \frac{1767732205903}{2027836641118} & \frac{1767732205903}{4055673282236} & \frac{1767732205903}{4055673282236} & 0 & 0 \\
  \frac{3}{5} & \frac{2746238789719}{10658868560708} & -\frac{640167445237}{6845629431997} & \frac{1767732205903}{4055673282236} & 0 \\
  1 & \frac{1471266399579}{7840856788654} & -\frac{4482444167858}{7529755066697} & \frac{11266239266428}{11593286722821} & \frac{1767732205903}{4055673282236} \\
  \hline
  3 & \frac{1471266399579}{7840856788654} & -\frac{4482444167858}{7529755066697} & \frac{11266239266428}{11593286722821} & \frac{1767732205903}{4055673282236} \\
  2 & \frac{2756255671327}{12835298489170} & -\frac{10771552573575}{22201958757719} & \frac{9247589265047}{10645013368117} & \frac{2193209047091}{5459859503100}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_15.png}}
\caption{Linear stability region for the implicit ARK-4-2-3 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Cash-5-2-4}
\label{Butcher:butcher-cash-5-2-4}\label{Butcher:cash-5-2-4}
\index{Cash-5-2-4 SDIRK method}
\code{CASH\_5\_2\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  Both the
method and embedding are A-stable; additionally the method is L-stable
(from \phantomsection\label{Butcher:id16}{\hyperref[References:c1979]{\emph{{[}C1979{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|ccccc}
  0.435866521508 & 0.435866521508 & 0 & 0 & 0 & 0 \\
  -0.7 & -1.13586652150 & 0.435866521508 & 0 & 0 & 0 \\
  0.8 & 1.08543330679 & -0.721299828287 & 0.435866521508 & 0 & 0 \\
  0.924556761814 & 0.416349501547 & 0.190984004184 & -0.118643265417 & 0.435866521508 & 0 \\
  1 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  \hline
  4 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  2 & 1.05646216107052 & -0.0564621610705236 & 0 & 0 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_16.png}}
\caption{Linear stability region for the Cash-5-2-4 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Cash-5-3-4}
\label{Butcher:butcher-cash-5-3-4}\label{Butcher:cash-5-3-4}
\index{Cash-5-3-4 SDIRK method}
\code{CASH\_5\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  Both the
method and embedding are A-stable; additionally the method is L-stable
(from \phantomsection\label{Butcher:id17}{\hyperref[References:c1979]{\emph{{[}C1979{]}}}})
\begin{gather}
\begin{split}\begin{array}{r|ccccc}
  0.435866521508 & 0.435866521508 & 0 & 0 & 0 & 0 \\
  -0.7 & -1.13586652150 & 0.435866521508 & 0 & 0 & 0 \\
  0.8 & 1.08543330679 & -0.721299828287 & 0.435866521508 & 0 & 0 \\
  0.924556761814 & 0.416349501547 & 0.190984004184 & -0.118643265417 & 0.435866521508 & 0 \\
  1 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  \hline
  4 & 0.896869652944 & 0.0182725272734 & -0.0845900310706 & -0.266418670647 & 0.435866521508 \\
  3 & 0.776691932910 & 0.0297472791484 & -0.0267440239074 & 0.220304811849 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_17.png}}
\caption{Linear stability region for the Cash-5-3-4 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{SDIRK-5-3-4}
\label{Butcher:butcher-sdirk-5-4}\label{Butcher:sdirk-5-3-4}
\index{SDIRK-5-3-4 method}
\code{SDIRK\_5\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  This is
the default 4th order implicit method.  Here, the method is both A-
and L-stable, although the embedding has reduced stability (from \phantomsection\label{Butcher:id18}{\hyperref[References:hw1996]{\emph{{[}HW1996{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|ccccc}
  \frac{1}{4} & \frac{1}{4} & 0 & 0 & 0 & 0 \\
  \frac{3}{4} & \frac{1}{2} & \frac{1}{4} & 0 & 0 & 0 \\
  \frac{11}{20} & \frac{17}{50} & -\frac{1}{25} & \frac{1}{4} & 0 & 0 \\
  \frac{1}{2} & \frac{371}{1360} & -\frac{137}{2720} & \frac{15}{544} & \frac{1}{4} & 0 \\
  1 & \frac{25}{24} & -\frac{49}{48} & \frac{125}{16} & -\frac{85}{12} & \frac{1}{4} \\
  \hline
  4 & \frac{25}{24} & -\frac{49}{48} & \frac{125}{16} & -\frac{85}{12} & \frac{1}{4} \\
  3 & \frac{59}{48} & -\frac{17}{96} & \frac{225}{32} & -\frac{85}{12} & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_18.png}}
\caption{Linear stability region for the SDIRK-5-3-4 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Kvaerno-5-3-4}
\label{Butcher:kvaerno-5-3-4}\label{Butcher:butcher-kvaerno-5-3-4}
\index{Kvaerno-5-3-4 ESDIRK method}
\code{KVAERNO\_5\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  Both the
method and embedding are A-stable (from \phantomsection\label{Butcher:id19}{\hyperref[References:k2004]{\emph{{[}K2004{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|ccccc}
  0 & 0 & 0 & 0 & 0 & 0 \\
  0.871733043 & 0.4358665215  & 0.4358665215  & 0 & 0 & 0 \\
  0.468238744853136 & 0.140737774731968 & -0.108365551378832 & 0.4358665215 & 0 & 0 \\
  1 & 0.102399400616089 & -0.376878452267324 & 0.838612530151233 & 0.4358665215 & 0 \\
  1 & 0.157024897860995 & 0.117330441357768 & 0.61667803039168 & -0.326899891110444 & 0.4358665215 \\
  \hline
  4 & 0.157024897860995 & 0.117330441357768 & 0.61667803039168 & -0.326899891110444 & 0.4358665215 \\
  3 & 0.102399400616089 & -0.376878452267324 & 0.838612530151233 & 0.4358665215 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_19.png}}
\caption{Linear stability region for the Kvaerno-5-3-4 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{ARK-6-3-4 (implicit)}
\label{Butcher:ark-6-3-4-implicit}\label{Butcher:butcher-ark-6-3-4-i}
\index{ARK-6-3-4 ESDIRK method}
\code{ARK436L2SA\_DIRK\_6\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  This
is the implicit portion of the default 4th order additive method.
Both the method and embedding are A-stable; additionally the method is
L-stable (from \phantomsection\label{Butcher:id20}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{1}{2} & \frac{1}{4} & \frac{1}{4} & 0 & 0 & 0 & 0 \\
  \frac{83}{250} & \frac{8611}{62500} & -\frac{1743}{31250} & \frac{1}{4} & 0 & 0 & 0 \\
  \frac{31}{50} & \frac{5012029}{34652500} & -\frac{654441}{2922500} & \frac{174375}{388108} & \frac{1}{4} & 0 & 0 \\
  \frac{17}{20} & \frac{15267082809}{155376265600} & -\frac{71443401}{120774400} & \frac{730878875}{902184768} & \frac{2285395}{8070912} & \frac{1}{4} & 0 \\
  1 & \frac{82889}{524892} & 0 & \frac{15625}{83664} & \frac{69875}{102672} & -\frac{2260}{8211} & \frac{1}{4} \\
  \hline
  4 & \frac{82889}{524892} & 0 & \frac{15625}{83664} & \frac{69875}{102672} & -\frac{2260}{8211} & \frac{1}{4} \\
  3 & \frac{4586570599}{29645900160} & 0 & \frac{178811875}{945068544} & \frac{814220225}{1159782912} & -\frac{3700637}{11593932} & \frac{61727}{225920}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_20.png}}
\caption{Linear stability region for the implicit ARK-6-3-4 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{Kvaerno-7-4-5}
\label{Butcher:kvaerno-7-4-5}\label{Butcher:butcher-kvaerno-7-4-5}
\index{Kvaerno-7-4-5 ESDIRK method}
\code{KVAERNO\_7\_4\_5} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  Both the
method and embedding are A-stable; additionally the method is
L-stable (from \phantomsection\label{Butcher:id21}{\hyperref[References:k2004]{\emph{{[}K2004{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|ccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  0.52 & 0.26 & 0.26 & 0 & 0 & 0 & 0 & 0 \\
  1.230333209967908 & 0.13 & 0.84033320996790809 & 0.26 & 0 & 0 & 0 & 0 \\
  0.895765984350076 & 0.22371961478320505 & 0.47675532319799699 & -0.06470895363112615 & 0.26 & 0 & 0 & 0 \\
  0.436393609858648 & 0.16648564323248321 & 0.10450018841591720 & 0.03631482272098715 & -0.13090704451073998 & 0.26 & 0 & 0 \\
  1 & 0.13855640231268224 & 0 & -0.04245337201752043 & 0.02446657898003141 & 0.61943039072480676 & 0.26 & 0 \\
  1 & 0.13659751177640291 & 0 & -0.05496908796538376 & -0.04118626728321046 & 0.62993304899016403 & 0.06962479448202728 & 0.26 \\
  \hline
  5 & 0.13659751177640291 & 0 & -0.05496908796538376 & -0.04118626728321046 & 0.62993304899016403 & 0.06962479448202728 & 0.26 \\
  4 & 0.13855640231268224 & 0 & -0.04245337201752043 & 0.02446657898003141 & 0.61943039072480676 & 0.26 & 0
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_21.png}}
\caption{Linear stability region for the Kvaerno-7-4-5 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\subsection{ARK-8-4-5 (implicit)}
\label{Butcher:ark-8-4-5-implicit}\label{Butcher:butcher-ark-8-4-5-i}
\index{ARK-8-4-5 ESDIRK method}
\code{ARK548L2SA\_DIRK\_8\_4\_5} for {\hyperref[c_interface/User_callable:c.ARKodeSetIRKTableNum]{\emph{\code{ARKodeSetIRKTableNum()}}}}.  This is
the default 5th order implicit method, and the implicit portion of the
default 5th order additive method.  Both the method and embedding are
A-stable; additionally the method is L-stable (from \phantomsection\label{Butcher:id22}{\hyperref[References:kc2003]{\emph{{[}KC2003{]}}}}).
\begin{gather}
\begin{split}\begin{array}{r|cccccccc}
  0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{41}{100} & \frac{41}{200} & \frac{41}{200} & 0 & 0 & 0 & 0 & 0 & 0 \\
  \frac{2935347310677}{11292855782101} & \frac{41}{400} & -\frac{567603406766}{11931857230679} & \frac{41}{200} & 0 & 0 & 0 & 0 & 0 \\
  \frac{1426016391358}{7196633302097} & \frac{683785636431}{9252920307686} & 0 & -\frac{110385047103}{1367015193373} & \frac{41}{200} & 0 & 0 & 0 & 0 \\
  \frac{92}{100} & \frac{3016520224154}{10081342136671} & 0 & \frac{30586259806659}{12414158314087} & -\frac{22760509404356}{11113319521817} & \frac{41}{200} & 0 & 0 & 0 \\
  \frac{24}{100} & \frac{218866479029}{1489978393911} & 0 & \frac{638256894668}{5436446318841} & -\frac{1179710474555}{5321154724896} & -\frac{60928119172}{8023461067671} & \frac{41}{200} & 0 & 0 \\
  \frac{3}{5} & \frac{1020004230633}{5715676835656} & 0 & \frac{25762820946817}{25263940353407} & -\frac{2161375909145}{9755907335909} & -\frac{211217309593}{5846859502534} & -\frac{4269925059573}{7827059040749} & \frac{41}{200} & 0 \\
  1 & -\frac{872700587467}{9133579230613} & 0 & 0 & \frac{22348218063261}{9555858737531} & -\frac{1143369518992}{8141816002931} & -\frac{39379526789629}{19018526304540} & \frac{32727382324388}{42900044865799} & \frac{41}{200} \\
  \hline
  5 & -\frac{872700587467}{9133579230613} & 0 & 0 & \frac{22348218063261}{9555858737531} & -\frac{1143369518992}{8141816002931} & -\frac{39379526789629}{19018526304540} & \frac{32727382324388}{42900044865799} & \frac{41}{200} \\
  4 & -\frac{975461918565}{9796059967033} & 0 & 0 & \frac{78070527104295}{32432590147079} & -\frac{548382580838}{3424219808633} & -\frac{33438840321285}{15594753105479} & \frac{3629800801594}{4656183773603} & \frac{4035322873751}{18575991585200}
\end{array}\end{split}\notag
\end{gather}\begin{figure}[htbp]
\centering
\capstart

\scalebox{0.500000}{\includegraphics{stab_region_22.png}}
\caption{Linear stability region for the implicit ARK-8-4-5 method.  The method's
region is outlined in blue; the embedding's region is in red.}\end{figure}


\section{Additive Butcher tables}
\label{Butcher:additive-butcher-tables}\label{Butcher:butcher-additive}
In the category of additive Runge-Kutta methods for split implicit and
explicit calculations, ARKode includes methods that have orders 3
through 5, with embeddings that are of orders 2 through 4.  These
Butcher table pairs are as follows:
\begin{itemize}
\item {} 
\index{ARK-4-2-3 ARK method}3rd-order pair:
{\hyperref[Butcher:butcher-ark-4-2-3-e]{\emph{\DUspan{}{ARK-4-2-3 (explicit)}}}} with {\hyperref[Butcher:butcher-ark-4-2-3-i]{\emph{\DUspan{}{ARK-4-2-3 (implicit)}}}},
corresponding to Butcher tables \code{ARK324L2SA\_ERK\_4\_2\_3} and
\code{ARK324L2SA\_DIRK\_4\_2\_3} for {\hyperref[c_interface/User_callable:c.ARKodeSetARKTableNum]{\emph{\code{ARKodeSetARKTableNum()}}}}.

\item {} 
\index{ARK-6-3-4 ARK method}4th-order pair:
{\hyperref[Butcher:butcher-ark-6-3-4-e]{\emph{\DUspan{}{ARK-6-3-4 (explicit)}}}} with {\hyperref[Butcher:butcher-ark-6-3-4-i]{\emph{\DUspan{}{ARK-6-3-4 (implicit)}}}},
corresponding to Butcher tables \code{ARK436L2SA\_ERK\_6\_3\_4} and
\code{ARK436L2SA\_DIRK\_6\_3\_4} for {\hyperref[c_interface/User_callable:c.ARKodeSetARKTableNum]{\emph{\code{ARKodeSetARKTableNum()}}}}.

\item {} 
\index{ARK-8-4-5 ARK method}5th-order pair:
{\hyperref[Butcher:butcher-ark-8-4-5-e]{\emph{\DUspan{}{ARK-8-4-5 (explicit)}}}} with {\hyperref[Butcher:butcher-ark-8-4-5-i]{\emph{\DUspan{}{ARK-8-4-5 (implicit)}}}},
corresponding to Butcher tables \code{ARK548L2SA\_ERK\_8\_4\_5} and
\code{ARK548L2SA\_ERK\_8\_4\_5} for {\hyperref[c_interface/User_callable:c.ARKodeSetARKTableNum]{\emph{\code{ARKodeSetARKTableNum()}}}}.

\end{itemize}
\phantomsection\label{References:references}
\begin{thebibliography}{SuperLUMT}
\bibitem[B1985]{B1985}{\phantomsection\label{References:b1985} 
Bank et al., Transient Simulation of Silicon Devices and
Circuits, \emph{IEEE Trans. CAD}, 4:436-451, 1985.
}
\bibitem[B1983]{B1983}{\phantomsection\label{References:b1983} 
S.R. Billington, Type-Insensitive Codes for the Solution of
Stiff and Nonstiff Systems of Ordinary Differential
Equations, \emph{in: Master Thesis, University of Manchester,
United Kingdom}, 1983.
}
\bibitem[BS1989]{BS1989}{\phantomsection\label{References:bs1989} 
P. Bogacki and L.F. Shampine. A 3(2) pair of Runge–Kutta
formulas, \emph{Appl. Math. Lett.}, 2:321–325, 1989.
}
\bibitem[BH1989]{BH1989}{\phantomsection\label{References:bh1989} 
P.N. Brown and A.C. Hindmarsh. Reduced Storage
Matrix Methods in Stiff ODE Systems. \emph{J. Appl. Math. \&
Comp.}, 31:49-91, 1989.
}
\bibitem[B2008]{B2008}{\phantomsection\label{References:b2008} 
J.C. Butcher, Numerical Methods for Ordinary Differential
Equations. Wiley, 2nd edition, Chicester, England, 2008.
}
\bibitem[B1992]{B1992}{\phantomsection\label{References:b1992} 
G.D. Byrne. Pragmatic Experiments with Krylov Methods
in the Stiff ODE Setting.  In J.R. Cash and I. Gladwell,
editors, \emph{Computational Ordinary Differential Equations},
pp. 323-356, Oxford University Press, 1992.
}
\bibitem[C1979]{C1979}{\phantomsection\label{References:c1979} 
J.R. Cash. Diagonally Implicit Runge-Kutta Formulae with
Error Estimates. \emph{IMA J Appl Math}, 24:293-301, 1979.
}
\bibitem[CK1990]{CK1990}{\phantomsection\label{References:ck1990} 
J.R. Cash and A.H. Karp. A variable order Runge-Kutta
method for initial value problems with rapidly varying
right-hand sides, \emph{ACM Trans. Math. Soft.},
16:201-222, 1990.
}
\bibitem[CGM2014]{CGM2014}{\phantomsection\label{References:cgm2014} 
J. CHeng, M. Grossman and T. McKercher. Professional Cuda
C Programming.  John Wiley \& Sons, 2014.
}
\bibitem[DP1980]{DP1980}{\phantomsection\label{References:dp1980} 
J.R. Dormand and P.J. Prince. A family of embedded
Runge-Kutta formulae, \emph{J. Comput. Appl. Math.} 6:19–26, 1980.
}
\bibitem[DP2010]{DP2010}{\phantomsection\label{References:dp2010} 
T. Davis and E. Palamadai Natarajan.  Algortithm 907: KLU,
a direct sparse solver for circuit simulation
problems. \emph{ACM Trans. Math. Soft.}, 37, 2010.
}
\bibitem[DGL1999]{DGL1999}{\phantomsection\label{References:dgl1999} 
J.W. Demmel, J.R. Gilbert and X.S. Li. An Asynchronous
Parallel Supernodal Algorithm for Sparse Gaussian
Elimination. \emph{SIAM J. Matrix Analysis and Applications},
20:915-952, 1999.
}
\bibitem[F2015]{F2015}{\phantomsection\label{References:f2015} 
R. Falgout and U.M. Yang. Hypre user's manual. \emph{LLNL
Technical Report}, 2015.
}
\bibitem[F1969]{F1969}{\phantomsection\label{References:f1969} 
E. Fehlberg. Low-order classical Runge-Kutta formulas with
step size control and their application to some heat
transfer problems. \emph{NASA Technical Report 315}, 1969.
}
\bibitem[F1993]{F1993}{\phantomsection\label{References:f1993} 
R.W. Freund. A Transpose-Free Quasi-Minimal Residual Algorithm
for Non-Hermitian Linear Systems. \emph{SIAM J. Sci. Comp.},
14:470-482, 1993.
}
\bibitem[G1991]{G1991}{\phantomsection\label{References:g1991} 
K. Gustafsson.  Control theoretic techniques for stepsize
selection in explicit Runge-Kutta methods. \emph{ACM
Trans. Math. Soft.}, 17:533-554, 1991.
}
\bibitem[G1994]{G1994}{\phantomsection\label{References:g1994} 
K. Gustafsson.  Control-theoretic techniques for stepsize
selection in implicit Runge-Kutta methods. \emph{ACM
Trans. Math. Soft.} 20:496-512, 1994.
}
\bibitem[HW1993]{HW1993}{\phantomsection\label{References:hw1993} 
E. Hairer, S. Norsett and G. Wanner.  Solving Ordinary
Differential Equations I. \emph{Springer Series in
Computational Mathematics}, vol. 8, 1993.
}
\bibitem[HW1996]{HW1996}{\phantomsection\label{References:hw1996} 
E. Hairer and G. Wanner. Solving Ordinary Differential
Equations II. \emph{Springer Series in Computational
Mathematics}, vol. 14, 1996.
}
\bibitem[HS1952]{HS1952}{\phantomsection\label{References:hs1952} 
M.R. Hestenes and E. Stiefel. Methods of Conjugate
Gradients for Solving Linear Systems. \emph{J. Research of the
National Bureau of Standards}, 49:409-436, 1952.
}
\bibitem[HS1980]{HS1980}{\phantomsection\label{References:hs1980} 
K.L. Hiebert and L.F. Shampine.  Implicitly Defined Output
Points for Solutions of ODEs.  Technical Report
SAND80-0180, Sandia National Laboratories, February 1980.
}
\bibitem[HS2017]{HS2017}{\phantomsection\label{References:hs2017} 
A.C. Hindmarsh and R. Serban. User Documentation for CVODE
v3.0.0. Technical Report UCRL-SM-208108, LLNL, 2017.
}
\bibitem[HSR2017]{HSR2017}{\phantomsection\label{References:hsr2017} 
A.C. Hindmarsh, R. Serban and D.R. Reynolds. Example
Programs for CVODE v3.0.0. Technical Report
UCRL-SM-208110, LLNL, 2017.
}
\bibitem[HT1998]{HT1998}{\phantomsection\label{References:ht1998} 
A.C. Hindmarsh and A.G. Taylor.  PVODE and KINSOL:
Parallel Software for Differential and Nonlinear
Systems. Technical Report UCRL-IL-129739, LLNL,
February 1998.
}
\bibitem[HK2014]{HK2014}{\phantomsection\label{References:hk2014} 
R.D. Hornung and J.A. Keasler.  The RAJA Portability
Layer: Overview and Status. Technical Report
LLNL-TR-661403, LLNL, September 2014.
}
\bibitem[KC2003]{KC2003}{\phantomsection\label{References:kc2003} 
C.A. Kennedy and M.H. Carpenter. Additive Runge-Kutta
schemes for convection-diffusion-reaction
equations. \emph{Appl. Numer. Math.}, 44:139-181, 2003.
}
\bibitem[KLU]{KLU}{\phantomsection\label{References:klu} 
\href{http://faculty.cse.tamu.edu/davis/suitesparse.html}{KLU Sparse Matrix Factorization Library}.
}
\bibitem[K2004]{K2004}{\phantomsection\label{References:k2004} 
A. Kv\{ae\}rno. Singly Diagonally Implicit Runge-Kutta
Methods with an Explicit First Stage. \emph{BIT Numer. Math.},
44:489-502, 2004.
}
\bibitem[L2005]{L2005}{\phantomsection\label{References:l2005} 
X.S. Li. An Overview of SuperLU: Algorithms,
Implementation, and User Interface. \emph{ACM
Trans. Math. Soft.}, 31:302-325, 2005.
}
\bibitem[R2013]{R2013}{\phantomsection\label{References:r2013} 
D.R. Reynolds. ARKode Example Documentation. Technical
Report, Southern Methodist University Center for Scientific
Computation, 2013.
}
\bibitem[SS1986]{SS1986}{\phantomsection\label{References:ss1986} 
Y. Saad and M.H. Schultz. GMRES: A Generalized Minimal Residual
Algorithm for Solving Nonsymmetric Linear Systems.
\emph{SIAM J. Sci. Stat. Comp.}, 7:856-869, 1986.
}
\bibitem[S1993]{S1993}{\phantomsection\label{References:s1993} 
Y. Saad. A flexible inner-outer preconditioned GMRES
algorithm.  \emph{SIAM J. Sci. Comput.}, 14:461-469, 1993.
}
\bibitem[SA2002]{SA2002}{\phantomsection\label{References:sa2002} 
A. Sayfy and A. Aburub. Embedded Additive Runge-Kutta
Methods. \emph{Intern. J. Computer Math.}, 79:945-953, 2002.
}
\bibitem[S1998]{S1998}{\phantomsection\label{References:s1998} 
G. Soderlind. The automatic control of numerical
integration.  \emph{CWI Quarterly}, 11:55-74, 1998.
}
\bibitem[S2003]{S2003}{\phantomsection\label{References:s2003} 
G. Soderlind. Digital filters in adaptive time-stepping.
\emph{ACM Trans. Math. Soft.}, 29:1-26, 2003.
}
\bibitem[S2006]{S2006}{\phantomsection\label{References:s2006} 
G. Soderlind. Time-step selection algorithms: Adaptivity,
control and signal processing. \emph{Appl. Numer. Math.},
56:488-502, 2006.
}
\bibitem[SuperLUMT]{SuperLUMT}{\phantomsection\label{References:superlumt} 
\href{http://crd-legacy.lbl.gov/~xiaoye/SuperLU/}{SuperLU\_MT Threaded Sparse Matrix Factorization Library}.
}
\bibitem[V1992]{V1992}{\phantomsection\label{References:v1992} 
H.A. Van Der Vorst. Bi-CGSTAB: A Fast and Smoothly Converging Variant
of Bi-CG for the Solution of Nonsymmetric Linear Systems. \emph{SIAM J. Sci. Stat. Comp.},
13:631-644, 1992.
}
\bibitem[V1978]{V1978}{\phantomsection\label{References:v1978} 
J.H. Verner. Explicit Runge-Kutta methods with estimates of
the local truncation error. \emph{SIAM J. Numer. Anal.},
15:772-790, 1978.
}
\bibitem[WN2011]{WN2011}{\phantomsection\label{References:wn2011} 
H.F. Walker and P. Ni. Anderson acceleration for
fixed-point iterations. \emph{SIAM J. Numer. Anal.},
49:1715-1735, 2011.
}
\bibitem[Z1963]{Z1963}{\phantomsection\label{References:z1963} 
J.A. Zonneveld. Automatic integration of ordinary
differential equations. \emph{Report R743, Mathematisch Centrum},
Postbus 4079, 1009AB Amsterdam, 1963.
}
\end{thebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
