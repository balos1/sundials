.. _MRIStep_CInterface.OptionalOutputs:

Optional output functions
------------------------------

MRIStep provides an extensive set of functions that can be used to
obtain solver performance information.  We organize these into groups:

1. SUNDIALS version information accessor routines are in the subsection
   :ref:`MRIStep_CInterface.SUNVersionInfo`,
2. General MRIStep output routines are in the subsection
   :ref:`MRIStep_CInterface.MRIStepMainOutputs`,
3. Output routines regarding root-finding results are in the subsection
   :ref:`MRIStep_CInterface.MRIStepRootOutputs`,
4. General usability routines (e.g. to print the current MRIStep
   parameters, or output the current Butcher tables) are in the
   subsection :ref:`MRIStep_CInterface.MRIStepExtraOutputs`.

Following each table, we elaborate on each function.

Some of the optional outputs, especially the various counters, can be
very useful in determining the efficiency of various methods inside
MRIStep.  For example:

* The counters *nssteps*, *nfsteps*, *nfs_evals*, and *nff_evals* provide a
  rough measure of the overall cost of a given run, and can be compared between
  runs with different solver options to suggest which set of options is the most
  efficient.

It is therefore recommended that users retrieve and output these
statistics following each run, and take some time to investigate
alternate solver options that will be more optimal for their
particular problem of interest.



.. _MRIStep_CInterface.SUNVersionInfo:

SUNDIALS version information
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following functions provide a way to get SUNDIALS version
information at runtime.


.. c:function:: int SUNDIALSGetVersion(char *version, int len)

   This routine fills a string with SUNDIALS version information.

   **Arguments:**
      * *version* -- character array to hold the SUNDIALS version information.
      * *len* -- allocated length of the *version* character array.

   **Return value:**
      * 0 if successful
      * -1 if the input string is too short to store the SUNDIALS version

   **Notes:** An array of 25 characters should be sufficient to hold
   the version information.



.. c:function:: int SUNDIALSGetVersionNumber(int *major, int *minor, int *patch, char *label, int len)

   This routine sets integers for the SUNDIALS major,
   minor, and patch release numbers and fills a string with the
   release label if applicable.

   **Arguments:**
      * *major* -- SUNDIALS release major version number.
      * *minor* -- SUNDIALS release minor version number.
      * *patch* -- SUNDIALS release patch version number.
      * *label* -- string to hold the SUNDIALS release label.
      * *len* -- allocated length of the *label* character array.

   **Return value:**
      * 0 if successful
      * -1 if the input string is too short to store the SUNDIALS label

   **Notes:** An array of 10 characters should be sufficient to hold
   the label information. If a label is not used in the release
   version, no information is copied to *label*.


.. _MRIStep_CInterface.MRIStepMainOutputs:

Main solver optional output functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. cssclass:: table-bordered

===================================================  ============================================
Optional output                                      Function name
===================================================  ============================================
Size of MRIStep real and integer workspaces          :c:func:`MRIStepGetWorkSpace()`
Cumulative numbers of internal steps                 :c:func:`MRIStepGetNumSteps()`
Step size used for the last successful step          :c:func:`MRIStepGetLastStep()`
Name of constant associated with a return flag       :c:func:`MRIStepGetReturnFlagName()`
No. of calls to the *fs* and *ff* functions          :c:func:`MRIStepGetNumRhsEvals()`
Current MRI Butcher tables                           :c:func:`MRIStepGetCurrentButcherTables()`
Last inner stepper return value                      :c:func:`MRIStepGetLastInnerStepFlag()`
===================================================  ============================================

.. Functions not currently provided by MRIStep
.. Current internal time reached by the solver          :c:func:`MRIStepGetCurrentTime()`
.. Suggested factor for tolerance scaling               :c:func:`MRIStepGetTolScaleFactor()`
.. Error weight vector for state variables              :c:func:`MRIStepGetErrWeights()`
.. No. of explicit stability-limited steps              :c:func:`MRIStepGetNumExpSteps()`
.. No. of accuracy-limited steps                        :c:func:`MRIStepGetNumAccSteps()`
.. No. of attempted steps                               :c:func:`MRIStepGetNumStepAttempts()`
.. No. of local error test failures that have occurred  :c:func:`MRIStepGetNumErrTestFails()`
.. Estimated local truncation error vector              :c:func:`MRIStepGetEstLocalErrors()`
.. Single accessor to many statistics at once           :c:func:`MRIStepGetTimestepperStats()`
.. Actual initial time step size used                   :c:func:`MRIStepGetActualInitStep()`
.. Step size to be attempted on the next step           :c:func:`MRIStepGetCurrentStep()`
.. Single accessor to many statistics at once           :c:func:`MRIStepGetStepStats()`

.. c:function:: int MRIStepGetWorkSpace(void* arkode_mem, long int* lenrw, long int* leniw)

   Returns the MRIStep real and integer workspace sizes.

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *lenrw* -- the number of ``realtype`` values in the MRIStep workspace.
      * *leniw* -- the number of integer values in the MRIStep workspace.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


.. c:function:: int MRIStepGetNumSteps(void* arkode_mem, long int* nssteps, long int* nfsteps)

   Returns the cumulative number of slow and fast internal steps taken by
   the solver (so far).

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *nssteps* -- number of slow steps taken in the solver.
      * *nfsteps* -- number of fast steps taken in the solver.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


..
   .. c:function:: int MRIStepGetActualInitStep(void* arkode_mem, realtype* hinused)

      Returns the value of the integration step size used on the first step.

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *hinused* -- actual value of initial step size.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


.. c:function:: int MRIStepGetLastStep(void* arkode_mem, realtype* hlast)

   Returns the integration step size taken on the last successful
   internal step.

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *hlast* -- step size taken on the last internal step.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


..
   .. c:function:: int MRIStepGetCurrentStep(void* arkode_mem, realtype* hcur)

      Returns the integration step size to be attempted on the next internal step.

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *hcur* -- step size to be attempted on the next internal step.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


.. c:function:: int MRIStepGetCurrentTime(void* arkode_mem, realtype* tcur)

   Returns the current internal time reached by the solver.

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *tcur* -- current internal time reached.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


..
   .. c:function:: int MRIStepGetTolScaleFactor(void* arkode_mem, realtype* tolsfac)

      Returns a suggested factor by which the user's
      tolerances should be scaled when too much accuracy has been
      requested for some internal step.

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *tolsfac* -- suggested scaling factor for user-supplied tolerances.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


..
   .. c:function:: int MRIStepGetErrWeights(void* arkode_mem, N_Vector eweight)

      Returns the current error weight vector.

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *eweight* -- solution error weights at the current time.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``

      **Notes:** The user must allocate space for *eweight*, that will be
      filled in by this function.


..
   .. c:function:: int MRIStepGetStepStats(void* arkode_mem, long int* nssteps, long int* nfsteps, realtype* hlast, realtype* tcur)

      Returns many of the most useful optional outputs in a single call.

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *nssteps* -- number of slow steps taken in the solver.
         * *nfsteps* -- number of fast steps taken in the solver.
         * *hlast* -- step size taken on the last internal step.
         * *tcur* -- current internal time reached.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


.. c:function:: char *MRIStepGetReturnFlagName(long int flag)

   Returns the name of the MRIStep constant corresponding to *flag*.

   **Arguments:**
      * *flag* -- a return flag from an MRIStep function.

   **Return value:**
   The return value is a string containing the name of
   the corresponding constant.


..
   .. c:function:: int MRIStepGetNumExpSteps(void* arkode_mem, long int* expsteps)

      Returns the cumulative number of stability-limited steps
      taken by the solver (so far).

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *expsteps* -- number of stability-limited steps taken in the solver.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


..
   .. c:function:: int MRIStepGetNumAccSteps(void* arkode_mem, long int* accsteps)

      Returns the cumulative number of accuracy-limited steps
      taken by the solver (so far).

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *accsteps* -- number of accuracy-limited steps taken in the solver.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


..
   .. c:function:: int MRIStepGetNumStepAttempts(void* arkode_mem, long int* step_attempts)

      Returns the cumulative number of steps attempted by the solver (so far).

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *step_attempts* -- number of steps attempted by solver.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


.. c:function:: int MRIStepGetNumRhsEvals(void* arkode_mem, long int* nfs_evals)

   Returns the number of calls to the user's outer (slow) right-hand side function,
   :math:`fs` (so far). 

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *nfs_evals* -- number of calls to the user's :math:`fs(t,y)` function.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


..
   .. c:function:: int MRIStepGetNumErrTestFails(void* arkode_mem, long int* netfails)

      Returns the number of local error test failures that
      have occurred (so far).

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *netfails* -- number of error test failures.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


.. c:function:: int MRIStepGetCurrentButcherTables(void* arkode_mem, ARKodeButcherTable *Bs, ARKodeButcherTable *Bf)

   Returns the slow and fast Butcher tables currently in use by the solver.

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *Bs* -- pointer to slow Butcher table structure.
      * *Bf* -- pointer to fast Butcher table structure.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``

   **Notes:**  The *ARKodeButcherTable* data structure is defined in
   the header file ``arkode/arkode_butcher.h``.  It is defined as a
   pointer to the following C structure:

   .. code-block:: c

      typedef struct ARKodeButcherTableMem {

        int q;           /* method order of accuracy       */
        int p;           /* embedding order of accuracy    */
        int stages;      /* number of stages               */
        realtype **A;    /* Butcher table coefficients     */
        realtype *c;     /* canopy node coefficients       */
        realtype *b;     /* root node coefficients         */
        realtype *d;     /* embedding coefficients         */

      } *ARKodeButcherTable;


..
   .. c:function:: int MRIStepGetEstLocalErrors(void* arkode_mem, N_Vector ele)

      Returns the vector of estimated local truncation errors
      for the current step.

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *ele* -- vector of estimated local truncation errors.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``

      **Notes:**  The user must allocate space for *ele*, that will be
      filled in by this function.

      The values returned in *ele* are valid only after a successful call
      to :c:func:`MRIStepEvolve()` (i.e. it returned a non-negative value).

      The *ele* vector, together with the *eweight* vector from
      :c:func:`MRIStepGetErrWeights()`, can be used to determine how the
      various components of the system contributed to the estimated local
      error test.  Specifically, that error test uses the WRMS norm of a
      vector whose components are the products of the components of these
      two vectors.  Thus, for example, if there were recent error test
      failures, the components causing the failures are those with largest
      values for the products, denoted loosely as ``eweight[i]*ele[i]``.


..
   .. c:function:: int MRIStepGetTimestepperStats(void* arkode_mem, long int* expsteps, long int* accsteps, long int* step_attempts, long int* nf_evals, long int* netfails)

      Returns many of the most useful time-stepper statistics in a single call.

      **Arguments:**
         * *arkode_mem* -- pointer to the MRIStep memory block.
         * *expsteps* -- number of stability-limited steps taken in the solver.
         * *accsteps* -- number of accuracy-limited steps taken in the solver.
         * *step_attempts* -- number of steps attempted by the solver.
         * *nf_evals* -- number of calls to the user's :math:`f(t,y)` function.
         * *netfails* -- number of error test failures.

      **Return value:**
         * *ARK_SUCCESS* if successful
         * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``

.. c:function:: int MRIStepGetLastInnerStepFlag(void* arkode_mem, int* flag)

   Returns the last return value from the inner stepper.

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *flag* -- inner stepper return value.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``


.. _MRIStep_CInterface.MRIStepExtraOutputs:

General usability functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following optional routines may be called by a user to inquire
about existing solver parameters, to retrieve stored Butcher tables,
write the current Butcher table, or even to test a provided Butcher
table to determine its analytical order of accuracy.  While none of
these would typically be called during the course of solving an
initial value problem, these may be useful for users wishing to better
understand MRIStep and/or specific Runge-Kutta methods.


.. cssclass:: table-bordered

===========================================================  ========================================
Optional routine                                             Function name
===========================================================  ========================================
Output all MRIStep solver parameters                         :c:func:`MRIStepWriteParameters()`
Output the current Butcher tables                            :c:func:`MRIStepWriteButcher()`
===========================================================  ========================================


.. c:function:: int MRIStepWriteParameters(void* arkode_mem, FILE *fp)

   Outputs all MRIStep solver parameters to the provided file pointer.

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *fp* -- pointer to use for printing the solver parameters.

   **Return value:**
      * *ARKS_SUCCESS* if successful
      * *ARKS_MEM_NULL* if the MRIStep memory was ``NULL``

   **Notes:** The *fp* argument can be ``stdout`` or ``stderr``, or it
   may point to a specific file created using ``fopen``.

   When run in parallel, only one process should set a non-NULL value
   for this pointer, since parameters for all processes would be
   identical.


.. c:function:: int MRIStepWriteButcher(void* arkode_mem, FILE *fp)

   Outputs the current Butcher tables to the provided file pointer.

   **Arguments:**
      * *arkode_mem* -- pointer to the MRIStep memory block.
      * *fp* -- pointer to use for printing the Butcher tables.

   **Return value:**
      * *ARK_SUCCESS* if successful
      * *ARK_MEM_NULL* if the MRIStep memory was ``NULL``

   **Notes:** The *fp* argument can be ``stdout`` or ``stderr``, or it
   may point to a specific file created using ``fopen``.

   When run in parallel, only one process should set a non-NULL value
   for this pointer, since tables for all processes would be
   identical.
