%===============================================================================
\chapter{Description of the SUNNonlinearSolver module}\label{c:sunnonlinsol}
%===============================================================================
\index{SUNNonlinearSolver@\texttt{SUNNonlinearSolver} module}
\input{sunnonlinsol_generic}

%---------------------------------------------------------------------------
\section{CVODE SUNNonlinearSolver interface}
\label{s:sunnonlinsol_interface}
%---------------------------------------------------------------------------

As discussed in Chapter \ref{s:math} each integration step requires the
(approximate) solution of a nonlinear system. This system can be formulated as
the rootfinding problem
\begin{equation}
  F(y^n) \equiv y^n - h_n \beta_{n,0} f(t_n,y^n) - a_n = 0 \, ,
\end{equation}
or as the fixed-point problem
\begin{equation}
  G(y^n) \equiv h_n \beta_{n,0} f(t_n,y^n) + a_n = y^n \, ,
\end{equation}
where $a_n\equiv\sum_{i>0}(\alpha_{n,i}y^{n-i}+h_n\beta_{n,i} {\dot{y}}^{n-i})$.

Rather than solving the above nonlinear systems for the new state $y^n$
{\cvode} reformulates the above problems to solve for the correction $y_{cor}$
to the predicted new state $y_{pred}$ so that $y^n = y_{pred} + y_{cor}$.
The nonlinear systems rewritten in terms of $y_{cor}$ are
\begin{equation} \label{eq:res_corrector}
  F(y_{cor}) \equiv y_{cor} - \gamma f(t_n, y^n) - \tilde{a}_n = 0 \, ,
\end{equation}
for the rootfinding problem and
\begin{equation} \label{eq:fp_corrector}
  G(y_{cor}) \equiv \gamma f(t_n, y^n) + \tilde{a}_n = y_{cor} \, .
\end{equation}
for the fixed-point problem.

The nonlinear system functions provided by {\cvode} to the nonlinear solver
module internally update the current value of the new state based on the input
correction vector i.e., $y^n = y_{pred} + y_{cor}$. The updated vector $y^n$ is
used when calling the ODE right-hand side function and when setting up linear
solves (e.g., updating the Jacobian or preconditioner).

{\cvode} provides several advanced functions that will not be needed by most
users, but might be useful for users who choose to provide their own
implementation of the \id{SUNNonlinearSolver} API. For example, such a user
might need access to the current value of $\gamma$ to compute Jacobian data.

\ucfunctionf{CVodeGetCurrentGamma}
{
  flag = CVodeGetCurrentGamma(cvode\_mem, \&gamma);
}
{
  The function \ID{CVodeGetCurrentGamma} returns the current
  value of the scalar $\gamma$.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvode} memory block.
  \item[gamma] (\id{realtype *})
      the current value of the scalar $\gamma$ appearing in the
      Newton equation $M = I - \gamma J$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[CV\_SUCCESS]
    The optional output value has been successfully set.
  \item[CV\_MEM\_NULL]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetCurrentState}
{
  flag = CVodeGetCurrentState(cvode\_mem, \&y);
}
{
  The function \ID{CVodeGetCurrentState} returns the current state vector. When
  called within the computation of a step (i.e., during a nonlinear solve) this
  is $y^n = y_{pred} + y_{cor}$. Otherwise this is the current internal solution
  vector $y(t)$. In either case the corresponding solution time can be obtained
  from \id{CVodeGetCurrentTime}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvode} memory block.
  \item[y] (\id{N\_Vector *})
    pointer that is set to the current state vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[CV\_SUCCESS]
    The optional output value has been successfully set.
  \item[CV\_MEM\_NULL]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetNonlinearSystemData}
{
  flag = CVodeGetNonlinearSystemData(&cvode\_mem, \&tn, \&ypred, \&yn, \&fn,\\
                                     &\&gamma, \&rl1, \&zn1, \&user\_data);
}
{
  The function \ID{CVodeGetNonlinearSystemData} returns all internal
  data required to construct the current nonlinear system
  \eqref{eq:res_corrector} or \eqref{eq:fp_corrector}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *}) pointer to the {\cvode} memory block.
  \item[tn] (\id{realtype*}) current value of the independent variable $t_n$.
  \item[ypred] (\id{N\_Vector*}) predicted state vector $y_{pred}$ at $t_n$.
    This vector must not be changed.
  \item[yn] (\id{N\_Vector*}) state vector $y^n$. This vector may be
    not current and may need to be filled (see the note below).
  \item[fn] (\id{N\_Vector*}) the right-hand side function evaluated at the
    current time and state, $f(t_n, y^n)$. This vector may be
    not current and may need to be filled (see the note below).
  \item[gamma] (\id{realtype*}) current value of $\gamma$.
  \item[rl1] (\id{realtype*}) a scaling factor used to compute $\tilde{a}_n = $
    \id{rl1 * zn1}.
  \item[zn1] (\id{N\_Vector*}) a vector used to compute $\tilde{a}_n = $
    \id{rl1 * zn1}.
  \item[user\_data] (\id{void**}) pointer to the user-defined data structures
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[CV\_SUCCESS]
    The optional output values have been successfully set.
  \item[CV\_MEM\_NULL]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  This routine is intended for users who wish to attach a custom
  \id{SUNNonlinSolSysFn} (see \S\ref{ss:sunnonlinsol_sunsuppliedfn}) to an
  existing \id{SUNNonlinearSolver} object (through a call to
  \id{SUNNonlinSolSetSysFn}) or who need access to nonlinear system data to
  compute the nonlinear system fucntion as part of a custom
  \id{SUNNonlinearSolver} object.

  When supplying a custom \id{SUNNonlinSolSysFn} to an existing
  \id{SUNNonlinearSolver} object, the user should call
  \id{CVodeGetNonlinearSystemData} \textbf{inside} the nonlinear system
  function to access the requisite data for evaluting the nonlinear system
  function of their choosing. Additionlly, if the \id{SUNNonlinearSolver} object
  (existing or custom) leverages the \id{SUNNonlinSolLSetupFn} and/or
  \id{SUNNonlinSolLSolveFn} functions supplied by {\cvode} (through calls to
  \id{SUNNonlinSolSetLSetupFn} and \id{SUNNonlinSolSetLSolveFn} respectively)
  the vectors \id{yn} and \id{fn} \textbf{must be filled} in by the user's
  \id{SUNNonlinSolSysFn} with the current state and corresponding evaluation of
  the right-hand side function respectively i.e.,
  \begin{align*}
    yn &= y_{pred} + y_{cor}, \\
    fn &= f\left(t_{n}, y^n\right),
  \end{align*}
  where $y_{cor}$ was the first argument supplied to the \id{SUNNonlinSolSysFn}.

  If this function is called as part of a custom linear solver (i.e., the
  default \id{SUNNonlinSolSysFn} is used) then the vectors \id{yn} and \id{fn}
  are only current when \id{CVodeGetNonlinearSystemData} is called after an
  evaluation of the nonlinear system function.
}
%%
%%
\ucfunctionf{CVodeComputeState}
{
  flag = CVodeComputeState(cvode\_mem, ycor, yn);
}
{
  The function computes the current $y(t)$ vector based on stored prediction and
  the given correction vector from the nonlinear solver i.e.,
  $y^n = y_{pred} + y_{cor}$.
}
{
  \begin{args}[cvode\_mem]
    \item[cvode\_mem] - (\id{void *}) pointer to the {\cvode} memory block
    \item[ycor] - (\id{N\_Vector}) the correction
    \item[yn] - (\id{N\_Vector}) the output vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVODE\_MEM\_NULL]
  \item[CV\_SUCCESS]
    The optional output value has been successfully set.
  \item[CV\_MEM\_NULL]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

%---------------------------------------------------------------------------
% sunnonlinsol module sections
%---------------------------------------------------------------------------

\input{sunnonlinsol_newton}
\input{sunnonlinsol_fixedpoint}
\input{sunnonlinsol_petscsnes}
