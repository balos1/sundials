%===================================================================================
\chapter{Using CVODES for Adjoint Sensitivity Analysis}\label{s:adjoint}
%===================================================================================

This chapter describes the use of {\cvodes} to compute sensitivities of derived
functions using adjoint sensitivity analysis. As mentioned before, the adjoint
sensitivity module of {\cvodes} provides the infrastructure for integrating
backward in time any system of ODEs that depends on the solution of the original
IVP, by providing various interfaces to the main {\cvodes} integrator, as well
as several supporting user-callable functions. For this reason, in the following
sections we refer to the {\em backward problem} and not to the
{\em adjoint problem} when discussing details relevant to the ODEs that
are integrated backward in  time. The backward problem can be the adjoint problem
(\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}), and
can be augmented with some quadrature differential equations.

{\cvodes} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

We begin with a brief overview, in the form of a skeleton user program.
Following that are detailed descriptions of the interface to the
various user-callable functions and of the user-supplied functions that were not
already described in Chapter \ref{s:simulation}.

%%
%%---------------------------------------------
%%---------------------------------------------
\section{A skeleton of the user's main program}
\label{ss:skeleton_adj}
%%---------------------------------------------
%%---------------------------------------------
%%

The following is a skeleton of the user's main program as an application of
{\cvodes}. The user program is to have these steps in the order indicated,
unless otherwise noted. For the sake of brevity, we defer many of the details
to the later sections.
As in \S\ref{ss:skeleton_sim}, most steps are independent of
the {\nvector}, {\sunmatrix}, {\sunlinsol}, and {\sunnonlinsol}
implementations used. For the steps that are not, refer to Chapters
\ref{s:nvector}, \ref{s:sunmatrix}, \ref{s:sunlinsol}, and \ref{c:sunnonlinsol}
for the specific name of the function to be called or macro to be referenced.

Steps that are unchanged from the skeleton programs presented in
\S\ref{ss:skeleton_sim}, \S\ref{s:forward_usage}, and
\S\ref{s:forward_quad_usage}, are grayed out.

\index{User main program!Adjoint sensitivity analysis}
\begin{Steps}

\item
  \textcolor{gray}{\bf Include necessary header files}

  The \id{cvodes.h} header file also defines additional types, constants, and
  function prototypes for the adjoint sensitivity module user-callable functions.
  In addition, the main program should include an {\nvector} implementation
  header file (for the particular implementation used), and, if a nonlinear
  solver requiring a linear solver (e.g., the default Newton iteration) will be
  used, the header file of the desired linear solver module.

\item
  \textcolor{gray}{\bf Initialize parallel or multi-threaded environment,
  if appropriate}

  \vspace{0.2in}\centerline{\bf Forward problem}

\item
  \textcolor{gray}{\bf Set problem dimensions etc. for the forward problem}

\item
  \textcolor{gray}{\bf Set initial conditions for the forward problem}

\item
  \textcolor{gray}{\bf Create {\cvodes} object for the forward problem}

\item
  \textcolor{gray}{\bf Initialize {\cvodes} for the forward problem}

\item
  \textcolor{gray}{\bf Specify integration tolerances for forward problem}

\item
  \textcolor{gray}{\bf Create matrix object for the forward problem}

\item
  \textcolor{gray}{\bf Create linear solver object for the forward problem}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Attach linear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Set optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Create nonlinear solver object for the forward problem}

\item
  \textcolor{gray}{\bf Attach nonlinear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Set nonlinear solver optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Initialize quadrature problem or problems for forward
    problems, using \id{CVodeQuadInit} and/or \id{CVodeQuadSensInit}.}

\item
  \textcolor{gray}{\bf Initialize forward sensitivity problem}

\item
  \textcolor{gray}{\bf Specify rootfinding}

\item
  {\bf Allocate space for the adjoint computation}

  Call \Id{CVodeAdjInit}\id{()} to allocate memory for the
  combined forward-backward problem (see \S\ref{sss:cvadjinit} for details).
  This call requires \id{Nd}, the number of steps between two consecutive checkpoints.
  \Id{CVodeAdjInit} also specifies the type of interpolation used
  (see \S\ref{ss:checkpointing}).

\item
  {\bf Integrate forward problem}

  Call \Id{CVodeF}, a wrapper for the {\cvodes} main integration
  function \id{CVode}, either in \Id{CV\_NORMAL} mode to the time
  \id{tout} or in \Id{CV\_ONE\_STEP} mode inside a loop (if intermediate
  solutions of the forward problem are desired (see \S\ref{sss:cvsolvef})).
  The final value of \id{tret} is then the maximum allowable value for the
  endpoint $T$ of the backward problem.

  \vspace{0.2in}\centerline{\bf Backward problem(s)}

 \item \label{i:back_start}
   {\bf Set problem dimensions etc. for the backward problem}

   This generally includes the backward problem vector length \id{NB},
   and possibly the local vector length \id{NBlocal}.

\item
  {\bf Set initial values for the backward problem}

  Set the endpoint time \id{tB0} $= T$, and set the corresponding vector \id{yB0}
  at which the backward problem starts.

\item
  {\bf Create the backward problem}

  Call \Id{CVodeCreateB}, a wrapper for \id{CVodeCreate}, to
  create the {\cvodes} memory block for the new backward problem. Unlike
  \id{CVodeCreate}, the function \id{CVodeCreateB} does not return a pointer to
  the newly created memory block (see \S\ref{sss:cvinitb}). Instead, this pointer
  is attached to the internal adjoint memory  block (created by \id{CVodeAdjInit})
  and returns an identifier called \id{which} that the user must later specify
  in any actions on the newly created backward problem.

\item
  {\bf Allocate memory for the backward problem}

  Call \Id{CVodeInitB} (or \Id{CVodeInitBS}, when the backward problem depends on the
  forward sensitivities). The two functions are actually wrappers for \id{CVodeInit}
  and allocate internal memory, specify problem data, and initialize {\cvodes}
  at \id{tB0} for the backward problem (see \S\ref{sss:cvinitb}).

\item
  {\bf Specify integration tolerances for backward problem}

  Call \id{CVodeSStolerancesB}\id{(...)} or \id{CVodeSVtolerancesB}\id{(...)}
  to specify a scalar relative tolerance and scalar absolute tolerance or
  scalar relative tolerance and a vector of absolute tolerances, respectively.
  The functions are wrappers for \id{CVodeSStolerances} and
  \id{CVodeSVtolerances}, but they require an extra argument \id{which},
  the identifier of the backward problem returned by \id{CVodeCreateB}.
  See \S\ref{sss:cvtolerances_b} for more information.


\item \label{i:matrixB}
  {\bf Create matrix object for the backward problem}

  If a nonlinear solver requiring a linear solve will be used (e.g., the
  the default Newton iteration) and the linear solver will be a direct linear
  solver, then a template Jacobian matrix must be created by calling the
  appropriate constructor function defined by the particular {\sunmatrix}
  implementation.

  For the {\sundials}-supplied {\sunmatrix} implementations, the
  matrix object may be created using a call of the form

  \id{SUNMatrix J = }\Id{SUNBandMatrix}\id{(...);}

   or

  \id{SUNMatrix J = }\Id{SUNDenseMatrix}\id{(...);}

   or

  \id{SUNMatrix J = }\Id{SUNSparseMatrix}\id{(...);}

  NOTE: The dense, banded, and sparse matrix objects are usable only in a
  serial or threaded environment.

  Note also that it is not required to use the same matrix type for both the forward
  and the backward problems.

\item \label{i:lin_solverB}
  {\bf Create linear solver object for the backward problem}

  If a nonlinear solver requiring a linear solver is chosen (e.g., the default
  Newton iteration), then the desired linear solver object for the backward
  problem must be created by calling the appropriate constructor function
  defined by the particular {\sunlinsol} implementation.

  For any of the {\sundials}-supplied {\sunlinsol} implementations,
  the linear solver object may be created using a call of the form

  \id{SUNLinearSolver LS = SUNLinSol\_*(...);}

  where \id{*} can be replaced with ``Dense'', ``SPGMR'', or other
  options, as discussed in \S\ref{sss:lin_solv_init} and Chapter {\ref{s:sunlinsol}}.

  Note that it is not required to use the same linear solver module for both the forward
  and the backward problems; for example, the forward problem could be solved
  with the {\sunlinsoldense} linear solver module and the backward problem with
  {\sunlinsolspgmr} linear solver module.

\item
  {\bf Set linear solver interface optional inputs for the backward problem}

  Call \id{*Set*} functions from the selected linear solver module to
  change optional inputs specific to that linear solver.
  See the documentation for each {\sunlinsol} module in Chapter
  {\ref{s:sunlinsol}} for details.

\item\label{i:lin_solver_interfaceB}
  {\bf Attach linear solver module for the backward problem}

  If a nonlinear solver requiring a linear solver is chosen for the backward
  problem (e.g., the default Newton iteration), then initialize the
  {\cvls} linear solver interface by attaching the linear solver
  object (and matrix object, if applicable) with the call (for details see
  \S\ref{sss:lin_solv_init}):

  \id{ier = }\Id{CVodeSetLinearSolverB}\id{(...);}

  Alternately, if the {\cvodes}-specific diagonal linear solver module,
  {\cvdiag}, is desired, initialize the linear solver module and
  attach it to {\cvodes} with the call

  \id{ier = }\Id{CVDiagB}\id{(...);}

\item
  {\bf Set optional inputs for the backward problem}

  Call \id{CVodeSet*B} functions to change from their default values
  any optional inputs that control the behavior of {\cvodes}. Unlike
  their counterparts for the forward problem, these functions take an
  extra argument \id{which}, the identifier of the backward problem returned
  by \id{CVodeCreateB} (see \S\ref{ss:optional_input_b}).

\item
  {\bf Create nonlinear solver object for the backward problem} (\textit{optional})

  If using a non-default nonlinear solver for the backward problem, then create
  the desired nonlinear solver object by calling the appropriate constructor
  function defined by the particular {\sunnonlinsol} implementation (e.g.,
  \id{NLSB = SUNNonlinSol\_***(...);} where \id{***} is the name of the
  nonlinear solver (see Chapter \ref{c:sunnonlinsol} for details).

\item
  {\bf Attach nonlinear solver module for the backward problem} (\textit{optional})

  If using a non-default nonlinear solver for the backward problem, then
  initialize the nonlinear solver interface by attaching the nonlinear solver
  object by calling \\ \noindent
  \id{ier = }\Id{CVodeSetNonlinearSolverB}\id{(cvode\_mem, NLSB);}
  (see \S\ref{ss:nonlin_solv_init_b} for details).

\item \label{i:quadB}
  {\bf Initialize quadrature calculation}

  If additional quadrature equations must be evaluated,
  call \id{CVodeQuadInitB} or \id{CVodeQuadInitBS} (if quadrature depends also on the
  forward sensitivities) as shown in \S\ref{sss:cvquadinitb}. These functions are
  wrappers around \id{CVodeQuadInit} and can be used to initialize and allocate
  memory for quadrature integration. Optionally, call \id{CVodeSetQuad*B} functions
  to change from their default values optional inputs that control the integration
  of quadratures during the backward phase.

\item
  {\bf Integrate backward problem}

  Call \Id{CVodeB}, a second wrapper around the {\cvodes} main integration
  function \id{CVode}, to integrate the backward problem from \id{tB0}
  (see \S\ref{sss:cvsolveb}). This function can be called either in \id{CV\_NORMAL}
  or \id{CV\_ONE\_STEP} mode. Typically, \id{CVodeB} will be called in \id{CV\_NORMAL}
  mode with an end time equal to the initial time $t_0$ of the forward problem.

\item \label{i:back_end}
  {\bf Extract quadrature variables}

  If applicable, call \Id{CVodeGetQuadB}, a wrapper around \id{CVodeGetQuad},
  to extract the values of the quadrature variables at the time returned
  by the last call to \id{CVodeB}. See \S\ref{sss:quad_get_b}.

\item
  {\bf Deallocate memory}

  Upon completion of the backward integration, call all necessary deallocation
  functions. These include appropriate destructors for the vectors
  \id{y} and \id{yB}, a call to \id{CVodeFree} to free the {\cvodes} memory block
  for the forward problem.  If one or more additional Adjoint
  Sensitivity Analyses are
  to be done for this problem, a call to \id{CVodeAdjFree} (see \S\ref{sss:cvadjinit})
  may be made to free and deallocate memory allocated for the backward problems,
  followed by a call to \id{CVodeAdjInit}.

\item
  {\bf Free the nonlinear solver memory for the forward and backward problems}

\item
  {\bf Free linear solver and matrix memory for the forward and backward problems}

\item
  \textcolor{gray}{\bf Finalize MPI, if used}

\end{Steps}

The above user interface to the adjoint sensitivity module in {\cvodes} was motivated by
the desire to keep it as close as possible in look and feel to the one for ODE IVP
integration. Note that if steps (\ref{i:back_start})-(\ref{i:back_end}) are not present,
a program with the above structure will have the same functionality as one described in
\S\ref{ss:skeleton_sim} for integration of ODEs, albeit with some overhead due to
the checkpointing scheme.

If there are multiple backward problems associated with the same forward problem,
repeat steps (\ref{i:back_start})-(\ref{i:back_end}) above for each successive
backward problem.  In the process, each call to \id{CVodeCreateB} creates a new
value of the identifier \id{which}.

%%
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
\section{User-callable functions for adjoint sensitivity analysis}
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
%%

%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity allocation and deallocation functions}
\label{sss:cvadjinit}
%%-------------------------------------------------------------------------------

After the setup phase for the forward problem, but before the call
to \id{CVodeF}, memory for the combined forward-backward problem must be
allocated by a call to the function \id{CVodeAdjInit}.
The form of the call to this function is
%%
%%
\ucfunctionf{CVodeAdjInit}
{
  flag = CVodeAdjInit(cvode\_mem, Nd, interpType);
}
{
  The function \ID{CVodeAdjInit} updates {\cvodes} memory block by allocating
  the internal memory needed for backward integration.
  Space is allocated for the \id{Nd} $= N_d$ interpolation data points, and a linked
  list of checkpoints is initialized.
}
{
  \begin{args}[interpType]
  \item[cvode\_mem] (\id{void *})
    is the pointer to the {\cvodes} memory block returned by a previous call to
    \id{CVodeCreate}.
  \item[Nd] (\id{long int})
    is the number of integration steps between two consecutive checkpoints.
  \item[interpType] (\id{int})
    specifies the type of interpolation used and can be \Id{CV\_POLYNOMIAL}
    or \Id{CV\_HERMITE}, indicating variable-degree polynomial and cubic Hermite
    interpolation, respectively (see \S\ref{ss:checkpointing}).
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[CV\_ILL\_INPUT]
   \item[\Id{CV\_SUCCESS}]
     \id{CVodeAdjInit} was successful.
   \item[\Id{CV\_MEM\_FAIL}]
     A memory allocation request has failed.
   \item[CV\_MEM\_NULL]
     \id{cvode\_mem} was NULL.
   \item[\Id{CV\_ILL\_INPUT}]
     One of the parameters was invalid: \id{Nd} was not positive or \id{interpType}
     is not one of the \id{CV\_POLYNOMIAL} or \id{CV\_HERMITE}.
   \end{args}
}
{
  The user must set \id{Nd} so that all data needed for interpolation of the
  forward problem solution between two checkpoints fits in memory. \id{CVodeAdjInit}
  attempts to allocate space for $(2$\id{Nd}$+3)$ variables of type \id{N\_Vector}.

  If an error occurred, \id{CVodeAdjInit} also sends a message to the
  error handler function.
}
%%
%%
\ucfunctionf{CVodeAdjReInit}
{
  flag = CVodeAdjReInit(cvode\_mem);
}
{
  The function \ID{CVodeAdjReInit} reinitializes the {\cvodes} memory
  block for ASA, assuming that the number of steps between check
  points and the type of interpolation remain unchanged.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    is the pointer to the {\cvodes} memory block returned by a previous call to
    \id{CVodeCreate}.
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[CV\_MEM\_NULL]
   \item[\Id{CV\_SUCCESS}]
     \id{CVodeAdjReInit} was successful.
   \item[CV\_MEM\_NULL]
     \id{cvode\_mem} was NULL.
   \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} was not previously called.
   \end{args}
}
{
  The list of check points (and associated memory) is deleted.

  The list of backward problems is kept. However, new backward problems can
  be added to this list by calling \id{CVodeCreateB}. If a new list of backward
  problems is also needed, then free the adjoint memory (by calling
  \id{CVodeAdjFree}) and reinitialize ASA with \id{CVodeAdjInit}.

  The {\cvodes} memory for the forward and backward problems can be reinitialized
  separately by calling \id{CVodeReInit} and \id{CVodeReInitB}, respectively.
}
%%
%%
\ucfunctionf{CVodeAdjFree}
{
  CVodeAdjFree(cvode\_mem);
}
{
  The function \ID{CVodeAdjFree} frees the memory related to backward integration
  allocated by a previous call to \id{CVodeAdjInit}.
}
{
  The only argument is the {\cvodes} memory block pointer returned by a previous call
  to \id{CVodeCreate}.
}
{
  The function \id{CVodeAdjFree} has no return value.
}
{
  This function frees all memory allocated by \id{CVodeAdjInit}. This
  includes workspace memory, the linked list of checkpoints, memory
  for the interpolation data, as well as the {\cvodes} memory for the
  backward integration phase.  Unless one or more further calls to \id{CVodeAdjInit}
  are to be made, \id{CVodeAdjFree} should not be called by the user, as it is
  invoked automatically by \id{CVodeFree}.
}
%%
%%

%%---------------------------------------------------------------------
\subsection{Forward integration function}
\label{sss:cvsolvef}
%%---------------------------------------------------------------------

The function \ID{CVodeF} is very similar to the {\cvodes} function \id{CVode}
(see \S\ref{sss:cvode}) in that it integrates the solution of the forward
problem and returns the solution in \id{y}. At the same time, however,
\id{CVodeF} stores checkpoint data every \id{Nd} integration steps. \id{CVodeF}
can be called repeatedly by the user.
%%
Note that \id{CVodeF} is used only for the forward integration pass within
an Adjoint Sensitivity Analysis.  It is not for use in Forward Sensitivity
Analysis; for that, see Chapter \ref{s:forward}.
%%
The call to this function has the form
%%
\ucfunctionf{CVodeF}
{
  flag = CVodeF(cvode\_mem, tout, yret, \&tret, itask, \&ncheck);
}
{
  The function \ID{CVodeF} integrates the forward problem over an interval in $t$
  and saves checkpointing data.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[yret] (\id{N\_Vector})
    the computed solution vector $y$.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}}
    \index{output mode}
    a flag indicating the job of the solver for the next step.
    The \Id{CV\_NORMAL} task is to have the solver take internal steps until
    it has reached or just passed the user-specified \id{tout}
    parameter. The solver then interpolates in order to
    return an approximate value of $y($\id{tout}$)$.
    The \Id{CV\_ONE\_STEP} option tells the solver to just take one internal step
    and return the solution at the point reached by that step.
  \item[ncheck] (\id{int})
    the number of (internal) checkpoints stored so far.
  \end{args}
}
{
  On return, \id{CVodeF} returns the vector \id{yret} and a corresponding
  independent variable value $t =$ \id{tret}, such that \id{yret} is the computed
  value of $y(t)$. Additionally, it returns in \id{ncheck} the number of
  internal checkpoints saved; the total number of checkpoint intervals is
  \id{ncheck}$ + 1$.
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:cvode}.
  \begin{args}[CV\_TOO\_MUCH\_WORK]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeF} succeeded.
  \item[\Id{CV\_TSTOP\_RETURN}]
    \id{CVodeF} succeeded by reaching the optional stopping point.
  \item[\Id{CV\_ROOT\_RETURN}]
    \id{CVodeF} succeeded and found one or more roots.  In this case,
    \id{tret} is the location of the root.  If \id{nrtfn} $>1$, call
    \id{CVodeGetRootInfo} to see which $g_i$ were found to have a root.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVodeF} is illegal.
  \item[\Id{CV\_TOO\_MUCH\_WORK}]
    The solver took \id{mxstep} internal steps but could not reach \id{tout}.
  \item[\Id{CV\_TOO\_MUCH\_ACC}]
    The solver could not satisfy the accuracy demanded by the user for some
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Error test failures occurred too many times during one
    internal time step or occurred with $|h| = h_{min}$.
  \item[\Id{CV\_CONV\_FAILURE}]
    Convergence test failures occurred too many times during
    one internal time step or occurred with $|h| = h_{min}$.
  \item[\Id{CV\_LSETUP\_FAIL}]
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_LSOLVE\_FAIL}]
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request has failed (in an attempt to allocate space
    for a new checkpoint).
  \end{args}
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{CVodeF} failures.

  At this time, \id{CVodeF} stores checkpoint information in memory only.
  Future versions will provide for a safeguard option of dumping checkpoint
  data into a temporary file as needed. The data stored at each checkpoint is basically
  a snapshot of the {\cvodes} internal memory block and contains enough information
  to restart the integration from that time and to proceed with the same step size and
  method order sequence as during the forward integration.

  In addition, \id{CVodeF} also stores interpolation data between consecutive checkpoints
  so that, at the end of this first forward integration phase, interpolation information
  is already available from the last checkpoint forward. In particular,
  if no checkpoints were necessary, there is no need for the second forward integration phase.

  {\warn}It is illegal to change the integration tolerances between consecutive calls
  to \id{CVodeF}, as this information is not captured in the checkpoint data.
}

%%---------------------------------------------------------------------
\subsection{Backward problem initialization functions}
\label{sss:cvinitb}
%%---------------------------------------------------------------------

The functions \id{CVodeCreateB} and \id{CVodeInitB} (or \id{CVodeInitBS}) must be
called in the order listed. They instantiate a {\cvodes} solver object, provide problem
and solution specifications, and allocate internal memory for the backward problem.
%%
%%
\ucfunctionf{CVodeCreateB}
{
  flag = CVodeCreateB(cvode\_mem, lmmB, \&which);
}
{
  The function \ID{CVodeCreateB} instantiates a {\cvodes} solver object and specifies
  the solution method for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[lmmB] (\id{int})
    specifies the linear multistep method and may be one of two
    possible values: \Id{CV\_ADAMS} or \Id{CV\_BDF}.
  \item[which] (\id{int})
    contains the identifier assigned by {\cvodes} for the newly created backward
    problem. Any call to \id{CVode*B} functions requires such an identifier.
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[CV\_MEM\_FAIL]
   \item[\Id{CV\_SUCCESS}]
     The call to \id{CVodeCreateB} was successful.
   \item[\Id{CV\_MEM\_NULL}]
     \id{cvode\_mem} was \id{NULL}.
   \item[\Id{CV\_NO\_ADJ}]
     The function \id{CVodeAdjInit} has not been previously called.
   \item[\Id{CV\_MEM\_FAIL}]
     A memory allocation request has failed.
   \end{args}
}
{}
%%
%%

There are two initialization functions for the backward problem -- one for
the case when the backward problem does not depend on the forward
sensitivities, and one for the case when it does.  These two functions
are described next.

The function \id{CVodeInitB} initializes the backward problem when it does
not depend on the forward sensitivities.  It is essentially a wrapper for
\id{CVodeInit} with some particularization for backward integration, as described below.

\ucfunctionf{CVodeInitB}
{
  flag = CVodeInitB(cvode\_mem, which, rhsB, tB0, yB0);
}
{
  The function \ID{CVodeInitB} provides problem specification, allocates internal memory,
  and initializes the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[rhsB] (\Id{CVRhsFnB})
    is the {\CC} function which computes $fB$, the right-hand side of the
    backward ODE problem. This function has the form
    \id{rhsB(t, y, yB, yBdot, user\_dataB)} (for full details see \S\ref{ss:ODErhs_b}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the
    backward problem, normally equal to the endpoint of the forward integration.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or either
    \id{yB0} or \id{rhsB} was \id{NULL}.
  \end{args}
}
{
  The memory allocated by \id{CVodeInitB} is deallocated by the function
  \id{CVodeAdjFree}.
}

For the case when backward problem also depends on the forward
sensitivities, user must call \id{CVodeInitBS} instead of \id{CVodeInitB}.
Only the third argument of each function differs between these two
functions.

\ucfunctionf{CVodeInitBS}
{
  flag = CVodeInitBS(cvode\_mem, which, rhsBS, tB0, yB0);
}
{
  The function \ID{CVodeInitBS} provides problem specification, allocates internal memory,
  and initializes the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[rhsBS] (\Id{CVRhsFnBS})
    is the {\CC} function which computes $fB$, the right-hand side of the
    backward ODE problem. This function has the form
    \id{rhsBS(t, y, yS, yB, yBdot, user\_dataB)}
    (for full details see \S\ref{ss:ODErhs_bs}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier,
    either \id{yB0} or \id{rhsBS} was \id{NULL},
    or sensitivities were not active during the forward integration.
  \end{args}
}
{
  The memory allocated by \id{CVodeInitBS} is deallocated by the function
  \id{CVodeAdjFree}.
}

The function \id{CVodeReInitB} reinitializes {\cvodes} for the solution of a series
of backward problems, each identified by a value of the parameter \id{which}.
\id{CVodeReInitB} is essentially a wrapper for \id{CVodeReInit}, and so
all details given for \id{CVodeReInit} in \S\ref{sss:cvreinit} apply
here.\index{reinitialization}  Also note that \id{CVodeReInitB} can be called to
reinitialize the backward problem even it has been initialized with the
sensitivity-dependent version \id{CVodeInitBS}.
Before calling \id{CVodeReInitB} for a new backward problem, call any
desired solution extraction functions \id{CVodeGet**} associated with the
previous backward problem.
The call to the \id{CVodeReInitB} function has the form
%%
%%
\ucfunctionf{CVodeReInitB}
{
  flag = CVodeReInitB(cvode\_mem, which, tB0, yB0)
}
{
  The function \ID{CVodeReInitB} reinitializes a {\cvodes} backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInitB} was successful.
  \item[\Id{CV\_NO\_MALLOC}]
    The function \id{CVodeInit} has not been previously called.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} memory block pointer was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_BAD\_TB0}]
    The final time \id{tB0} is outside the interval over which the forward problem
    was solved.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or
    \id{yB0} was \id{NULL}.
  \end{args}
}
{}

%%
%%==============================================================================
\subsection{Tolerance specification functions for backward problem}
\label{sss:cvtolerances_b}
%%==============================================================================
%%
One of the following two functions must be called to specify the integration
tolerances for the backward problem. Note that this call must be made after the
call to \id{CVodeInitB} or \id{CVodeInitBS}.
%%
\ucfunctionf{CVodeSStolerancesB}
{
  flag = CVodeSStolerancesB(cvode\_mem, which, reltolB, abstolB);
}
{
  The function \ID{CVodeSStolerancesB} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltolB] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstolB] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSStolerancesB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}]
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the input tolerances was negative.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeSVtolerancesB}
{
  flag = CVodeSVtolerancesB(cvode\_mem, which, reltolB, abstolB);
}
{
  The function \ID{CVodeSVtolerancesB} specifies scalar relative tolerance and
  vector absolute tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{N\_Vector})
    is the vector of absolute error tolerances.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSVtolerancesB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}]
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    The relative error tolerance was negative or the absolute tolerance
    had a negative component.
  \end{args}
}
{
  This choice of tolerances is important when the absolute error tolerance needs to
  be different for each component of the state vector $y$.
}
%%

%%---------------------------------------------------------------------
\subsection{Linear solver initialization functions for backward problem}
\label{sss:lin_solv_b}
%%---------------------------------------------------------------------

\index{CVODES@{\cvodes} linear solvers!usage with adjoint module|(}
All {\cvodes} linear solver modules available for forward problems
are available for the backward problem.  They should be created as
for the forward problem and then attached to the memory structure for the backward
problem using the following functions.

\index{CVODES@{\cvodes} linear solver interface!CVLS@{\cvls}}
\ucfunctionf{CVodeSetLinearSolverB}
{
  flag = CVodeSetLinearSolverB(cvode\_mem, which, LS, A);
}
{
  The function \ID{CVodeSetLinearSolverB} attaches a generic
  {\sunlinsol} object \id{LS} and corresponding template
  Jacobian {\sunmatrix} object \id{A} to {\cvodes}, initializing the
  {\cvls} linear solver interface for solution of the backward
  problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    represents the identifier of the backward problem returned by \\ \noindent
    \id{CVodeCreateB}.
  \item[LS] (\id{SUNLinearSolver})
    {\sunlinsol} object to use for solving linear systems for the backward problem.
  \item[A] (\id{SUNMatrix})
    {\sunmatrix} object for used as a template for the Jacobian for the backward
    problem (or \id{NULL} if not applicable).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}
  \item[\Id{CVLS\_SUCCESS}]
    The {\cvls} initialization was successful.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The {\cvls} solver is not compatible with the current {\nvector} module.
  \item[\Id{CVLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVAdjInit} has not been previously called.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  If \id{LS} is a matrix-based linear solver, then the template
  Jacobian matrix \id{J} will be used in the solve process, so if
  additional storage is required within the {\sunmatrix} object
  (e.g., for factorization of a banded matrix), ensure that the input
  object is allocated with sufficient size (see the documentation of
  the particular {\sunmatrix} type in Chapter \ref{s:sunmatrix} for
  further information).

  The previous routines \Id{CVDlsSetLinearSolverB} and
  \Id{CVSpilsSetLinearSolverB} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
%%
\ucfunctionf{CVDiagB}
{
  flag = CVDiagB(cvode\_mem, which);
}
{
  The function \ID{CVDiagB} selects the {\cvdiag} linear solver for the solution
  of the backward problem.

  The user's main program must include the \id{cvodes\_diag.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    represents the identifier of the backward problem returned by \\ \noindent
    \id{CVodeCreateB}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDIAG\_ILL\_INPUT]
  \item[\Id{CVDIAG\_SUCCESS}]
    The {\cvdiag} initialization was successful.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_ILL\_INPUT}]
    The {\cvdiag} solver is not compatible with the current {\nvector} module.
  \item[\Id{CVDIAG\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvdiag} solver is the simplest of all of the available {\cvodes}
  linear solver interfaces.  The {\cvdiag} solver uses an approximate
  diagonal Jacobian formed by way of a difference quotient. The user
  does {\em not} have the option of supplying a function to compute an
  approximate diagonal Jacobian.
}


%%---------------------------------------------------------------------
\subsection{Nonlinear solver initialization function for backward problem}
\label{sss:nonlin_solv_init_b}
%%---------------------------------------------------------------------

\index{CVODES@{\cvodes} nonlinear solvers!usage with adjoint module|(}
All {\cvodes} nonlinear solver modules available for forward problems
are available for the backward problem. As with the forward problem {\cvodes}
uses the {\sunnonlinsol} implementation of Newton's method defined by the
{\sunnonlinsolnewton} module (see \S\ref{s:sunnonlinsol_newton}) by default.

To specify a different nonlinear solver for the backward problem, the user's
program must create a {\sunnonlinsol} object by calling the appropriate
constructor routine. The user must then attach the {\sunnonlinsol} object by
calling \Id{CVodeSetNonlinearSolverB}, as documented below.

When changing the nonlinear solver in {\cvodes}, \id{CVodeSetNonlinearSolverB}
must be called after \id{CVodeInitB}. If any calls to \id{CVodeB} have been
made, then {\cvodes} will need to be reinitialized by calling \id{CVodeReInitB}
to ensure that the nonlinear solver is initialized correctly before any
subsequent calls to \id{CVodeB}.

\ucfunctionf{CVodeSetNonlinearSolverB}
{
  flag = CVodeSetNonlinearSolverB(cvode\_mem, which, NLS);
}
{
  The function \ID{CVodeSetNonLinearSolverB} attaches a {\sunnonlinsol}
  object (\id{NLS}) to {\cvodes} for the solution of the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    represents the identifier of the backward problem returned by \\ \noindent
    \id{CVodeCreateB}.
  \item[NLS] (\id{SUNNonlinearSolver})
    {\sunnonlinsol} object to use for solving nonlinear systems for the backward
    problem.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The nonlinear solver was successfully attached.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVAdjInit} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier or the
    {\sunnonlinsol} object is \id{NULL}, does not implement the required
    nonlinear solver operations, is not of the correct type, or the residual
    function, convergence test function, or maximum number of nonlinear
    iterations could not be set.
  \end{args}
}
{}


%%---------------------------------------------------------------------
\subsection{Backward integration function}
\label{sss:cvsolveb}
%%---------------------------------------------------------------------

The function \ID{CVodeB} performs the integration of the backward problem.
It is essentially a wrapper for the {\cvodes} main integration function
\id{CVode} and, in the case in which checkpoints were needed, it evolves
the solution of the backward problem through a sequence of forward-backward
integration pairs between consecutive checkpoints.
The first run of each pair integrates the original IVP forward in time and
stores interpolation data; the second run integrates the backward problem
backward in time and performs the required interpolation to provide
the solution of the IVP to the backward problem.

The function \id{CVodeB} does not return the solution \id{yB} itself.
To obtain that, call the function \id{CVodeGetB}, which is also
described below.

The \id{CVodeB} function does not support rootfinding, unlike \id{CVodeF},
which supports the finding of roots of functions of $(t,y)$.  If rootfinding
was performed by \id{CVodeF}, then for the sake of efficiency, it should be
disabled for \id{CVodeB} by first calling \id{CVodeRootInit} with \id{nrtfn} = 0.

The call to \id{CVodeB} has the form
%%
%%
\ucfunctionf{CVodeB}
{
  flag = CVodeB(cvode\_mem, tBout, itaskB);
}
{
  The function \ID{CVodeB} integrates the backward ODE problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[tBout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[itaskB] (\id{int})
    \index{output mode}
    a flag indicating the job of the solver for the next step.
    The \Id{CV\_NORMAL} task is to have the solver take internal steps until
    it has reached or just passed the user-specified value \id{tBout}.
    The solver then interpolates in order to
    return an approximate value of $yB($\id{tBout}$)$.
    The \Id{CV\_ONE\_STEP} option tells the solver to take just one internal step in
    the direction of \id{tBout} and return.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:cvode}.
  \begin{args}[CV\_TOO\_MUCH\_WORK]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeB} succeeded.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_NO\_BCK}]
    No backward problem has been added to the list of backward problems by
    a call to \id{CVodeCreateB}
  \item[\Id{CV\_NO\_FWD}]
    The function \id{CVodeF} has not been previously called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVodeB} is illegal.
  \item[\Id{CV\_BAD\_ITASK}]
    The \id{itaskB} argument has an illegal value.
  \item[\Id{CV\_TOO\_MUCH\_WORK}]
    The solver took \id{mxstep} internal steps but could not reach \id{tBout}.
  \item[\Id{CV\_TOO\_MUCH\_ACC}]
    The solver could not satisfy the accuracy demanded by the user for some
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Error test failures occurred too many times during one internal time step.
  \item[\Id{CV\_CONV\_FAILURE}]
    Convergence test failures occurred too many times during one internal time step.
  \item[\Id{CV\_LSETUP\_FAIL}]
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_SOLVE\_FAIL}]
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_BCKMEM\_NULL}]
    The solver memory for the backward problem was not created with
    a call to \id{CVodeCreateB}.
  \item[\Id{CV\_BAD\_TBOUT}]
    The desired output time \id{tBout} is outside the interval over which the
    forward problem was solved.
  \item[\Id{CV\_REIFWD\_FAIL}]
    Reinitialization of the forward problem failed at the first checkpoint
    (corresponding to the initial time of the forward problem).
  \item[\Id{CV\_FWD\_FAIL}]
    An error occurred during the integration of the forward problem.
  \end{args}
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{CVodeB} failures.

  In the case of multiple checkpoints and multiple backward problems, a given
  call to \id{CVodeB} in \id{CV\_ONE\_STEP} mode may not advance every problem
  one step, depending on the relative locations of the current times reached.
  But repeated calls will eventually advance all problems to \id{tBout}.
}
%%
%%
To obtain the solution \id{yB} to the backward problem, call the function
\id{CVodeGetB} as follows:
%%
\ucfunctionf{CVodeGetB}
{
  flag = CVodeGetB(cvode\_mem, which, \&tret, yB);
}
{
  The function \ID{CVodeGetB} provides the solution \id{yB} of the backward ODE
  problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yB] (\id{N\_Vector})
    the backward solution at time \id{tret}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
   \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  {\warn}The user must allocate space for \id{yB}.

  To obtain the solution associated with a given backward problem at some
  other time within the last integration step, first obtain a pointer to the
  proper {\cvodes} memory structure by calling \id{CVodeGetAdjCVodeBmem}
  and then use it to call \id{CVodeGetDky}.
}


%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity optional input}

At any time during the integration of the forward problem, the user can disable
the checkpointing of the forward sensitivities by calling the following function:

\ucfunctionf{CVodeAdjSetNoSensi}
{
  flag = CVodeAdjSetNoSensi(cvode\_mem);
}
{
  The function \ID{CVodeAdjSetNoSensi} instructs \id{CVodeF} not
  to save checkpointing data for forward sensitivities anymore.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes}  memory block.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_FAIL]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeCreateB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \end{args}
}
{}
%%-------------------------------------------------------------------------------


%%---------------------------------------------------------------------
\subsection{Optional input functions for the backward problem}
\label{ss:optional_input_b}
%%---------------------------------------------------------------------
%%

As for the forward problem there are numerous optional input parameters that
control the behavior of the {\cvodes} solver for the backward problem. {\cvodes}
provides functions that can be used to change these optional input parameters
from their default values which are then described in detail in the remainder of
this section, beginning with those for the main {\cvodes} solver and continuing
with those for the linear solver interfaces. Note that the diagonal linear
solver module has no optional inputs. For the most casual use of {\cvodes}, the
reader can skip to \S\ref{ss:user_fct_adj}.

We note that, on an error return, all of the optional input functions send an
error message to the error handler function.
\index{error messages}
All error return values are negative, so the test \id{flag < 0} will catch all
errors. Finally, a call to a \id{CVodeSet***B} function can be made from the
user's calling program at any time and, if successful, takes effect immediately.

\subsubsection{Main solver optional input functions}
\index{optional input!backward solver|(}

The adjoint module in {\cvodes} provides wrappers for most of the optional
input functions defined in \S\ref{sss:optin_main}. The only difference is
that the user must specify the identifier \id{which} of the backward problem
within the list managed by {\cvodes}.

The optional input functions defined for the backward problem are:
\begin{verbatim}
  flag = CVodeSetUserDataB(cvode_mem, which, user_dataB);
  flag = CVodeSetMaxOrdB(cvode_mem, which, maxordB);
  flag = CVodeSetMaxNumStepsB(cvode_mem, which, mxstepsB);
  flag = CVodeSetInitStepB(cvode_mem, which, hinB)
  flag = CVodeSetMinStepB(cvode_mem, which, hminB);
  flag = CVodeSetMaxStepB(cvode_mem, which, hmaxB);
  flag = CVodeSetStabLimDetB(cvode_mem, which, stldetB);
  flag = CVodeSetConstraintsB(cvode_mem, which, constraintsB);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values
of their counterparts, but it can also be \Id{CV\_NO\_ADJ} if \id{CVodeAdjInit}
has not been called, or \Id{CV\_ILL\_INPUT} if \id{which} was an invalid identifier.

\index{optional input!backward solver|)}

%%
%%
%%==================================================================================
%%
\subsubsection{Linear solver interface optional input functions}
\index{optional input!generic linear solver interface|(}
\index{CVLS@{\cvls} linear solver interface!optional input|(}
\index{optional input!matrix-based linear solver|(}
When using matrix-based linear solver modules, the {\cvls} solver interface
needs a function to compute an approximation to the Jacobian matrix or the
linear system for the backward problem. The function to evaluate the Jacobian
can be attached through a call to either \id{CVodeSetJacFnB} or
\id{CVodeSetJacFnBS}, with the second used when the backward problem depends
on the forward sensitivities.
%%
\index{Jacobian approximation function!user-supplied (backward)}
\ucfunctionf{CVodeSetJacFnB}
{
  flag = CVodeSetJacFnB(cvode\_mem, which, jacB);
}
{
  The function \ID{CVodeSetJacFnB} specifies the Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{CVLsJacFnB})
    user-defined Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    \id{CVodeSetJacFnB} succeeded.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \\ \noindent
    \id{CVodeSetLinearSolverB}.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVLsJacFnB} is described in \S\ref{ss:jacFn_b}.

  The previous routine \Id{CVDlsSetJacFnB} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
\index{Jacobian approximation function!user-supplied (backward)}
\ucfunctionf{CVodeSetJacFnBS}
{
  flag = CVodeSetJacFnBS(cvode\_mem, which, jacBS);
}
{
  The function \ID{CVodeSetJacFnBS} specifies the Jacobian
  approximation function to be used for the backward problem, in the
  case where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{CVLsJacFnBS})
    user-defined Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    \id{CVodeSetJacFnBS} succeeded.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \\ \noindent
    \id{CVodeSetLinearSolverB}.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVLsJacFnBS} is described in \S\ref{ss:jacFn_b}.

  The previous routine \Id{CVDlsSetJacFnBS} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
Alternatively, a function to evaluate the linear system can be attached
through a call to either \id{CVodeSetLinSysFnB} or \id{CVodeSetLinSysFnBS}, with
the second used when the backward problem depends on the forwrad sensitivities.
%%
\index{Linear system approximation function!user-supplied (backward)}
\ucfunctionf{CVodeSetLinSysFnB}
{
  flag = CVodeSetLinSysFnB(cvode\_mem, which, linsysB);
}
{
  The function \ID{CVodeSetLinSysFnB} specifies the linear system
  approximation function to be used for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[linsysB] (\id{CVLsLinSysFnB})
    user-defined linear system approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    \id{CVodeSetLinSysFnB} succeeded.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \\ \noindent
    \id{CVodeSetLinearSolverB}.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVLsLinSysFnB} is described in \S\ref{ss:linsysFn_b}.
}
%%
\index{Linear system approximation function!user-supplied (backward)}
\ucfunctionf{CVodeSetLinSysFnBS}
{
  flag = CVodeSetLinSysFnBS(cvode\_mem, which, linsysBS);
}
{
  The function \ID{CVodeSetLinSysFnBS} specifies the linear system
  approximation function to be used for the backward problem, in the
  case where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[linsysBS] (\id{CVLsLinSysFnBS})
    user-defined linear system approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    \id{CVodeSetLinSysFnBS} succeeded.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \\ \noindent
    \id{CVodeSetLinearSolverB}.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{CVLsLinSysFnBS} is described in \S\ref{ss:linsysFn_b}.
}
%%
The function \id{CVodeSetLinearSolutionScalingB} can be used to enable or
disable solution scaling when using a matrix-based linear solver.
%%
\index{Linear solution scaling function!user-supplied (backward)}
\ucfunctionf{CVodeSetLinearSolutionScalingB}
{
  flag = CVodeSetLinearSolutionScaling(cvode\_mem, which, onoffB);
}
{
  The function \ID{CVodeSetLinearSolutionScalingB} enables or disables scaling
  the linear system solution to account for a change in $\gamma$ in the linear
  system in the backward problem. For more details see
  \S\ref{ss:sunlinsol_lagged_matrix}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvode} memory block.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[onoffB] (\id{booleantype})
    flag to enable (\id{SUNTRUE}) or disable (\id{SUNFALSE}) scaling
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The flag value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver interface has not been initialized.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The attached linear solver is not matrix-based or the linear multistep
    method type is not BDF.
  \end{args}
}
{
  By default scaling is enabled with matrix-based linear solvers when using BDF
  methods.
}
%%
\index{optional input!matrix-based linear solver|)}
%%
%%
%%
\index{optional input!matrix-free linear solver|(}
%%
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
\ucfunctionf{CVodeSetJacTimesB}
{
  flag = CVodeSetJacTimesB(cvode\_mem, which, jsetupB, jtvB);
}
{
  The function \ID{CVodeSetJacTimesB} specifies the Jacobian-vector
  setup and product functions to be used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtsetupB] (\id{CVLsJacTimesSetupFnB})
    user-defined function to set up the Jacobian-vector product.
    Pass \id{NULL} if no setup is necessary.
  \item[jtvB] (\id{CVLsJacTimesVecFnB})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{CVLsJacTimesVecFnB} and
  \id{CVLsJacTimesSetupFnB} are described in \S\ref{ss:jtimesv_b}.

  The previous routine \Id{CVSpilsSetJacTimesB} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
\ucfunctionf{CVodeSetJacTimesBS}
{
  flag = CVodeSetJacTimesBS(cvode\_mem, which, jtvBS);
}
{
  The function \ID{CVodeSetJacTimesBS} specifies the Jacobian-vector
  setup and product functions to be used, in the case where the backward problem
  depends on the forward sensitivities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtsetupBS] (\id{CVLsJacTimesSetupFnBS})
    user-defined function to set up the Jacobian-vector product.
    Pass \id{NULL} if no setup is necessary.
  \item[jtvBS] (\id{CVLsJacTimesVecFnBS})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{CVLsJacTimesVecFnBS} and
  \id{CVLsJacTimesSetupFnBS} are described in \S\ref{ss:jtimesv_b}.

  The previous routine \Id{CVSpilsSetJacTimesBS} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
%%
When using the internal difference quotient the user may optionally supply an
alternative right-hand side function for use in the Jacobian-vector product
approximation for the backward problem by calling \id{CVodeSetJacTimesRhsFnB}.
The alternative right-hand side function should compute a suitable (and
differentiable) approximation to the right-hand side function provided to
\id{CVodeInitB} or \id{CVodeInitBS}. For example, as done in
\cite{dorr2010numerical} for a forward integration without sensitivity analysis,
the alternative function may use lagged values when evaluating a nonlinearity in
the right-hand side to avoid differencing a potentially non-differentiable
factor.
%%
%%
\index{Jacobian approximation function!Jacobian times vector!alternative-rhs (backward)}
\ucfunctionf{CVodeSetJacTimesRhsFnB}
{
  flag = CVodeSetJacTimesRhsFnB(cvode\_mem, which, jtimesRhsFn);
}
{
  The function \ID{CVodeSetJacTimesRhsFn} specifies an alternative ODE
  right-hand side function for use in the internal Jacobian-vector product
  difference quotient approximation.
}
{
  \begin{args}[jtimesRhsFn]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtimesRhsFn] (\Id{CVRhsFn})
    is the {\CC} function which computes the alternative ODE right-hand side
    function to use in Jacobian-vector product difference quotient
    approximations. This function has the form \id{f(t, y, ydot, user\_data)}
    (for full details see \S\ref{ss:rhsFn}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_SUNLS\_FAIL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier or the internal
    difference quotient approximation is disabled.
  \end{args}
}
{
  The default is to use the right-hand side function provided to \id{CVodeInit}
  in the internal difference quotient. If the input right-hand side function is
  \id{NULL}, the default is used.

  This function must be called \emph{after} the {\cvls} linear solver interface
  has been initialized through a call to \id{CVodeSetLinearSolverB}.
}
%%
%%
\index{optional input!matrix-free linear solver|)}
%%
%%
%%
\index{optional input!iterative linear solver|(}
%%
%%
\index{preconditioning!user-supplied|(}
\ucfunctionf{CVodeSetPreconditionerB}
{
  flag = CVodeSetPreconditionerB(cvode\_mem, which, psetupB, psolveB);
}
{
  The function \ID{CVodeSetPrecSolveFnB} specifies the preconditioner
  setup and solve functions for the backward integration.
}
{
  \begin{args}[psetupB]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupB] (\id{CVLPrecSetupFnB})
    user-defined preconditioner setup function.
  \item[psolveB] (\id{CVLsPrecSolveFnB})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{CVLsPrecSolveFnB} and \id{CVLsPrecSetupFnB} are
  described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, respectively.
  The \id{psetupB} argument may be \id{NULL} if no setup operation is involved
  in the preconditioner.

  The previous routine \Id{CVSpilsSetPrecSolveFnB} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
\ucfunctionf{CVodeSetPreconditionerBS}
{
  flag = CVodeSetPreconditionerBS(cvode\_mem, which, psetupBS, psolveBS);
}
{
  The function \ID{CVodeSetPrecSolveFnBS} specifies the preconditioner
  setup and solve functions for the backward integration, in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[psetupBS]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupBS] (\id{CVLsPrecSetupFnBS})
    user-defined preconditioner setup function.
  \item[psolveBS] (\id{CVLsPrecSolveFnBS})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{CVodePrecSolveFnBS} and \id{CVodePrecSetupFnBS} are
  described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, respectively.
  The \id{psetupBS} argument may be \id{NULL} if no setup operation is involved
  in the preconditioner.

  The previous routine \Id{CVSpilsSetPrecSolveFnBS} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
\index{preconditioning!user-supplied|)}
%%
\ucfunctionf{CVodeSetEpsLinB}
{
  flag = CVodeSetEpsLinB(cvode\_mem, which, eplifacB);
}
{
  The function \ID{CVodeSetEpsLinB} specifies the factor by
  which the Krylov linear solver's convergence test constant is reduced
  from the nonlinear iteration test constant.
  This routine can be used in both the cases wherethe backward problem
  does and does not depend on the forward sensitvities.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[eplifacB] (\id{realtype})
    value of the convergence test constant reduction factor ($\geq 0.0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or
    \id{eplifacB} was negative.
  \end{args}
}
{
  The default value is $0.05$.
  Passing a value \id{eplifacB}$ = 0.0$ also indicates using the default value.


  The previous routine \Id{CVSpilsSetEpsLinB} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
\index{optional input!iterative linear solver|)}
%%
\index{CVLS@{\cvls} linear solver interface!optional input|)}
\index{optional input!generic linear solver interface|)}



%---------------------------------------------------------------------------
\subsection{Optional output functions for the backward problem}\label{ss:optional_output_b}
\index{optional output!backward solver|(}
%%
The user of the adjoint module in {\cvodes} has access to any of the optional
output functions described in \S\ref{ss:optional_output}, both for the main solver
and for the linear solver modules. The first argument of these \id{CVodeGet*} and
\id{CVode*Get*} functions is the pointer to the {\cvodes} memory block for the
backward problem. In order to call any of these functions, the user must first
call the following function to obtain this pointer.
%%
\ucfunctionf{CVodeGetAdjCVodeBmem}
{
  cvode\_memB = CVodeGetAdjCVodeBmem(cvode\_mem, which);
}
{
  The function \ID{CVodeGetAdjCVodeBmem} returns a pointer to the {\cvodes}
  memory block for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block created by \id{CVodeCreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \end{args}
}
{
  The return value, \id{cvode\_memB} (of type \id{void *}), is a pointer to the
  {\cvodes} memory for the backward problem.
}
{
  {\warn}The user should not modify \id{cvode\_memB} in any way.

  Optional output calls should pass \id{cvode\_memB} as the first argument;
  for example, to get the number of integration steps:
  \id{flag = CVodeGetNumSteps(cvodes\_memB, \&nsteps)}.
}
\index{optional output!backward solver|)}

To get values of the {\it forward} solution during a backward integration,
use the following function.  The input value of \id{t} would typically be
equal to that at which the backward solution has just been obtained with
\id{CVodeGetB}.  In any case, it must be within the last checkpoint interval
used by \id{CVodeB}.

\ucfunctionf{CVodeGetAdjY}
{
  flag = CVodeGetAdjY(cvode\_mem, t, y);
}
{
  The function \ID{CVodeGetAdjY} returns the interpolated value of
  the forward solution $y$ during a backward integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block created by \id{CVodeCreate}.
  \item[t] (\id{realtype})
    value of the independent variable at which $y$ is desired (input).
  \item[y] (\id{N\_Vector}) forward solution $y(t)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
 \begin{args}[CV\_GETY\_BADT]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetAdjY} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_GETY\_BADT}]
    The value of \id{t} was outside the current checkpoint interval.
  \end{args}
}
{
  {\warn} The user must allocate space for \id{y}.
}

\ucfunctionf{CVodeGetAdjCheckPointsInfo}
{
  flag = CVodeGetAdjCheckPointsInfo(cvode\_mem, CVadjCheckPointRec *ckpnt);
}
{
  The function \ID{CVodeGetAdjCheckPointsInfo} loads an array of \id{ncheck+1}
  records of type \id{CVadjCheckPointRec}.
  The user must allocate space for the array \id{ckpnt}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block created by \id{CVodeCreate}.
  \item[ckpnt] (\id{CVadjCheckPointRec *})
    array of \id{ncheck+1} checkpoint records, each of type \id{CVadjCheckPointRec}.
  \end{args}
}
{  The return value is \id{CV\_SUCCESS} if successful, or
   \id{CV\_MEM\_NULL} if \id{cvode\_mem} is \id{NULL}, or
   \id{CV\_NO\_ADJ} if ASA was not initialized.}
{  The members of each record \id{ckpnt[i]} are:
\begin{itemize}
 \item \id{ckpnt[i].my\_addr} (\id{void *}) address of current checkpoint
   in \\
   \id{cvode\_mem->cv\_adj\_mem}
 \item \id{ckpnt[i].next\_addr} (\id{void *}) address of next checkpoint
 \item \id{ckpnt[i].t0} (\id{realtype}) start of checkpoint interval
 \item \id{ckpnt[i].t1} (\id{realtype}) end of checkpoint interval
 \item \id{ckpnt[i].nstep} (\id{long int}) step counter at ckeckpoint \id{t0}
 \item \id{ckpnt[i].order} (\id{int}) method order at checkpoint \id{t0}
 \item \id{ckpnt[i].step} (\id{realtype}) step size at checkpoint \id{t0}
\end{itemize}
}


%%---------------------------------------------------------------------
\subsection{Backward integration of quadrature equations}
%%---------------------------------------------------------------------

Not only the backward problem but also the backward quadrature equations
may or may not depend on the forward sensitivities.  Accordingly, either
\id{CVodeQuadInitB} or \id{CVodeQuadInitBS} should be used to allocate internal
memory and to initialize backward quadratures.  For any other operation
(extraction, optional input/output, reinitialization, deallocation),
the same function is callable regardless of whether or not the quadratures
are sensitivity-dependent.

\subsubsection{Backward quadrature initialization functions}
\label{sss:cvquadinitb}

The function \id{CVodeQuadInitB} initializes and allocates memory for the backward
integration of quadrature equations that do not depend on forward sensitivities.
It has the following form:
%%
%%
\ucfunctionf{CVodeQuadInitB}
{
flag = CVodeQuadInitB(cvode\_mem, which, rhsQB, yQB0);
}
{
  The function \ID{CVodeQuadInitB} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQB] (\Id{CVQuadRhsFnB})
    is the {\CC} function which computes $fQB$, the right-hand side of the
    backward quadrature equations. This function has the form
    \id{rhsQB(t, y, yB, qBdot, user\_dataB)}
    (see \S\ref{sss:rhs_quad_B}).
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadInitB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%
%%

The function \id{CVodeQuadInitBS} initializes and allocates memory for the backward
integration of quadrature equations that depends on the forward sensitivities.
%%
%%
\ucfunctionf{CVodeQuadInitBS}
{
flag = CVodeQuadInitBS(cvode\_mem, which, rhsQBS, yQBS0);
}
{
  The function \ID{CVodeQuadInitBS} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQBS] (\Id{CVQuadRhsFnBS})
    is the {\CC} function which computes $fQBS$, the right-hand side of the
    backward quadrature equations. This function has the form
    \id{rhsQBS(t, y, yS, yB, qBdot, user\_dataB)}
    (see \S\ref{sss:rhs_quad_sens_B}).
  \item[yQBS0] (\id{N\_Vector})
    is the value of the sensitivity-dependent quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadInitBS} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}


The integration of quadrature equations during the backward phase can be
re-initialized by calling the following function.
Before calling \id{CVodeQuadReInitB} for a new backward problem, call any
desired solution extraction functions \id{CVodeGet**} associated with the
previous backward problem.
%%
%%
\ucfunctionf{CVodeQuadReInitB}
{
  flag = CVodeQuadReInitB(cvode\_mem, which, yQB0);
}
{
  The function \ID{CVodeQuadReInitB} re-initializes the backward quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadReInitB} was successful.
 \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} was \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration was not activated through a  previous
    call to \id{CVodeQuadInitB}.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  The function \id{CVodeQuadReInitB} can be called after a call to either
  \id{CVodeQuadInitB} or \id{CVodeQuadInitBS}.
}

\subsubsection{Backward quadrature extraction function}
\label{sss:quad_get_b}
To extract the values of the quadrature variables at the last return time
of \id{CVodeB}, {\cvodes} provides a wrapper for the function \ID{CVodeGetQuad}
(see \S\ref{ss:quad_get}). The call to this function has the form
%%
%%
\ucfunctionf{CVodeGetQuadB}
{
  flag = CVodeGetQuadB(cvode\_mem, which, \&tret, yQB);
}
{
  The function \ID{CVodeGetQuadB} returns the quadrature solution vector after
  a successful return from \id{CVodeB}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yQB] (\id{N\_Vector})
    the computed quadrature vector.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetQuadB} is one of:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetQuadB} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    \id{cvode\_mem} is \id{NULL}.
  \item[\Id{CV\_NO\_ADJ}]
    The function \id{CVodeAdjInit} has not been previously called.
  \item[CV\_NO\_QUAD]
    Quadrature integration was not initialized.
  \item[CV\_BAD\_DKY]
    \id{yQB} was \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  {\warn}The user must allocate space for \id{yQB}.

  To obtain the quadratures associated with a given backward problem at some
  other time within the last integration step, first obtain a pointer to the
  proper {\cvodes} memory structure by calling \id{CVodeGetAdjCVodeBmem}
  and then use it to call \id{CVodeGetQuadDky}.
}
%%\subsubsection{Tolerance specification functions for backward quadrature integration}

\subsubsection{Optional input/output functions for backward quadrature integration}
\label{sss:quad_optional_input_B}
\index{optional input!quadrature integration}
\index{optional output!quadrature integration}
Optional values controlling the backward integration of quadrature equations can be
changed from their default values through calls to one of the following functions
which are wrappers for the corresponding optional input functions defined in
\S\ref{ss:quad_optional_input}. The user must specify  the identifier \id{which}
of the backward problem for which the optional values are specified.

\begin{verbatim}
  flag = CVodeSetQuadErrConB(cvode_mem, which, errconQ);
  flag = CVodeQuadSStolerancesB(cvode_mem, which, reltolQ, abstolQ);
  flag = CVodeQuadSVtolerancesB(cvode_mem, which, reltolQ, abstolQ);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values
of its counterparts, but it can also be \Id{CV\_NO\_ADJ} if the function
\id{CVodeAdjInit} has not been previously called or \Id{CV\_ILL\_INPUT} if the
parameter \id{which} was an invalid identifier.

Access to optional outputs related to backward quadrature integration can be
obtained by calling the corresponding \id{CVodeGetQuad*} functions
(see \S\ref{ss:quad_optional_output}).  A pointer \id{cvode\_memB} to the
{\cvodes} memory block for the backward problem, required as the first
argument of these functions, can be obtained through a call to the functions
\id{CVodeGetAdjCVodeBmem} (see \S\ref{ss:optional_output_b}).


%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
\section{User-supplied functions for adjoint sensitivity analysis}
\label{ss:user_fct_adj}
%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
%%

In addition to the required ODE right-hand side function and any optional functions
for the forward problem, when using the adjoint sensitivity module in {\cvodes},
the user must supply one function defining the backward problem ODE and, optionally,
functions to supply Jacobian-related information and one or two functions
that define the preconditioner (if an iterative {\sunlinsol} module is
selected) for the backward problem.
Type definitions for all these user-supplied functions are given below.

\subsection{ODE right-hand side for the backward problem}\label{ss:ODErhs_b}
\index{adjoint sensitivity analysis!right-hand side evaluation}
\index{right-hand side function!backward problem}

If the backward problem does not depend on the forward sensitivities,
the user must provide a \id{rhsB} function of type \ID{CVRhsFnB} defined as follows:
\usfunction{CVRhsFnB}
{
  typedef int (*CVRhsFnB)(&realtype t, N\_Vector y, \\
                          &N\_Vector yB, N\_Vector yBdot, void *user\_dataB);
}
{
  This function evaluates the right-hand side $f_B(t,y,y_B)$ of the backward problem
  ODE system.  This could be either (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[yBdot]
    is the output vector containing the right-hand side $f_B$ of the backward ODE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_RHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{yBdot} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{yBdot} arguments are all
  of type \id{N\_Vector}, but \id{yB} and \id{yBdot} typically have
  different internal representations from \id{y}. It is the user's
  responsibility to access the vector data consistently (including the use of the
  correct accessor macros from each {\nvector} implementation). For the sake of
  computational efficiency, the vector functions in the two {\nvector} implementations
  provided with {\cvodes} do not perform any consistency checks with respect to their
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to
  the user's \id{rhsB} function every time it is called and can be the same as the
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{rhsB} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_RHSFUNC\_FAIL}.
}

\subsection{ODE right-hand side for the backward problem depending on the forward sensitivities}\label{ss:ODErhs_bs}
\index{adjoint sensitivity analysis!right-hand side evaluation}
\index{right-hand side function!backward problem}

If the backward problem does depend on the forward sensitivities,
the user must provide a \id{rhsBS} function of type \ID{CVRhsFnBS} defined as follows:
\usfunction{CVRhsFnBS}
{
  typedef int (*CVRhsFnBS)(&realtype t, N\_Vector y, N\_Vector *yS, \\
                           &N\_Vector yB, N\_Vector yBdot, void *user\_dataB);
}
{
  This function evaluates the right-hand side $f_B(t, y, y_B, s)$ of the backward problem
  ODE system.  This could be either (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of
    the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[yBdot]
    is the output vector containing the right-hand side $f_B$ of the backward ODE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_RHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{qBdot} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{yBdot} arguments are all of type \id{N\_Vector},
  but \id{yB} and \id{yBdot} typically have different internal representations
  from \id{y}.  Likewise for each \id{yS[i]}.  It is the user's
  responsibility to access the vector data consistently (including the use of the
  correct accessor macros from each {\nvector} implementation). For the sake of
  computational efficiency, the vector functions in the two {\nvector} implementations
  provided with {\cvodes} do not perform any consistency checks with respect to their
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to
  the user's \id{rhsBS} function every time it is called and can be the same as the
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{rhsBS} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_RHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Quadrature right-hand side for the backward problem}
\index{right-hand side function!quadrature backward problem}
\index{adjoint sensitivity analysis!quadrature evaluation}
\label{sss:rhs_quad_B}
The user must provide an \id{fQB} function of type \ID{CVQuadRhsFnB} defined by
\usfunction{CVQuadRhsFnB}
{
  typedef int (*CVQuadRhsFnB)(&realtype t, N\_Vector y, N\_Vector yB, \\
                              &N\_Vector qBdot, void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[qBdot]
    is the output vector containing the right-hand side \id{fQB} of the backward
    quadrature equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVQuadRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalBQ} is handled within {\cvodes}.

  The \id{y}, \id{yB}, and \id{qBdot} arguments are all of type \id{N\_Vector},
  but they typically do not all have the same representation. It is the user's
  responsibility to access the vector data consistently (including the use of the
  correct accessor macros from each {\nvector} implementation). For the sake of
  computational efficiency, the vector functions in the two {\nvector} implementations
  provided with {\cvodes} do not perform any consistency checks with repsect to their
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQB} function every time
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{fQB} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_QRHSFUNC\_FAIL}.
}

\subsection{Sensitivity-dependent quadrature right-hand side for the backward problem}
\index{right-hand side function!sensitivity-dep. quadrature backward problem}
\index{adjoint sensitivity analysis!sensitivity-dependent quadrature evaluation}
\label{sss:rhs_quad_sens_B}
The user must provide an \id{fQBS} function of type \ID{CVQuadRhsFnBS} defined by
\usfunction{CVQuadRhsFnBS}
{
  typedef int (*CVQuadRhsFnBS)(&realtype t, N\_Vector y, N\_Vector *yS, \\
  &N\_Vector yB, N\_Vector qBdot, \\
  &void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of
    the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[qBdot]
    is the output vector containing the right-hand side \id{fQBS} of the backward
    quadrature equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  A \id{CVQuadRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{qBdot} is handled within {\cvodes}.

  The \id{y}, \id{yS}, and \id{qBdot} arguments are all of type \id{N\_Vector},
  but they typically do not all have the same internal representation.
  Likewise for each \id{yS[i]}.  It is the user's
  responsibility to access the vector data consistently (including the use of the
  correct accessor macros from each {\nvector} implementation). For the sake of
  computational efficiency, the vector functions in the two {\nvector} implementations
  provided with {\cvodes} do not perform any consistency checks with repsect to their
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQBS} function every time
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{fQBS} function, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{CVodeB} will return \id{CV\_QRHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian construction for the backward problem (matrix-based linear solvers)}\label{ss:jacFn_b}

If a matrix-based linear solver module is used for the backward
problem (i.e., a non-\id{NULL} {\sunmatrix} object was supplied to
\Id{CVodeSetLinearSolverB}), the user may provide a function of type
\ID{CVLsJacFnB} or \ID{CVLsJacFnBS} (see \S\ref{ss:optional_input_b}),
defined as follows:
%%
\index{Jacobian approximation function!user-supplied (backward)}
\usfunction{CVLsJacFnB}
{
  typedef int (*CVLsJacFnB)(&realtype t, N\_Vector y, \\
                            &N\_Vector yB, N\_Vector fyB, \\
                            &SUNMatrix JacB, void *user\_dataB, \\
                            &N\_Vector tmp1B, N\_Vector tmp2B, \\
                            &N\_Vector tmp3B);
}
{
  This function computes the Jacobian of the backward problem (or an approximation
  to it).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which
    can be used by the \id{CVLsJacFnB} function as temporary storage or work space.
  \end{args}
}
{
  A \id{CVLsJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_RECVR}), or a negative
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvls} sets \id{last\_flag} to
  \Id{CVLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied Jacobian function must load the
  matrix \id{JacB} with an approximation to the Jacobian matrix
  at the point (\id{t},\id{y},\id{yB}), where \id{y} is the solution
  of the original IVP at time \id{tt}, and \id{yB} is the solution of the
  backward problem at the same time.
  Information regarding the structure of the specific {\sunmatrix}
  structure (e.g.~number of rows, upper/lower bandwidth, sparsity
  type) may be obtained through using the implementation-specific
  {\sunmatrix} interface functions (see Chapter \ref{s:sunmatrix} for
  details).

  With direct linear solvers (i.e., linear solvers with type
  \Id{SUNLINEARSOLVER\_DIRECT}), the Jacobian matrix $J(t,y)$ is zeroed out
  prior to calling the user-supplied Jacobian function so only nonzero elements
  need to be loaded into \id{JacB}.

  {\warn}Before calling the user's \id{CVLsJacFnB}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvls} sets \id{last\_flag} to
  \Id{CVLS\_JACFUNC\_UNRECVR}).

  The previous function type \Id{CVDlsJacFnB} is identical to
  \id{CVLsJacFnB}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
%%
\index{Jacobian approximation function!user-supplied (backward)}
\usfunction{CVLsJacFnBS}
{
  typedef int (*CVLsJacFnBS)(&realtype t, N\_Vector y, \\
                             &N\_Vector *yS, N\_Vector yB, N\_Vector fyB, \\
                             &SUNMatrix JacB, void *user\_dataB, \\
                             &N\_Vector tmp1B, N\_Vector tmp2B, \\
                             &N\_Vector tmp3B);
}
{
  This function computes the Jacobian of the backward problem (or an
  approximation to it), in the case where the backward problem depends on the
  forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[JacB]
    is the output approximate Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which
    can be used by \id{CVLsJacFnBS} as temporary storage or work space.
  \end{args}
}
{
  A \id{CVLsJacFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_RECVR}), or a negative
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodeB}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvls} sets \id{last\_flag} to
  \Id{CVLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied Jacobian function must load the
  matrix \id{JacB} with an approximation to the Jacobian matrix at the point
  (\id{t},\id{y},\id{yS},\id{yB}), where \id{y} is the solution of the original
  IVP at time \id{tt}, \id{yS} is the vector of forward sensitivities at time \id{tt},
  and \id{yB} is the solution of the backward problem at the same time.
  Information regarding the structure of the specific {\sunmatrix}
  structure (e.g.~number of rows, upper/lower bandwidth, sparsity
  type) may be obtained through using the implementation-specific
  {\sunmatrix} interface functions (see Chapter \ref{s:sunmatrix} for
  details).

  With direct linear solvers (i.e., linear solvers with type
  \Id{SUNLINEARSOLVER\_DIRECT}, the Jacobian matrix $J(t,y)$ is zeroed out prior
  to calling the user-supplied Jacobian function so only nonzero elements need
  to be loaded into \id{JacB}.

  {\warn}Before calling the user's \id{CVLsJacFnBS}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvls} sets \id{last\_flag} to
  \Id{CVLS\_JACFUNC\_UNRECVR}).

  The previous function type \Id{CVDlsJacFnBS} is identical to
  \id{CVLsJacFnBS}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%==============================================================================
\subsection{Linear system construction for the backward problem (matrix-based linear solvers)}
\label{ss:linsysFn_b}

With matrix-based linear solver modules, as an alternative to optionally
supplying a function for evaluating the Jacobian of the ODE right-hand side
function, the user may optionally supply a function of type \ID{CVLsLinSysFnB}
or \ID{CVLsLinSysFnBS} (see \S\ref{ss:optional_input_b}) for evaluating the
linear system, $M_B = I - \gamma_B J_B$ (or an approximation of it) for the
backward problem.
%%
\index{Linear system approximation function!user-supplied (backward)}
\usfunction{CVLsLinSysFnB}
{
  typedef int (*CVLsLinSysFnB)(&realtype t, N\_Vector y, N\_Vector yB, \\
                               &N\_Vector fyB, SUNMatrix AB, \\
                               &booleantype jokB, booleantype *jcurB,\\
                               &realtype gammaB, void *user\_dataB, \\
                               &N\_Vector tmp1B, N\_Vector tmp2B, \\
                               &N\_Vector tmp3B);
}
{
  This function computes the linear system of the backward problem (or an
  approximation to it).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[MB]
    is the output approximate linear system matrix.
  \item[jokB]
    is an input flag indicating whether Jacobian-related
    data needs to be recomputed (\id{jokB}=\id{SUNFALSE}) or information saved
    from a previous invokation can be safely used (\id{jokB}=\id{SUNTRUE}).
  \item[jcurB]
    is an output flag which must be set to \id{SUNTRUE} if Jacobian-relatd data
    was recomputed or \id{SUNFALSE} otherwise.
  \item[gammaB]
    is the scalar appearing in the matrix $M_B = I - \gamma_B J_B$.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which
    can be used by the \id{CVLsLinSysFnB} function as temporary storage or work space.
  \end{args}
}
{
  A \id{CVLsLinSysFnB} should return \id{0} if successful, a positive value if a
  recoverable error occurred (in which case {\cvodes} will attempt to correct,
  while {\cvls} sets \id{last\_flag} to \Id{CVLS\_JACFUNC\_RECVR}), or a
  negative value if it failed unrecoverably (in which case the integration is
  halted, \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL} and {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied linear system function must load the matrix \id{MB} with an
  approximation to the linear system matrix at the point (\id{t}, \id{y},
  \id{yB}), where \id{y} is the solution of the original IVP at time \id{tt},
  and \id{yB} is the solution of the backward problem at the same time.

  {\warn}Before calling the user's \id{CVLsLinSysFnB}, {\cvodes} needs to
  evaluate (through interpolation) the values of the states from the forward
  integration. If an error occurs in the interpolation, {\cvodes} triggers an
  unrecoverable failure in the linear system function which will halt the
  integration (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_UNRECVR}).
}
%%
\index{Linear system approximation function!user-supplied (backward)}
\usfunction{CVLsLinSysFnBS}
{
  typedef int (*CVLsLinSysFnBS)(&realtype t, N\_Vector y, N\_Vector* yS,\\
                                &N\_Vector yB, N\_Vector fyB, SUNMatrix MB,\\
                                &booleantype jokB, booleantype *jcurB,\\
                                &realtype gammaB, void *user\_dataB, \\
                                &N\_Vector tmp1B, N\_Vector tmp2B, \\
                                &N\_Vector tmp3B);
}
{
  This function computes the linear system of the backward problem (or an
  approximation to it), in the case where the backward problem depends on the
  forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[MB]
    is the output approximate linear system matrix.
  \item[jokB]
    is an input flag indicating whether Jacobian-related
    data needs to be recomputed (\id{jokB}=\id{SUNFALSE}) or information saved
    from a previous invokation can be safely used (\id{jokB}=\id{SUNTRUE}).
  \item[jcurB]
    is an output flag which must be set to \id{SUNTRUE} if Jacobian-relatd data
    was recomputed or \id{SUNFALSE} otherwise.
  \item[gammaB]
    is the scalar appearing in the matrix $M_B = I - \gamma_B J_B$.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which
    can be used by \id{CVLsLinSysFnBS} as temporary storage or work space.
  \end{args}
}
{
  A \id{CVLsLinSysFnBS} should return \id{0} if successful, a positive value if
  a recoverable error occurred (in which case {\cvodes} will attempt to correct,
  while {\cvls} sets \id{last\_flag} to \Id{CVLS\_JACFUNC\_RECVR}), or a
  negative value if it failed unrecoverably (in which case the integration is
  halted, \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL} and {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied linear system function must load the matrix \id{MB} with an
  approximation to the linear system matrix at the point (\id{t}, \id{y},
  \id{yS}, \id{yB}), where \id{y} is the solution of the original IVP at time
  \id{tt}, \id{yS} is the vector of forward sensitivities at time \id{t}, and
  \id{yB} is the solution of the backward problem at the same time.

  {\warn}Before calling the user's \id{CVLsLinSysFnBS}, {\cvodes} needs to
  evaluate (through interpolation) the values of the states from the forward
  integration.  If an error occurs in the interpolation, {\cvodes} triggers an
  unrecoverable failure in the linear system function which will halt the
  integration (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL} and {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_UNRECVR}).
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian-vector product for the backward problem (matrix-free linear solvers)}\label{ss:jtimesv_b}
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}

If a matrix-free linear solver is to be used for the backward problem
(i.e., a \id{NULL}-valued {\sunmatrix} was supplied to
\id{CVodeSetLinearSolverB} in the steps described in
\S\ref{ss:skeleton_adj}), the user may provide a function of type
\Id{CVLsJacTimesVecFnB} or \Id{CVLsJacTimesVecFnBS} in the following form,
to compute matrix-vector products $Jv$. If such a function is not supplied,
the default is a difference quotient approximation to these products.
%%
\usfunction{CVLsJacTimesVecFnB}
{
  typedef int (*CVLsJacTimesVecFnB)(&N\_Vector vB, N\_Vector JvB, \\
                                    &realtype t, N\_Vector y, N\_Vector yB,\\
                                    &N\_Vector fyB, void *user\_dataB,\\
                                    &N\_Vector tmpB);
}
{
  This function computes the action of the Jacobian \id{JB} for
  the backward problem on a given vector \id{vB}.
}
{
  \begin{args}[user\_dataB]
  \item[vB]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[JvB]
    is the computed output vector \id{JB*vB}.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type \id{N\_Vector} which
    can be used by \id{CVLsJacTimesVecFn} as temporary storage or work space.
  \end{args}
}
{
  The return value of a function of type \id{CVLsJacTimesVecFnB} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the
  vector \id{JvB} with the product of the Jacobian of the backward
  problem at the point (\id{t},\id{y}, \id{yB}) and the vector \id{vB}.
  Here, \id{y} is the solution of the original IVP at time \id{t} and
  \id{yB} is the solution of the backward problem at the same time.
  The rest of the arguments are equivalent to those passed to a function of type
  \id{CVLsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).
  If the backward problem is the adjoint of ${\dot y} = f(t, y)$, then this
  function is to compute $-(\dfdyI)^T v_B$.

  The previous function type \Id{CVSpilsJacTimesVecFnB} is identical
  to \\ \noindent \id{CVLsJacTimesVecFnB}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon.
}
\usfunction{CVLsJacTimesVecFnBS}
{
  typedef int (*CVLsJacTimesVecFnBS)(&N\_Vector vB, N\_Vector JvB, \\
                                     &realtype t, N\_Vector y, N\_Vector *yS,\\
                                     &N\_Vector yB, N\_Vector fyB,\\
                                     &void *user\_dataB, N\_Vector tmpB);
}
{
  This function computes the action of the Jacobian \id{JB} for
  the backward problem on a given vector \id{vB}, in the case where
  the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[vB]
    is the vector by which the Jacobian must be multiplied to the right.
  \item[JvB]
    is the computed output vector \id{JB*vB}.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    is a pointer to an array containing the forward sensitivity vectors.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[user\_dataB]
    is a pointer to user data -- the same as passed to \id{CVodeSetUserDataB}.
  \item[tmpB]
    is a pointer to memory allocated for a variable of type \id{N\_Vector} which
    can be used by \id{CVLsJacTimesVecFn} as temporary storage or work space.
  \end{args}
}
{
  The return value of a function of type \id{CVLsJacTimesVecFnBS} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the product of the Jacobian of the backward problem
  at the point (\id{t},\id{y}, \id{yB}) and the vector \id{vB}.
  Here, \id{y} is the solution of the original IVP at time \id{t} and
  \id{yB} is the solution of the backward problem at the same time.
  The rest of the arguments are equivalent to those passed to a function of type
  \id{CVLsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).

  The previous function type \Id{CVSpilsJacTimesVecFnBS} is identical
  to \\ \noindent \id{CVLsJacTimesVecFnBS}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon.
}

%%-------------------------------------------------------------------------------------
\subsection{Jacobian-vector product setup for the backward problem (matrix-free linear solvers)}\label{ss:jactimesvecsetup_b}
\index{Jacobian approximation function!Jacobian-vector setup!user-supplied (backward)}

If the user's Jacobian-times-vector routine requires that any
Jacobian-related data be preprocessed or evaluated, then this needs to
be done in a user-supplied function of type \Id{CVLsJacTimesSetupFnB}
or \Id{CVLsJacTimesSetupFnBS}, defined as follows:
%%
\usfunction{CVLsJacTimesSetupFnB}
{
  typedef int (*CVLsJacTimesSetupFnB)(&realtype t, \\
                                      &N\_Vector y, N\_Vector yB, \\
                                      &N\_Vector fyB, void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian data needed
  by the Jacobian-times-vector routine for the backward problem.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the right-hand-side for the backward problem.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVSetUserDataB}.
  \end{args}
}
{
  The value returned by the Jacobian-vector setup function
  should be $0$ if successful, positive for a recoverable error (in
  which case the step will be retried), or negative for an
  unrecoverable error (in which case the integration is halted).
}
{
  Each call to the Jacobian-vector setup function is preceded by a call to
  the backward problem residual user function with the same
  \id{(t,y, yB)} arguments.
  Thus, the setup function can use any auxiliary data that is computed
  and saved during the evaluation of the right-hand-side function.

  If the user's \id{CVLsJacTimesVecFnB} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{cvode\_mem}
  to \id{user\_dataB} and then use the \id{CVGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  The previous function type \Id{CVSpilsJacTimesSetupFnB} is identical
  to \\ \noindent \id{CVLsJacTimesSetupFnB}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon.
}
%%
\usfunction{CVLsJacTimesSetupFnBS}
{
  typedef int (*CVLsJacTimesSetupFnBS)(&realtype t, \\
                                       &N\_Vector y, N\_Vector *yS, \\
                                       &N\_Vector yB, N\_Vector fyB, \\
                                       &void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian data needed
  by the Jacobian-times-vector routine for the backward problem, in the case that
  the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of
    the forward solution.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the right-hand-side function for the backward problem.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVSetUserDataB}.
  \end{args}
}
{
  The value returned by the Jacobian-vector setup function
  should be $0$ if successful, positive for a recoverable error (in
  which case the step will be retried), or negative for an
  unrecoverable error (in which case the integration is halted).
}
{
  Each call to the Jacobian-vector setup function is preceded by a call to
  the backward problem residual user function with the same
  \id{(t,y, yS, yB)} arguments.
  Thus, the setup function can use any auxiliary data that is computed
  and saved during the evaluation of the right-hand-side function.

  If the user's \id{CVLsJacTimesVecFnBS} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{cvode\_mem}
  to \id{user\_dataB} and then use the \id{CVGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  The previous function type \Id{CVSpilsJacTimesSetupFnBS} is identical
  to \\ \noindent \id{CVLsJacTimesSetupFnBS}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon.
}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioner solve for the backward problem (iterative linear solvers)}\label{ss:psolve_b}
\index{preconditioning!user-supplied}
\index{CVLS@{\cvls} linear solver!preconditioner solve function}

If a user-supplied preconditioner is to be used with a {\sunlinsol}
solver module, then the user must provide a function to solve the
linear system $Pz = r$, where $P$ may be either a left or a right
preconditioner matrix.  Here $P$ should approximate (at least crudely)
the matrix $M_B = I - \gamma_B J_B$, where $J_B = \partial f_B/ \partial y_B$.  If
preconditioning is done on both sides, the product of the two
preconditioner matrices should approximate $M_B$.
This function must be of one of the following two types:
%%
\usfunction{CVLsPrecSolveFnB}
{
  typedef int (*CVLsPrecSolveFnB)(&realtype t, N\_Vector y, \\
                                  &N\_Vector yB, N\_Vector fyB, \\
                                  &N\_Vector rvecB, N\_Vector zvecB, \\
                                  &realtype gammaB, realtype deltaB, \\
                                  &void *user\_dataB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[gammaB]
    is the scalar appearing in the matrix, $M_B = I - \gamma_B J_B$.
  \item[deltaB]
    is an input tolerance to be used if an iterative method
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful,
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{CVSpilsPrecSolveFnB} is identical to
  \id{CVLsPrecSolveFnB}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
%
\usfunction{CVLsPrecSolveFnBS}
{
  typedef int (*CVLsPrecSolveFnBS)(&realtype t, N\_Vector y, N\_Vector *yS,\\
                                   &N\_Vector yB, N\_Vector fyB, \\
                                   &N\_Vector rvecB, N\_Vector zvecB, \\
                                   &realtype gammaB, realtype deltaB, \\
                                   &void *user\_dataB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem,
  in the case where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    is a pointer to an array containing the forward sensitivity vectors.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[gammaB]
    is the scalar appearing in the matrix, $M_B = I - \gamma_B J_B$.
  \item[deltaB]
    is an input tolerance to be used if an iterative method
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful,
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{CVSpilsPrecSolveFnBS} is identical to
  \id{CVLsPrecSolveFnBS}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioner setup for the backward problem (iterative linear solvers)}\label{ss:psetup_b}
\index{preconditioning!user-supplied}
\index{CVLS@{\cvls} linear solver!preconditioner setup function}

If the user's preconditioner requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied function of one of the following two types:
%%
\usfunction{CVLsPrecSetupFnB}
{
  typedef int (*CVLsPrecSetupFnB)(&realtype t, N\_Vector y, \\
                                  &N\_Vector yB, N\_Vector fyB, \\
                                  &booleantype jokB, booleantype *jcurPtrB,\\
                                  &realtype gammaB, void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem.
}
{
  The arguments of a \id{CVLsPrecSetupFnB} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[jokB]
    is an input flag indicating whether Jacobian-related
    data needs to be recomputed (\id{jokB}=\id{SUNFALSE}) or information saved
    from a previous invokation can be safely used (\id{jokB}=\id{SUNTRUE}).
  \item[jcurPtr]
    is an output flag which must be set to \id{SUNTRUE} if Jacobian-relatd data
    was recomputed or \id{SUNFALSE} otherwise.
  \item[gammaB]
    is the scalar appearing in the matrix $M_B = I - \gamma_B J_B$.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful,
  positive for a recoverable error (in which case the step will be retried),
  or negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{CVSpilsPrecSetupFnB} is identical to
  \id{CVLsPrecSetupFnB}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

\usfunction{CVLsPrecSetupFnBS}
{
  typedef int (*CVLsPrecSetupFnBS)(&realtype t, N\_Vector y, N\_Vector *yS,\\
                                   &N\_Vector yB, N\_Vector fyB, \\
                                   &booleantype jokB, booleantype *jcurPtrB,\\
                                   &realtype gammaB, void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem, in the case where the
  backward problem depends on the forward sensitivities.

}
{
  The arguments of a \id{CVLsPrecSetupFnBS} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yS]
    is a pointer to an array containing the forward sensitivity vectors.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[fyB]
    is the current value of the backward right-hand side function $f_B$.
  \item[jokB]
    is an input flag indicating whether Jacobian-related
    data needs to be recomputed (\id{jokB}=\id{SUNFALSE}) or information saved
    from a previous invokation can be safely used (\id{jokB}=\id{SUNTRUE}).
  \item[jcurPtr]
    is an output flag which must be set to \id{SUNTRUE} if Jacobian-relatd data
    was recomputed or \id{SUNFALSE} otherwise.
  \item[gammaB]
    is the scalar appearing in the matrix $M_B = I - \gamma_B J_B$.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful,
  positive for a recoverable error (in which case the step will be retried),
  or negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{CVSpilsPrecSetupFnBS} is identical to
  \id{CVLsPrecSetupFnBS}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
%%
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
\section{Using CVODES preconditioner modules for the backward problem}
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
%%

As on the forward integration phase, the efficiency of Krylov iterative methods
for the solution of linear systems can be greatly enhanced through preconditioning.
Both preconditioner modules provided with {\sundials}, the serial banded
preconditioner {\cvbandpre} and the parallel band-block-diagonal preconditioner
module {\cvbbdpre}, provide interface functions through which they can be used
on the backward integration phase.


%%-------------------------------------------------------------------
\subsection{Using the banded preconditioner CVBANDPRE}
%%-------------------------------------------------------------------

\index{CVBANDPRE@{\cvbandpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\cvodes} offers an interface to the banded
preconditioner module {\cvbandpre} described in section \S\ref{sss:cvbandpre}.
This preconditioner, usable only in a serial setting, provides a band matrix
preconditioner based on difference quotients of the backward problem right-hand
side function \id{fB}.  It generates
a banded approximation to the Jacobian with $m_{lB}$ sub-diagonals and $m_{uB}$
super-diagonals to be used with one of the Krylov linear solvers.

In order to use the {\cvbandpre} module in the solution of the backward problem,
the user need not define any additional functions.
Instead, {\em after} an iterative {\sunlinsol} object has been
attached to {\cvodes} via a call to \Id{CVodeSetLinearSolverB}, the
following call to the {\cvbandpre} module initialization function must be made.
%%
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|(}
\ucfunctionf{CVBandPrecInitB}
{
  flag = CVBandPrecInitB(cvode\_mem, which, nB, muB, mlB);
}
{
  The function \ID{CVBandPrecInitB} initializes and allocates
  memory for the {\cvbandpre} preconditioner for the backward problem.
  It creates, allocates, and stores (internally in the {\cvodes}
  solver block) a pointer to the newly created {\cvbandpre} memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[nB] (\id{sunindextype})
    backward problem dimension.
  \item[muB] (\id{sunindextype})
    upper half-bandwidth of the backward problem Jacobian approximation.
  \item[mlB] (\id{sunindextype})
    lower half-bandwidth of the backward problem Jacobian approximation.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The call to \id{CVodeBandPrecInitB} was successful.
  \item[\Id{CVLS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVLS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|)}
For more details on {\cvbandpre} see \S\ref{sss:cvbandpre}.
\index{CVBANDPRE@{\cvbandpre} preconditioner!usage with adjoint module|)}



%%-------------------------------------------------------------------
\subsection{Using the band-block-diagonal preconditioner CVBBDPRE}
%%-------------------------------------------------------------------
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\cvodes} offers an interface to the band-block-diagonal
preconditioner module {\cvbbdpre} described in section \S\ref{sss:cvbbdpre}.
This generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix and can be used with one of the Krylov linear solvers
and with the MPI-parallel vector module {\nvecp}.

In order to use the {\cvbbdpre} module in the solution of the backward problem,
the user must define one or two additional functions, described at the
end of this section.

\subsubsection{Initialization of CVBBDPRE}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|(}
The {\cvbbdpre} module is initialized by calling the following function,
{\em after} an iterative {\sunlinsol} object has been
attached to {\cvodes} via a call to \Id{CVodeSetLinearSolverB}.
%%
%%
\ucfunctionf{CVBBDPrecInitB}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = CVBBDPrecInitB(&cvode\_mem, which, NlocalB, mudqB, mldqB,\\
                          &mukeepB, mlkeepB, dqrelyB, glocB, gcommB);
  \end{tabular}
}
{
  The function \ID{CVBBDPrecInitB} initializes and allocates
  memory for the {\cvbbdpre} preconditioner for the backward problem.
  It creates, allocates, and stores (internally in the {\cvodes} solver
  block) a pointer to the newly created {\cvbbdpre} memory block.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[NlocalB] (\id{sunindextype})
    local vector dimension for the backward problem.
  \item[mudqB] (\id{sunindextype})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{sunindextype})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeepB] (\id{sunindextype})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeepB] (\id{sunindextype})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.  The default is \id{dqrelyB}$ = \sqrt{\text{unit roundoff}}$, which
    can be specified by passing \id{dqrely}$ = 0.0$.
  \item[glocB] (\id{CVBBDLocalFnB})
    the function which computes the function $g_B(t,y,y_B)$ approximating
    the right-hand side of the backward problem.
  \item[gcommB] (\id{CVBBDCommFnB})
    the optional function which performs all interprocess communication required for
    the computation of $g_B$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The call to \id{CVodeBBDPrecInitB} was successful.
  \item[\Id{CVLS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVLS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
To reinitialize the {\cvbbdpre} preconditioner module for the backward problem,
possibly with changes in \id{mudqB}, \id{mldqB}, or \id{dqrelyB}, call the following
function:
%%
\ucfunctionf{CVBBDPrecReInitB}
{
  flag = CVBBDPrecReInitB(cvode\_mem, which, mudqB, mldqB, dqrelyB);
}
{
  The function \ID{CVBBDPrecReInitB} reinitializes the {\cvbbdpre} preconditioner
  for the backward problem.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[mudqB] (\id{sunindextype})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{sunindextype})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The call to \id{CVodeBBDPrecReInitB} was successful.
  \item[\Id{CVLS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CVLS\_PMEM\_NULL}]
    The \id{CVodeBBDPrecInitB} has not been previously called.
  \item[\Id{CVLS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{CVLS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|)}
%%
For more details on {\cvbbdpre} see \S\ref{sss:cvbbdpre}.

\subsubsection{User-supplied functions for CVBBDPRE}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|(}
To use the {\cvbbdpre} module, the user must supply one or two functions which the
module calls to construct the preconditioner: a required function \id{glocB}
(of type \id{CVBBDLocalFnB}) which approximates the right-hand side of the backward
problem and which is computed locally, and an optional function \id{gcommB}
(of type \id{CVBBDCommFnB}) which performs all interprocess communication necessary
to evaluate this approximate right-hand side (see \S\ref{sss:cvbbdpre}).
The prototypes for these two functions are described below.
%%
%%
\usfunction{CVBBDLocalFnB}
{
  typedef int (*CVBBDLocalFnB)(&sunindextype NlocalB, realtype t, N\_Vector y,\\
                               &N\_Vector yB, N\_Vector gB, void *user\_dataB);
}
{
  This \id{glocB} function loads the vector \id{gB}, an approximation to the
  right-hand side $f_B$ of the backward problem, as a function of \id{t}, \id{y},
  and \id{yB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB]
    is the local vector length for the backward problem.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[gB]
    is the output vector, $g_B(t, y, y_B)$.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  An \id{CVBBDLocalFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL}).
}
{
  This routine must assume that all interprocess communication of data needed to
  calculate \id{gB} has already been done, and this data is accessible within
  \id{user\_dataB}.

  {\warn}Before calling the user's \id{CVBBDLocalFnB}, {\cvodes} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\cvodes} triggers an unrecoverable
  failure in the preconditioner setup function which will halt the integration
  (\id{CVodeB} returns \id{CV\_LSETUP\_FAIL}).
}
%%
%%
\usfunction{CVBBDCommFnB}
{
  typedef int (*CVBBDCommFnB)(&sunindextype NlocalB, realtype t, N\_Vector y,\\
                              &N\_Vector yB, void *user\_dataB);
}
{
  This \id{gcommB} function must perform all interprocess communications necessary
  for the execution of the \id{glocB} function above, using the input
  vectors \id{y} and \id{yB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB]
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}
    parameter passed to \id{CVodeSetUserDataB}.
  \end{args}
}
{
  An \id{CVBBDCommFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVodeB} returns \Id{CV\_LSETUP\_FAIL}).
}
{
  The \id{gcommB} function is expected to save communicated data in space defined within the
  structure \id{user\_dataB}.

  Each call to the \id{gcommB} function is preceded by a call to the function that
  evaluates the right-hand side of the backward problem with the same \id{t}, \id{y},
  and \id{yB}, arguments. If there is no additional communication needed, then
  pass \id{gcommB = NULL} to \id{CVBBDPrecInitB}.
}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|)}
%%
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage with adjoint module|)}
