%%===================================================================================
\chapter{Using CVODES for IVP Solution}\label{s:simulation}
%%===================================================================================

This chapter is concerned with the use of {\cvodes} for the solution of
initial value problems (IVPs) in a C language setting.  The following
sections treat the header files and the layout of the user's main
program, and provide descriptions of the {\cvodes} user-callable
functions and user-supplied functions.
This usage is essentially equivalent to using {\cvode}~\cite{cvode_ug}.

The sample programs described in the companion document \cite{cvodes_ex}
may also be helpful.  Those codes may be used as templates (with the removal
of some lines used in testing) and are included in the {\cvodes} package.

Users with applications written in {\F} should see Chapter \ref{s:cvfort},
which describes interfacing with {\cvodes} from {\F}.

The user should be aware that not all {\sunlinsol} and {\sunmatrix}
modules are compatible with all {\nvector} implementations.
\index{CVODES@{\cvodes} linear solvers!NVECTOR@{\nvector} compatibility}
Details on compatibility are given in the documentation for each
{\sunmatrix} module (Chapter \ref{s:sunmatrix}) and each {\sunlinsol}
module (Chapter \ref{s:sunlinsol}). For example, {\nvecp} is not
compatible with the dense, banded, or sparse {\sunmatrix} types, or with
the corresponding dense, banded, or sparse {\sunlinsol} modules.  Please
check Chapters \ref{s:sunmatrix} and \ref{s:sunlinsol} to verify
compatibility between these modules.  In addition to that
documentation, we note that the {\cvbandpre} preconditioning module is
only compatible with the {\nvecs}, {\nvecopenmp}, and {\nvecpthreads}
vector implementations, and the preconditioner module {\cvbbdpre}
can only be used with {\nvecp}.
It is not recommended to use a threaded vector module with SuperLU\_MT
unless it is the {\nvecopenmp} module, and SuperLU\_MT is also compiled
with OpenMP.

{\cvodes} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

%%==============================================================================
\section{Access to library and header files}\label{ss:file_access}
%%==============================================================================

At this point, it is assumed that the installation of {\cvodes},
following the procedure described in Appendix \ref{c:install}, has
been completed successfully.

Regardless of where the user's application program resides, its
associated compilation and load commands must make reference to the
appropriate locations for the library and header files required by
{\cvodes}.  The relevant library files are
\begin{itemize}
\item {\em libdir}\id{/libsundials\_cvodes.}{\em lib},
\item {\em libdir}\id{/libsundials\_nvec*.}{\em lib},
\end{itemize}
where the file extension .{\em lib} is typically \id{.so} for shared libraries
and \id{.a} for static libraries. The relevant header files are located in
the subdirectories
\begin{itemize}
\item {\em incdir}\id{/include/cvodes}
\item {\em incdir}\id{/include/sundials}
\item {\em incdir}\id{/include/nvector}
\item {\em incdir}\id{/include/sunmatrix}
\item {\em incdir}\id{/include/sunlinsol}
\item {\em incdir}\id{/include/sunnonlinsol}
\end{itemize}
The directories {\em libdir} and {\em incdir} are the install library and include
directories, respectively. For a default installation, these are {\em instdir}\id{/lib} and
{\em instdir}\id{/include}, respectively, where {\em instdir} is the directory
where {\sundials} was installed (see Appendix \ref{c:install}).

Note that an application cannot link to both the {\cvode} and {\cvodes} libraries
because both contain user-callable functions with the same names (to ensure that
{\cvodes} is backward compatible with {\cvode}). Therefore, applications that contain
both ODE problems and ODEs with sensitivity analysis, should use {\cvodes}.


%%===================================================================================
\section{Data Types}\label{s:types}
%%===================================================================================
\input{types}

%%===================================================================================
\section{Header files}\label{ss:header_sim}
%%===================================================================================
\index{header files}
The calling program must include several header files so that various macros
and data types can be used. The header file that is always required is:
%%
\begin{itemize}
\item  \Id{cvodes/cvodes.h},
  the main header file for {\cvodes}, which defines the several
  types and various constants, and includes function prototypes.  This
  includes the header file for {\cvls}, \\ \noindent \Id{cvodes/cvodes\_ls.h}.
\end{itemize}
%%
Note that \id{cvodes.h} includes \Id{sundials\_types.h},
which defines the types \id{realtype}, \id{sunindextype}, and \id{booleantype}
and the constants \id{SUNFALSE} and \id{SUNTRUE}.

The calling program must also include an {\nvector} implementation header file,
of the form \\ \noindent \id{nvector/nvector\_***.h}.  See Chapter \ref{s:nvector}
for the appropriate name.  This file in turn includes the header file
\Id{sundials\_nvector.h} which defines the abstract \Id{N\_Vector} data type.

If using a non-default nonlinear solver module, or when interacting
with a {\sunnonlinsol} module directly, the calling program must also
include a {\sunnonlinsol} implementation header file, of the form
\id{sunnonlinsol/sunnonlinsol\_***.h} where \id{***} is the name of the
nonlinear solver module (see Chapter \ref{c:sunnonlinsol} for more
information). This file in turn includes the header file
\Id{sundials\_nonlinearsolver.h} which defines the abstract
\Id{SUNNonlinearSolver} data type.

If using a nonlinear solver that requires the solution of a linear
system of the form (\ref{e:Newton}) (e.g., the default Newton iteration),
then a linear solver module header file will be required.
\index{CVODES@{\cvodes} linear solvers!header files}
The header files corresponding to the various {\sundials}-provided
linear solver modules available for use with {\cvodes} are:
%%
\begin{itemize}
\item Direct linear solvers:
  \begin{itemize}
  \item \Id{sunlinsol/sunlinsol\_dense.h},
    which is used with the dense linear solver module,
    {\sunlinsoldense};

  \item \Id{sunlinsol/sunlinsol\_band.h},
    which is used with the banded linear solver module,
    {\sunlinsolband};

  \item \Id{sunlinsol/sunlinsol\_lapackdense.h},
    which is used with the LAPACK dense linear solver module,
    {\sunlinsollapdense};

  \item \Id{sunlinsol/sunlinsol\_lapackband.h},
    which is used with the LAPACK banded linear solver module,
    {\sunlinsollapband};

  \item \Id{sunlinsol/sunlinsol\_klu.h},
    which is used with the {\klu} sparse linear solver module,
    {\sunlinsolklu};

  \item \Id{sunlinsol/sunlinsol\_superlumt.h},
    which is used with the {\superlumt} sparse linear solver
    module, {\sunlinsolslumt};
  \end{itemize}

\item Iterative linear solvers:
  \begin{itemize}
  \item \Id{sunlinsol/sunlinsol\_spgmr.h},
    which is used with the scaled, preconditioned GMRES Krylov linear
    solver module, {\sunlinsolspgmr};

  \item \Id{sunlinsol/sunlinsol\_spfgmr.h},
    which is used with the scaled, preconditioned FGMRES Krylov linear
    solver module, {\sunlinsolspfgmr};

  \item \Id{sunlinsol/sunlinsol\_spbcgs.h},
    which is used with the scaled, preconditioned Bi-CGStab Krylov
    linear solver module, {\sunlinsolspbcgs};

  \item \Id{sunlinsol/sunlinsol\_sptfqmr.h},
    which is used with the scaled, preconditioned TFQMR Krylov linear
    solver module, {\sunlinsolsptfqmr};

  \item \Id{sunlinsol/sunlinsol\_pcg.h},
    which is used with the scaled, preconditioned CG Krylov linear
    solver module, {\sunlinsolpcg};
  \end{itemize}
\item \Id{cvodes/cvodes\_diag.h},
  which is used with the {\cvdiag} diagonal linear solver module.
\end{itemize}

The header files for the {\sunlinsoldense} and {\sunlinsollapdense}
linear solver modules include the file
\id{sunmatrix/sunmatrix\_dense.h}, which defines the {\sunmatdense}
matrix module, as as well as various functions and macros acting on
such matrices.

The header files for the {\sunlinsolband} and {\sunlinsollapband}
linear solver modules include the file
\id{sunmatrix/sunmatrix\_band.h}, which defines the {\sunmatband}
matrix module, as as well as various functions and macros acting on
such matrices.

The header files for the {\sunlinsolklu} and {\sunlinsolslumt}
sparse linear solvers include the file
\id{sunmatrix/sunmatrix\_sparse.h}, which defines the {\sunmatsparse}
matrix module, as well as various functions and macros acting on such
matrices.

The header files for the Krylov iterative solvers include the file
\id{sundials/sundials\_iterative.h}, which enumerates the kind of
preconditioning, and (for the {\spgmr} and {\spfgmr} solvers) the
choices for the Gram-Schmidt process.

Other headers may be needed, according to the choice of
preconditioner, etc.  For example, in the \id{cvsDiurnal\_kry\_p}
example (see \cite{cvodes_ex}), preconditioning is done with a
block-diagonal matrix. For this, even though the {\sunlinsolspgmr}
linear solver is used, the header \id{sundials/sundials\_dense.h} is
included for access to the underlying generic dense matrix arithmetic
routines.

%%====================================================================
\section{A skeleton of the user's main program}\label{ss:skeleton_sim}
%%====================================================================

The following is a skeleton of the user's main program (or calling
program) for the integration of an ODE IVP. Most of the steps are
independent of the {\nvector}, {\sunmatrix}, {\sunlinsol}, and {\sunnonlinsol}
implementations used. For the steps that are not, refer to Chapters
\ref{s:nvector}, \ref{s:sunmatrix}, \ref{s:sunlinsol}, and \ref{c:sunnonlinsol}
for the specific name of the function to be called or macro to be referenced.

\index{User main program!IVP solution}
\begin{Steps}

\item
  {\bf Initialize parallel or multi-threaded environment, if appropriate}

  For example, call \id{MPI\_Init} to initialize {\mpi} if used, or
  set \id{num\_threads}, the number of threads to use within the threaded
  vector functions, if used.

\item
  {\bf Set problem dimensions etc.}

  This generally includes the problem size \id{N}, and may include
  the local vector length \id{Nlocal}.

  Note: The variables \id{N} and \id{Nlocal} should be of type \id{sunindextype}.

\item
  {\bf Set vector of initial values}

  To set the vector \id{y0} of initial values, use the appropriate
  functions defined by the particular {\nvector} implementation.

  For native {\sundials} vector implementations
  (except the {\cuda} and {\raja}-based ones), use a call
  of the form \id{y0 = N\_VMake\_***(..., ydata)} if the \id{realtype} array
  \id{ydata} containing the initial values of $y$ already exists.
  Otherwise, create a new vector by making a call of the form
  \id{y0 = N\_VNew\_***(...)}, and then set its elements by accessing
  the underlying data with a call of the form
  \id{ ydata = N\_VGetArrayPointer(y0)}.
  See \S\ref{ss:nvec_ser}-\ref{ss:nvec_pthreads} for details.

  For the {\hypre} and {\petsc} vector wrappers, first create and initialize
  the underlying vector, and then create an {\nvector} wrapper with a call
  of the form \id{y0 = N\_VMake\_***(yvec)}, where \id{yvec} is a {\hypre}
  or {\petsc} vector. Note that calls like \id{N\_VNew\_***(...)} and
  \id{N\_VGetArrayPointer(...)} are not available for these vector wrappers.
  See \S\ref{ss:nvec_parhyp} and \S\ref{ss:nvec_petsc} for details.

  If using either the {\cuda}- or {\raja}-based vector implementations
  use a call of the form
  \id{y0 = N\_VMake\_***(..., c)} where \id{c} is a pointer to a \id{suncudavec}
  or \id{sunrajavec} vector class if this class already exists.  Otherwise,
  create a new vector
  by making a call of the form \id{y0 = N\_VNew\_***(...)}, and then set its
  elements by accessing the underlying data where it is located
  with a call of the form
  \id{N\_VGetDeviceArrayPointer\_***} or \id{N\_VGetHostArrayPointer\_***}.
  Note that the vector class will allocate memory on both the host and device
  when instantiated.  See \S\ref{ss:nvec_cuda}-\ref{ss:nvec_raja} for details.

%   If a \id{realtype} array \id{ydata} containing the initial values of $y$
%   already exists, it may be possible to do this either with a call of the form
%   \id{y0 = N\_VMake\_***(..., ydata);}
%   or by making a call of the form
%   \id{y0 = N\_VNew\_***(...);}
%   and loading values into the structure defined by \id{NV\_DATA\_***(y0)},
%   provided these functions and macro exist for the {\nvector} module chosen.

\item\label{i:cvode_create}
  {\bf Create {\cvodes} object}

  Call \id{cvode\_mem = }\id{CVodeCreate}\id{(lmm)}
  to create the {\cvodes} memory block and to specify the
  linear multistep method.
  \id{CVodeCreate} returns a pointer to the {\cvodes} memory structure.
  See \S\ref{sss:cvodemalloc} for details.

\item\label{i:cvode_malloc}
  {\bf Initialize {\cvodes} solver}

  Call \id{CVodeInit}\id{(...)}
  to provide required problem specifications, allocate internal memory for
  {\cvodes}, and initialize {\cvodes}.
  \id{CVodeInit} returns a flag, the value of which indicates either success or
  an illegal argument value.  See \S\ref{sss:cvodemalloc} for details.

\item
  {\bf Specify integration tolerances}

  Call \id{CVodeSStolerances}\id{(...)} or \id{CVodeSVtolerances}\id{(...)}
  to specify either a scalar relative tolerance and scalar absolute tolerance, or
  a scalar relative tolerance and a vector of absolute tolerances, respectively.
  Alternatively, call \id{CVodeWFtolerances} to specify a function which sets
  directly the weights used in evaluating WRMS vector norms.
  See \S\ref{sss:cvtolerances} for details.

\item\label{i:matrix}
  {\bf Create matrix object}

  If a nonlinear solver requiring a linear solve will be used (e.g., the
  default Newton iteration) and the linear solver will be a matrix-based linear
  solver, then a template Jacobian matrix must be created by calling the
  appropriate constructor function defined by the particular {\sunmatrix}
  implementation.

  For the {\sundials}-supplied {\sunmatrix} implementations, the
  matrix object may be created using a call of the form

  \id{SUNMatrix J = }\Id{SUNBandMatrix}\id{(...);}

   or

  \id{SUNMatrix J = }\Id{SUNDenseMatrix}\id{(...);}

   or

  \id{SUNMatrix J = }\Id{SUNSparseMatrix}\id{(...);}

  NOTE: The dense, banded, and sparse matrix objects are usable only in a
  serial or threaded environment.

\item\label{i:lin_solver}
  {\bf Create linear solver object}

  If a nonlinear solver requiring a linear solver is chosen (e.g., the default
  Newton iteration), then the desired linear solver object must be created by
  calling the appropriate constructor function defined by the particular
  {\sunlinsol} implementation.

  For any of the {\sundials}-supplied {\sunlinsol} implementations,
  the linear solver object may be created using a call of the form

  \id{SUNLinearSolver LS = SUNLinSol\_*(...);}

  where \id{*} can be replaced with ``Dense'', ``SPGMR'', or other
  options, as discussed in \S\ref{sss:lin_solv_init} and Chapter {\ref{s:sunlinsol}}.

\item
  {\bf Set linear solver optional inputs}

  Call \id{*Set*} functions from the selected linear solver module to
  change optional inputs specific to that linear solver.
  See the documentation for each {\sunlinsol} module in Chapter
  {\ref{s:sunlinsol}} for details.

\item\label{i:lin_solver_interface}
  {\bf Attach linear solver module}

  If a nonlinear solver requiring a linear solver is chosen (e.g., the default
  Newton iteration), then initialize the {\cvls} linear solver
  interface by attaching the linear solver object (and matrix object, if
  applicable) with the call (for details see
  \S\ref{sss:lin_solv_init}):

  \id{ier = }\Id{CVodeSetLinearSolver}\id{(...);}

  Alternately, if the {\cvodes}-specific diagonal linear solver module,
  {\cvdiag}, is desired, initialize the linear solver module and
  attach it to {\cvodes} with the call

  \id{ier = }\Id{CVDiag}\id{(...);}

\item
  {\bf Set optional inputs}

  Call \id{CVodeSet*} functions to change any
  optional inputs that control the behavior of {\cvodes} from their default values.
  See \S\ref{sss:optin_main} and \S\ref{ss:optional_input} for details.

\item\label{i:nonlin_solver}
  {\bf Create nonlinear solver object} (\textit{optional})

  If using a non-default nonlinear solver (see \S\ref{ss:nonlin_solv_init}),
  then create the desired nonlinear solver object by calling the appropriate
  constructor function defined by the particular {\sunnonlinsol} implementation
  (e.g., \id{NLS = SUNNonlinSol\_***(...);} where \id{***} is the name of the
  nonlinear solver (see Chapter \ref{c:sunnonlinsol} for details).

\item\label{i:nonlin_solver_interface}
  {\bf Attach nonlinear solver module} (\textit{optional})

  If using a non-default nonlinear solver, then initialize the nonlinear solver
  interface by attaching the nonlinear solver object by calling
  \id{ier = }\Id{CVodeSetNonlinearSolver}\id{(cvode\_mem, NLS);} (see
  \S\ref{ss:nonlin_solv_init} for details).

\item
  {\bf Set nonlinear solver optional inputs} (\textit{optional})

  Call the appropriate set functions for the selected nonlinear solver module to
  change optional inputs specific to that nonlinear solver. These \textit{must}
  be called after \id{CVodeInit} if using the default nonlinear solver or after
  attaching a new nonlinear solver to {\cvode}, otherwise the optional inputs
  will be overridden by {\cvodes} defaults. See Chapter \ref{c:sunnonlinsol} for
  more information on optional inputs.

\item
  {\bf Specify rootfinding problem}
  \index{Rootfinding}

  Optionally, call \id{CVodeRootInit} to initialize a rootfinding problem
  to be solved during the integration of the ODE system.
  See \S\ref{ss:cvrootinit}, and see \S\ref{sss:optin_root} for
  relevant optional input calls.

\item
  {\bf Advance solution in time}

  For each point at which output is desired, call
  \id{ier = }\Id{CVode}\id{(cvode\_mem, tout, yout, \&tret, itask)}.
  Here \Id{itask} specifies the return mode.
  The vector \id{yout} (which can be the same as
  the vector \id{y0} above) will contain $y(t)$.
  See \S\ref{sss:cvode} for details.

\item
  {\bf Get optional outputs}

  Call \id{CV*Get*} functions to obtain optional output.
  See \S\ref{ss:optional_output} for details.

\item
  {\bf Deallocate memory for solution vector}

  Upon completion of the integration, deallocate memory for the vector \id{y}
  (or \id{yout}) by calling the appropriate destructor function defined by the
  {\nvector} implementation:

  \id{N\_VDestroy(y);}

\item
  {\bf Free solver memory}

  Call \Id{CVodeFree}\id{(\&cvode\_mem)} to free the memory allocated by {\cvodes}.

\item
  {\bf Free nonlinear solver memory} (\textit{optional})

  If a non-default nonlinear solver was used, then call
  \Id{SUNNonlinSolFree}\id{(NLS)} to free any memory allocated for the
  {\sunnonlinsol} object.

\item
  {\bf Free linear solver and matrix memory}

  Call \Id{SUNLinSolFree} and \ID{SUNMatDestroy} to free any memory
  allocated for the linear solver and matrix objects created above.

\item
  {\bf Finalize MPI, if used}

  Call \id{MPI\_Finalize()} to terminate MPI.

\end{Steps}

\input{linear-vector-table}


%%===========================================================
\section{User-callable functions}\label{ss:callable_fct_sim}
%%===========================================================

This section describes the {\cvodes} functions that are called by the
user to setup and then solve an IVP. Some of these are required. However,
starting with \S\ref{ss:optional_input}, the functions listed involve
optional inputs/outputs or restarting, and those paragraphs may be
skipped for a casual use of {\cvodes}. In any case, refer to
\S\ref{ss:skeleton_sim} for the correct order of these calls.

On an error, each user-callable function returns a negative value and
sends an error message to the error handler routine, which prints the
message on \id{stderr} by default. However, the user can set a file
as error output or can provide his own error handler function (see
\S\ref{sss:optin_main}).

%%==============================================================================
\subsection{CVODES initialization and deallocation functions}
\label{sss:cvodemalloc}
%%==============================================================================

The following three functions must be called in the order listed. The last one
is to be called only after the IVP solution is complete, as it frees the
{\cvodes} memory block created and allocated by the first two calls.
%%
\ucfunctionf{CVodeCreate}
{
  cvode\_mem = CVodeCreate(lmm);
}
{
  The function \ID{CVodeCreate} instantiates a {\cvodes} solver object and
  specifies the solution method.
}
{
  \begin{args}[lmm]
  \item[lmm] (\id{int})
    specifies the linear multistep method and must be one of two
    possible values: \Id{CV\_ADAMS} or \Id{CV\_BDF}.
  \end{args}
  The recommended choices for \Id{lmm} are \id{CV\_ADAMS} for nonstiff problems
  and \id{CV\_BDF} for stiff problems. The default Newton iteration is
  recommended for stiff problems, and the fixed-point solver (previously referred
  to as the functional iteration in this guide) is
  recommended for nonstiff problems. For details on how to attach a
  different nonlinear solver module to {\cvodes} see the description of
  \id{CVodeSetNonlinearSolver}.
}
{
  If successful, \id{CVodeCreate} returns a pointer to the newly created
  {\cvodes} memory block (of type \id{void *}).  Otherwise, it returns \id{NULL}.
}
{}
%%
%%
\ucfunctionf{CVodeInit}
{
flag = CVodeInit(cvode\_mem, f, t0, y0);
}
{
  The function \ID{CVodeInit} provides required problem and solution
  specifications, allocates internal memory, and initializes {\cvodes}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[f] (\Id{CVRhsFn})
    is the {\CC} function which computes the right-hand side function $f$ in the ODE.
    This function has the form \id{f(t, y, ydot, user\_data)} (for full details see
    \S\ref{ss:rhsFn}).
  \item[t0] (\id{realtype})
    is the initial value of $t$.
  \item[y0] (\id{N\_Vector})
    is the initial value of $y$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeInit} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory block was not initialized through a previous call
    to \id{CVodeCreate}.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CV\_ILL\_INPUT}]
    An input argument to \id{CVodeInit} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{CVodeInit} also sends an error message to the
  error handler function.
}
%%
%%
\ucfunctionf{CVodeFree}
{
  CVodeFree(\&cvode\_mem);
}
{
  The function \ID{CVodeFree} frees the memory allocated by
  a previous call to \id{CVodeCreate}.
}
{
  The argument is the pointer to the {\cvodes} memory block (of type \id{void *}).
}
{
  The function \id{CVodeFree} has no return value.
}
{}


%%==============================================================================
\subsection{CVODES tolerance specification functions}\label{sss:cvtolerances}
%%==============================================================================
%%
One of the following three functions must be called to specify the integration
tolerances (or directly specify the weights used in evaluating WRMS vector norms).
Note that this call must be made after the call to \id{CVodeInit}.
%%
\ucfunctionf{CVodeSStolerances}
{
  flag = CVodeSStolerances(cvode\_mem, reltol, abstol);
}
{
  The function \ID{CVodeSStolerances} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSStolerances} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}]
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the input tolerances was negative.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeSVtolerances}
{
  flag = CVodeSVtolerances(cvode\_mem, reltol, abstol);
}
{
  The function \ID{CVodeSVtolerances} specifies scalar relative tolerance and
  vector absolute tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{N\_Vector})
    is the vector of absolute error tolerances.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeSVtolerances} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}]
    The allocation function \id{CVodeInit} has not been called.
  \item[\Id{CV\_ILL\_INPUT}]
    The relative error tolerance was negative or the absolute tolerance
    had a negative component.
  \end{args}
}
{
  This choice of tolerances is important when the absolute error tolerance needs to
  be different for each component of the state vector $y$.
}
%%
%%
\ucfunctionf{CVodeWFtolerances}
{
  flag = CVodeWFtolerances(cvode\_mem, efun);
}
{
  The function \ID{CVodeWFtolerances} specifies a user-supplied function \id{efun}
  that sets the multiplicative error weights $W_i$ for use in the weighted
  RMS norm, which are normally defined by Eq. (\ref{e:errwt}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[efun] (\id{CVEwtFn})
    is the {\CC} function which defines the \id{ewt} vector (see
    \S\ref{ss:ewtsetFn}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeWFtolerances} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory block was not initialized through a previous call to
    \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}]
    The allocation function \id{CVodeInit} has not been called.
  \end{args}
}
{}

\index{tolerances}
{\bf General advice on choice of tolerances.}
For many users, the appropriate choices for tolerance values in
\id{reltol} and \id{abstol} are a concern.  The following pieces of
advice are relevant.

(1) The scalar relative tolerance \id{reltol} is to be set to control relative
errors.  So \id{reltol} $= 10^{-4}$ means that errors are controlled to .01\%.
We do not recommend using \id{reltol} larger than $10^{-3}$.  On the other hand,
\id{reltol} should not be so small that it is comparable to the unit roundoff
of the machine arithmetic (generally around 1.0E-15).

(2) The absolute tolerances \id{abstol} (whether scalar or vector) need to
be set to control absolute errors when any components of the solution
vector \id{y} may be so small that pure relative error control is
meaningless.  For example, if \id{y[i]} starts at some nonzero value, but in time
decays to zero, then pure relative error control on \id{y[i]} makes no sense
(and is overly costly) after \id{y[i]} is below some noise level.  Then
\id{abstol} (if scalar) or \id{abstol[i]} (if a vector) needs to be set to that
noise level.  If the different components have different noise levels,
then \id{abstol} should be a vector.  See the example \id{cvsRoberts\_dns} in the
{\cvodes} package, and the discussion of it in the {\cvodes} Examples document
\cite{cvodes_ex}.
In that problem, the three components vary betwen 0 and 1, and have
different noise levels; hence the \id{abstol} vector.  It is impossible to
give any general advice on \id{abstol} values, because the appropriate noise
levels are completely problem-dependent.  The user or modeler hopefully has
some idea as to what those noise levels are.

(3) Finally, it is important to pick all the tolerance values conservatively,
because they control the error committed on each individual time step.
The final (global) errors are some sort of accumulation of those
per-step errors.  A good rule of thumb is to reduce the tolerances by a
factor of .01 from the actual desired limits on errors.  So if you
want .01\% accuracy (globally), a good choice is \id{reltol} $= 10^{-6}$.
But in any case, it is a good idea to do a few experiments with
the tolerances to see how the computed solution values vary as
tolerances are reduced.

\vspace{0.1in}
\index{tolerances}
{\bf Advice on controlling unphysical negative values.}
In many applications, some components in the true solution are always
positive or non-negative, though at times very small.  In the numerical
solution, however, small negative (hence unphysical) values can then
occur.  In most cases, these values are harmless, and simply need to
be controlled, not eliminated. The following pieces of advice are relevant.

(1) The way to control the size of unwanted negative computed values
is with tighter absolute tolerances.  Again this requires some
knowledge of the noise level of these components, which may or may not
be different for different components.  Some experimentation may be
needed.

(2) If output plots or tables are being generated, and it is important
to avoid having negative numbers appear there (for the sake of avoiding
a long explanation of them, if nothing else), then eliminate them, but
only in the context of the output medium.  Then the internal values carried
by the solver are unaffected.  Remember that a small negative value in \id{y}
returned by {\cvodes}, with magnitude comparable to \id{abstol} or less,
is equivalent to zero as far as the computation is concerned.

(3) The user's right-hand side routine \id{f} should never change a
negative value in the solution vector \id{y} to a non-negative value,
as a "solution" to this problem.  This can cause instability.  If the
\id{f} routine cannot tolerate a zero or negative value (e.g. because
there is a square root or log of it), then the offending value should
be changed to zero or a tiny positive number in a temporary variable
(not in the input \id{y} vector) for the purposes of computing $f(t,y)$.

(4) Positivity and non-negativity constraints on components can be
enforced by use of the recoverable error return feature in the
user-supplied right-hand side function.  However, because this option
involves some extra overhead cost, it should only be exercised if the
use of absolute tolerances to control the computed values is
unsuccessful.

%%
%%==============================================================================
\subsection{Linear solver interface functions}\label{sss:lin_solv_init}
%%==============================================================================

As previously explained, if the nonlinear solver requires the solution of
linear systems of the form (\ref{e:Newton}) (e.g., the default Newton
iteration), there are two {\cvodes} linear solver interfaces currently
available for this task: {\cvls} and {\cvdiag}.

The first corresponds to the main linear solver interface in {\cvodes},
that supports all valid {\sunlinsol} modules.  Here, matrix-based
{\sunlinsol} modules utilize {\sunmatrix} objects to store the
approximate Jacobian matrix $J = \partial{f}/\partial{y}$, the Newton
matrix $M = I-\gamma J$, and factorizations used throughout the
solution process.  Conversely, matrix-free {\sunlinsol} modules
instead use iterative methods to solve the Newton systems of
equations, and only require the \emph{action} of the matrix on a
vector, $Mv$.  With most of these methods, preconditioning can be done
on the left only, the right only, on both the left and right, or not
at all.  The exceptions to this rule are {\spfgmr} that supports right
preconditioning only and {\pcg} that performs symmetric
preconditioning.  For the specification of a preconditioner, see the
iterative linear solver sections in \S\ref{ss:optional_input} and
\S\ref{ss:user_fct_sim}.

If preconditioning is done, user-supplied functions define linear
operators corresponding to left and right preconditioner matrices
$P_1$ and $P_2$ (either of which could be the identity matrix), such
that the product $P_1 P_2$ approximates the matrix $M = I - \gamma J$
of (\ref{e:Newtonmat}).

The {\cvdiag} linear solver interface supports a direct linear solver,
that uses only a diagonal approximation to $J$.

\index{CVODES@{\cvodes} linear solvers!selecting one|(}
To specify a generic linear solver to {\cvodes}, after the call to
\id{CVodeCreate} but before any calls to \id{CVodes}, the user's
program must create the appropriate \Id{SUNLinearSolver} object and call
the function \Id{CVodeSetLinearSolver}, as documented below.
To create the \id{SUNLinearSolver} object, the user may call one of
the {\sundials}-packaged {\sunlinsol} module constructor routines via
a call of the form

\begin{verbatim}
      SUNLinearSolver LS = SUNLinSol_*(...);
\end{verbatim}

The current list of such constructor routines includes
\Id{SUNLinSol\_Dense},
\Id{SUNLinSol\_Band}, \\ \noindent
\Id{SUNLinSol\_LapackDense},
\Id{SUNLinSol\_LapackBand},
\Id{SUNLinSol\_KLU},
\Id{SUNLinSol\_SuperLUMT}, \\ \noindent
\Id{SUNLinSol\_SPGMR},
\Id{SUNLinSol\_SPFGMR},
\Id{SUNLinSol\_SPBCGS},
\Id{SUNLinSol\_SPTFQMR}, and
\Id{SUNLinSol\_PCG}.

Alternately, a user-supplied
\id{SUNLinearSolver} module may be created and used instead.  The use
of each of the generic linear solvers involves certain constants,
functions and possibly some macros, that are likely to be needed in
the user code.  These are available in the corresponding header file
associated with the specific {\sunmatrix} or {\sunlinsol} module in
question, as described in Chapters \ref{s:sunmatrix} and
\ref{s:sunlinsol}.

Once this solver object has been constructed, the user should attach
it to {\cvodes} via a call to \Id{CVodeSetLinearSolver}.  The first
argument passed to this function is the {\cvodes} memory pointer
returned by \id{CVodeCreate}; the second argument is the desired
{\sunlinsol} object to use for solving linear systems.  The third
argument is an optional {\sunmatrix} object to accompany matrix-based
{\sunlinsol} inputs (for matrix-free linear solvers, the third
argument should be \id{NULL}).  A call to this function initializes
the {\cvls} linear solver interface, linking it to the main {\cvodes}
integrator, and allows the user to specify additional parameters and
routines pertinent to their choice of linear solver.
%%

To instead specify the {\cvodes}-specific diagonal linear solver
interface, the user's program must call \Id{CVDiag}, as documented
below.  The first argument passed to this function is the {\cvodes}
memory pointer returned by \id{CVodeCreate}.
\index{CVODES@{\cvodes} linear solver interfaces!selecting one|)}

\index{CVODES@{\cvodes} linear solver interfaces!CVLS@{\cvls}}
\index{CVLS@{\cvls} generic linear solver!SUNLINEARSOLVER@{\sunlinsol} compatibility}
\ucfunctionf{CVodeSetLinearSolver}
{
  flag = CVodeSetLinearSolver(cvode\_mem, LS, J);
}
{
  The function \ID{CVodeSetLinearSolver} attaches a generic {\sunlinsol}
  object \id{LS} and corresponding template Jacobian {\sunmatrix}
  object \id{J} (if applicable) to {\cvodes}, initializing the
  {\cvls} linear solver interface.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[LS] (\id{SUNLinearSolver})
    {\sunlinsol} object to use for solving linear systems of the form
    (\ref{e:Newton}).
  \item[J] (\id{SUNMatrix})
    {\sunmatrix} object for used as a template for the Jacobian (or
    \id{NULL} if not applicable).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_SUNLS\_FAIL]
  \item[\Id{CVLS\_SUCCESS}]
    The {\cvls} initialization was successful.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The {\cvls} interface is not compatible with the \id{LS} or
    \id{J} input objects or is incompatible with the current
    {\nvector} module.
  \item[\Id{CVLS\_SUNLS\_FAIL}]
    A call to the \id{LS} object failed.
  \item[\Id{CVLS\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  If \id{LS} is a matrix-based linear solver, then the template
  Jacobian matrix \id{J} will be used in the solve process, so if
  additional storage is required within the {\sunmatrix} object
  (e.g. for factorization of a banded matrix), ensure that the input
  object is allocated with sufficient size (see the documentation of
  the particular {\sunmatrix} type in Chapter \ref{s:sunmatrix} for
  further information).

  When using sparse linear solvers, it is typically much more
  efficient to supply \id{J} so that it includes the full sparsity
  pattern of the Newton system matrices $M=I-\gamma J$, even if \id{J}
  itself has zeros in nonzero locations of $I$.  The reasoning for
  this is that $M$ is constructed in-place, on top of the
  user-specified values of \id{J}, so if the sparsity pattern in
  \id{J} is insufficient to store $M$ then it will need to be resized
  internally by {\cvode}.

  The previous routines \Id{CVDlsSetLinearSolver} and
  \Id{CVSpilsSetLinearSolver} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
%%
\index{CVODES@{\cvodes} linear solver interfaces!CVDIAG@{\cvdiag}}
\index{CVDIAG@{\cvdiag} linear solver!selection of}
\index{CVDIAG@{\cvdiag} linear solver!Jacobian approximation used by}
\index{Jacobian approximation function!diagonal!difference quotient}
\ucfunctionf{CVDiag}
{
  flag = CVDiag(cvode\_mem);
}
{
  The function \ID{CVDiag} selects the {\cvdiag} linear solver.

  The user's main program must include the \id{cvodes\_diag.h} header file.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVDIAG\_ILL\_INPUT]
  \item[\Id{CVDIAG\_SUCCESS}]
    The {\cvdiag} initialization was successful.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_ILL\_INPUT}]
    The {\cvdiag} solver is not compatible with the current {\nvector} module.
  \item[\Id{CVDIAG\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  The {\cvdiag} solver is the simplest of all of the available {\cvodes}
  linear solvers.  The {\cvdiag} solver uses an approximate
  diagonal Jacobian formed by way of a difference quotient. The user
  does {\em not} have the option of supplying a function to compute an
  approximate diagonal Jacobian.
}
%%
%%==================================================================================
%%
\subsection{Nonlinear solver interface function}
\label{ss:nonlin_solv_init}

By default {\cvodes} uses the {\sunnonlinsol} implementation of Newton's method
defined by the {\sunnonlinsolnewton} module (see \S\ref{s:sunnonlinsol_newton}).
To specify a different nonlinear solver in {\cvodes}, the user's program must
create a {\sunnonlinsol} object by calling the appropriate constructor routine.
The user must then attach the {\sunnonlinsol} object by calling
\Id{CVodeSetNonlinearSolver}, as documented below.

When changing the nonlinear solver in {\cvodes}, \id{CVodeSetNonlinearSolver} must
be called after \id{CVodeInit}. If any calls to \id{CVode} have been made, then
{\cvodes} will need to be reinitialized by calling \id{CVodeReInit} to ensure
that the nonlinear solver is initialized correctly before any subsequent calls
to \id{CVode}.

The first argument passed to the routine \id{CVodeSetNonlinearSolver} is the
{\cvodes} memory pointer returned by \id{CVodeCreate} and the second argument is
the {\sunnonlinsol} object to use for solving the nonlinear system
(\ref{e:nonlinear}) or (\ref{e:nonlinear_fixedpoint}).
A call to this function attaches the nonlinear solver to the main {\cvodes}
integrator.

\ucfunctionf{CVodeSetNonlinearSolver}
{
  flag = CVodeSetNonlinearSolver(cvode\_mem, NLS);
}
{
  The function \ID{CVodeSetNonLinearSolver} attaches a {\sunnonlinsol}
  object (\id{NLS}) to {\cvodes}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[NLS] (\id{SUNNonlinearSolver})
    {\sunnonlinsol} object to use for solving nonlinear systems
    (\ref{e:nonlinear}) or (\ref{e:nonlinear_fixedpoint}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The nonlinear solver was successfully attached.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The {\sunnonlinsol} object is \id{NULL}, does not implement the required
    nonlinear solver operations, is not of the correct type, or the residual
    function, convergence test function, or maximum number of nonlinear
    iterations could not be set.
  \end{args}
}
{
  When forward sensitivity analysis capabilities are enabled and the
  \id{CV\_STAGGERED} or \id{CV\_STAGGERED1} corrector method is used this
  function sets the nonlinear solver method for correcting state variables (see
  \S\ref{sss:cvfwd_nonlin_solv_init} for more details).
}

%%==============================================================================
\subsection{Rootfinding initialization function}\label{ss:cvrootinit}
\index{Rootfinding}

While solving the IVP, {\cvodes} has the capability to find the
roots of a set of user-defined functions. To activate the root finding
algorithm, call the following function.  This is normally called only
once, prior to the first call to \id{CVode}, but if the rootfinding
problem is to be changed during the solution, \id{CVodeRootInit} can also
be called prior to a continuation call to \id{CVode}.
%%
%%
\ucfunctionf{CVodeRootInit}
{
  flag = CVodeRootInit(cvode\_mem, nrtfn, g);
}
{
  The function \ID{CVodeRootInit} specifies that the roots of a set of
  functions $g_i(t,y)$ are to be found while the IVP is being solved.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[nrtfn] (\id{int})
    is the number of root functions $g_i$.
  \item[g] (\id{CVRootFn})
    is the {\CC} function which defines the \id{nrtfn} functions $g_i(t,y)$
    whose roots are sought. See \S\ref{ss:rootFn} for details.
 \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[CV\_SUCCESS]
    The call to \id{CVodeRootInit} was successful.
  \item[CV\_MEM\_NULL]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[CV\_MEM\_FAIL]
    A memory allocation failed.
  \item[CV\_ILL\_INPUT]
    The function \id{g} is \id{NULL}, but \id{nrtfn} $ > 0$.
  \end{args}
}
{
  If a new IVP is to be solved with a call to \id{CVodeReInit}, where the new
  IVP has no rootfinding problem but the prior one did, then call
  \id{CVodeRootInit} with \id{nrtfn}$=0$.
}


%%==============================================================================
\subsection{CVODES solver function}\label{sss:cvode}
%%==============================================================================

This is the central step in the solution process --- the call to
perform the integration of the IVP.  One of the input arguments (\id{itask})
specifies one of two modes as to where {\cvodes} is to return a solution.
But these modes are modified if the user has set a stop time (with
\id{CVodeSetStopTime}) or requested rootfinding.

%
\ucfunctionf{CVode}
{
  flag = CVode(cvode\_mem, tout, yout, \&tret, itask);
}
{
  The function \ID{CVode} integrates the ODE over an interval in $t$.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[yout] (\id{N\_Vector})
    the computed solution vector.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}|textbf}
    \index{output mode}
    a flag indicating the job of the solver for the next user step.
    The \Id{CV\_NORMAL} option causes the solver to take internal steps until
    it has reached or just passed the user-specified \id{tout}
    parameter. The solver then interpolates in order to
    return an approximate value of $y($\id{tout}$)$.
    The \Id{CV\_ONE\_STEP} option tells the solver to take just one internal step
    and then return the solution at the point reached by that step.
  \end{args}
}
{
  \id{CVode} returns a vector \id{yout} and a corresponding
  independent variable value $t =$ \id{tret}, such that \id{yout} is the computed
  value of $y(t)$.

  In \id{CV\_NORMAL} mode (with no errors), \id{tret} will be equal to \id{tout}
  and \id{yout} = $y($\id{tout}$)$.

  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_FIRST\_RHSFUNC\_FAIL]
  \item[\Id{CV\_SUCCESS}]
    \id{CVode} succeeded and no roots were found.
  \item[\Id{CV\_TSTOP\_RETURN}]
    \id{CVode} succeeded by reaching the stopping point specified through
    the optional input function \id{CVodeSetStopTime} (see \S\ref{sss:optin_main}).
  \item[\Id{CV\_ROOT\_RETURN}]
    \id{CVode} succeeded and found one or more roots.  In this case,
    \id{tret} is the location of the root.  If \id{nrtfn} $>1$, call
    \id{CVodeGetRootInfo} to see which $g_i$ were found to have a root.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \item[\Id{CV\_NO\_MALLOC}]
    The {\cvodes} memory was not allocated by a call to \id{CVodeInit}.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the inputs to \id{CVode} was illegal, or some other input to the
    solver was either illegal or missing.
    The latter category includes the following situations:
    (a) The tolerances have not been set.
    (b) A component of the error weight vector became zero during internal
    time-stepping.
    (c) The linear solver initialization function (called by the user after calling
    \id{CVodeCreate}) failed to set the linear solver-specific \id{lsolve} field in
    \id{cvode\_mem}.
    (d) A root of one of the root functions was found both at a point $t$ and also
    very near $t$.
    In any case, the user should see the error message for details.
  \item[\Id{CV\_TOO\_CLOSE}]
    The initial time $t_0$ and the output time $t_{out}$ are too close to each
    other and the user did not specify an initial step size.
  \item[\Id{CV\_TOO\_MUCH\_WORK}]
    The solver took \id{mxstep} internal steps but still could not reach \id{tout}.
    The default value for \id{mxstep} is \id{MXSTEP\_DEFAULT = 500}.
  \item[\Id{CV\_TOO\_MUCH\_ACC}]
    The solver could not satisfy the accuracy demanded by the user for some
    internal step.
  \item[\Id{CV\_ERR\_FAILURE}]
    Either error test failures occurred too many times (\id{MXNEF = 7}) during one
    internal time step, or with $|h| = h_{min}$.
  \item[\Id{CV\_CONV\_FAILURE}]
    Either convergence test failures occurred too many times (\id{MXNCF = 10}) during
    one internal time step, or with $|h| = h_{min}$.
  \item[\Id{CV\_LINIT\_FAIL}]
    The linear solver interface's initialization function failed.
  \item[\Id{CV\_LSETUP\_FAIL}]
    The linear solver interface's setup function failed in an unrecoverable manner.
  \item[\Id{CV\_LSOLVE\_FAIL}]
    The linear solver interface's solve function failed in an unrecoverable manner.
  \item[\Id{CV\_CONSTR\_FAIL}]
    The inequality constraints were violated and the solver was unable
    to recover.
  \item[\Id{CV\_RHSFUNC\_FAIL}]
    The right-hand side function failed in an unrecoverable manner.
  \item[\Id{CV\_FIRST\_RHSFUNC\_FAIL}]
    The right-hand side function had a recoverable error at the first call.
  \item[\Id{CV\_REPTD\_RHSFUNC\_ERR}]
    Convergence test failures occurred too many times due to repeated recoverable errors in
    the right-hand side function. This flag will also
    be returned if the right-hand side function had repeated recoverable errors
    during the estimation of an initial step size.
  \item[\Id{CV\_UNREC\_RHSFUNC\_ERR}]
    The right-hand function had a recoverable error, but no recovery was possible.
    This failure mode is rare, as it can occur only if the right-hand side function
    fails recoverably after an error test failed while at order one.
  \item[\Id{CV\_RTFUNC\_FAIL}]
    The rootfinding function failed.
  \end{args}
}
{
  The vector \id{yout} can occupy the same space as the vector \id{y0} of
  initial conditions that was passed to \id{CVodeInit}.

  In the \id{CV\_ONE\_STEP} mode, \id{tout} is used only on the first call,
  and only to get the direction and a rough scale of the independent variable.

  If a stop time is enabled (through a call to \id{CVodeSetStopTime}), then
  \id{CVode} returns the solution at \id{tstop}. Once the integrator returns
  at a stop time, any future testing for \id{tstop} is disabled (and can be
  reenabled only though a new call to \id{CVodeSetStopTime}).

  All failure return values are negative and so the test \id{flag < 0}
  will trap all \id{CVode} failures.

  On any error return in which one or more internal steps were taken by
  \id{CVode}, the returned values of \id{tret} and \id{yout} correspond to
  the farthest point reached in the integration.  On all other error returns,
  \id{tret} and \id{yout} are left unchanged from the previous \id{CVode}
  return.

}

%%==============================================================================
\subsection{Optional input functions}\label{ss:optional_input}
%%==============================================================================

There are numerous optional input parameters that control the behavior
of the {\cvodes} solver.  {\cvodes} provides functions that can be used to change
these optional input parameters from their default values.
Table \ref{t:optional_input} lists all optional input functions in {\cvodes} which
are then described in detail in the remainder of this section, begining with those
for the main {\cvodes} solver and continuing with those for the linear
solver interfaces.  Note that the diagonal linear solver module has no
optional inputs.  For the most casual use of {\cvodes}, the reader
can skip to \S\ref{ss:user_fct_sim}.

We note that, on an error return, all of the optional input functions send an
error message to the error handler function.
\index{error messages}
All error return values are negative, so the test \id{flag < 0} will catch all
errors. Finally, a call to a \id{CVodeSet***} function can be made from the
user's calling program at any time and, if successful, takes effect immediately.

\begin{table}
\centering
\caption{Optional inputs for {\cvodes} and {\cvls}}
\label{t:optional_input}
\medskip
\begin{tabular}{|l|l|l|}\hline
{\bf Optional input} & {\bf Function name} & {\bf Default} \\
\hline
\multicolumn{3}{|c|}{\bf CVODES main solver} \\
\hline
Pointer to an error file & \id{CVodeSetErrFile} & \id{stderr}  \\
Error handler function & \id{CVodeSetErrHandlerFn} & internal fn. \\
User data & \id{CVodeSetUserData} & {\tt NULL} \\
Maximum order for BDF method & \id{CVodeSetMaxOrd} & 5 \\
Maximum order for Adams method & \id{CVodeSetMaxOrd} & 12  \\
Maximum no. of internal steps before $t_{\mbox{\scriptsize out}}$ & \id{CVodeSetMaxNumSteps} & 500 \\
Maximum no. of warnings for $t_n+h=t_n$ & \id{CVodeSetMaxHnilWarns} & 10 \\
Flag to activate stability limit detection & \id{CVodeSetStabLimDet} & {\tt SUNFALSE} \\
Initial step size & \id{CVodeSetInitStep} & estimated \\
Minimum absolute step size & \id{CVodeSetMinStep} & 0.0 \\
Maximum absolute step size & \id{CVodeSetMaxStep} & $\infty$ \\
Value of $t_{stop}$ & \id{CVodeSetStopTime} & undefined \\
Maximum no. of error test failures & \id{CVodeSetMaxErrTestFails} & 7 \\
Maximum no. of nonlinear iterations & \id{CVodeSetMaxNonlinIters} & 3 \\
Maximum no. of convergence failures & \id{CVodeSetMaxConvFails} & 10 \\
Coefficient in the nonlinear convergence test & \id{CVodeSetNonlinConvCoef} & 0.1 \\
Inequality constraints on solution & \id{CVodeSetConstraints} & \id{NULL} \\
Direction of zero-crossing & \id{CVodeSetRootDirection} & both \\
Disable rootfinding warnings & \id{CVodeSetNoInactiveRootWarn} & none \\
\hline
\multicolumn{3}{|c|}{\bf CVLS linear solver interface} \\
\hline
Linear solver setup frequency & \id{CVodeSetMaxStepsBetweenLSetup} & 20\\
Jacobian / preconditioner update frequency & \id{CVodeSetMaxStepsBetweenJac} & 51\\
Jacobian function & \id{CVodeSetJacFn} & DQ\\
Linear System function & \id{CVodeSetLinSysFn} & internal\\
Enable or disable linear solution scaling & \id{CVodeSetLinearSolutionScaling} & on\\
Jacobian-times-vector functions & \id{CVodeSetJacTimes} & NULL, DQ \\
Jacobian-times-vector DQ RHS function & \id{CVodeSetJacTimesRhsFn} & NULL \\
Preconditioner functions & \id{CVodeSetPreconditioner} & NULL, NULL \\
Ratio between linear and nonlinear tolerances & \id{CVodeSetEpsLin} & 0.05 \\
\hline
\end{tabular}
\end{table}

%%==============================================================================
\subsubsection{Main solver optional input functions}\label{sss:optin_main}
%%==============================================================================
\index{optional input!solver|(}

The calls listed here can be executed in any order.
However, if either of the functions \id{CVodeSetErrFile} or
\id{CVodeSetErrHandlerFn} is to be called, that call should be first,
in order to take effect for any later error message.

%%
\index{error messages!redirecting}
\ucfunctionf{CVodeSetErrFile}
{
flag = CVodeSetErrFile(cvode\_mem, errfp);
}
{
  The function \ID{CVodeSetErrFile} specifies a pointer to the file
  where all {\cvodes} messages should be directed when the default
  {\cvodes} error handler function is used.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[errfp] (\id{FILE *})
    pointer to output file.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value for \id{errfp} is \id{stderr}.

  Passing a value of \id{NULL} disables all future error message output
  (except for the case in which the {\cvodes} memory pointer is \id{NULL}).
  This use of \Id{CVodeSetErrFile} is strongly discouraged.

  {\warn}If \id{CVodeSetErrFile} is to be called, it should be called before any
  other optional input functions, in order to take effect for any later error message.
}
%%
\index{error messages!user-defined handler}
\ucfunctionf{CVodeSetErrHandlerFn}
{
flag = CVodeSetErrHandlerFn(cvode\_mem, ehfun, eh\_data);
}
{
  The function \ID{CVodeSetErrHandlerFn} specifies the optional user-defined function
  to be used in handling error messages.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[ehfun] (\id{CVErrHandlerFn})
    is the {\CC} error handler function (see \S\ref{ss:ehFn}).
  \item[eh\_data] (\id{void *})
    pointer to user data passed to \id{ehfun} every time it is called.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The function \id{ehfun} and data pointer \id{eh\_data} have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Error messages indicating that the {\cvodes} solver memory is \id{NULL} will
  always be directed to \id{stderr}.
}
%%
%%
\ucfunctionf{CVodeSetUserData}
{
  flag = CVodeSetUserData(cvode\_mem, user\_data);
}
{
  The function \ID{CVodeSetUserData} specifies the user data block \Id{user\_data}
  and attaches it to the main {\cvodes} memory block.
}
{
  \begin{args}[cvode\_data]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[user\_data] (\id{void *})
    pointer to the user data.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If specified, the pointer to \id{user\_data} is passed to all user-supplied
  functions that have it as an argument. Otherwise, a \id{NULL} pointer is passed.

  {\warn}If \id{user\_data} is needed in user linear solver or preconditioner
   functions, the call to \id{CVodeSetUserData} must be made {\it before} the
   call to specify the linear solver.
}
%%
%%
\ucfunctionf{CVodeSetMaxOrd}
{
flag = CVodeSetMaxOrd(cvode\_mem, maxord);
}
{
  The function \ID{CVodeSetMaxOrd} specifies the maximum order of the
  linear multistep method.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxord] (\id{int})
    value of the maximum method order.  This must be positive.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The specified value \id{maxord} is $\leq 0$, or larger than
    its previous value.
  \end{args}
}
{
  The default value is \id{ADAMS\_Q\_MAX = 12} for
  the Adams-Moulton method and \id{BDF\_Q\_MAX = 5}
  for the BDF method.
  Since \Id{maxord} affects the memory requirements
  for the internal {\cvodes} memory block, its value
  cannot be increased past its previous value.

  An input value greater than the default will result in the default value.
}
%%
%%
\ucfunctionf{CVodeSetMaxNumSteps}
{
flag = CVodeSetMaxNumSteps(cvode\_mem, mxsteps);
}
{
  The function \ID{CVodeSetMaxNumSteps} specifies the maximum number
  of steps to be taken by the solver in its attempt to reach
  the next output time.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[mxsteps] (\id{long int})
    maximum allowed number of steps.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
   Passing \id{mxsteps} $= 0$ results in {\cvodes} using the default value ($500$).

   Passing \id{mxsteps} $< 0$ disables the test (\it{not recommended}).
}
%%
%%
\ucfunctionf{CVodeSetMaxHnilWarns}
{
flag = CVodeSetMaxHnilWarns(cvode\_mem, mxhnil);
}
{
  The function \ID{CVodeSetMaxHnilWarns} specifies the maximum number of
  messages issued by the solver warning that $t+h=t$ on the next internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[mxhnil] (\id{int})
    maximum number of warning messages $( > 0)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $10$.
  A negative value for \id{mxhnil} indicates that no warning messages should
  be issued.
}
%%
%%
\ucfunctionf{CVodeSetStabLimDet}
{
flag = CVodeSetstabLimDet(cvode\_mem, stldet);
}
{
  The function \ID{CVodeSetStabLimDet} indicates if
  the BDF stability limit detection algorithm should be used. See \S\ref{s:bdf_stab}
  for further details.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[stldet] (\id{booleantype})
    flag controlling stability limit detection (\id{SUNTRUE} = on; \id{SUNFALSE} = off).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The linear multistep method is not set to \id{CV\_BDF}.
  \end{args}
}
{
  The default value is \id{SUNFALSE}. If \id{stldet = SUNTRUE} when BDF is used
  and the method order is greater than or equal to 3, then an internal function, \id{CVsldet},
  is called to detect a possible stability limit. If such a limit is detected, then the order is
  reduced.
}
%%
%%
\ucfunctionf{CVodeSetInitStep}
{
flag = CVodeSetInitStep(cvode\_mem, hin);
}
{
  The function \ID{CVodeSetInitStep} specifies the initial step size.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hin] (\id{realtype})
    value of the initial step size to be attempted.
    Pass $0.0$ to use the default value.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  By default, {\cvodes} estimates the initial step size to be the solution $h$
  of the equation $\| 0.5 h^2 {\ddot y} \|_{\mbox{\scriptsize WRMS}} = 1$,
  where ${\ddot y}$ is an estimated second derivative of the solution at \id{t0}.
}
%%
%%
\index{step size bounds|(}
\ucfunctionf{CVodeSetMinStep}
{
flag = CVodeSetMinStep(cvode\_mem, hmin);
}
{
  The function \ID{CVodeSetMinStep} specifies a lower bound on the magnitude
  of the step size.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hmin] (\id{realtype})
    minimum absolute value of the step size $( \geq 0.0 )$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    Either \id{hmin} is nonpositive or it exceeds the maximum allowable step size.
  \end{args}
}
{
  The default value is $0.0$.
}
%%
%%
\ucfunctionf{CVodeSetMaxStep}
{
flag = CVodeSetMaxStep(cvode\_mem, hmax);
}
{
  The function \ID{CVodeSetMaxStep} specifies an upper bound on the magnitude
  of the step size.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hmax] (\id{realtype})
    maximum absolute value of the step size $( \geq 0.0 )$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    Either \id{hmax} is nonpositive or it is smaller than the minimum allowable step size.
  \end{args}
}
{
  Pass \id{hmax} $ = 0.0$ to obtain the default value $\infty$.
}
\index{step size bounds|)}
%%
%%
\ucfunctionf{CVodeSetStopTime}
{
flag = CVodeSetStopTime(cvode\_mem, tstop);
}
{
  The function \ID{CVodeSetStopTime} specifies the value of the
  independent variable $t$ past which the solution is not to proceed.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tstop] (\id{realtype})
    value of the independent variable past which the solution should
    not proceed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The value of \id{tstop} is not beyond the current $t$ value, $t_n$.
  \end{args}
}
{
  The default, if this routine is not called, is that no stop time is imposed.

  Once the integrator returns at a stop time, any future testing for \id{tstop}
  is disabled (and can be reenabled only though a new call to \id{CVodeSetStopTime}).
}
%%
%%
\ucfunctionf{CVodeSetMaxErrTestFails}
{
flag = CVodeSetMaxErrTestFails(cvode\_mem, maxnef);
}
{
  The function \ID{CVodeSetMaxErrTestFails} specifies the
  maximum number of error test failures permitted in attempting one step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxnef] (\id{int})
    maximum number of error test failures allowed on one step $( > 0)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $7$.
}
%%
%%
\ucfunctionf{CVodeSetMaxNonlinIters}
{
flag = CVodeSetMaxNonlinIters(cvode\_mem, maxcor);
}
{
  The function \ID{CVodeSetMaxNonlinIters} specifies the maximum
  number of nonlinear solver iterations permitted per step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxcor] (\id{int})
    maximum number of nonlinear solver iterations allowed per step $( > 0)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_MEM\_FAIL}]
    The {\sunnonlinsol} module is \id{NULL}.
  \end{args}
}
{
  The default value is $3$.
}
%%
%%
\ucfunctionf{CVodeSetMaxConvFails}
{
flag = CVodeSetMaxConvFails(cvode\_mem, maxncf);
}
{
  The function \ID{CVodeSetMaxConvFails} specifies the
  maximum number of nonlinear solver convergence failures permitted during
  one step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[maxncf] (\id{int})
    maximum number of allowable nonlinear solver convergence failures
    per step $( > 0)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $10$.
}
%%
%%
\ucfunctionf{CVodeSetNonlinConvCoef}
{
flag = CVodeSetNonlinConvCoef(cvode\_mem, nlscoef);
}
{
  The function \ID{CVodeSetNonlinConvCoef} specifies the safety factor used
  in the nonlinear convergence test (see \S\ref{ss:ivp_sol}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nlscoef] (\id{realtype})
    coefficient in nonlinear convergence test $( > 0.0)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The default value is $0.1$.
}
%%
\ucfunctionf{CVodeSetConstraints}
{
flag = CVodeSetConstraints(cvode\_mem, constraints);
}
{
  The function \ID{CVodeSetConstraints} specifies a vector defining
  inequality constraints for each component of the solution vector $y$.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[constraints] (\id{N\_Vector})
    vector of constraint flags. If \id{constraints[i]} is
    \begin{itemize}
    \item[$0.0$] then no constraint is imposed on $y_i$.
    \item[$1.0$] then $y_i$ will be constrained to be $y_i \ge 0.0$.
    \item[$-1.0$] then $y_i$ will be constrained to be $y_i \le 0.0$.
    \item[$2.0$] then $y_i$ will be constrained to be $y_i > 0.0$.
    \item[$-2.0$] then $y_i$ will be constrained to be $y_i < 0.0$.
    \end{itemize}
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    The constraints vector contains illegal values or the simultaneous corrector
    option has been selected when doing forward sensitivity analysis.
  \end{args}
}
{
  The presence of a non-\id{NULL} constraints vector that is not $0.0$ in
  all components will cause constraint checking to be performed.
  However, a call with $0.0$ in all components of \id{constraints} will
  result in an illegal input return. A \id{NULL} constraints vector will disable
  constraint checking.

  Constraint checking when doing forward sensitivity analysis with the
  simultaneous corrector option is currently disallowed and will result in an
  illegal input return.
}
\index{optional input!solver|)}

%%==============================================================================
\subsubsection{Linear solver interface optional input functions}
\label{sss:optin_ls}
%%==============================================================================
\index{optional input!generic linear solver interface|(}
\index{CVLS@{\cvls} linear solver interface!optional input|(}

The mathematical explanation of the linear solver methods
available to {\cvodes} is provided in \S\ref{ss:ivp_sol}.  We
group the user-callable routines into four categories: general
routines concerning the overall {\cvls} linear solver interface,
optional inputs for matrix-based linear solvers, optional inputs for
matrix-free linear solvers, and optional inputs for iterative linear
solvers.  We note that the matrix-based and matrix-free groups are
mutually exclusive, whereas the ``iterative'' tag can apply to either
case.

As discussed in \S\ref{ss:ivp_sol}, {\cvodes} strives to reuse matrix
and preconditioner data for as many solves as possible to amortize the
high costs of matrix construction and factorization.  To that end,
{\cvodes} provides user-callable routines to modify this behavior.  Recall
that the Newton system matrices are $M(t,y) = I - \gamma J(t,y)$, where the
right-hand side function has Jacobian matrix
$J(t,y) = \frac{\partial f(t,y)}{\partial y}$.

The matrix or preconditioner for $M$ can only be updated within a call
to the linear solver `setup' routine.  In general, the frequency with
which this setup routine is called may be controlled with the
\id{msbp} argument to \id{CVodeSetMaxStepsBetweenLSetup}. When this occurs, the
validity of $M$ for successive time steps intimately depends on whether the
corresponding $\gamma$ and $J$ inputs remain valid.

At each call to the linear solver setup routine the decision to update $M$ with
a new value of $\gamma$, and to reuse or reevaluate Jacobian information, depends
on several factors including:
\begin{itemize}
  \item the success or failure of previous solve attempts,
  \item the success or failure of the previous time step attempts,
  \item the change in $\gamma$ from the value used when constructing $M$, and
  \item the number of steps since Jacobian information was last evaluated.
\end{itemize}

The frequency with which to update Jacobian information can be controlled with
the \id{msbj} argument to \id{CVodeSetMaxStepsBetweenJac}. We note that this
is only checked \textit{within} calls to the linear solver setup routine, so
values \id{msbj} $<$ \id{msbp} do not make sense. For linear-solvers with
user-supplied preconditioning the above factors are used to determine whether to
recommend updating the Jacobian information in the preconditioner (i.e., whether
to set \id{jok} to \id{SUNFALSE} in calling the user-supplied preconditioner
setup function (see \S\ref{ss:psolveFn}). For matrix-based linear solvers these
factors determine whether the matrix
$J(t,y) = \frac{\partial f(t,y)}{\partial y}$
should be updated (either with an internal finite difference approximation or a
call to the user-supplied Jacobian function (see \S\ref{ss:jacFn})); if not then
the previous value is reused and the system matrix
$M(t,y) \approx M - \gamma J(t,y)$
is recomputed using the current $\gamma$ value.


\index{Linear solver setup frequency!optional input}
\ucfunctionf{CVodeSetMaxStepsBetweenLSetup}
{
  retval = CVodeSetMaxStepsBetweenLSetup(cvode\_mem, msbp);
}
{
  The function \ID{CVodeSetMaxStepsBetweenLSetup} specifies the frequency of
  calls to the linear solver setup function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[msbj] (\id{long int})
    the linear solver setup frequency.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver interface has not been initialized.
  \end{args}
}
{
  Positive values of \id{msbp} specify the linear solver setup frequency. For
  example, an input of \id{1} means the setup function will be called every time
  step while an input of \id{2} means it will be called called every other time
  step. If \id{msbp} is less than 1, the default value of 20 will be used.

  This function must be called \emph{after} the {\cvls} linear solver interface
  has been initialized through a call to \id{CVodeSetLinearSolver}.
}

\index{Jacobian update frequency!optional input}
\index{Preconditioner update frequency!optional input}
\ucfunctionf{CVodeSetMaxStepsBetweenJac}
{
  retval = CVodeSetMaxStepsBetweenJac(cvode\_mem, msbj);
}
{
  The function \ID{CVodeSetMaxStepsBetweenJac} specifies the frequency for
  recomputing the Jacobian or recommending a preconditioner update.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[msbj] (\id{long int})
    the Jacobian re-computation or preconditioner update frequency.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver interface has not been initialized.
  \end{args}
}
{
  If \id{msbj} is less than 1, the default value of 51 will be used.

  This function must be called \emph{after} the {\cvls} linear solver
  interface has been initialized through a call to
  \id{CVodeSetLinearSolver}.
}


\index{optional input!matrix-based linear solver|(}
\index{CVLS@{\cvls} linear solver interface!Jacobian approximation used by}
When using matrix-based linear solver modules, the {\cvls} solver interface
needs a function to compute an approximation to the Jacobian matrix $J(t,y)$ or
the linear system $M = I - \gamma J$. The function to evaluate $J(t,y)$ the must
be of type \id{CVLsJacFn}. The user can supply a Jacobian function, or if using
a dense or banded matrix $J$, can use the default internal difference quotient
approximation
\index{Jacobian approximation function!difference quotient}
that comes with the {\cvls} solver. To specify a user-supplied Jacobian function
\id{jac}, {\cvls} provides the function \id{CVodeSetJacFn}. The {\cvls}
interface passes the pointer \id{user\_data} to the Jacobian function. This
allows the user to create an arbitrary structure with relevant problem data and
access it during the execution of the user-supplied Jacobian function, without
using global data in the program. The pointer \id{user\_data} may be specified
through \id{CVodeSetUserData}.
%%
\index{Jacobian approximation function!user-supplied}
\ucfunctionf{CVodeSetJacFn}
{
  flag = CVodeSetJacFn(cvode\_mem, jac);
}
{
  The function \ID{CVodeSetJacFn} specifies the Jacobian
  approximation function to be used for a matrix-based solver within
  the {\cvls} interface.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[jac] (\id{CVLsJacFn})
    user-defined Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver interface has not been initialized.
  \end{args}
}
{
  This function must be called \emph{after} the {\cvls} linear solver
  interface has been initialized through a call to
  \id{CVodeSetLinearSolver}.

  By default, {\cvls} uses an internal difference quotient function
  for dense and band matrices.  If \id{NULL} is passed to \id{jac},
  this default function is used.  An error will occur if no \id{jac}
  is supplied when using other matrix types.

  The function type \id{CVLsJacFn} is described in \S\ref{ss:jacFn}.

  The previous routine \Id{CVDlsSetJacFn} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
To specify a user-supplied linear system function \id{linsys}, {\cvls} provides
the function\\ \id{CVodeSetLinSysFn}. The {\cvls} interface passes the pointer
\id{user\_data} to the linear system function. This allows the user to create an
arbitrary structure with relevant problem data and access it during the
execution of the user-supplied linear system function, without using global data
in the program. The pointer \id{user\_data} may be specified through
\id{CVodeSetUserData}.
%%
\index{Linear system approximation function!user-supplied}
\ucfunctionf{CVodeSetLinSysFn}
{
  flag = CVodeSetLinSysFn(cvode\_mem, linsys);
}
{
  The function \ID{CVodeSetLinSysFn} specifies the linear system approximation
  function to be used for a matrix-based solver within the {\cvls} interface.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[linsys] (\id{CVLsLinSysFn})
    user-defined linear system approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver interface has not been initialized.
  \end{args}
}
{
  This function must be called \emph{after} the {\cvls} linear solver
  interface has been initialized through a call to
  \id{CVodeSetLinearSolver}.

  By default, {\cvls} uses an internal linear system function leveraging the
  {\sunmatrix} API to form the system $M = I - \gamma J$ using either an
  internal finite difference approximation or user-supplied function to compute
  the Jacobian. If \id{linsys} is \id{NULL}, this default function is used.

  The function type \id{CVLsLinSysFn} is described in \S\ref{ss:linsysFn}.
}
%%
When using a matrix-based linear solver the matrix information will be updated
infrequently to reduce matrix construction and, with direct solvers,
factorization costs. As a result the value of $\gamma$ may not be current and,
with BDF methods, a scaling factor is applied to the solution of the linear
system to account for the lagged value of $\gamma$. See
\S\ref{ss:sunlinsol_lagged_matrix} for more details. The function
\id{CVodeSetLinearSolutionScaling} can be used to disable this scaling when
necessary, e.g., when providing a custom linear solver that updates the matrix
using the current $\gamma$ as part of the solve.
%%
\index{Linear solution scaling function!user-supplied}
\ucfunctionf{CVodeSetLinearSolutionScaling}
{
  flag = CVodeSetLinearSolutionScaling(cvode\_mem, onoff);
}
{
  The function \ID{CVodeSetLinearSolutionScaling} enables or disables scaling
  the linear system solution to account for a change in $\gamma$ in the linear
  system. For more details see \S\ref{ss:sunlinsol_lagged_matrix}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvode} memory block.
  \item[onoff] (\id{booleantype})
    flag to enable (\id{SUNTRUE}) or disable (\id{SUNFALSE}) scaling
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The flag value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver interface has not been initialized.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The attached linear solver is not matrix-based or the linear multistep
    method type is not BDF.
  \end{args}
}
{
  This function must be called \emph{after} the {\cvls} linear solver
  interface has been initialized through a call to
  \id{CVodeSetLinearSolver}.

  By default scaling is enabled with matrix-based linear solvers when using BDF
  methods.
}
%%
\index{optional input!matrix-based linear solver|)}
%%
%%
%%
\index{optional input!matrix-free linear solver|(}
\index{CVLS@{\cvls} linear solver interface!Jacobian-vector product approximation used by}
When using matrix-free linear solver modules, the {\cvls} solver
interface requires a function to compute an approximation to the
product between the Jacobian matrix $J(t,y)$ and a vector $v$. The
user can supply a Jacobian-times-vector approximation function or use
the default internal difference quotient function
\index{Jacobian approximation function!Jacobian times vector!difference quotient}
that comes with the {\cvls} interface.

A user-defined Jacobian-vector product
function must be of type \id{CVLsJacTimesVecFn} and
can be specified through a call to \id{CVodeSetJacTimes} (see
\S\ref{ss:jtimesFn} for specification details).
The evaluation and processing of any Jacobian-related data needed by
the user's Jacobian-times-vector function may be done in the optional
user-supplied function \id{jtsetup} (see \S\ref{ss:jtsetupFn} for
specification details).
%
The pointer \id{user\_data} received through \id{CVodeSetUserData} (or
a pointer to \id{NULL} if \id{user\_data} was not specified)
is passed to the Jacobian-times-vector setup and product functions, \id{jtsetup} and
\id{jtimes}, each time they are called.  This allows the user to
create an arbitrary structure with relevant problem data and access it
during the execution of the user-supplied functions
without using global data in the program.
%%
\index{Jacobian approximation function!Jacobian times vector!user-supplied}
\ucfunctionf{CVodeSetJacTimes}
{
  flag = CVodeSetJacTimes(cvode\_mem, jtsetup, jtimes);
}
{
  The function \ID{CVodeSetJacTimes} specifies the Jacobian-vector
  setup and product functions.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[jtsetup] (\id{CVLsJacTimesSetupFn})
    user-defined Jacobian-vector setup function.
    Pass \id{NULL} if no setup is necessary.
  \item[jtimes] (\id{CVLsJacTimesVecFn})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_SUNLS\_FAIL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_SUNLS\_FAIL}]
    An error occurred when setting up the system matrix-times-vector
    routines in the {\sunlinsol} object used by the {\cvls}
    interface.
  \end{args}
}
{
  The default is to use an internal finite difference quotient for
  \id{jtimes} and to omit \id{jtsetup}.  If \id{NULL} is passed to
  \id{jtimes}, these defaults are used.  A user may specify
  non-\id{NULL} \id{jtimes} and \id{NULL} \id{jtsetup} inputs.

  This function must be called \emph{after} the {\cvls} linear solver
  interface has been initialized through a call to
  \id{CVodeSetLinearSolver}.

  The function type \id{CVLsJacTimesSetupFn} is described in \S\ref{ss:jtsetupFn}.

  The function type \id{CVLsJacTimesVecFn} is described in \S\ref{ss:jtimesFn}.

  The previous routine \Id{CVSpilsSetJacTimes} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
When using the internal difference quotient the user may optionally supply an
alternative right-hand side function for use in the Jacobian-vector product
approximation by calling \id{CVodeSetJacTimesRhsFn}. The alternative right-hand
side function should compute a suitable (and differentiable) approximation to
the right-hand side function provided to \id{CVodeInit}. For example, as done in
\cite{dorr2010numerical}, the alternative function may use lagged values when
evaluating a nonlinearity in the right-hand side to avoid differencing a
potentially non-differentiable factor.
%%
%%
\index{Jacobian approximation function!Jacobian times vector!alternative-rhs}
\ucfunctionf{CVodeSetJacTimesRhsFn}
{
  flag = CVodeSetJacTimesRhsFn(cvode\_mem, jtimesRhsFn);
}
{
  The function \ID{CVodeSetJacTimesRhsFn} specifies an alternative ODE
  right-hand side function for use in the internal Jacobian-vector product
  difference quotient approximation.
}
{
  \begin{args}[jtimesRhsFn]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[jtimesRhsFn] (\Id{CVRhsFn})
    is the {\CC} function which computes the alternative ODE right-hand side
    function to use in Jacobian-vector product difference quotient
    approximations. This function has the form \id{f(t, y, ydot, user\_data)}
    (for full details see \S\ref{ss:rhsFn}).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_SUNLS\_FAIL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The internal difference quotient approximation is disabled.
  \end{args}
}
{
  The default is to use the right-hand side function provided to \id{CVodeInit}
  in the internal difference quotient. If the input right-hand side function is
  \id{NULL}, the default is used.

  This function must be called \emph{after} the {\cvls} linear solver interface
  has been initialized through a call to \id{CVodeSetLinearSolver}.
}
%%
%%
\index{optional input!matrix-free linear solver|)}
%%
%%
%%
%%
\index{optional input!iterative linear solver|(}
\index{preconditioning!user-supplied|(}
When using an iterative linear solver, the user may supply a
preconditioning operator to aid in solution of the system.  This
operator consists of two user-supplied functions, \id{psetup} and
\id{psolve}, that are supplied to {\cvodes} using the function
\Id{CVodeSetPreconditioner}.  The \id{psetup} function supplied to
this routine should handle evaluation and preprocessing of any
Jacobian data needed by the user's preconditioner solve function,
\id{psolve}.  The user data pointer received through
\id{CVodeSetUserData} (or a pointer to \id{NULL} if user data was not
specified) is passed to the \id{psetup} and \id{psolve} functions.
This allows the user to create an arbitrary structure with relevant
problem data and access it during the execution of the user-supplied
preconditioner functions without using global data in the program.

Also, as described in \S\ref{ss:ivp_sol}, the {\cvls} interface
requires that iterative linear solvers stop when the norm of the
preconditioned residual satisfies
\[
  \|r\| \le \frac{\epsilon_L \epsilon}{10}
\]
where $\epsilon$ is the nonlinear solver tolerance, and the default
$\epsilon_L = 0.05$; this value may be modified by the user through
the \id{CVodeSetEpsLin} function.


\index{CVLS@{\cvls} linear solver interface!preconditioner setup function}
\index{CVLS@{\cvls} linear solver interface!preconditioner solve function}
\ucfunctionf{CVodeSetPreconditioner}
{
  flag = CVodeSetPreconditioner(cvode\_mem, psetup, psolve);
}
{
  The function \ID{CVodeSetPreconditioner} specifies the preconditioner
  setup and solve functions.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[psetup] (\id{CVLsPrecSetupFn})
    user-defined preconditioner setup function.
    Pass \id{NULL} if no setup is necessary.
  \item[psolve] (\id{CVLsPrecSolveFn})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional values have been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_SUNLS\_FAIL}]
    An error occurred when setting up preconditioning in the
    {\sunlinsol} object used by the {\cvls} interface.
  \end{args}
}
{
  The default is \id{NULL} for both arguments (i.e., no
  preconditioning).

  This function must be called \emph{after} the {\cvls} linear solver
  interface has been initialized through a call to
  \id{CVodeSetLinearSolver}.

  The function type \id{CVLsPrecSolveFn} is described in \S\ref{ss:psolveFn}.

  The function type \id{CVLsPrecSetupFn} is described in \S\ref{ss:precondFn}.

  The previous routine \Id{CVSpilsSetPreconditioner} is now a wrapper
  for this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
\index{preconditioning!user-supplied|)}
%%
%%
\index{CVLS@{\cvls} linear solver interface!convergence test}
\ucfunctionf{CVodeSetEpsLin}
{
  flag = CVodeSetEpsLin(cvode\_mem, eplifac);
}
{
  The function \ID{CVodeSetEpsLin} specifies the factor by
  which the Krylov linear solver's convergence test constant is
  reduced from the nonlinear solver test constant.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[eplifac] (\id{realtype}) linear convergence safety factor $(
    \geq 0.0)$.

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The factor \id{eplifac} is negative.
  \end{args}
}
{
  The default value is $0.05$.

  This function must be called \emph{after} the {\cvls} linear solver
  interface has been initialized through a call to
  \id{CVodeSetLinearSolver}.

  If \id{eplifac}$ = 0.0$ is passed, the default value is used.

  The previous routine \Id{CVSpilsSetEpsLin} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
%%
\index{optional input!iterative linear solver|)}
\index{CVLS@{\cvls} linear solver interface!optional input||)}
\index{optional input!generic linear solver interface|)}



%%==============================================================================
\subsubsection{Rootfinding optional input functions}\label{sss:optin_root}
\index{optional input!rootfinding|(}
%%
The following functions can be called to set optional inputs to control the
rootfinding algorithm.
%%
\ucfunctionf{CVodeSetRootDirection}
{
flag = CVodeSetRootDirection(cvode\_mem, rootdir);
}
{
  The function \ID{CVodeSetRootDirection} specifies the direction of
  zero-crossings to be located and returned.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[rootdir] (\id{int *})
    state array of length \id{nrtfn}, the number of root functions $g_i$, as specified
    in the call to the function \id{CVodeRootInit}.  A value of $0$ for
    \id{rootdir[i]} indicates that crossing in either direction for $g_i$
    should be reported.  A value of $+1$ or $-1$ indicates that the solver should
    report only zero-crossings where $g_i$ is increasing or decreasing, respectively.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    rootfinding has not been activated through a call to \id{CVodeRootInit}.
  \end{args}
}
{
  The default behavior is to monitor for both zero-crossing directions.
}
%%
%%
\ucfunctionf{CVodeSetNoInactiveRootWarn}
{
flag = CVodeSetNoInactiveRootWarn(cvode\_mem);
}
{
  The function \ID{CVodeSetNoInactiveRootWarn} disables issuing a warning
  if some root function appears to be identically zero at the beginning of the integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\cvodes} will not report the initial conditions as a possible zero-crossing
  (assuming that one or more components $g_i$ are zero at the initial time).
  However, if it appears that some $g_i$ is identically zero at the initial
  time (i.e., $g_i$ is zero at the initial time and after the first step),
  {\cvodes} will issue a warning which can be disabled with this optional input
  function.
}
%%
\index{optional input!rootfinding|)}

%%==============================================================================
\subsection{Interpolated output function}\label{ss:optional_dky}
\index{optional output!interpolated solution}

An optional function \Id{CVodeGetDky} is available to obtain additional
output values.  This function should only be called after a successful
return from \id{CVode} as it provides interpolated values either of
$y$ or of its derivatives (up to the current order of the integration
method) interpolated to any value of $t$ in the last internal step
taken by {\cvodes}.

The call to the \id{CVodeGetDky} function has the following form:
%%
\ucfunctionf{CVodeGetDky}
{
  flag = CVodeGetDky(cvode\_mem, t, k, dky);
}
{
  The function \ID{CVodeGetDky} computes the \id{k}-th derivative of the function
  \id{y} at time \id{t}, i.e. $d^{(k)}y/dt^{(k)} (t)$, where $t_n - h_u \le$
  \id{t} $\le t_n$, $t_n$ denotes the current internal time reached, and $h_u$
  is the  last internal step size successfully used by the solver.  The
  user may request \id{k} $= 0, 1, \ldots, q_u$, where $q_u$ is the current order
  (optional output \id{qlast}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[t] (\id{realtype})  the value of the independent variable at
    which the derivative is to be evaluated.
  \item[k] (\id{int}) the derivative order requested.
  \item[dky] (\id{N\_Vector})
    vector containing the derivative.
    This vector must be allocated by the user.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetDky} succeeded.
  \item[\Id{CV\_BAD\_K}]
    \id{k} is not in the range $0, 1, \ldots, q_u$.
  \item[\Id{CV\_BAD\_T}]
    \id{t} is not in the interval $[t_n - h_u , t_n]$.
  \item[\Id{CV\_BAD\_DKY}]
    The \id{dky} argument was \id{NULL}.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} argument was \id{NULL}.
  \end{args}

}
{
  It is only legal to call the function \id{CVodeGetDky} after a
  successful return from \id{CVode}. See \id{CVodeGetCurrentTime},
  \id{CVodeGetLastOrder}, and \id{CVodeGetLastStep} in the next section for
  access to $t_n$, $q_u$, and $h_u$, respectively.
}

%%==============================================================================
\subsection{Optional output functions}\label{ss:optional_output}
%%==============================================================================

{\cvodes} provides an extensive set of functions that can be used to obtain
solver performance information.
Table \ref{t:optional_output} lists all optional output functions in {\cvodes},
which are then described in detail in the remainder of this section.

Some of the optional outputs, especially the various counters, can be
very useful in determining how successful the {\cvodes} solver is in
doing its job.  For example, the counters \id{nsteps} and \id{nfevals}
provide a rough measure of the overall cost of a given run, and can be
compared among runs with differing input options to suggest which set
of options is most efficient.  The ratio \id{nniters/nsteps} measures
the performance of the nonlinear solver in solving the nonlinear
systems at each time step; typical values for this range from 1.1 to
1.8.  The ratio \id{njevals/nniters} (in the case of a matrix-based linear
solver), and the ratio \id{npevals/nniters} (in the case of an
iterative linear solver) measure the overall degree of nonlinearity
in these systems, and also the quality of the approximate Jacobian or
preconditioner being used.  Thus, for example, \id{njevals/nniters}
can indicate if a user-supplied Jacobian is inaccurate, if this ratio
is larger than for the case of the corresponding internal Jacobian.
The ratio \id{nliters/nniters} measures the performance of the Krylov
iterative linear solver, and thus (indirectly) the quality of the
preconditioner.

\vspace*{.2in}

\newlength{\colAA}
\settowidth{\colAA}{No. of r.h.s. calls for finite diff. Jacobian[-vector] evals.}
\newlength{\colBB}
\settowidth{\colBB}{\id{CVodeGetNumNonlinSolvConvFails}}


\begin{table}
\centering
\caption{Optional outputs from {\cvodes}, {\cvls}, and {\cvdiag}}
\label{t:optional_output}
\medskip
\begin{tabular}{|p{\colAA}|p{\colBB}|}
\hline
{\bf Optional output} & {\bf Function name} \\
\hline
\multicolumn{2}{|c|}{\bf CVODES main solver} \\
\hline
Size of {\cvodes} real and integer workspaces & \id{CVodeGetWorkSpace} \\
Cumulative number of internal steps & \id{CVodeGetNumSteps} \\
No. of calls to r.h.s. function & \id{CVodeGetNumRhsEvals} \\
No. of calls to linear solver setup function & \id{CVodeGetNumLinSolvSetups} \\
No. of local error test failures that have occurred & \id{CVodeGetNumErrTestFails} \\
Order used during the last step & \id{CVodeGetLastOrder} \\
Order to be attempted on the next step & \id{CVodeGetCurrentOrder} \\
No. of order reductions due to stability limit detection & \id{CVodeGetNumStabLimOrderReds} \\
Actual initial step size used & \id{CVodeGetActualInitStep} \\
Step size used for the last step & \id{CVodeGetLastStep} \\
Step size to be attempted on the next step & \id{CVodeGetCurrentStep} \\
Current internal time reached by the solver & \id{CVodeGetCurrentTime} \\
Suggested factor for tolerance scaling  & \id{CVodeGetTolScaleFactor} \\
Error weight vector for state variables & \id{CVodeGetErrWeights} \\
Estimated local error vector & \id{CVodeGetEstLocalErrors} \\
No. of nonlinear solver iterations & \id{CVodeGetNumNonlinSolvIters} \\
No. of nonlinear convergence failures & \id{CVodeGetNumNonlinSolvConvFails} \\
All {\cvodes} integrator statistics & \id{CVodeGetIntegratorStats} \\
{\cvodes} nonlinear solver statistics & \id{CVodeGetNonlinSolvStats} \\
Array showing roots found & \id{CVodeGetRootInfo} \\
No. of calls to user root function & \id{CVodeGetNumGEvals} \\
Name of constant associated with a return flag & \id{CVodeGetReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf CVLS linear solver interface} \\
\hline
Size of real and integer workspaces & \id{CVodeGetLinWorkSpace} \\
No. of Jacobian evaluations & \id{CVodeGetNumJacEvals} \\
No. of r.h.s. calls for finite diff. Jacobian[-vector] evals. & \id{CVodeGetNumLinRhsEvals} \\
No. of linear iterations & \id{CVodeGetNumLinIters} \\
No. of linear convergence failures & \id{CVodeGetNumLinConvFails} \\
No. of preconditioner evaluations & \id{CVodeGetNumPrecEvals} \\
No. of preconditioner solves & \id{CVodeGetNumPrecSolves} \\
No. of Jacobian-vector setup evaluations & \id{CVodeGetNumJTSetupEvals} \\
No. of Jacobian-vector product evaluations & \id{CVodeGetNumJtimesEvals} \\
Last return from a linear solver function & \id{CVodeGetLastLinFlag} \\
Name of constant associated with a return flag & \id{CVodeGetLinReturnFlagName} \\
\hline
\multicolumn{2}{|c|}{\bf CVDIAG linear solver interface} \\
\hline
Size of {\cvdiag} real and integer workspaces & \id{CVDiagGetWorkSpace} \\
No. of r.h.s. calls for finite diff. Jacobian evals. & \id{CVDiagGetNumRhsEvals} \\
Last return from a {\cvdiag} function & \id{CVDiagGetLastFlag} \\
Name of constant associated with a return flag & \id{CVDiagGetReturnFlagName} \\
\hline
\end{tabular}
\end{table}

%%==============================================================================
%% SUNDIALS-wide functions for getting version information
\input{sundials_version}
%%==============================================================================

%%==============================================================================
\subsubsection{Main solver optional output functions}\label{sss:optout_main}
%%==============================================================================
\index{optional output!solver|(}
%%
{\cvodes} provides several user-callable functions that can be used to obtain
different quantities that may be of interest to the user, such as solver workspace
requirements, solver performance statistics, as well as additional data from
the {\cvodes} memory block (a suggested tolerance scaling factor, the error weight
vector, and the vector of estimated local errors). Functions are also provided to
extract statistics related to the performance of the {\cvodes} nonlinear solver
used. As a convenience, additional information extraction functions provide the
optional outputs in groups.
%%
These optional output functions are described next.
%%
%%
\ucfunctionf{CVodeGetWorkSpace}
{
  flag = CVodeGetWorkSpace(cvode\_mem, \&lenrw, \&leniw);
}
{
  The function \ID{CVodeGetWorkSpace} returns the
  {\cvodes} real and integer workspace sizes.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrw] (\id{long int})
    the number of \id{realtype} values in the {\cvodes} workspace.
  \item[leniw] (\id{long int})
    the number of integer values in the {\cvodes} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  \index{memory requirements!CVODES@{\cvodes} solver}
  In terms of the problem size $N$, the maximum method order \id{maxord}, and
  the number \id{nrtfn} of root functions (see \S\ref{ss:cvrootinit}),
  the actual size of the real workspace, in \id{realtype} words, is
  given by the following:
  \begin{itemize}
  \item base value: \id{lenrw} $= 96 + ($\id{maxord+5}$)*N_r + 3*$\id{nrtfn};
  \item using \id{CVodeSVtolerances}: \id{lenrw} $=$ \id{lenrw} $+ N_r$;
  \item with constraint checking (see \id{CVodeSetConstraints}):
    \id{lenrw} $=$ \id{lenrw} $+ N_r$;
  \end{itemize}
  where $N_r$ is the number of real words in one \id{N\_Vector} ($\approx N$).

  The size of the integer workspace (without distinction between \id{int}
  and \id{long int} words) is given by:
  \begin{itemize}
  \item base value: \id{leniw} $= 40 + ($\id{maxord+5}$)*N_i ~ + ~ $\id{nrtfn};
  \item using \id{CVodeSVtolerances}: \id{leniw} $=$ \id{leniw} $+ N_i$;
  \item with constraint checking: \id{lenrw} $=$ \id{lenrw} $+ N_i$;
  \end{itemize}
  where $N_i$ is the number of integer words in one \id{N\_Vector}
  (= 1 for {\nvecs} and 2*\id{npes} for {\nvecp} and \id{npes} processors).

  For the default value of \id{maxord}, no rootfinding, no constraints, and
  without using \id{CVodeSVtolerances}, these lengths are given roughly by:
  \begin{itemize}
  \item For the Adams method: \id{lenrw} $= 96 + 17N$ and \id{leniw} $= 57$
  \item For the BDF method: \id{lenrw} $= 96 + 10N$ and \id{leniw} $= 50$
  \end{itemize}

  Note that additional memory is allocated if quadratures and/or forward sensitivity
  integration is enabled. See \S\ref{ss:quad_malloc} and \S\ref{ss:sensi_malloc}
  for more details.
}
%%
\ucfunctionf{CVodeGetNumSteps}
{
  flag = CVodeGetNumSteps(cvode\_mem, \&nsteps);
}
{
  The function \ID{CVodeGetNumSteps} returns the cumulative number of internal
  steps taken by the solver (total so far).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nsteps] (\id{long int})
    number of steps taken by {\cvodes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetNumRhsEvals}
{
  flag = CVodeGetNumRhsEvals(cvode\_mem, \&nfevals);
}
{
  The function \ID{CVodeGetNumRhsEvals} returns the
  number of calls to the user's right-hand side function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevals] (\id{long int})
    number of calls to the user's \id{f} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  The \id{nfevals} value returned by \id{CVodeGetNumRhsEvals} does not
  account for calls made to \id{f} by a linear solver or preconditioner
  module.
}
%%
%%
\ucfunctionf{CVodeGetNumLinSolvSetups}
{
  flag = CVodeGetNumLinSolvSetups(cvode\_mem, \&nlinsetups);
}
{
  The function \ID{CVodeGetNumLinSolvSetups} returns the
  number of calls made to the linear solver's setup function.
}
{
  \begin{args}[nlinsetups]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nlinsetups] (\id{long int})
    number of calls made to the linear solver setup function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetNumErrTestFails}
{
  flag = CVodeGetNumErrTestFails(cvode\_mem, \&netfails);
}
{
  The function \ID{CVodeGetNumErrTestFails} returns the
  number of local error test failures that have occurred.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[netfails] (\id{long int})
    number of error test failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetLastOrder}
{
  flag = CVodeGetLastOrder(cvode\_mem, \&qlast);
}
{
  The function \ID{CVodeGetLastOrder} returns the
  integration method order used during the last internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[qlast] (\id{int})
    method order used on the last internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetCurrentOrder}
{
  flag = CVodeGetCurrentOrder(cvode\_mem, \&qcur);
}
{
  The function \ID{CVodeGetCurrentOrder} returns the
  integration method order to be used on the next internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[qcur] (\id{int})
    method order to be used on the next internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetLastStep}
{
  flag = CVodeGetLastStep(cvode\_mem, \&hlast);
}
{
  The function \ID{CVodeGetLastStep} returns the
  integration step size taken on the last internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hlast] (\id{realtype})
    step size taken on the last internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetCurrentStep}
{
  flag = CVodeGetCurrentStep(cvode\_mem, \&hcur);
}
{
  The function \ID{CVodeGetCurrentStep} returns the
  integration step size to be attempted on the next internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hcur] (\id{realtype})
    step size to be attempted on the next internal step.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetActualInitStep}
{
  flag = CVodeGetActualInitStep(cvode\_mem, \&hinused);
}
{
  The function \ID{CVodeGetActualInitStep} returns the
  value of the integration step size used on the first step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[hinused] (\id{realtype})
    actual value of initial step size.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Even if the value of the initial integration step size was specified
  by the user through a call to \id{CVodeSetInitStep}, this value might have
  been changed by {\cvodes} to ensure that the step size is within the
  prescribed bounds ($h_{\min} \le h_0 \le h_{\max}$), or to satisfy the
  local error test condition.
}
%%
%%
\ucfunctionf{CVodeGetCurrentTime}
{
  flag = CVodeGetCurrentTime(cvode\_mem, \&tcur);
}
{
  The function \ID{CVodeGetCurrentTime} returns the
  current internal time reached by the solver.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tcur] (\id{realtype})
    current internal time reached.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetNumStabLimOrderReds}
{
  flag = CVodeGetNumStabLimOrderReds(cvode\_mem, \&nslred);
}
{
  The function \ID{CVodeGetNumStabLimOrderReds} returns the
  number of order reductions dictated by the BDF stability limit
  detection algorithm (see \S\ref{s:bdf_stab}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nslred] (\id{long int})
    number of order reductions due to stability limit detection.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  If the stability limit detection algorithm was not initialized
  (\id{CVodeSetStabLimDet} was not called), then \id{nslred} = 0.
}
%%
%%
\ucfunctionf{CVodeGetTolScaleFactor}
{
  flag = CVodeGetTolScaleFactor(cvode\_mem, \&tolsfac);
}
{
  The function \ID{CVodeGetTolScaleFactor} returns a
  suggested factor by which the user's tolerances
  should be scaled when too much accuracy has been
  requested for some internal step.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[tolsfac] (\id{realtype})
    suggested scaling factor for user-supplied tolerances.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetErrWeights}
{
  flag = CVodeGetErrWeights(cvode\_mem, eweight);
}
{
  The function \ID{CVodeGetErrWeights} returns the solution error weights at
  the current time. These are the reciprocals of the $W_i$ given by (\ref{e:errwt}).
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[eweight] (\id{N\_Vector})
    solution error weights at the current time.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\warn}The user must allocate memory for \id{eweight}.
}
%%
%%
\ucfunctionf{CVodeGetEstLocalErrors}
{
  flag = CVodeGetEstLocalErrors(cvode\_mem, ele);
}
{
  The function \ID{CVodeGetEstLocalErrors} returns the
  vector of estimated local errors.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[ele] (\id{N\_Vector})
    estimated local errors.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  {\warn}The user must allocate memory for \id{ele}.

  The values returned in \id{ele} are valid only if \id{CVode} returned
  a non-negative value.

  The \id{ele} vector, togther with the \id{eweight} vector from
  \id{CVodeGetErrWeights}, can be used to determine how the various
  components of the system contributed to the estimated local error
  test.  Specifically, that error test uses the RMS norm of a vector
  whose components are the products of the components of these two vectors.
  Thus, for example, if there were recent error test failures, the components
  causing the failures are those with largest values for the products,
  denoted loosely as \id{eweight[i]*ele[i]}.
}
%%
%%
\ucfunctionf{CVodeGetIntegratorStats}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = CVodeGetIntegratorStats(&cvode\_mem, \&nsteps, \&nfevals, \\
                                   &\&nlinsetups, \&netfails, \&qlast, \&qcur, \\
                                   &\&hinused, \&hlast, \&hcur, \&tcur);
  \end{tabular}
}
{
  The function \ID{CVodeGetIntegratorStats} returns the {\cvodes} integrator
  statistics as a group.
}
{
  \begin{args}[nlinsetups]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nsteps] (\id{long int})
    number of steps taken by {\cvodes}.
  \item[nfevals] (\id{long int})
    number of calls to the user's \id{f} function.
  \item[nlinsetups] (\id{long int})
    number of calls made to the linear solver setup function.
  \item[netfails] (\id{long int})
    number of error test failures.
  \item[qlast] (\id{int})
    method order used on the last internal step.
  \item[qcur] (\id{int})
    method order to be used on the next internal step.
  \item[hinused] (\id{realtype})
    actual value of initial step size.
  \item[hlast] (\id{realtype})
    step size taken on the last internal step.
  \item[hcur] (\id{realtype})
    step size to be attempted on the next internal step.
  \item[tcur] (\id{realtype})
    current internal time reached.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    the optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    the \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetNumNonlinSolvIters}
{
  flag = CVodeGetNumNonlinSolvIters(cvode\_mem, \&nniters);
}
{
  The function \ID{CVodeGetNumNonlinSolvIters} returns the
  number of nonlinear iterations performed.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations performed.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_MEM\_FAIL}]
    The {\sunnonlinsol} module is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetNumNonlinSolvConvFails}
{
  flag = CVodeGetNumNonlinSolvConvFails(cvode\_mem, \&nncfails);
}
{
  The function \ID{CVodeGetNumNonlinSolvConvFails} returns the
  number of nonlinear convergence failures that have occurred.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nncfails] (\id{long int})
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetNonlinSolvStats}
{
  flag = CVodeGetNonlinSolvStats(cvode\_mem, \&nniters, \&nncfails);
}
{
  The function \ID{CVodeGetNonlinSolvStats} returns the
  {\cvodes} nonlinear solver statistics as a group.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nniters] (\id{long int})
    number of nonlinear iterations performed.
  \item[nncfails] (\id{long int})
    number of nonlinear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_MEM\_FAIL}]
    The {\sunnonlinsol} module is \id{NULL}.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetReturnFlagName}
{
  name = CVodeGetReturnFlagName(flag);
}
{
  The function \ID{CVodeGetReturnFlagName} returns the
  name of the {\cvodes} constant corresponding to \id{flag}.
}
{
  The only argument, of type \id{int}, is a return flag from a {\cvodes} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{optional output!solver|)}


%%
%%==================================================================================
%%
\subsubsection{Rootfinding optional output functions}\label{sss:optout_root}

There are two optional output functions associated with rootfinding.
%%
%%
\ucfunctionf{CVodeGetRootInfo}
{
  flag = CVodeGetRootInfo(cvode\_mem, rootsfound);
}
{
  The function \ID{CVodeGetRootInfo} returns an array showing which
  functions were found to have a root.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[rootsfound] (\id{int *})
    array of length \id{nrtfn} with the indices of the user functions $g_i$
    found to have a root.  For $i=0,\ldots,$\id{nrtfn}$-1$,
    \id{rootsfound}[$i$]$\ne 0$ if $g_i$ has a root, and $= 0$ if not.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  Note that, for the components $g_i$ for which a root was found,
  the sign of \id{rootsfound}[$i$] indicates the direction of
  zero-crossing. A value of $+1$ indicates that $g_i$ is increasing,
  while a value of $-1$ indicates a decreasing $g_i$.

  {\warn}The user must allocate memory for the vector \id{rootsfound}.
}
%%
%%
\ucfunctionf{CVodeGetNumGEvals}
{
  flag = CVodeGetNumGEvals(cvode\_mem, \&ngevals);
}
{
  The function \ID{CVodeGetNumGEvals} returns the cumulative
  number of calls made to the user-supplied root function $g$.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[ngevals] (\id{long int})
    number of calls made to the user's function \id{g} thus far.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

%%==============================================================================
\subsubsection{{\cvls} linear solver interface optional output functions}
\label{sss:optout_ls}
%%==============================================================================
\index{optional output!generic linear solver interface|(}
\index{CVLS@{\cvls} linear solver interface!optional output|(}
The following optional outputs are available from the {\cvls} modules:
workspace requirements,
number of calls to the Jacobian routine,
number of calls to the right-hand side routine for finite-difference Jacobian or Jacobian-vector product approximation,
number of linear iterations,
number of linear convergence failures,
number of calls to the preconditioner setup and solve routines,
number of calls to the Jacobian-vector setup and product routines,
and last return value from a linear solver function.
Note that, where the name of an output would otherwise conflict with
the name of an optional output from the main solver, a suffix \id{LS}
(for Linear Solver) has been added (e.g. \id{lenrwLS}).
%%
%%
\index{CVLS@{\cvls} linear solver interface!memory requirements}
\index{memory requirements!CVLS@{\cvls} linear solver interface}
\ucfunctionf{CVodeGetLinWorkSpace}
{
  flag = CVodeGetLinWorkSpace(cvode\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{CVodeGetLinWorkSpace} returns the sizes of the real and
  integer workspaces used by the {\cvls} linear solver interface.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\cvls} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\cvls} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output values have been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The workspace requirements reported by this routine correspond only
  to memory allocated within this interface and to memory allocated by
  the {\sunlinsol} object attached to it.  The template Jacobian
  matrix allocated by the user outside of {\cvls} is not included in
  this report.

  The previous routines \Id{CVDlsGetWorkspace} and
  \Id{CVSpilsGetWorkspace} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumJacEvals}
{
  flag = CVodeGetNumJacEvals(cvode\_mem, \&njevals);
}
{
  The function \ID{CVodeGetNumJacEvals} returns the
  number of calls made to the {\cvls} Jacobian approximation
  function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[njevals] (\id{long int})
    the number of calls to the Jacobian function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The previous routine \Id{CVDlsGetNumJacEvals} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumLinRhsEvals}
{
  flag = CVodeGetNumLinRhsEvals(cvode\_mem, \&nfevalsLS);
}
{
  The function \ID{CVodeGetNumLinRhsEvals} returns the
  number of calls made to the user-supplied right-hand side function
  due to the finite difference Jacobian approximation or finite
  difference Jacobian-vector product approximation.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls made to the user-supplied right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The value \id{nfevalsLS} is incremented only if one of the default
  internal difference quotient functions is used.

  The previous routines \Id{CVDlsGetNumRhsEvals} and
  \Id{CVSpilsGetNumRhsEvals} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumLinIters}
{
  flag = CVodeGetNumLinIters(cvode\_mem, \&nliters);
}
{
  The function \ID{CVodeGetNumLinIters} returns the
  cumulative number of linear iterations.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nliters] (\id{long int})
    the current number of linear iterations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The previous routine \Id{CVSpilsGetNumLinIters} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumLinConvFails}
{
  flag = CVodeGetNumLinConvFails(cvode\_mem, \&nlcfails);
}
{
  The function \ID{CVodeGetNumLinConvFails} returns the
  cumulative number of linear convergence failures.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nlcfails] (\id{long int})
    the current number of linear convergence failures.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The previous routine \Id{CVSpilsGetNumConvFails} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumPrecEvals}
{
  flag = CVodeGetNumPrecEvals(cvode\_mem, \&npevals);
}
{
  The function \ID{CVodeGetNumPrecEvals} returns the
  number of preconditioner evaluations, i.e., the number of
  calls made to \id{psetup} with \id{jok = SUNFALSE}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[npevals] (\id{long int})
    the current number of calls to \id{psetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The previous routine \Id{CVSpilsGetNumPrecEvals} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumPrecSolves}
{
  flag = CVodeGetNumPrecSolves(cvode\_mem, \&npsolves);
}
{
  The function \ID{CVodeGetNumPrecSolves} returns the
  cumulative number of calls made to the preconditioner
  solve function, \id{psolve}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[npsolves] (\id{long int})
    the current number of calls to \id{psolve}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The previous routine \Id{CVSpilsGetNumPrecSolves} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumJTSetupEvals}
{
  flag = CVodeGetNumJTSetupEvals(cvode\_mem, \&njtsetup);
}
{
  The function \ID{CVodeGetNumJTSetupEvals} returns the
  cumulative number of calls made to the Jacobian-vector setup
  function \id{jtsetup}.
}
{
  \begin{args}
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[njtsetup] (\id{long int})
    the current number of calls to \id{jtsetup}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The previous routine \Id{CVSpilsGetNumJTSetupEvals} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetNumJtimesEvals}
{
  flag = CVodeGetNumJtimesEvals(cvode\_mem, \&njvevals);
}
{
  The function \ID{CVodeGetNumJtimesEvals} returns the
  cumulative number of calls made to the Jacobian-vector function
  \id{jtimes}.
}
{
  \begin{args}
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[njvevals] (\id{long int})
    the current number of calls to \id{jtimes}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  The previous routine \Id{CVSpilsGetNumJtimesEvals} is now a wrapper for
  this routine, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetLastLinFlag}
{
  flag = CVodeGetLastLinFlag(cvode\_mem, \&lsflag);
}
{
  The function \ID{CVodeGetLastLinFlag} returns the
  last return value from a {\cvls} routine.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from a {\cvls} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_LMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    The {\cvls} linear solver has not been initialized.
  \end{args}
}
{
  If the {\cvls} setup function failed (i.e., \id{CVode} returned
  \id{CV\_LSETUP\_FAIL}) when using the {\sunlinsoldense} or
  {\sunlinsolband} modules, then the value of \id{lsflag} is equal to
  the column index (numbered from one) at which a zero diagonal
  element was encountered during the LU factorization of the (dense or
  banded) Jacobian matrix.

  If the {\cvls} setup function failed when using another {\sunlinsol}
  module, then \id{lsflag} will be \id{SUNLS\_PSET\_FAIL\_UNREC},
  \id{SUNLS\_ASET\_FAIL\_UNREC}, or \\ \noindent \id{SUNLS\_PACKAGE\_FAIL\_UNREC}.

  If the {\cvls} solve function failed (i.e., \id{CVode} returned
  \id{CV\_LSOLVE\_FAIL}), then \id{lsflag} contains the error return
  flag from the {\sunlinsol} object, which will be one of:\\ \noindent
  \id{SUNLS\_MEM\_NULL}, indicating that the {\sunlinsol} memory is \id{NULL};
  \\ \noindent \id{SUNLS\_ATIMES\_FAIL\_UNREC}, indicating an unrecoverable failure in the
  $Jv$ function;\\ \noindent
  \id{SUNLS\_PSOLVE\_FAIL\_UNREC}, indicating that the preconditioner solve
  function \id{psolve} failed unrecoverably;
  \id{SUNLS\_GS\_FAIL}, indicating a failure in the Gram-Schmidt
  procedure ({\spgmr} and {\spfgmr} only);
  \id{SUNLS\_QRSOL\_FAIL}, indicating that the matrix $R$ was found to be
  singular during the QR solve phase ({\spgmr} and {\spfgmr} only); or
  \id{SUNLS\_PACKAGE\_FAIL\_UNREC}, indicating an unrecoverable
  failure in an external iterative linear solver package.

  The previous routines \Id{CVDlsGetLastFlag} and
  \Id{CVSpilsGetLastFlag} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
\ucfunctionf{CVodeGetLinReturnFlagName}
{
  name = CVodeGetLinReturnFlagName(lsflag);
}
{
  The function \ID{CVodeGetLinReturnFlagName} returns the
  name of the {\cvls} constant corresponding to \id{lsflag}.
}
{
  The only argument, of type \id{long int}, is a return flag from a {\cvls}
  function.
}
{
  The return value is a string containing the name of the corresponding constant.

  If $1 \leq $ \id{lsflag} $ \leq N$ (LU factorization failed), this routine
  returns ``NONE''.
}
{
  The previous routines \Id{CVDlsGetReturnFlagName} and
  \Id{CVSpilsGetReturnFlagName} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%
\index{CVLS@{\cvls} linear solver interface!optional output|)}
\index{optional output!generic linear solver interface|)}




%%==============================================================================
\subsubsection{Diagonal linear solver interface optional output functions}
\label{sss:optout_diag}
%%==============================================================================
\index{optional output!diagonal linear solver interface|(}
\index{CVDIAG@{\cvdiag} linear solver interface!optional output|(}
The following optional outputs are available from the {\cvdiag} module:
workspace requirements, number of calls to the right-hand side routine for
finite-difference Jacobian approximation, and last return value from a
{\cvdiag} function.
Note that, where the name of an output would otherwise conflict with
the name of an optional output from the main solver, a suffix \id{LS}
(for Linear Solver) has been added here (e.g.  \id{lenrwLS}).
%%
%%
\index{CVDIAG@{\cvdiag} linear solver interface!memory requirements}
\index{memory requirements!CVDIAG@{\cvdiag} linear solver interface}
\ucfunctionf{CVDiagGetWorkSpace}
{
  flag = CVDiagGetWorkSpace(cvode\_mem, \&lenrwLS, \&leniwLS);
}
{
  The function \ID{CVDiagGetWorkSpace} returns the
  {\cvdiag} real and integer workspace sizes.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwLS] (\id{long int})
    the number of \id{realtype} values in the {\cvdiag} workspace.
  \item[leniwLS] (\id{long int})
    the number of integer values in the {\cvdiag} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDIAG\_LMEM\_NULL]
  \item[\Id{CVDIAG\_SUCCESS}]
    The optional output valus have been successfully set.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_LMEM\_NULL}]
    The {\cvdiag} linear solver has not been initialized.
  \end{args}
}
{
  In terms of the problem size $N$, the actual size of the real workspace
  is roughly $3 N$ \id{realtype} words.
}
%%
%%
\ucfunctionf{CVDiagGetNumRhsEvals}
{
  flag = CVDiagGetNumRhsEvals(cvode\_mem, \&nfevalsLS);
}
{
  The function \ID{CVDiagGetNumRhsEvals} returns the
  number of calls made to the user-supplied right-hand side function due to the
  finite difference Jacobian approximation.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsLS] (\id{long int})
    the number of calls made to the user-supplied right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDIAG\_LMEM\_NULL]
  \item[\Id{CVDIAG\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_LMEM\_NULL}]
    The {\cvdiag} linear solver has not been initialized.
  \end{args}
}
{
  The number of diagonal approximate Jacobians formed is
  equal to the number of calls made to the linear solver setup function
  (see \id{CVodeGetNumLinSolvSetups}).
}
%%
%%
\ucfunctionf{CVDiagGetLastFlag}
{
  flag = CVDiagGetLastFlag(cvode\_mem, \&lsflag);
}
{
  The function \ID{CVDiagGetLastFlag} returns the
  last return value from a {\cvdiag} routine.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lsflag] (\id{long int})
    the value of the last return flag from a {\cvdiag} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVDIAG\_LMEM\_NULL]
  \item[\Id{CVDIAG\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVDIAG\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CVDIAG\_LMEM\_NULL}]
    The {\cvdiag} linear solver has not been initialized.
  \end{args}
}
{
  If the {\cvdiag} setup function failed (\id{CVode} returned \id{CV\_LSETUP\_FAIL}),
  the value of \id{lsflag} is equal to \id{CVDIAG\_INV\_FAIL}, indicating that a
  diagonal element with value zero was encountered.
  The same value is also returned if the {\cvdiag} solve function failed
  (\id{CVode} returned \id{CV\_LSOLVE\_FAIL}).
}
%%
%%
\ucfunctionf{CVDiagGetReturnFlagName}
{
  name = CVDiagGetReturnFlagName(lsflag);
}
{
  The function \ID{CVDiagGetReturnFlagName} returns the
  name of the {\cvdiag} constant corresponding to \id{lsflag}.
}
{
  The only argument, of type \id{long int}, is a return flag from a {\cvdiag} function.
}
{
  The return value is a string containing the name of the corresponding constant.
}
{}
\index{CVDIAG@{\cvdiag} linear solver interface!optional output|)}
\index{optional output!diagonal linear solver interface|)}


%%==============================================================================
\subsection{CVODES reinitialization function}\label{sss:cvreinit}
%%==============================================================================
\index{reinitialization}

The function \Id{CVodeReInit} reinitializes the main {\cvodes} solver for
the solution of a new problem, where a prior call to \Id{CVodeInit}
been made. The new problem must have the same size as the previous one.
\id{CVodeReInit} performs the same input checking and initializations
that \id{CVodeInit} does, but does no memory allocation, as it assumes that the
existing internal memory is sufficient for the new problem.
A call to \id{CVodeReInit} deletes the solution history that was stored
internally during the previous integration.  Following a successful call to
\id{CVodeReInit}, call \id{CVode} again for the solution of the new problem.

The use of \id{CVodeReInit} requires that the maximum method order, denoted by
\Id{maxord}, be no larger for the new problem than for the previous problem.
This condition is
automatically fulfilled if the multistep method parameter \Id{lmm}
is unchanged (or changed from \Id{CV\_ADAMS} to \Id{CV\_BDF}) and the default
value for \id{maxord} is specified.

If there are changes to the linear solver specifications, make the
appropriate calls to either the linear solver objects themselves, or
to the {\cvls} interface routines, as described in
\S\ref{sss:lin_solv_init}.  Otherwise, all solver inputs set
previously remain in effect.

One important use of the \id{CVodeReInit} function is in the treating
of jump discontinuities in the RHS function.  Except in cases of
fairly small jumps, it is usually more efficient to stop at each point
of discontinuity and restart the integrator with a readjusted ODE
model, using a call to \id{CVodeReInit}.  To stop when the location of
the discontinuity is known, simply make that location a value of tout.
To stop when the location of the discontinuity is determined by the
solution, use the rootfinding feature.  In either case, it is critical
that the RHS function {\it not} incorporate the discontinuity, but
rather have a smooth extention over the discontinuity, so that the
step across it (and subsequent rootfinding, if used) can be done
efficiently.  Then use a switch within the RHS function (communicated
through \id{user\_data}) that can be flipped between the stopping of
the integration and the restart, so that the restarted problem uses
the new values (which have jumped).  Similar comments apply if there
is to be a jump in the dependent variable vector.


%%
%%
\ucfunctionf{CVodeReInit}
{
  flag = CVodeReInit(cvode\_mem, t0, y0);
}
{
  The function \id{CVodeReInit} provides required problem specifications
  and reinitializes {\cvodes}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[t0] (\id{realtype})
    is the initial value of $t$.
  \item[y0] (\id{N\_Vector})
    is the initial value of $y$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_NO\_MALLOC]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInit} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory block was not initialized through a
    previous call to \id{CVodeCreate}.
  \item[\Id{CV\_NO\_MALLOC}]
    Memory space for the {\cvodes} memory block was not allocated through a
    previous call to \id{CVodeInit}.
  \item[\Id{CV\_ILL\_INPUT}]
    An input argument to \id{CVodeReInit} has an illegal value.
  \end{args}
}
{
  If an error occurred, \id{CVodeReInit} also sends an error message to the
  error handler function.
}


%%==============================================================================
\section{User-supplied functions}\label{ss:user_fct_sim}
%%==============================================================================

The user-supplied functions consist of one function defining the ODE,
(optionally) a function that handles error and warning messages,
(optionally) a function that provides the error weight vector,
(optionally) one or two functions that provide Jacobian-related
information for the linear solver, and
(optionally) one or two functions that define the preconditioner for
use in any of the Krylov iterative algorithms.

%%==============================================================================
\subsection{ODE right-hand side} \label{ss:rhsFn}
%%==============================================================================
\index{right-hand side function}
The user must provide a function of type \Id{CVRhsFn} defined as follows:
\usfunction{CVRhsFn}
{
  typedef int (*CVRhsFn)(&realtype t, N\_Vector y, N\_Vector ydot, \\
                         &void *user\_data);
}
{
  This function computes the ODE right-hand side for a given value
  of the independent variable $t$ and state vector $y$.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[ydot]
    is the output vector $f(t,y)$.
  \item[user\_data]
    is the \Id{user\_data}
    pointer passed to \id{CVodeSetUserData}.
  \end{args}
}
{
  A \id{CVRhsFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \Id{CV\_RHSFUNC\_FAIL} is returned).
}
{
  Allocation of memory for \id{ydot} is handled within {\cvodes}.

  A recoverable failure error return from the \id{CVRhsFn} is typically used to
  flag a value of the dependent variable \id{y} that is ``illegal'' in
  some way (e.g., negative where only a non-negative value is physically
  meaningful).  If such a return is made, {\cvodes} will attempt to recover
  (possibly repeating the nonlinear solve, or reducing the step size)
  in order to avoid this recoverable error return.

  For efficiency reasons, the right-hand side function is not evaluated
  at the converged solution of the nonlinear solver. Therefore, in general, a
  recoverable error in that converged value cannot be corrected.  (It may be
  detected when the right-hand side function is called the first time during
  the following integration step, but a successful step cannot be undone.)
  However, if the user program also includes quadrature integration, the
  state variables can be checked for legality in the call to
  \id{CVQuadRhsFn}, which is called at the converged solution of the
  nonlinear system, and therefore {\cvodes} can be flagged to attempt
  to recover from such a situation. Also, if sensitivity analysis is
  performed with one of the staggered methods, the ODE right-hand side
  function is called at the converged solution of the nonlinear system,
  and a recoverable error at that point can be flagged, and {\cvodes}
  will then try to correct it.

  There are two other situations in which recovery is not possible
  even if the right-hand side function returns a recoverable error flag.
  One is when this occurs at the very first call to the \id{CVRhsFn}
  (in which case {\cvodes} returns \Id{CV\_FIRST\_RHSFUNC\_ERR}).
  The other is when a recoverable error is reported by \id{CVRhsFn}
  after an error test failure, while the linear multistep method order is
  equal to 1 (in which case {\cvodes} returns \Id{CV\_UNREC\_RHSFUNC\_ERR}).
}

%%==============================================================================
\subsection{Error message handler function}
\label{ss:ehFn}
%%==============================================================================
\index{error messages!user-defined handler}
As an alternative to the default behavior of directing error and warning messages
to the file pointed to by \id{errfp} (see \id{CVodeSetErrFile}), the user may
provide a function of type \ID{CVErrHandlerFn} to process any such messages.
The function type \id{CVErrHandlerFn} is defined as follows:
\usfunction{CVErrHandlerFn}
{
  typedef void (*CVErrHandlerFn)(&int error\_code, const char *module,\\
                                 &const char *function, char *msg,\\
                                 &void *eh\_data);
}
{
  This function processes error and warning messages from {\cvodes} and
  its sub-modules.
}
{
  \begin{args}[error\_code]
  \item[error\_code]
    is the error code.
  \item[module]
    is the name of the {\cvodes} module reporting the error.
  \item[function]
    is the name of the function in which the error occurred.
  \item[msg]
    is the error message.
  \item[eh\_data]
    is a pointer to user data, the same as the \Id{eh\_data}
    parameter passed to \id{CVodeSetErrHandlerFn}.
  \end{args}
}
{
  A \id{CVErrHandlerFn} function has no return value.
}
{
  \id{error\_code} is negative for errors and positive (\Id{CV\_WARNING}) for warnings.
  If a function that returns a pointer to memory encounters an
  error, it sets \id{error\_code} to 0.
}

%%==============================================================================
\subsection{Error weight function}
\label{ss:ewtsetFn}
%%==============================================================================
\index{tolerances}
As an alternative to providing the relative and absolute tolerances, the user may
provide a function of type \Id{CVEwtFn} to compute a vector \id{ewt} containing the
weights in the WRMS norm
$\|\ v \|_{\mbox{\scriptsize WRMS}} = \sqrt{(1/N)\sum_1^N (W_i \cdot v_i)^2}$.
These weights will be used in place of those defined by Eq. (\ref{e:errwt}).
The function type \id{CVEwtFn} is defined as follows:
\usfunction{CVEwtFn}
{
  typedef int (*CVEwtFn)(N\_Vector y, N\_Vector ewt, void *user\_data);
}
{
  This function computes the WRMS error weights for the vector $y$.
}
{
  \begin{args}[user\_data]
  \item[y]
    is the value of the dependent variable vector at which the weight
    vector is to be computed.
  \item[ewt]
    is the output vector containing the error weights.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}
    parameter passed to \id{CVodeSetUserData}.
  \end{args}
}
{
  A \id{CVEwtFn} function type must return $0$ if it successfully set
  the error weights and $-1$ otherwise.
}
{
  Allocation of memory for \id{ewt} is handled within {\cvodes}.

  {\warn}The error weight vector must have all components positive. It is the
  user's responsiblity to perform this test and return $-1$ if it is not
  satisfied.
}


%%==============================================================================
\subsection{Rootfinding function}\label{ss:rootFn}
%%
If a rootfinding problem is to be solved during the integration of the ODE system,
the user must supply a {\CC} function of type \Id{CVRootFn}, defined as follows:
%%
\usfunction{CVRootFn}
{
  typedef int (*CVRootFn)(&realtype t, N\_Vector y, realtype *gout, \\
                          &void *user\_data);
}
{
  This function implements a vector-valued function $g(t,y)$ such that the roots of
  the \id{nrtfn} components $g_i(t,y)$ are sought.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[gout]
    is the output array, of length \id{nrtfn}, with components $g_i(t,y)$.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}
    parameter passed to \id{CVodeSetUserData}.
  \end{args}
}
{
  A \id{CVRootFn} should return 0 if successful or a non-zero value if
  an error occurred (in which case the integration is halted and \id{CVode} returns
  \Id{CV\_RTFUNC\_FAIL}).
}
{
  Allocation of memory for \id{gout} is automatically handled within {\cvodes}.
}


%%==============================================================================
\subsection{Jacobian construction (matrix-based linear solvers)}
\label{ss:jacFn}
%%==============================================================================
\index{Jacobian approximation function!user-supplied|(}

If a matrix-based linear solver module is used (i.e., a non-\id{NULL}
{\sunmatrix} object was supplied to \Id{CVodeSetLinearSolver}), the user may
optionally provide a function of type \Id{CVLsJacFn} for evaluating the Jacobian
of the ODE right-hand side function (or an approximation of it). \id{CVLsJacFn}
is defined as follows:
%%
\usfunction{CVLsJacFn}
{
  typedef int (*CVLsJacFn)(&realtype t, N\_Vector y, N\_Vector fy, \\
                           &SUNMatrix Jac, void *user\_data,\\
                           &N\_Vector tmp1, N\_Vector tmp2, N\_Vector tmp3);
}
{
  This function computes the Jacobian matrix $J = \partial f / \partial y$
  (or an approximation to it).
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector,
    namely the predicted value of $y(t)$.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[Jac]
    is the output Jacobian matrix (of type \id{SUNMatrix}).
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}
    parameter passed to \id{CVodeSetUserData}.
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated
    for variables of type \id{N\_Vector} which can be used by a
    \id{CVLsJacFn} function as temporary storage or work space.
  \end{args}
}
{
  A \id{CVLsJacFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct, while {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_RECVR}), or a negative
  value if it failed unrecoverably (in which case the integration is halted, \id{CVodes}
  returns \Id{CV\_LSETUP\_FAIL} and {\cvls} sets \id{last\_flag} to
  \Id{CVLS\_JACFUNC\_UNRECVR}).
}
{
  Information regarding the structure of the specific {\sunmatrix}
  structure (e.g.~number of rows, upper/lower bandwidth, sparsity
  type) may be obtained through using the implementation-specific
  {\sunmatrix} interface functions (see Chapter \ref{s:sunmatrix} for
  details).

  With direct linear solvers (i.e., linear solvers with type
  \Id{SUNLINEARSOLVER\_DIRECT}), the Jacobian matrix $J(t,y)$ is zeroed out
  prior to calling the user-supplied Jacobian function so only nonzero elements
  need to be loaded into \id{Jac}.

  If the user's \id{CVLsJacFn} function uses difference quotient
  approximations, then it may need to access quantities not in the
  argument list.  These include the current step size, the error
  weights, etc.  To obtain these, the user will need to add a pointer
  to \id{cv\_mem} to \id{user\_data} and then use the \id{CVodeGet*}
  functions described in \S\ref{sss:optout_main}. The unit roundoff
  can be accessed as \id{UNIT\_ROUNDOFF} defined in
  \id{sundials\_types.h}.

  {\bf dense}:\\
  A user-supplied dense Jacobian function must load the \id{N} by \id{N}
  dense matrix \id{Jac} with an approximation to the Jacobian matrix $J(t,y)$
  at the point (\id{t}, \id{y}).  The accessor macros \Id{SM\_ELEMENT\_D}
  and \Id{SM\_COLUMN\_D} allow the user to read and write dense matrix
  elements without making explicit references to the underlying
  representation of the {\sunmatdense} type.
  \id{SM\_ELEMENT\_D(J, i, j)} references the (\id{i}, \id{j})-th
  element of the dense matrix \id{Jac} (with \id{i}, \id{j }$= 0\ldots
  \id{N}-1$). This macro is meant for small problems for which efficiency
  of access is not a major concern.  Thus, in terms of the indices $m$
  and $n$ ranging from $1$ to $N$, the Jacobian element $J_{m,n}$ can
  be set using the statement \id{SM\_ELEMENT\_D(J, m-1, n-1) =}
  $J_{m,n}$.  Alternatively, \id{SM\_COLUMN\_D(J, j)} returns a
  pointer to the first element of the \id{j}-th column of \id{Jac}
  (with \id{j }$= 0\ldots \id{N}-1$), and the elements of the \id{j}-th column
  can then be accessed using ordinary array indexing.  Consequently,
  $J_{m,n}$ can be loaded using the statements
  \id{col\_n = SM\_COLUMN\_D(J, n-1);} \id{col\_n[m-1] =} $J_{m,n}$.
  For large problems, it is more efficient to use \id{SM\_COLUMN\_D}
  than to use \id{SM\_ELEMENT\_D}.  Note that both of these macros
  number rows and columns starting from $0$.  The {\sunmatdense} type
  and accessor macros are documented in \S\ref{ss:sunmat_dense}.

  {\bf banded}:\\
  A user-supplied banded Jacobian function must load the \id{N} by \id{N} banded matrix
  \id{Jac} with the elements of the Jacobian $J(t,y)$ at the point
  (\id{t},\id{y}).  The accessor macros \Id{SM\_ELEMENT\_B},
  \Id{SM\_COLUMN\_B}, and \Id{SM\_COLUMN\_ELEMENT\_B} allow the user
  to read and write band matrix elements without making specific
  references to the underlying representation of the {\sunmatband}
  type.  \id{SM\_ELEMENT\_B(J, i, j)} references the (\id{i},
  \id{j})-th element of the band matrix \id{Jac}, counting from $0$.
  This macro is meant for use in small problems for which efficiency
  of access is not a major concern.  Thus, in terms of the indices $m$
  and $n$ ranging from $1$ to $\id{N}$ with $(m,n)$ within the band defined
  by \id{mupper} and \id{mlower}, the Jacobian element $J_{m,n}$ can
  be loaded using the statement \id{SM\_ELEMENT\_B(J, m-1, n-1) =}
  $J_{m,n}$. The elements within the band are those with \id{-mupper}
  $\le$ \id{m-n} $\le$ \id{mlower}. Alternatively,
  \id{SM\_COLUMN\_B(J, j)} returns a pointer to the diagonal element
  of the \id{j}-th column of \id{Jac}, and if we assign this address
  to \id{realtype *col\_j}, then the \id{i}-th element of the
  \id{j}-th column is given by
  \id{SM\_COLUMN\_ELEMENT\_B(col\_j, i, j)}, counting from $0$.  Thus,
  for $(m,n)$ within the band, $J_{m,n}$ can be loaded by setting
  \id{col\_n = SM\_COLUMN\_B(J, n-1);}
  \id{SM\_COLUMN\_ELEMENT\_B(col\_n, m-1, n-1) =} $J_{m,n}$.  The
  elements of the \id{j}-th column can also be accessed via ordinary
  array indexing, but this approach requires knowledge of the
  underlying storage for a band matrix of type {\sunmatband}.
  The array \id{col\_n} can be indexed from $-$\id{mupper} to
  \id{mlower}. For large problems, it is more efficient to use
  \id{SM\_COLUMN\_B} and \id{SM\_COLUMN\_ELEMENT\_B} than to use the
  \id{SM\_ELEMENT\_B} macro.  As in the dense case, these macros all
  number rows and columns starting from $0$.  The {\sunmatband} type
  and accessor macros are documented in \S\ref{ss:sunmat_band}.

  {\bf sparse}:\\
  A user-supplied sparse Jacobian function must load the \id{N} by \id{N}
  compressed-sparse-column or compressed-sparse-row matrix \id{Jac}
  with an approximation to the Jacobian matrix $J(t,y)$ at the point
  (\id{t}, \id{y}).  Storage for \id{Jac} already exists on entry to
  this function, although the user should ensure that sufficient space
  is allocated in \id{Jac} to hold the nonzero values to be set; if
  the existing space is insufficient the user may reallocate the data
  and index arrays as needed.  The amount of allocated space in a
  {\sunmatsparse} object may be accessed using the macro
  \Id{SM\_NNZ\_S} or the routine \Id{SUNSparseMatrix\_NNZ}.  The
  {\sunmatsparse} type and accessor macros are documented in
  \S\ref{ss:sunmat_sparse}.

  The previous function type \Id{CVDlsJacFn} is identical to
  \id{CVLsJacFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
\index{Jacobian approximation function!user-supplied|)}

%%==============================================================================
\subsection{Linear system construction (matrix-based linear solvers)}
\label{ss:linsysFn}
%%==============================================================================
\index{Linear system function!user-supplied|(}

With matrix-based linear solver modules, as an alternative to optionally
supplying a function for evaluating the Jacobian of the ODE right-hand side
function, the user may optionally supply a function of type \Id{CVLsLinSysFn}
for evaluating the linear system, $M = I - \gamma J$ (or an approximation of
it). \Id{CVLsLinSysFn} is defined as follows:
%%
\usfunction{CVLsLinSysFn}
{
  typedef int (*CVLsLinSysFn)(&realtype t, N\_Vector y, N\_Vector fy, \\
                              &SUNMatrix M, booleantype jok, \\
                              &booleantype *jcur, realtype gamma, \\
                              &void *user\_data, N\_Vector tmp1, \\
                              &N\_Vector tmp2, N\_Vector tmp3);
}
{
  This function computes the linear system matrix $M = I - \gamma J$ (or an
  approximation to it).
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, namely the predicted
    value of $y(t)$.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[M]
    is the output linear system matrix (of type \id{SUNMatrix}).
  \item[jok]
    is an input flag indicating whether the Jacobian-related data needs to be
    updated. The \id{jok} flag enables reusing of Jacobian data across linear
    solves however, the user is responsible for storing Jacobian data for
    reuse. \id{jok = SUNFALSE} means that the Jacobian-related data must be
    recomputed from scratch. \id{jok = SUNTRUE}  means that the Jacobian data,
    if saved from the previous call to this function, can be reused (with the
    current value of \id{gamma}). A call with \id{jok = SUNTRUE} can only occur
    after a call with \id{jok = SUNFALSE}.
  \item[jcur]
    is a pointer to a flag which should be set to \id{SUNTRUE} if Jacobian data
    was recomputed, or set to \id{SUNFALSE} if Jacobian data was not recomputed,
    but saved data was still reused.
  \item[gamma]
    is the scalar $\gamma$ appearing in the matrix $M = I - \gamma J$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data} parameter passed
    to the function \id{CVodeSetUserData}.
  \item[tmp1]
  \item[tmp2]
  \item[tmp3]
    are pointers to memory allocated for variables of type \id{N\_Vector} which
    can be used by a \id{CVLsLinSysFn} function as temporary storage or work
    space.
  \end{args}
}
{
  A \id{CVLsLinSysFn} should return \id{0} if successful, a positive value if a
  recoverable error occurred (in which case {\cvode} will attempt to correct,
  while {\cvls} sets \id{last\_flag} to \Id{CVLS\_JACFUNC\_RECVR}), or a
  negative value if it failed unrecoverably (in which case the integration is
  halted, \id{CVode} returns \Id{CV\_LSETUP\_FAIL} and {\cvls} sets
  \id{last\_flag} to \Id{CVLS\_JACFUNC\_UNRECVR}).
}
{}
\index{Linear system function!user-supplied|)}


%%==============================================================================
\subsection{Jacobian-vector product (matrix-free linear solvers)}\label{ss:jtimesFn}
%%==============================================================================
\index{Jacobian approximation function!Jacobian-vector product!user-supplied|(}

If a matrix-free linear solver is to be used (i.e., a \id{NULL}-valued
{\sunmatrix} was supplied to \\ \noindent \id{CVodeSetLinearSolver}), the user may
provide a function of type \Id{CVLsJacTimesVecFn} in the following form,
to compute matrix-vector products $Jv$. If such a function is not supplied,
the default is a difference quotient approximation to these products.

\usfunction{CVLsJacTimesVecFn}
{
  typedef int (*CVLsJacTimesVecFn)&(N\_Vector v, N\_Vector Jv, \\
                                  &realtype t, N\_Vector y, N\_Vector fy,\\
                                  &void *user\_data, N\_Vector tmp);
}
{
  This function computes the product $J v = (\partial f / \partial y) v$
  (or an approximation to it).
}
{
  \begin{args}[user\_data]
  \item[v]
    is the vector by which the Jacobian must be multiplied.
  \item[Jv]
      is the output vector computed.
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to \id{CVodeSetUserData}.
  \item[tmp]
    is a pointer to memory allocated for a variable of type \id{N\_Vector}
    which can be used for work space.
  \end{args}
}
{
  The value returned by the Jacobian-vector product function should be
  $0$ if successful. Any other return value will result in an unrecoverable
  error of the generic Krylov solver, in which case the integration is halted.
}
{
  This function must return a value of $J*v$ that uses the {\it current}
  value of $J$, i.e. as evaluated at the current $(t,y)$.

  If the user's \id{CVLsJacTimesVecFn} function uses difference quotient
  approximations, it may need to access quantities not in the argument
  list. These include the current step size, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{cv\_mem}
  to \id{user\_data} and then use the \id{CVodeGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  The previous function type \Id{CVSpilsJacTimesVecFn} is identical to
  \id{CVLsJacTimesVecFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
\index{Jacobian approximation function!Jacobian-vector product!user-supplied|)}


%%==============================================================================
\subsection{Jacobian-vector product setup (matrix-free linear solvers)}\label{ss:jtsetupFn}
%%==============================================================================
\index{Jacobian approximation function!Jacobian-vector setup|(}

If the user's Jacobian-times-vector routine requires that any
Jacobian-related data be preprocessed or evaluated, then this needs to
be done in a user-supplied function of type \Id{CVLsJacTimesSetupFn},
defined as follows:

\usfunction{CVLsJacTimesSetupFn}
{
  typedef int (*CVLsJacTimesSetupFn)(&realtype t, N\_Vector y, \\
                                     &N\_Vector fy, void *user\_data);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the Jacobian-times-vector routine.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to \id{CVodeSetUserData}.
  \end{args}
}
{
  The value returned by the Jacobian-vector setup function
  should be $0$ if successful, positive for a recoverable error (in
  which case the step will be retried), or negative for an
  unrecoverable error (in which case the integration is halted). }
{
  Each call to the Jacobian-vector setup function is preceded by a call to
  the \id{CVRhsFn} user function with the same \id{(t,y)} arguments.
  Thus, the setup function can use any auxiliary data that is computed
  and saved during the evaluation of the ODE right-hand side.

  If the user's \id{CVLsJacTimesSetupFn} function uses difference quotient
  approximations, it may need to access quantities not in the argument
  list. These include the current step size, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{cv\_mem}
  to \id{user\_data} and then use the \id{CVodeGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  The previous function type \Id{CVSpilsJacTimesSetupFn} is identical
  to\\ \noindent \id{CVLsJacTimesSetupFn}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon.
}
\index{Jacobian approximation function!Jacobian-vector setup|)}


%%==============================================================================
\subsection{Preconditioner solve (iterative linear solvers)} \label{ss:psolveFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{CVLS@{\cvls} linear solver interface!preconditioner solve function}

If a user-supplied preconditioner is to be used with a {\sunlinsol}
solver module, then the user must provide a function to solve the
linear system $Pz = r$, where $P$ may be either a left or right
preconditioner matrix.  Here $P$ should approximate (at least crudely)
the matrix $M = I - \gamma J$, where $J = \partial f/ \partial y$. If
preconditioning is done on both sides, the product of the two
preconditioner matrices should approximate $M$.
This function must be of type \Id{CVLsPrecSolveFn}, defined as follows:
%%
%%
\usfunction{CVLsPrecSolveFn}
{
  typedef int (*CVLsPrecSolveFn)(&realtype t, N\_Vector y, N\_Vector fy,\\
                                 &N\_Vector r, N\_Vector z, realtype gamma,\\
                                 &realtype delta, int lr, void *user\_data);
}
{
  This function solves the preconditioned system $Pz = r$.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[r]
    is the right-hand side vector of the linear system.
  \item[z]
    is the computed output vector.
  \item[gamma]
    is the scalar $\gamma$ appearing in the matrix given by $M=I-\gamma J$.
  \item[delta]
    is an input tolerance to be used if an iterative method
    is employed in the solution.  In that case, the residual
    vector $Res = r - P z$ of the system should be made less than
    \id{delta} in the weighted $l_2$ norm,
    i.e., $\sqrt{\sum_i (Res_i \cdot ewt_i)^2 } < $ \id{delta}.
    To obtain the \id{N\_Vector} \id{ewt}, call \id{CVodeGetErrWeights}
    (see \S\ref{sss:optout_main}).
  \item[lr]
    is an input flag indicating whether the preconditioner solve
    function is to use the left preconditioner (\id{lr = 1}) or
    the right preconditioner (\id{lr = 2});
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to the function \id{CVodeSetUserData}.
  \end{args}
}
{
  The value returned by the preconditioner solve function is a flag
  indicating whether it was successful.  This value should be $0$ if successful,
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{CVSpilsPrecSolveFn} is identical to
  \id{CVLsPrecSolveFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%==============================================================================
\subsection{Preconditioner setup (iterative linear solvers)}\label{ss:precondFn}
%%==============================================================================
\index{preconditioning!user-supplied}
\index{CVLS@{\cvls} linear solver interface!preconditioner setup function}

If the user's preconditioner requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied function of type \Id{CVLsPrecSetupFn}, defined as follows:
\usfunction{CVLsPrecSetupFn}
{
  typedef int (*CVLsPrecSetupFn)(&realtype t, N\_Vector y, N\_Vector fy,\\
                                 &booleantype jok, booleantype *jcurPtr,\\
                                 &realtype gamma, void *user\_data);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector,
    namely the predicted value of $y(t)$.
  \item[fy]
    is the current value of the vector $f(t,y)$.
  \item[jok]
    is an input flag indicating whether the Jacobian-related
    data needs to be updated. The \id{jok} argument provides for
    the reuse of Jacobian data in the preconditioner solve function.
    \id{jok = SUNFALSE} means that the Jacobian-related data
    must be recomputed from scratch.
    \id{jok = SUNTRUE}  means that the Jacobian data, if saved from
    the previous call to this function, can be reused
    (with the current value of \id{gamma}).
    A call with \id{jok = SUNTRUE} can only occur after
    a call with \id{jok = SUNFALSE}.
  \item[jcurPtr]
    is a pointer to a flag which should be
    set to \id{SUNTRUE} if Jacobian data was recomputed, or set
    to \id{SUNFALSE} if Jacobian data was not
    recomputed, but saved data was still reused.
  \item[gamma]
    is the scalar $\gamma$ appearing in the matrix $M = I - \gamma J$.
  \item[user\_data]
    is a pointer to user data, the same as the \id{user\_data}
    parameter passed to the function \id{CVodeSetUserData}.
  \end{args}
}
{
  The value returned by the preconditioner setup function is a flag
  indicating whether it was successful.  This value should be $0$ if successful,
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{
  The operations performed by this function might include forming a crude
  approximate Jacobian and performing an LU factorization of the resulting
  approximation to $M=I - \gamma J$.

  Each call to the preconditioner setup function is preceded by a call to
  the \id{CVRhsFn} user function with the same \id{(t,y)} arguments.
  Thus, the preconditioner setup function can use any auxiliary data that is
  computed and saved during the evaluation of the ODE right-hand side.

  This function is not called in advance of every call to the preconditioner
  solve function, but rather is called only as often as needed to achieve
  convergence in the nonlinear solver.

  If the user's \id{CVLsPrecSetupFn} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current step size, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{cv\_mem}
  to \id{user\_data} and then use the \id{CVodeGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  The previous function type \Id{CVSpilsPrecSetupFn} is identical to
  \id{CVLsPrecSetupFn}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%
%%===================================================================================
\section{Integration of pure quadrature equations}
%%===================================================================================
%%
{\cvodes} allows the ODE system to include {\em pure quadratures}.  In
this case, it is more efficient to treat the quadratures separately by
excluding them from the nonlinear solution stage.  To do this, begin
by excluding the quadrature variables from the vector \id{y} and
excluding the quadrature equations from within \id{res}.  Thus a
separate vector \id{yQ} of quadrature variables is to satisfy
$(d/dt)$\id{yQ} = $f_Q(t,y)$.  The following is an overview of the
sequence of calls in a user's main program in this situation. Steps
that are unchanged from the skeleton program presented in
\S\ref{ss:skeleton_sim} are grayed out.

\index{User main program!integration of quadratures}
\begin{Steps}

\item
  \textcolor{gray}{\bf Initialize parallel or multi-threaded environment,
  if appropriate}

\item
  {\bf Set problem dimensions, etc.}

  Set the problem size \id{N} (excluding quadrature variables),
  and the number of quadrature variables \id{Nq}.

  If appropriate, set the local vector length \id{Nlocal} (excluding quadrature
   variables), and the local number of quadrature variables \id{Nqlocal}.

\item
  \textcolor{gray}{\bf Set vector of initial values}

\item\label{i:quad_cvode_create}
  \textcolor{gray}{\bf Create {\cvodes} object}

\item
  \textcolor{gray}{\bf Initialize {\cvodes} solver}

\item
  \textcolor{gray}{\bf Specify integration tolerances}

\item
  \textcolor{gray}{\bf Create matrix object}

\item
  \textcolor{gray}{\bf Create linear solver object}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

\item
  \textcolor{gray}{\bf Attach linear solver module}

\item
  \textcolor{gray}{\bf Set optional inputs}

\item
  \textcolor{gray}{\bf Attach nonlinear solver module}

\item
  \textcolor{gray}{\bf Set nonlinear solver optional inputs}

\item
  {\bf Set vector \id{yQ0} of initial values for quadrature variables}

  Typically, the quadrature variables should be initialized to $0$.

\item
  {\bf Initialize quadrature integration}

  Call \id{CVodeQuadInit} to specify the quadrature equation right-hand
  side function and to allocate internal memory related to quadrature integration.
  See \S\ref{ss:quad_malloc} for details.

\item\label{i:quad_optional_inputs}
  {\bf Set optional inputs for quadrature integration}

  Call \id{CVodeSetQuadErrCon} to indicate whether or not quadrature variables
  shoule be used in the step size control mechanism, and to specify the integration
  tolerances for quadrature variables.
  See \S\ref{ss:quad_optional_input} for details.

\item\label{i:quad_cvode_solve}
  \textcolor{gray}{\bf Advance solution in time}

\item
  {\bf Extract quadrature variables}

  Call \id{CVodeGetQuad} to obtain the values of the quadrature variables at
  the current time. See \S\ref{ss:quad_get} for details.

\item
  \textcolor{gray}{\bf Get optional outputs}

\item
  {\bf Get quadrature optional outputs}

  Call \id{CVodeGetQuad*} functions to obtain optional output related to
  the integration of quadratures.
  See \S\ref{ss:quad_optional_output} for details.

\item
  {\bf Deallocate memory for solution vector and for the vector of quadrature variables}

\item
  \textcolor{gray}{\bf Free solver memory}

\item
  \textcolor{gray}{\bf Free nonlinear solver memory}

\item
  \textcolor{gray}{\bf Free linear solver and matrix memory}

\item
  \textcolor{gray}{\bf Finalize MPI, if used}

\end{Steps}
%%
\id{CVodeQuadInit} can be called and quadrature-related optional inputs
(step \ref{i:quad_optional_inputs} above) can be set anywhere between steps
\ref{i:quad_cvode_create} and \ref{i:quad_cvode_solve}.

%%===================================================================================

\subsection{Quadrature initialization and deallocation functions}\label{ss:quad_malloc}

The function \id{CVodeQuadInit} activates integration of quadrature equations
and allocates internal memory related to these calculations.
The form of the call to this function is as follows:
%%
\ucfunctionf{CVodeQuadInit}
{
flag = CVodeQuadInit(cvode\_mem, fQ, yQ0);
}
{
  The function \ID{CVodeQuadInit} provides required problem specifications,
  allocates internal memory, and initializes quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block returned by \id{CVodeCreate}.
  \item[fQ] (\Id{CVQuadRhsFn})
    is the {\CC} function which computes $f_Q$, the right-hand side of the quadrature
    equations. This function has the form
    \id{fQ(t, y, yQdot, fQ\_data)} (for full details see \S\ref{ss:user_fct_quad}).
  \item[yQ0] (\id{N\_Vector})
    is the initial value of \id{yQ} (typically \id{yQ0} has all zero components).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_MEM\_FAIL]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeQuadInit} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory was not initialized by a prior call to \id{CVodeCreate}.
  \item[\Id{CV\_MEM\_FAIL}]
    A memory allocation request failed.
  \end{args}
}
{
  If an error occurred, \id{CVodeQuadInit} also sends an error message to the
  error handler function.
}
%%
\index{memory requirements!CVODES@{\cvodes} solver}
In terms of the number of quadrature variables $N_q$ and maximum method order \id{maxord},
the size of the real workspace is increased as follows:
\begin{itemize}
\item Base value: \id{lenrw} $=$ \id{lenrw} $+$ (\id{maxord+5})$N_q$
\item If using \id{CVodeSVtolerances} (see \id{CVodeSetQuadErrCon}): \id{lenrw} $=$ \id{lenrw} $+ N_q$
\end{itemize}
the size of the integer workspace is increased as follows:
\begin{itemize}
\item Base value: \id{leniw} $=$ \id{leniw} $+$ (\id{maxord+5})$N_q$
\item If using \id{CVodeSVtolerances}: \id{leniw} $=$ \id{leniw} $+ N_q$
\end{itemize}

The function \id{CVodeQuadReInit}, useful during the solution of a sequence of problems of
same size, reinitializes the quadrature-related internal memory
and must follow a call to \Id{CVodeQuadInit} (and maybe a call to \id{CVodeReInit}).
The number \id{Nq} of quadratures is assumed to be unchanged from the prior call to
\id{CVodeQuadInit}.
The call to the \id{CVodeQuadReInit} function has the following form:
%%
\ucfunctionf{CVodeQuadReInit}
{
  flag = CVodeQuadReInit(cvode\_mem, yQ0);
}
{
  The function \ID{CVodeQuadReInit} provides required problem specifications
  and reinitializes the quadrature integration.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[yQ0] (\id{N\_Vector})
    is the initial value of \id{yQ}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The call to \id{CVodeReInit} was successful.
  \item[\Id{CV\_MEM\_NULL}]
    The {\cvodes} memory was not initialized by a prior call to \id{CVodeCreate}.
  \item[\Id{CV\_NO\_QUAD}]
    Memory space for the quadrature integration was not allocated by a prior
    call to \id{CVodeQuadInit}.
  \end{args}
}
{
  If an error occurred, \id{CVodeQuadReInit} also sends an error message to the
  error handler function.
}
%%
%%
%%
\ucfunctionf{CVodeQuadFree}
{
  CVodeQuadFree(cvode\_mem);
}
{
  The function \ID{CVodeQuadFree} frees the memory allocated for quadrature integration.
}
{
  The argument is the pointer to the {\cvodes} memory block (of type \id{void *}).
}
{
  The function \id{CVodeQuadFree} has no return value.
}
{
  In general, \id{CVodeQuadFree} need not be called by the user as it is
  invoked automatically by \id{CVodeFree}.
}

%%===================================================================================

\subsection{CVODES solver function}

Even if quadrature integration was enabled, the call to the main solver
function \id{CVode} is exactly the same as in \S\ref{sss:cvode}. However, in this
case the return value \id{flag} can also be one of the following:
\begin{args}[CV\_FIRST\_QRHSFUNC\_FAIL]
\item[\Id{CV\_QRHSFUNC\_FAIL}]
  The quadrature right-hand side function failed in an unrecoverable manner.
\item[\Id{CV\_FIRST\_QRHSFUNC\_FAIL}]
  The quadrature right-hand side function failed at the first call.
\item[\Id{CV\_REPTD\_QRHSFUNC\_ERR}]
  Convergence test failures occurred too many times due to repeated recoverable errors in
  the quadrature right-hand side function. This value will also
  be returned if the quadrature right-hand side function had repeated recoverable errors
  during the estimation of an initial step size (assuming the quadrature
  variables are included in the error tests).
\item[\Id{CV\_UNREC\_RHSFUNC\_ERR}]
  The quadrature right-hand function had a recoverable error, but no recovery was possible.
  This failure mode is rare, as it can occur only if the quadrature right-hand side function
  fails recoverably after an error test failed while at order one.
\end{args}

%%===================================================================================

\subsection{Quadrature extraction functions}\label{ss:quad_get}

If quadrature integration has been initialized by a call to \id{CVodeQuadInit},
or reinitialized by a call to \id{CVodeQuadReInit}, then {\cvodes} computes both a solution
and quadratures at time \id{t}. However, \id{CVode} will still return only the solution
$y$ in \id{yout}. Solution quadratures can be obtained using the following function:
%%
%%
\ucfunctionf{CVodeGetQuad}
{
  flag = CVodeGetQuad(cvode\_mem, \&tret, yQ);
}
{
  The function \ID{CVodeGetQuad} returns the quadrature solution vector after a
  successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeInit}.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yQ] (\id{N\_Vector})
    the computed quadrature vector. This vector must be allocated by the user.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetQuad} is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetQuad} was successful.
  \item[CV\_MEM\_NULL]
    \id{cvode\_mem} was NULL.
  \item[CV\_NO\_QUAD]
    Quadrature integration was not initialized.
  \item[CV\_BAD\_DKY]
    \id{yQ} is \id{NULL}.
  \end{args}
}
{
  In case of an error return, an error message is also sent to the error handler
  function.
}
%%
%%
\index{optional output!interpolated quadratures}
The function \Id{CVodeGetQuadDky} computes the \id{k}-th derivatives of the interpolating
polynomials for the quadrature variables at time \id{t}.
This function is called by \id{CVodeGetQuad} with \id{k = 0} and with the current time
at which \id{CVode} has returned, but may also be called
directly by the user.
%%
\ucfunctionf{CVodeGetQuadDky}
{
  flag = CVodeGetQuadDky(cvode\_mem, t, k, dkyQ);
}
{
  The function \ID{CVodeGetQuadDky} returns derivatives of the quadrature solution
  vector after a successful return from \id{CVode}.
}
{
  \begin{args}[cvode\_mem]
  \item[\id{cvode\_mem}] (\id{void *})
    pointer to the memory previously allocated by \id{CVodeInit}.
  \item[\id{t}] (\id{realtype})
    the time at which quadrature information is
    requested. The time \id{t} must fall within the interval defined by the last
    successful step taken by {\cvodes}.
  \item[\id{k}] (\id{int}) order of the requested derivative.  This
    must be $\leq$ \id{qlast}.
  \item[\id{dkyQ}] (\id{N\_Vector})
    the vector containing the derivative. This vector must be allocated by the user.
  \end{args}
}
{
  The return value \id{flag} of \id{CVodeGetQuadDky} is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    \id{CVodeGetQuadDky} succeeded.
  \item[\Id{CV\_MEM\_NULL}]
    The pointer to \id{cvode\_mem} was NULL.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration was not initialized.
  \item[\Id{CV\_BAD\_DKY}]
    The vector \id{dkyQ} is \id{NULL}.
  \item[\Id{CV\_BAD\_K}]
    \id{k} is not in the range $0, 1, \ldots,$ \id{qlast}.
  \item[\Id{CV\_BAD\_T}]
    The time \id{t} is not in the allowed range.
  \end{args}
}
{
  In case of an error return, an error message is also sent to the error handler function.
}
%%
%%

%%===================================================================================

\subsection{Optional inputs for quadrature integration}\label{ss:quad_optional_input}
\index{optional input!quadrature integration|(}
{\cvodes} provides the following optional input functions to control the integration
of quadrature equations.
%%
%%
\ucfunctionf{CVodeSetQuadErrCon}
{
 flag = CVodeSetQuadErrCon(cvode\_mem, errconQ);
}
{
  The function \ID{CVodeSetQuadErrCon} specifies whether or not the
  quadrature variables are to be used in the step size control mechanism
  within {\cvodes}.  If they are, the user must call \id{CVodeQuadSStolerances}
  or \id{CVodeQuadSVtolerances} to specify the
  integration tolerances for the quadrature variables.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[errconQ] (\id{booleantype})
    specifies whether quadrature variables are included (\id{SUNTRUE}) or not
    (\id{SUNFALSE}) in the error control mechanism.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{
  By default, \id{errconQ} is set to \id{SUNFALSE}.

  {\warn}It is illegal to call \id{CVodeSetQuadErrCon} before a call
  to \id{CVodeQuadInit}.
}


If the quadrature variables are part of the step size control mechanism,
one of the following functions must be called to specify the
integration tolerances for quadrature variables.

\ucfunctionf{CVodeQuadSStolerances}
{
 flag = CVodeQuadSVtolerances(cvode\_mem, reltolQ, abstolQ);
}
{
  The function \ID{CVodeQuadSStolerances} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[reltolQ] (\id{realtype})
    \index{tolerances}
    is the scalar relative error tolerance.
  \item[abstolQ] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration was not initialized.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the input tolerances was negative.
  \end{args}
}
{}

\ucfunctionf{CVodeQuadSVtolerances}
{
 flag = CVodeQuadSVtolerances(cvode\_mem, reltolQ, abstolQ);
}
{
  The function \ID{CVodeQuadSVtolerances} specifies scalar relative and
  vector absolute tolerances.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[reltolQ] (\id{realtype})
    \index{tolerances}
    is the scalar relative error tolerance.
  \item[abstolQ] (\id{N\_Vector})
    is the vector absolute error tolerance.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_ILL\_INPUT]
  \item[\Id{CV\_SUCCESS}]
    The optional value has been successfully set.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration was not initialized.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_ILL\_INPUT}]
    One of the input tolerances was negative.
  \end{args}
}
{}
\index{optional input!quadrature integration|)}
%%
%%

%%===================================================================================

\subsection{Optional outputs for quadrature integration}\label{ss:quad_optional_output}
\index{optional output!quadrature integration|(}

{\cvodes} provides the following functions that can be used to obtain solver
performance information related to quadrature integration.

\ucfunctionf{CVodeGetQuadNumRhsEvals}
{
  flag = CVodeGetQuadNumRhsEvals(cvode\_mem, \&nfQevals);
}
{
  The function \ID{CVodeGetQuadNumRhsEvals} returns the
  number of calls made to the user's quadrature right-hand side function.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfQevals] (\id{long int})
    number of calls made to the user's \id{fQ} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetQuadNumErrTestFails}
{
  flag = CVodeGetQuadNumErrTestFails(cvode\_mem, \&nQetfails);
}
{
  The function \ID{CVodeGetQuadNumErrTestFails} returns the
  number of local error test failures due to quadrature variables.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nQetfails] (\id{long int})
    number of error test failures due to quadrature variables.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
%%
%%
\ucfunctionf{CVodeGetQuadErrWeights}
{
  flag = CVodeGetQuadErrWeights(cvode\_mem, eQweight);
}
{
  The function \ID{CVodeGetQuadErrWeights} returns the quadrature error weights
  at the current time.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[eQweight] (\id{N\_Vector})
    quadrature error weights at the current time.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    The \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{
  {\warn}The user must allocate memory for \id{eQweight}.

  If quadratures were not included in the error control mechanism (through a
  call to \id{CVodeSetQuadErrCon} with \id{errconQ = SUNTRUE}),
  \id{CVodeGetQuadErrWeights} does not set the \id{eQweight} vector.
}
%%
%%
\ucfunctionf{CVodeGetQuadStats}
{
  flag = CVodeGetQuadStats(cvode\_mem, \&nfQevals, \&nQetfails);
}
{
  The function \ID{CVodeGetQuadStats} returns the {\cvodes} integrator statistics
  as a group.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfQevals] (\id{long int})
    number of calls to the user's \id{fQ} function.
  \item[nQetfails] (\id{long int})
    number of error test failures due to quadrature variables.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CV\_MEM\_NULL]
  \item[\Id{CV\_SUCCESS}]
    the optional output values have been successfully set.
  \item[\Id{CV\_MEM\_NULL}]
    the \id{cvode\_mem} pointer is \id{NULL}.
  \item[\Id{CV\_NO\_QUAD}]
    Quadrature integration has not been initialized.
  \end{args}
}
{}
\index{optional output!quadrature integration|)}
%%
%%

%%===================================================================================

\subsection{User-supplied function for quadrature integration}
\label{ss:user_fct_quad}

\index{right-hand side function!quadrature equations}
For integration of quadrature equations, the user must provide a function
that defines the right-hand side of the quadrature equations (in other words,
the integrand function of the integral that must be evaluated). This function
must be of type \Id{CVQuadRhsFn} defined as follows:
\usfunction{CVQuadRhsFn}
{
  typedef int (*CVQuadRhsFn)(&realtype t, N\_Vector y, \\
                             &N\_Vector yQdot, void *user\_data);
}
{
  This function computes the quadrature equation right-hand side for a given value
  of the independent variable $t$ and state vector $y$.
}
{
  \begin{args}[user\_data]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yQdot]
    is the output vector $f_Q(t,y)$.
  \item[user\_data]
    is the \Id{user\_data} pointer passed to \id{CVodeSetUserData}.
  \end{args}
}
{
  A \id{CVQuadRhsFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \Id{CV\_QRHSFUNC\_FAIL} is returned).
}
{
  Allocation of memory for \id{yQdot} is automatically handled within {\cvodes}.

  Both \id{y} and \id{yQdot} are of type \id{N\_Vector},
  but they  typically have different internal representations. It is the user's
  responsibility to access the vector data consistently (including the use of the
  correct accessor macros from each {\nvector} implementation). For the sake of
  computational efficiency, the vector functions in the two {\nvector} implementations
  provided with {\cvodes} do not perform any consistency checks with respect to their
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  There are two situations in which recovery is not possible even if \id{CVQuadRhsFn}
  function returns a recoverable error flag.  One is when this occurs at the
  very first call to the \id{CVQuadRhsFn} (in which case {\cvodes} returns
  \Id{CV\_FIRST\_QRHSFUNC\_ERR}).  The other is when a recoverable error is reported
  by \id{CVQuadRhsFn} after an error test failure, while the linear multistep method
  order is equal to 1 (in which case {\cvodes} returns \Id{CV\_UNREC\_QRHSFUNC\_ERR}).
}


%%==============================================================================
\section{Preconditioner modules}\label{ss:preconds}
%%==============================================================================

The efficiency of Krylov iterative methods for the solution of linear systems
can be greatly enhanced through preconditioning. For problems in which the
user cannot define a more effective, problem-specific preconditioner,
{\cvodes} provides a banded preconditioner in the module {\cvbandpre} and
a band-block-diagonal preconditioner module {\cvbbdpre}.

%%==============================================================================
\subsection{A serial banded preconditioner module}\label{sss:cvbandpre}
%%==============================================================================

\index{CVBANDPRE@{\cvbandpre} preconditioner!description}
\index{preconditioning!banded}

This preconditioner provides a band matrix preconditioner for use with
iterative {\sunlinsol} modules through the {\cvls} linear solver
interface, in a serial setting.
It uses difference quotients of the ODE right-hand side function \id{f} to
generate a band matrix of bandwidth $m_l + m_u + 1$, where the number of
super-diagonals ($m_u$, the upper half-bandwidth) and sub-diagonals
($m_l$, the lower half-bandwidth) are specified by the user, and uses this to
form a preconditioner for use with the Krylov linear solver.
Although this matrix is intended to approximate the Jacobian
$\partial f / \partial y$, it may be a very crude approximation.  The true Jacobian
need not be banded, or its true bandwidth may be larger than $m_l + m_u + 1$, as
long as the banded approximation generated here is sufficiently accurate to
speed convergence as a preconditioner.

\index{CVBANDPRE@{\cvbandpre} preconditioner!usage|(}
In order to use the {\cvbandpre} module, the user need not define any
additional functions.
%%
Aside from the header files required for the integration of the ODE problem
(see \S\ref{ss:header_sim}),  to use the {\cvbandpre} module, the main program
must include the header file \id{cvodes\_bandpre.h} which declares the needed
function prototypes.\index{header files}
%%
The following is a summary of the usage of this module. Steps that are
unchanged from the skeleton program presented in
\S\ref{ss:skeleton_sim} are grayed out.
%%
%%
\index{User main program!CVBANDPRE@{\cvbandpre} usage}
\begin{Steps}

\item
  \textcolor{gray}{\bf Initialize multi-threaded environment, if appropriate}

\item
  \textcolor{gray}{\bf Set problem dimensions etc.}

\item
  \textcolor{gray}{\bf Set vector of initial values}

\item
  \textcolor{gray}{\bf Create {\cvodes} object}

\item
  \textcolor{gray}{\bf Initialize {\cvodes} solver}

\item
  \textcolor{gray}{\bf Specify integration tolerances}

\item
  {\bf Create linear solver object}

  When creating the iterative linear solver object, specify the type
  of preconditioning (\id{PREC\_LEFT} or \id{PREC\_RIGHT}) to use.

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

\item \label{i:bandpre_attach}
  \textcolor{gray}{\bf Attach linear solver module}

\item \label{i:bandpre_init}
  {\bf Initialize the {\cvbandpre} preconditioner module}

  Specify the upper and lower half-bandwidths (\id{mu} and \id{ml}, respectively) and call

  \id{flag = CVBandPrecInit(cvode\_mem, N, mu, ml);}

  to allocate memory and initialize the internal preconditioner data.

\item
  \textcolor{gray}{\bf Set optional inputs}

  Note that the user should not overwrite the preconditioner setup function
  or solve function through calls to the \id{CVodeSetPreconditioner}
  optional input function.

\item
  \textcolor{gray}{\bf Create nonlinear solver object}

\item
  \textcolor{gray}{\bf Attach nonlinear solver module}

\item
  \textcolor{gray}{\bf Set nonlinear solver optional inputs}

\item
  \textcolor{gray}{\bf Specify rootfinding problem}

\item
  \textcolor{gray}{\bf Advance solution in time}

\item
  {\bf Get optional outputs}

  Additional optional outputs associated with {\cvbandpre} are available by
  way of two routines described below,
  \id{CVBandPrecGetWorkSpace} and \id{CVBandPrecGetNumRhsEvals}.

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item
  \textcolor{gray}{\bf Free solver memory}

\item
  \textcolor{gray}{\bf Free nonlinear solver memory}

\item
  \textcolor{gray}{\bf Free linear solver memory}

\end{Steps}
\index{CVBANDPRE@{\cvbandpre} preconditioner!usage|)}
%%
%%------------------------------------------------------------------------------------
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|(}
%%
The {\cvbandpre} preconditioner module is initialized and attached
by calling the following function:
%%
\index{half-bandwidths}
\ucfunctionf{CVBandPrecInit}
{
  flag = CVBandPrecInit(cvode\_mem, N, mu, ml);
}
{
  The function \ID{CVBandPrecInit} initializes the {\cvbandpre} preconditioner
  and allocates required (internal) memory for it.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[N] (\id{sunindextype})
    problem dimension.
  \item[mu] (\id{sunindextype})
    upper half-bandwidth of the Jacobian approximation.
  \item[ml] (\id{sunindextype})
    lower half-bandwidth of the Jacobian approximation.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The call to \id{CVBandPrecInit} was successful.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer was \id{NULL}.
  \item[\Id{CVLS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVLS\_LMEM\_NULL}]
    A {\cvls} linear solver memory was not attached.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The supplied vector implementation was not compatible with block
    band preconditioner.
  \end{args}
}
{
  The banded approximate Jacobian will have nonzero elements only in locations
  $(i,j)$ with $-$\id{ml} $\leq j-i \leq$ \id{mu}.
}
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!user-callable functions|)}

\index{optional output!banded preconditioner|(}
\index{CVBANDPRE@{\cvbandpre} preconditioner!optional output|(}
%%
%%------------------------------------------------------------------------------------
%%
\noindent The following three optional output functions are available for use with
the {\cvbandpre} module:
%%
%%
\ucfunctionf{CVBandPrecGetWorkSpace}
{
  flag = CVBandPrecGetWorkSpace(cvode\_mem, \&lenrwBP, \&leniwBP);
}
{
  The function \ID{CVBandPrecGetWorkSpace} returns the sizes of
  the {\cvbandpre} real and integer workspaces.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwBP] (\id{long int})
    the number of \id{realtype} values in the {\cvbandpre} workspace.
  \item[leniwBP] (\id{long int})
    the number of integer values in the {\cvbandpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_PMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output values have been successfully set.
  \item[\Id{CVLS\_PMEM\_NULL}]
    The {\cvbandpre} preconditioner has not been initialized.
  \end{args}
}
{
  \index{memory requirements!CVBANDPRE@{\cvbandpre} preconditioner}
  The workspace requirements reported by this routine correspond only
  to memory allocated within the {\cvbandpre} module (the banded
  matrix approximation, banded {\sunlinsol} object, and temporary vectors).

  The workspaces referred to here exist in addition to those given by the
  corresponding function \id{CVodeGetLinWorkSpace}.
}
%%
%%
\ucfunctionf{CVBandPrecGetNumRhsEvals}
{
  flag = CVBandPrecGetNumRhsEvals(cvode\_mem, \&nfevalsBP);
}
{
  The function \ID{CVBandPrecGetNumRhsEvals} returns the
  number of calls made to the user-supplied right-hand side function for
  the finite difference banded Jacobian approximation used within
  the preconditioner setup function.
}
{
  \begin{args}[nfevalsBP]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[nfevalsBP] (\id{long int})
    the number of calls to the user right-hand side function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[CVLS\_PMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_PMEM\_NULL}]
    The {\cvbandpre} preconditioner has not been initialized.
  \end{args}
}
{
The counter \id{nfevalsBP} is distinct from the counter \id{nfevalsLS}
returned by the corresponding function \id{CVodeGetNumLinRhsEvals} and
\id{nfevals} returned by\\ \noindent \id{CVodeGetNumRhsEvals}.
The total number of right-hand side function evaluations is the
sum of all three of these counters.
}
%%
\index{CVBANDPRE@{\cvbandpre} preconditioner!optional output|)}
\index{optional output!banded preconditioner|)}

%%==============================================================================
\subsection{A parallel band-block-diagonal preconditioner module}
\label{sss:cvbbdpre}
%%==============================================================================

A principal reason for using a parallel ODE solver such as {\cvodes} lies
in the solution of partial differential equations (PDEs).  Moreover,
the use of a Krylov iterative method for the solution of many such
problems is motivated by the nature of the underlying linear system of
equations (\ref{e:Newton}) that must be solved at each time step.  The
linear algebraic system is large, sparse, and structured. However, if
a Krylov iterative method is to be effective in this setting, then a
nontrivial preconditioner needs to be used.  Otherwise, the rate of
convergence of the Krylov iterative method is usually unacceptably
slow.  Unfortunately, an effective preconditioner tends to be
problem-specific.

However, we have developed one type of preconditioner that treats a
rather broad class of PDE-based problems.  It has been successfully
used for several realistic, large-scale problems \cite{HiTa:98} and is
included in a software module within the {\cvodes} package. This module
works with the parallel vector module {\nvecp} and is usable with any of
the Krylov iterative linear solvers through the {\cvls} interface.
It generates a preconditioner that is a block-diagonal matrix with
each block being a band matrix. The blocks need not have the same
number of super- and sub-diagonals and these numbers may vary from
block to block. This Band-Block-Diagonal Preconditioner module is
called {\cvbbdpre}.

\index{CVBBDPRE@{\cvbbdpre} preconditioner!description|(}
\index{preconditioning!band-block diagonal}
One way to envision these preconditioners is to think of the domain of
the computational PDE problem as being subdivided into $M$ non-overlapping
subdomains.  Each of these subdomains is then assigned to one of the
$M$ processes to be used to solve the ODE system. The basic idea is
to isolate the preconditioning so that it is local to each process,
and also to use a (possibly cheaper) approximate right-hand side
function. This requires the definition of a new function $g(t,y)$
which approximates the function $f(t, y)$ in the definition of the ODE
system (\ref{e:ivp}). However, the user may set $g = f$.  Corresponding
to the domain decomposition, there is a decomposition of the solution
vector $y$ into $M$ disjoint blocks $y_m$, and a decomposition of $g$
into blocks $g_m$.  The block $g_m$ depends both on $y_m$ and on
components of blocks $y_{m'}$ associated with neighboring subdomains
(so-called ghost-cell data).  Let $\bar{y}_m$ denote $y_m$ augmented
with those other components on which $g_m$ depends.  Then we have
\begin{equation}
  g(t,y) = [g_1(t,\bar{y}_1), g_2(t,\bar{y}_2), \ldots, g_M(t,\bar{y}_M)]^T
\end{equation}
and each of the blocks $g_m(t, \bar{y}_m)$ is uncoupled from the others.

The preconditioner associated with this decomposition has the form
\begin{equation}
  P= \operatorname{diag}[P_1, P_2, \ldots, P_M]
\end{equation}
where
\begin{equation}
  P_m \approx I - \gamma J_m
\end{equation}
and $J_m$ is a difference quotient approximation to
$\partial g_m/\partial y_m$. This matrix is taken to be banded, with
upper and lower half-bandwidths \id{mudq} and \id{mldq} defined as
the number of non-zero diagonals above and below the main diagonal,
respectively. The difference quotient approximation is computed using
\id{mudq} $+$ \id{mldq} $+ 2$ evaluations of $g_m$, but only a matrix
of bandwidth \id{mukeep} $+$ \id{mlkeep} $+ 1$ is retained.
Neither pair of parameters need be the true half-bandwidths of the Jacobian of the
local block of $g$, if smaller values provide a more efficient
preconditioner. The solution of the complete linear system
\begin{equation}
  Px = b
\end{equation}
reduces to solving each of the equations
\begin{equation}
  P_m x_m = b_m
\end{equation}
and this is done by banded LU factorization of $P_m$ followed by a banded
backsolve.
\index{CVBBDPRE@{\cvbbdpre} preconditioner!description|)}

Similar block-diagonal preconditioners could be considered with different
treatments of the blocks $P_m$. For example, incomplete LU factorization or
an iterative method could be used instead of banded LU factorization.

\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|(}
The {\cvbbdpre} module calls two user-provided functions to construct $P$:
a required function \id{gloc} (of type \id{CVLocalFn}) which approximates
the right-hand side function $g(t,y) \approx f(t,y)$ and which is computed locally,
and an optional function \id{cfn} (of type \id{CVCommFn}) which performs
all interprocess communication necessary to evaluate the approximate right-hand
side $g$.  These are in addition to the user-supplied right-hand side function
\id{f}.  Both functions take as input the same pointer \id{user\_data} that is passed
by the user to \id{CVodeSetUserData} and that was passed to the user's function \id{f}.
The user is responsible for providing space (presumably within \id{user\_data})
for components of \id{y} that are communicated between processes by \id{cfn}, and
that are then used by \id{gloc}, which should not do any communication.

%%
%%
\usfunction{CVLocalFn}
{
  typedef int (*CVLocalFn)(&sunindextype Nlocal, realtype t, N\_Vector y, \\
                           &N\_Vector glocal, void *user\_data);
}
{
  This \id{gloc} function computes $g(t,y)$. It loads the vector
  \id{glocal} as a function of \id{t} and \id{y}.
}
{
  \begin{args}[user\_data]
  \item[Nlocal]
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the dependent variable.
  \item[glocal]
    is the output vector.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}
    parameter passed to \id{CVodeSetUserData}.
  \end{args}
}
{
  A \id{CVLocalFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVode} returns \Id{CV\_LSETUP\_FAIL}).
}
{
  This function must assume that all interprocess communication of data needed to
  calculate \id{glocal} has already been done, and that this data is accessible within
  \id{user\_data}.

  The case where $g$ is mathematically identical to $f$ is allowed.
}
%%
%%
\usfunction{CVCommFn}
{
  typedef int (*CVCommFn)(&sunindextype Nlocal, realtype t,  \\
                          &N\_Vector y, void *user\_data);
}
{
  This \id{cfn} function performs all interprocess communication necessary
  for the execution of the \id{gloc} function above, using the input vector \id{y}.
}
{
  \begin{args}[user\_data]
  \item[Nlocal]
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the dependent variable.
  \item[user\_data]
    is a pointer to user data, the same as the \Id{user\_data}
    parameter passed to \id{CVodeSetUserData}.
  \end{args}
}
{
  A \id{CVCommFn} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\cvodes} will attempt to correct), or a negative
  value if it failed unrecoverably (in which case the integration is halted and
  \id{CVode} returns \Id{CV\_LSETUP\_FAIL}).
}
{
  The \id{cfn} function is expected to save communicated data in space defined
  within the data structure \id{user\_data}.

  Each call to the \id{cfn} function is preceded by a call to the right-hand side
  function \id{f} with the same (\id{t}, \id{y}) arguments.  Thus, \id{cfn} can omit
  any communication done by \id{f} if relevant to the evaluation of \id{glocal}.
  If all necessary communication was done in \id{f}, then \id{cfn = NULL}
  can be passed in the call to \id{CVBBDPrecInit} (see below).
}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-supplied functions|)}

\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage|(}
%%
Besides the header files required for the integration of the ODE problem
(see \S\ref{ss:header_sim}),  to use the {\cvbbdpre} module, the main program
must include the header file \id{cvodes\_bbdpre.h} which declares the needed
function prototypes.\index{header files}

The following is a summary of the proper usage of this module. Steps that are
unchanged from the skeleton program presented in \S\ref{ss:skeleton_sim} are grayed out.
%%
%%
\index{User main program!CVBBDPRE@{\cvbbdpre} usage}
\begin{Steps}
\item
  \textcolor{gray}{\bf Initialize MPI environment}

\item
  \textcolor{gray}{\bf Set problem dimensions etc.}

\item
  \textcolor{gray}{\bf Set vector of initial values}

\item
  \textcolor{gray}{\bf Create {\cvodes} object}

\item
  \textcolor{gray}{\bf Initialize {\cvodes} solver}

\item
  \textcolor{gray}{\bf Specify integration tolerances}

\item
  {\bf Create linear solver object}

  When creating the iterative linear solver object, specify the type
  of preconditioning (\id{PREC\_LEFT} or \id{PREC\_RIGHT}) to use.

\item
  \textcolor{gray}{\bf Set linear solver optional inputs}

\item \label{i:bbdpre_attach}
  \textcolor{gray}{\bf Attach linear solver module}

\item \label{i:bbdpre_init}
  {\bf Initialize the {\cvbbdpre} preconditioner module}

  Specify the upper and lower half-bandwidths \id{mudq} and \id{mldq}, and
  \id{mukeep} and \id{mlkeep}, and call

   \id{
     \begin{tabular}[t]{@{}r@{}l@{}}
       flag = CVBBDPrecInit(&cvode\_mem, local\_N, mudq, mldq, \\
                            &mukeep, mlkeep, dqrely, gloc, cfn);
     \end{tabular}
   }

   to allocate memory and initialize the internal preconditioner data.
   The last two arguments of \id{CVBBDPrecInit} are the two user-supplied
   functions described above.

\item
  \textcolor{gray}{\bf Set optional inputs}

  Note that the user should not overwrite the preconditioner setup function
  or solve function through calls to the \id{CVodeSetPreconditioner}
  optional input function.

\item
  \textcolor{gray}{\bf Create nonlinear solver object}

\item
  \textcolor{gray}{\bf Attach nonlinear solver module}

\item
  \textcolor{gray}{\bf Set nonlinear solver optional inputs}

\item
  \textcolor{gray}{\bf Specify rootfinding problem}

\item
  \textcolor{gray}{\bf Advance solution in time}

\item
  {\bf Get optional outputs}

  Additional optional outputs associated with {\cvbbdpre} are available by
  way of two routines described below,
  \id{CVBBDPrecGetWorkSpace} and \id{CVBBDPrecGetNumGfnEvals}.

\item
  \textcolor{gray}{\bf Deallocate memory for solution vector}

\item
  \textcolor{gray}{\bf Free solver memory}

\item
  \textcolor{gray}{\bf Free nonlinear solver memory}

\item
  \textcolor{gray}{\bf Free linear solver memory}

\item
  \textcolor{gray}{\bf Finalize MPI}

\end{Steps}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!usage|)}
%%
%%------------------------------------------------------------------------------------
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|(}
%%
The user-callable functions that initialize (step \ref{i:bbdpre_init} above) or re-initialize
the {\cvbbdpre} preconditioner module are described next.
%%
\index{half-bandwidths}
\ucfunctionf{CVBBDPrecInit}
{
   \begin{tabular}[t]{@{}r@{}l@{}}
     flag = CVBBDPrecInit(&cvode\_mem, local\_N, mudq, mldq, \\
                          &mukeep, mlkeep, dqrely, gloc, cfn);
   \end{tabular}
}
{
  The function \ID{CVBBDPrecInit} initializes and allocates (internal)
  memory for the {\cvbbdpre} preconditioner.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[local\_N] (\id{sunindextype})
    local vector length.
  \item[mudq] (\id{sunindextype})
    upper half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[mldq] (\id{sunindextype})
    lower half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[mukeep] (\id{sunindextype})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeep] (\id{sunindextype})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dqrely] (\id{realtype})
    the relative increment in components of \id{y} used in the difference quotient
    approximations.  The default is \id{dqrely}$ = \sqrt{\text{unit roundoff}}$,
    which can be specified by passing \id{dqrely} $= 0.0$.
  \item[gloc] (\id{CVLocalFn})
    the {\CC} function which computes the approximation $g(t,y) \approx f(t,y)$.
  \item[cfn] (\id{CVCommFn})
    the optional {\CC} function which performs all interprocess communication
    required for the computation of $g(t,y)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_ILL\_INPUT]
  \item[\Id{CVLS\_SUCCESS}]
    The call to \id{CVBBDPrecInit} was successful.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer was \id{NULL}.
  \item[\Id{CVLS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{CVLS\_LMEM\_NULL}]
    A {\cvls} linear solver was not attached.
  \item[\Id{CVLS\_ILL\_INPUT}]
    The supplied vector implementation was not compatible with block
    band preconditioner.
  \end{args}
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} to be used in the
  difference quotient calculation of the approximate Jacobian is negative or
  exceeds the value \id{local\_N}$-1$, it is replaced by 0 or
  \id{local\_N}$-1$ accordingly.

  The half-bandwidths \id{mudq} and \id{mldq} need not be the true
  half-bandwidths of the Jacobian of the local block of $g$
  when smaller values may provide a greater efficiency.

  Also, the half-bandwidths \id{mukeep} and \id{mlkeep} of the retained
  banded approximate Jacobian block may be even smaller,
  to reduce storage and computational costs further.

  For all four half-bandwidths, the values need not be the
  same on every processor.
}


The {\cvbbdpre} module also provides a reinitialization function to allow
solving a sequence of problems of the same size, with the same linear solver
choice, provided there is no change in \id{local\_N}, \id{mukeep}, or \id{mlkeep}.
After solving one problem, and after calling \id{CVodeReInit} to
re-initialize {\cvodes} for a subsequent problem, a call to \id{CVBBDPrecReInit}
can be made to change any of the following: the half-bandwidths \id{mudq} and
\id{mldq} used in the difference-quotient Jacobian approximations, the relative
increment \id{dqrely}, or one of the user-supplied functions \id{gloc} and \id{cfn}.
If there is a change in any of the linear solver inputs, an additional call
to the ``Set'' routines provided by the {\sunlinsol} module, and/or
one or more of the corresponding {\cvls} ``set'' functions, must
also be made (in the proper order).

\ucfunctionf{CVBBDPrecReInit}
{
  flag = CVBBDPrecReInit(cvode\_mem, mudq, mldq, dqrely);
}
{
  The function \ID{CVBBDPrecReInit} re-initializes the {\cvbbdpre} preconditioner.
}
{
  \begin{args}[cvode\_mem]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[mudq] (\id{sunindextype})
    upper half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[mldq] (\id{sunindextype})
    lower half-bandwidth to be used in the difference quotient Jacobian approximation.
  \item[dqrely] (\id{realtype})
    the relative increment in components of \id{y} used in the difference quotient
    approximations.  The default is \id{dqrely} $= \sqrt{\text{unit roundoff}}$,
    which can be specified by passing \id{dqrely} $= 0.0$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_PMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The call to \id{CVBBDPrecReInit} was successful.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer was \id{NULL}.
  \item[\Id{CVLS\_LMEM\_NULL}]
    A {\cvls} linear solver memory was not attached.
  \item[\Id{CVLS\_PMEM\_NULL}]
    The function \id{CVBBDPrecInit} was not previously called.
  \end{args}
}
{
  If one of the half-bandwidths \id{mudq} or \id{mldq} is negative or
  exceeds the value \id{local\_N}$-1$, it is replaced by 0 or
  \id{local\_N}$-1$ accordingly.
}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!user-callable functions|)}
%%
%%------------------------------------------------------------------------------------
%%
\index{optional output!band-block-diagonal preconditioner|(}
\index{CVBBDPRE@{\cvbbdpre} preconditioner!optional output|(}
The following two optional output functions are available for use with
the {\cvbbdpre} module:
%%
\ucfunctionf{CVBBDPrecGetWorkSpace}
{
  flag = CVBBDPrecGetWorkSpace(cvode\_mem, \&lenrwBBDP, \&leniwBBDP);
}
{
  The function \ID{CVBBDPrecGetWorkSpace} returns the local
  {\cvbbdpre} real and integer workspace sizes.
}
{
  \begin{args}[lenrwBBDP]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[lenrwBBDP] (\id{long int})
    local number of \id{realtype} values in the {\cvbbdpre} workspace.
  \item[leniwBBDP] (\id{long int})
    local number of integer values in the {\cvbbdpre} workspace.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_PMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer was \id{NULL}.
  \item[\Id{CVLS\_PMEM\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{
  \index{memory requirements!CVBBDPRE@{\cvbbdpre} preconditioner}
  The workspace requirements reported by this routine correspond only
  to memory allocated within the {\cvbbdpre} module (the banded
  matrix approximation, banded {\sunlinsol} object, temporary vectors).
  These values are local to each process.

  The workspaces referred to here exist in addition to those given by the
  corresponding function \id{CVodeGetLinWorkSpace}.
}
%%
%%
\ucfunctionf{CVBBDPrecGetNumGfnEvals}
{
  flag = CVBBDPrecGetNumGfnEvals(cvode\_mem, \&ngevalsBBDP);
}
{
  The function \ID{CVBBDPrecGetNumGfnEvals} returns the
  number of calls made to the user-supplied \id{gloc} function due to the
  finite difference approximation of the Jacobian blocks used within
  the preconditioner setup function.
}
{
  \begin{args}[ngevalsBBDP]
  \item[cvode\_mem] (\id{void *})
    pointer to the {\cvodes} memory block.
  \item[ngevalsBBDP] (\id{long int})
    the number of calls made to the user-supplied \id{gloc} function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[CVLS\_PMEM\_NULL]
  \item[\Id{CVLS\_SUCCESS}]
    The optional output value has been successfully set.
  \item[\Id{CVLS\_MEM\_NULL}]
    The \id{cvode\_mem} pointer was \id{NULL}.
  \item[\Id{CVLS\_PMEM\_NULL}]
    The {\cvbbdpre} preconditioner has not been initialized.
  \end{args}
}
{}
%%
\index{CVBBDPRE@{\cvbbdpre} preconditioner!optional output|)}
\index{optional output!band-block-diagonal preconditioner|)}

In addition to the \id{ngevalsBBDP} \id{gloc} evaluations,
the costs associated with {\cvbbdpre} also include \id{nlinsetups} LU
factorizations, \id{nlinsetups} calls to \id{cfn}, \id{npsolves} banded
backsolve calls, and \id{nfevalsLS} right-hand side function evaluations,
where \id{nlinsetups} is an optional {\cvodes} output and \id{npsolves} and
\id{nfevalsLS} are linear solver optional outputs (see \S\ref{ss:optional_output}).
