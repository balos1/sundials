%===================================================================================
\chapter{Description of the SUNLinearSolver module}\label{s:sunlinsol}
%===================================================================================
\index{SUNLinearSolver@\texttt{SUNLinearSolver} module}
\input{sunlinsol_generic}


%---------------------------------------------------------------------------
\section{IDA SUNLinearSolver interface}
\label{s:sunlinsol_interface}
%---------------------------------------------------------------------------

Table \ref{t:sunlinsoluse} below lists the {\sunlinsol} module linear solver
functions used within the {\idals} interface. As with the {\sunmatrix} module, we
emphasize that the {\ida} user does not need to know detailed usage of linear
solver functions by the {\ida} code modules in order to use {\ida}. The
information is presented as an implementation detail for the interested reader.

The linear solver functions listed below are marked with \cm to
indicate that they are required, or with $\dagger$ to indicate that
they are only called if they are non-\id{NULL} in the {\sunlinsol}
implementation that is being used. Note:
\begin{enumerate}
\item Although {\idals} does not call \id{SUNLinSolLastFlag}
  directly, this routine is available for users to query linear solver
  issues directly.
\item Although {\idals} does not call \id{SUNLinSolFree}
  directly, this routine should be available for users to call when
  cleaning up from a simulation.
\end{enumerate}

\begin{table}[htb]
\centering
\caption{List of linear solver function usage in the {\idals} interface}\label{t:sunlinsoluse}
\medskip
\begin{tabular}{|r|c|c|c|} \hline
                                                    &
\begin{sideways}{DIRECT}             \end{sideways} &
\begin{sideways}{ITERATIVE}          \end{sideways} &
\begin{sideways}{MATRIX\_ITERATIVE}  \end{sideways} \\ \hline\hline
%                                  DIRECT       ITER    & MAT-ITER
\id{SUNLinSolGetType}           &    \cm    &    \cm    &    \cm    \\ \hline
\id{SUNLinSolSetATimes}         & $\dagger$ &    \cm    & $\dagger$ \\ \hline
\id{SUNLinSolSetPreconditioner} & $\dagger$ & $\dagger$ & $\dagger$ \\ \hline
\id{SUNLinSolSetScalingVectors} & $\dagger$ & $\dagger$ & $\dagger$ \\ \hline
\id{SUNLinSolInitialize}        &    \cm    &    \cm    &    \cm    \\ \hline
\id{SUNLinSolSetup}             &    \cm    &    \cm    &    \cm    \\ \hline
\id{SUNLinSolSolve}             &    \cm    &    \cm    &    \cm    \\ \hline
\id{SUNLinSolNumIters}          &           &    \cm    &    \cm    \\ \hline
\id{SUNLinSolResid}             &           &    \cm    &    \cm    \\ \hline
$^1$\id{SUNLinSolLastFlag}      &           &           &           \\ \hline
$^2$\id{SUNLinSolFree}          &           &           &           \\ \hline
\id{SUNLinSolSpace}             & $\dagger$ & $\dagger$ & $\dagger$ \\ \hline
\end{tabular}
\end{table}

Since there are a wide range of potential {\sunlinsol} use cases, the following
subsections describe some details of the {\idals} interface, in the case that
interested users wish to develop custom {\sunlinsol} modules.

%---------------------------------------------------------------------------
\subsection{Lagged matrix information}
\label{ss:sunlinsol_lagged_matrix}
%---------------------------------------------------------------------------

If the {\sunlinsol} object self-identifies as having type
\id{SUNLINEARSOLVER\_DIRECT} or \\ \noindent
\id{SUNLINEARSOLVER\_MATRIX\_ITERATIVE}, then the {\sunlinsol} object solves a
linear system \emph{defined} by a {\sunmatrix} object. {\idals} will update the
matrix information infrequently according to the strategies outlined in
\S\ref{ss:ivp_sol}. To this end, we differentiate between the \emph{desired}
linear system $Mx=b$ and the \emph{actual} linear system $\bar{M}\bar{x} = b$.
Since {\idals} updates the {\sunmatrix} object infrequently, it is
likely that $\alpha\ne\bar{\alpha}$, and in turn $M\ne\bar{M}$.
Therefore, after calling the {\sunlinsol}-provided \id{SUNLinSolSolve}
routine, we test whether $\alpha / \bar{\alpha} \ne 1$, and if this is
the case we scale the solution $\bar{x}$ to correct the linear system
solution $x$ via
\begin{equation}
  \label{eq:rescaling}
  x = \frac{2}{1 + \alpha / \bar{\alpha}} \bar{x}.
\end{equation}
The motivation for this selection of the scaling factor $c = 2/(1 +
\alpha/\bar{\alpha})$ is discussed in detail in \cite{BCP:96,Hin:00}.
In short, if we consider a stationary iteration for the linear system
as consisting of a solve with $\bar{M}$ followed by scaling by $c$,
then for a linear constant-coefficient problem, the error in the
solution vector will be reduced at each iteration by the error matrix
$E = I - c \bar{M}^{-1} M$, with a convergence rate given by the
spectral radius of $E$.  Assuming that stiff systems have a spectrum
spread widely over the left half-plane, $c$ is chosen to minimize the
magnitude of the eigenvalues of $E$.


%---------------------------------------------------------------------------
\subsection{Iterative linear solver tolerance}
\label{ss:sunlinsol_iterative_tolerance}
%---------------------------------------------------------------------------

If the {\sunlinsol} object self-identifies as having type
\id{SUNLINEARSOLVER\_ITERATIVE} or \newline
\id{SUNLINEARSOLVER\_MATRIX\_ITERATIVE} then {\idals} will set the input
tolerance \id{delta} as described in \S\ref{ss:ivp_sol}. However, if the
iterative linear solver does not support scaling matrices (i.e., the \newline
\id{SUNLinSolSetScalingVectors} routine is \id{NULL}), then {\idals} will attempt
to adjust the linear solver tolerance to account for this lack of functionality.
To this end, the following assumptions are made:
\begin{enumerate}
\item All solution components have similar magnitude; hence the error
  weight vector $W$ used in the WRMS norm (see \S\ref{ss:ivp_sol})
  should satisfy the assumption
  \[
    W_i \approx W_{mean},\quad \text{for}\quad i=0,\ldots,n-1.
  \]
\item The {\sunlinsol} object uses a standard 2-norm to measure
  convergence.
\end{enumerate}

Since {\ida} uses identical left and right scaling matrices,
$S_1 = S_2 = S = \operatorname{diag}(W)$, then the linear
solver convergence requirement is converted as follows
(using the notation from equations
\eqref{eq:transformed_linear_system}-\eqref{eq:transformed_linear_system_components}):
\begin{align*}
  &\left\| \tilde{b} - \tilde{A} \tilde{x} \right\|_2  <  \text{tol}\\
  \Leftrightarrow \quad & \left\| S P_1^{-1} b - S P_1^{-1} A x \right\|_2  <  \text{tol}\\
  \Leftrightarrow \quad & \sum_{i=0}^{n-1} \left[W_i \left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \text{tol}^2\\
  \Leftrightarrow \quad & W_{mean}^2 \sum_{i=0}^{n-1} \left[\left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \text{tol}^2\\
  \Leftrightarrow \quad & \sum_{i=0}^{n-1} \left[\left(P_1^{-1} (b - A x)\right)_i\right]^2  <  \left(\frac{\text{tol}}{W_{mean}}\right)^2\\
  \Leftrightarrow \quad & \left\| P_1^{-1} (b - A x)\right\|_2  <  \frac{\text{tol}}{W_{mean}}
\end{align*}
Therefore the tolerance scaling factor
\[
  W_{mean} = \|W\|_2 / \sqrt{n}
\]
is computed and the scaled tolerance \id{delta}$= \text{tol} / W_{mean}$ is
supplied to the {\sunlinsol} object.

%---------------------------------------------------------------------------
% sunlinsol module sections
%---------------------------------------------------------------------------

\input{sunlinsol_dense}
\input{sunlinsol_band}
\input{sunlinsol_lapackdense}
\input{sunlinsol_lapackband}
\input{sunlinsol_klu}
\input{sunlinsol_superludist}
\input{sunlinsol_superlumt}
\input{sunlinsol_cusolversp}
\input{sunlinsol_magmadense}
\input{sunlinsol_spgmr}
\input{sunlinsol_spfgmr}
\input{sunlinsol_spbcgs}
\input{sunlinsol_sptfqmr}
\input{sunlinsol_pcg}
\input{sunlinsol_examples}
