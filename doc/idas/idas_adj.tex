%===================================================================================
\chapter{Using IDAS for Adjoint Sensitivity Analysis}\label{s:adjoint}
%===================================================================================

This chapter describes the use of {\idas} to compute sensitivities of derived 
functions using adjoint sensitivity analysis. As mentioned before, the adjoint
sensitivity module of {\idas} provides the infrastructure for integrating
backward in time any system of DAEs that depends on the solution of the original
IVP, by providing various interfaces to the main {\idas} integrator, as well 
as several supporting user-callable functions. For this reason, in the following
sections we refer to the {\em backward problem} and not to the 
{\em adjoint problem} when discussing details relevant to the DAEs that
are integrated backward in  time. The backward problem can be the adjoint problem
(\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}), and
can be augmented with some quadrature differential equations.

{\idas} uses various constants for both input and output.  These are
defined as needed in this chapter, but for convenience are also listed
separately in Appendix \ref{c:constants}.

We begin with a brief overview, in the form of a skeleton user program.
Following that are detailed descriptions of the interface to the
various user-callable functions and of the user-supplied functions that were
not already described in Chapter \ref{s:simulation}.

%%
%%----------------------------------------------------------------------
%%----------------------------------------------------------------------
\section{A skeleton of the user's main program}\label{ss:skeleton_adj}
%%---------------------------------------------------------------------
%%----------------------------------------------------------------------
%%
The following is a skeleton of the user's main program as an application of
{\idas}. The user program is to have these steps in the order indicated, 
unless otherwise noted. For the sake of brevity, we defer many of the details
to the later sections.
As in \S\ref{ss:skeleton_sim}, most steps are independent of
the {\nvector}, {\sunmatrix}, {\sunlinsol}, and {\sunnonlinsol} 
implementations used. For the steps that are not, refer to Chapters
\ref{s:nvector}, \ref{s:sunmatrix}, \ref{s:sunlinsol}, and \ref{c:sunnonlinsol}
for the specific name of the function to be called or macro to be referenced.

Steps that are unchanged from the skeleton programs presented in
\S\ref{ss:skeleton_sim}, \S\ref{s:forward_usage}, and
\S\ref{s:forward_quad_usage}, are grayed out.

\index{User main program!Adjoint sensitivity analysis}
\begin{Steps}

\item
  \textcolor{gray}{\bf Include necessary header files}
  
  The \id{idas.h} header file also defines additional types, constants, and
  function prototypes for the adjoint sensitivity module user-callable functions.
  In addition, the main program should include an {\nvector} implementation
  header file (for the particular implementation used) and, if a nonlinear
  solver requiring a linear solver (e.g., the default Newton iteration) will be
  used, the header file of the desired linear solver module.

\item
  \textcolor{gray}{\bf Initialize parallel or multi-threaded environment}

  \vspace{0.2in}\centerline{\bf Forward problem}

\item
  \textcolor{gray}{\bf Set problem dimensions etc. for the forward problem}

\item
  \textcolor{gray}{\bf Set initial conditions for the forward problem}

\item
  \textcolor{gray}{\bf Create {\idas} object for the forward problem}

\item
  \textcolor{gray}{\bf Initialize {\idas} solver for the forward problem}

\item
  \textcolor{gray}{\bf Specify integration tolerances for forward problem}

\item
  \textcolor{gray}{\bf Set optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Create matrix object for the forward problem}

\item
  \textcolor{gray}{\bf Create linear solver object for the forward problem}

\item
  \textcolor{gray}{\bf Set linear solver optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Attach linear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Create nonlinear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Attach nonlinear solver module for the forward problem}

\item
  \textcolor{gray}{\bf Set nonlinear solver optional inputs for the forward problem}

\item
  \textcolor{gray}{\bf Initialize quadrature problem or problems for forward
   problems, using \id{IDAQuadInit} and/or \id{IDAQuadSensInit}.}

\item
  \textcolor{gray}{\bf Initialize forward sensitivity problem}

\item
  \textcolor{gray}{\bf Specify rootfinding}

\item
  {\bf Allocate space for the adjoint computation}

  Call \Id{IDAAdjInit}\id{()} to allocate memory for the 
  combined forward-backward problem (see \S\ref{sss:idaadjinit} for details).
  This call requires \id{Nd}, the number of steps between two consecutive checkpoints.
  \Id{IDAAdjInit} also specifies the type of interpolation used 
  (see \S\ref{ss:checkpointing}).

\item
  {\bf Integrate forward problem}

  Call \Id{IDASolveF}, a wrapper for the {\idas} main integration
  function \id{IDASolve}, either in \Id{IDA\_NORMAL} mode to the time 
  \id{tout} or in \Id{IDA\_ONE\_STEP} mode inside a loop (if intermediate
  solutions of the forward problem are desired (see \S\ref{sss:idasolvef})).
  The final value of \id{tret} is then the maximum allowable value for
  the endpoint $T$ of the backward problem.

  \vspace{0.2in}\centerline{\bf Backward problem(s)}

 \item \label{i:back_start}
   {\bf Set problem dimensions etc. for the backward problem}
   
   This generally includes \id{NB}, the number of variables in the backward problem
   and possibly the local vector length \id{NBlocal}.

\item
  {\bf Set initial values for the backward problem}

  Set the endpoint time \id{tB0} $= T$, and set the corresponding vectors \id{yB0}
  and \id{ypB0} at which the backward problem starts.

\item
  {\bf Create the backward problem}

  Call \Id{IDACreateB}, a wrapper for \id{IDACreate}, to create the
  {\idas} memory block for the new backward problem. Unlike \id{IDACreate}, 
  the function \id{IDACreateB} does not return a pointer to the newly created 
  memory block (see \S\ref{sss:idainitb}). Instead, this pointer is attached to 
  the internal adjoint memory  block (created by \id{IDAAdjInit}) and returns an
  identifier called \id{which} that the user must later specify in any actions on
  the newly created backward problem.

\item
  {\bf Allocate memory for the backward problem}

  Call \Id{IDAInitB} (or \Id{IDAInitBS}, when the backward problem depends on the
  forward sensitivities). The two functions are actually wrappers for \id{IDAInit} 
  and allocate internal memory, specify problem data, and initialize {\idas} 
  at \id{tB0} for the backward problem (see \S\ref{sss:idainitb}).

\item 
  {\bf Specify integration tolerances for backward problem}
  
  Call \id{IDASStolerancesB}\id{(...)} or \id{IDASVtolerancesB}\id{(...)}
  to specify a scalar relative tolerance and scalar absolute tolerance, or a
  scalar relative tolerance and a vector of absolute tolerances, respectively.
  The functions are wrappers for \id{IDASStolerances}\id{(...)} and
  \id{IDASVtolerances}\id{(...)} but they require an extra argument \id{which},
  the identifier of the backward problem returned by \id{IDACreateB}.
  See \S\ref{sss:idatolerances_b} for more information.


\item
  {\bf Set optional inputs for the backward problem}

  Call \id{IDASet*B} functions to change from their default values
  any optional inputs that control the behavior of {\idas}. Unlike
  their counterparts for the forward problem, these functions take an
  extra argument \id{which}, the identifier of the backward problem returned 
  by \id{IDACreateB} (see \S\ref{ss:optional_input_b}).


\item \label{i:matrixB}
  {\bf Create matrix object for the backward problem}

  If a nonlinear solver requiring a linear solve will be used (e.g., the
  the default Newton iteration) and the linear solver will be a direct linear
  solver, then a template Jacobian matrix must be created by calling the
  appropriate constructor function defined by the particular {\sunmatrix}
  implementation.
  
  NOTE: The dense, banded, and sparse matrix objects are usable only in a
  serial or threaded environment.

  Note also that it is not required to use the same matrix type for both the forward 
  and the backward problems. 

\item \label{i:lin_solverB}
  {\bf Create linear solver object for the backward problem}

  If a nonlinear solver requiring a linear solver is chosen (e.g., the default
  Newton iteration), then the desired linear solver object for the backward
  problem must be created by calling the appropriate constructor function
  defined by the particular {\sunlinsol} implementation.
  
  Note that it is not required to use the same linear solver module for both the forward 
  and the backward problems; for example, the forward problem could be solved
  with the {\sunlinsoldense} linear solver module and the backward
  problem with {\sunlinsolspgmr} linear solver module. 

\item
  {\bf Set linear solver interface optional inputs for the backward problem}

  Call \id{IDASet*B} functions to change optional inputs specific to
  the linear solver interface. See \S\ref{ss:optional_input_b} for details.

\item\label{i:lin_solver_interfaceB}
  {\bf Attach linear solver module for the backward problem}

  If a nonlinear solver requiring a linear solver is chosen for the backward
  problem (e.g., the default Newton iteration), then initialize the
  {\idals} linear solver interface by attaching the linear solver
  object (and matrix object, if applicable) with the following call (for details see
  \S\ref{sss:lin_solv_init}):

  \id{ier = }\Id{IDASetLinearSolverB}\id{(...);}

\item
  {\bf Create nonlinear solver object for the backward problem} (\textit{optional})

  If using a non-default nonlinear solver for the backward problem, then create
  the desired nonlinear solver object by calling the appropriate constructor
  function defined by the particular {\sunnonlinsol} implementation e.g.,
  \id{NLSB = SUNNonlinSol\_***(...);} where \id{***} is the name of the
  nonlinear solver (see Chapter \ref{c:sunnonlinsol} for details).

\item
  {\bf Attach nonlinear solver module for the backward problem} (\textit{optional})

  If using a non-default nonlinear solver for the backward problem, then
  initialize the nonlinear solver interface by attaching the nonlinear solver
  object by calling \\ \noindent
  \id{ier = }\Id{IDASetNonlinearSolverB}\id{(idaode\_mem, NLSB);}
  (see \S\ref{sss:nonlin_solv_init} for details).

\item \label{i:quadB}
  {\bf Initialize quadrature calculation}

  If additional quadrature equations must be evaluated, 
  call \id{IDAQuadInitB} or \id{IDAQuadInitBS} (if quadrature depends also on the
  forward sensitivities) as shown in \S\ref{sss:idaquadinitb}. These functions are
  wrappers around \id{IDAQuadInit} and can be used to initialize and allocate 
  memory for quadrature integration. Optionally, call \id{IDASetQuad*B} functions 
  to change from their default values optional inputs that control the integration 
  of quadratures during the backward phase.

\item
  {\bf Integrate backward problem}

  Call \Id{IDASolveB}, a second wrapper around the {\idas} main integration
  function \id{IDASolve}, to integrate the backward problem from \id{tB0}
  (see \S\ref{sss:idasolveb}). This function can be called either in \id{IDA\_NORMAL}
  or \id{IDA\_ONE\_STEP} mode. Typically, \id{IDASolveB} will be called in \id{IDA\_NORMAL}
  mode with an end time equal to the initial time $t_0$ of the forward problem.

\item \label{i:back_end}
  {\bf Extract quadrature variables}

  If applicable, call \Id{IDAGetQuadB}, a wrapper around \id{IDAGetQuad},
  to extract the values of the quadrature variables at the time returned
  by the last call to \id{IDASolveB}.  See \S\ref{sss:quad_get_b}.

\item
  {\bf Deallocate memory}

  Upon completion of the backward integration, call all necessary deallocation
  functions. These include appropriate destructors for the vectors \id{y} and
  \id{yB}, a call to \id{IDAFree} to free the {\idas} memory block for the
  forward problem.  If one or more additional adjoint sensitivity analyses are to
  be done for this problem, a call to \id{IDAAdjFree} (see \S\ref{sss:idaadjinit})
  may be made to free and deallocate the memory allocated for the backward problems,
  followed by a call to \id{IDAAdjInit}.

\item
  {\bf Free the nonlinear solver memory for the forward and backward problems}

\item
  {\bf Free linear solver and matrix memory for the forward and backward problems}

\item
  \textcolor{gray}{\bf Finalize MPI, if used}

\end{Steps}

The above user interface to the adjoint sensitivity module in {\idas} was motivated by
the desire to keep it as close as possible in look and feel to the one for DAE IVP 
integration. Note that if steps (\ref{i:back_start})-(\ref{i:back_end}) are not present, 
a program with the above structure will have the same functionality as one described in
\S\ref{ss:skeleton_sim} for integration of DAEs, albeit with some overhead due to 
the checkpointing scheme.

If there are multiple backward problems associated with the same forward problem,
repeat steps (\ref{i:back_start})-(\ref{i:back_end}) above for each successive
backward problem.  In the process, each call to \id{IDACreateB} creates a new
value of the identifier \id{which}.

%%
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
\section{User-callable functions for adjoint sensitivity analysis}
%%-------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------
%%

%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity allocation and deallocation functions}
\label{sss:idaadjinit}
%%-------------------------------------------------------------------------------

After the setup phase for the forward problem, but before the call
to \id{IDASolveF}, memory for the combined forward-backward problem must be
allocated by a call to the function \id{IDAAdjInit}.
The form of the call to this function is
%%
%%
\ucfunctionf{IDAAdjInit}
{
  flag = IDAAdjInit(ida\_mem, Nd, interpType);
}
{
  The function \ID{IDAAdjInit} updates {\idas} memory block by allocating 
  the internal memory needed for backward integration.
  Space is allocated for the \id{Nd} $= N_d$ interpolation data points, and
  a linked list of checkpoints is initialized.
}
{
  \begin{args}[interpType]
  \item[ida\_mem] (\id{void *}) 
    is the pointer to the {\idas} memory block returned by a previous call
    to \id{IDACreate}.
  \item[Nd] (\id{long int}) 
    is the number of integration steps between two consecutive checkpoints.
  \item[interpType] (\id{int})
    specifies the type of interpolation used and can be \Id{IDA\_POLYNOMIAL}
    or \Id{IDA\_HERMITE}, indicating variable-degree polynomial and cubic Hermite
    interpolation, respectively (see \S\ref{ss:checkpointing}).
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[IDA\_ILL\_INPUT]
   \item[\Id{IDA\_SUCCESS}] 
     \id{IDAAdjInit} was successful.
   \item[\Id{IDA\_MEM\_FAIL}]
     A memory allocation request has failed.
   \item[IDA\_MEM\_NULL] 
     \id{ida\_mem} was NULL.
   \item[\Id{IDA\_ILL\_INPUT}]
     One of the parameters was invalid: \id{Nd} was not positive or \id{interpType}
     is not one of the \id{IDA\_POLYNOMIAL} or \id{IDA\_HERMITE}.
   \end{args}
}
{
  The user must set \id{Nd} so that all data needed for interpolation of the 
  forward problem solution between two checkpoints fits in memory. \id{IDAAdjInit}
  attempts to allocate space for $(2$\id{Nd}$+3)$ variables of type \id{N\_Vector}.

  If an error occurred, \id{IDAAdjInit} also sends a message to the
  error handler function.
}
%%
%%
\ucfunctionf{IDAAdjReInit}
{
  flag = IDAAdjReInit(ida\_mem);
}
{
  The function \ID{IDAAdjReInit} reinitializes the {\idas} memory
  block for ASA, assuming that the number of steps between check
  points and the type of interpolation remain unchanged.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    is the pointer to the {\idas} memory block returned by a previous call to
    \id{IDACreate}.
  \end{args}
}
{
   The return value \id{flag} (of type \id{int}) is one of:
   \begin{args}[IDA\_MEM\_NULL]
   \item[\Id{IDA\_SUCCESS}] 
     \id{IDAAdjReInit} was successful.
   \item[IDA\_MEM\_NULL] 
     \id{ida\_mem} was NULL.
   \item[\Id{IDA\_NO\_ADJ}]
     The function \id{IDAAdjInit} was not previously called.
   \end{args}
}
{
  The list of check points (and associated memory) is deleted.

  The list of backward problems is kept. However, new backward problems can 
  be added to this list by calling \id{IDACreateB}. If a new list of backward
  problems is also needed, then free the adjoint memory (by calling
  \id{IDAAdjFree}) and reinitialize ASA with \id{IDAAdjInit}.

  The {\idas} memory for the forward and backward problems can be reinitialized
  separately by calling \id{IDAReInit} and \id{IDAReInitB}, respectively.
}



%%
%%
\ucfunctionf{IDAAdjFree}
{
  IDAAdjFree(ida\_mem);
}
{
  The function \ID{IDAAdjFree} frees the memory related to backward integration
  allocated by a previous call to \id{IDAAdjInit}.
}
{
  The only argument is the {\idas} memory block pointer returned by a previous call 
  to \id{IDACreate}.
}
{
  The function \id{IDAAdjFree} has no return value.
}
{
  This function frees all memory allocated by \id{IDAAdjInit}. This
  includes workspace memory, the linked list of checkpoints, memory
  for the interpolation data, as well as the {\idas} memory for the
  backward integration phase.

  Unless one or more further calls to \id{IDAAdjInit} are to be made,
  \id{IDAAdjFree} should not be called by the user, as it is invoked
  automatically by \id{IDAFree}.
}
%%
%%


%%-------------------------------------------------------------------------------
\subsection{Adjoint sensitivity optional input}

At any time during the integration of the forward problem, the user
can disable the checkpointing of the forward sensitivities by calling
the following function:

\ucfunctionf{IDAAdjSetNoSensi}
{
  flag = IDAAdjSetNoSensi(ida\_mem);
}
{
  The function \ID{IDAAdjSetNoSensi} instructs \id{IDASolveF} not
  to save checkpointing data for forward sensitivities any more.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas}  memory block.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDA\_MEM\_FAIL]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDACreateB} was successful.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \end{args}
}
{}
%%-------------------------------------------------------------------------------


%%---------------------------------------------------------------------
\subsection{Forward integration function}
\label{sss:idasolvef}
%%---------------------------------------------------------------------

The function \ID{IDASolveF} is very similar to the {\idas} function \id{IDASolve}
(see \S\ref{sss:idasolve}) in that it integrates the solution of the forward
problem and returns the solution $(y,\dot{y})$. At the same time, however, 
\id{IDASolveF} stores checkpoint data every \id{Nd} integration steps.
\id{IDASolveF} can be called repeatedly by the user.
%%
Note that \id{IDASolveF} is used only for the forward integration pass within
an Adjoint Sensitivity Analysis.  It is not for use in Forward Sensitivity
Analysis; for that, see Chapter \ref{s:forward}.
%%
The call to this function has the form
%%
\ucfunctionf{IDASolveF}
{
  flag = IDASolveF(ida\_mem, tout, \&tret, yret, ypret, itask, \&ncheck);
}
{
  The function \ID{IDASolveF} integrates the forward problem over an interval in $t$
  and saves checkpointing data.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[tout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yret] (\id{N\_Vector})
    the computed solution vector $y$.
  \item[ypret] (\id{N\_Vector})
    the computed solution vector $\dot{y}$.
  \item[itask] (\id{int})
    \index{itask@\texttt{itask}}
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{IDA\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user-specified \id{tout}
    parameter. The solver then interpolates in order to   
    return an approximate value of $y($\id{tout}$)$ and $\dot{y}($\id{tout}$)$. 
    The \Id{IDA\_ONE\_STEP} option tells the solver to take just one internal step  
    and return the solution at the point reached by that step. 
  \item[ncheck] (\id{int})
    the number of (internal) checkpoints stored so far.
  \end{args}
}
{
  On return, \id{IDASolveF} returns vectors \id{yret}, \id{ypret} and a corresponding 
  independent variable value $t =$ \id{tret}, such that \id{yret} is the computed 
  value of $y(t)$ and \id{ypret} the value of $\dot{y}(t)$. Additionally, it returns 
  in \id{ncheck} the number of internal checkpoints saved; the total number of
  checkpoint intervals is \id{ncheck}$ + 1$.
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:idasolve}.
  \begin{args}[IDA\_TOO\_MUCH\_WORK]
  \item[\Id{IDA\_SUCCESS}]
    \id{IDASolveF} succeeded.
  \item[\Id{IDA\_TSTOP\_RETURN}]
    \id{IDASolveF} succeeded by reaching the optional stopping point.
  \item[\Id{IDA\_ROOT\_RETURN}]
    \id{IDASolveF} succeeded and found one or more roots.  In this case,
    \id{tret} is the location of the root.  If \id{nrtfn} $>1$, call
    \id{IDAGetRootInfo} to see which $g_i$ were found to have a root.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}]
    One of the inputs to \id{IDASolveF} is illegal.
  \item[\Id{IDA\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tout}. 
  \item[\Id{IDA\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{IDA\_ERR\_FAILURE}]
    Error test failures occurred too many times during one 
    internal time step or occurred with $|h| = h_{min}$.
  \item[\Id{IDA\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during 
    one internal time step or occurred with $|h| = h_{min}$.             
  \item[\Id{IDA\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{IDA\_LSOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{IDA\_NO\_ADJ}]
     The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}]
    A memory allocation request has failed (in an attempt to allocate space
    for a new checkpoint).
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{IDASolveF} failures.

  At this time, \id{IDASolveF} stores checkpoint information in memory
  only. Future versions will provide for a safeguard option of dumping checkpoint
  data into a temporary file as needed. The data stored at each checkpoint is basically
  a snapshot of the {\idas} internal memory block and contains enough information
  to restart the integration from that time and to proceed with the same step size and
  method order sequence as during the forward integration.
  
  In addition, \id{IDASolveF} also stores interpolation data between consecutive checkpoints
  so that, at the end of this first forward integration phase, interpolation information
  is already available from the last checkpoint forward. In particular,
  if no checkpoints were necessary, there is no need for the second forward integration phase.

  {\warn}It is illegal to change the integration tolerances between consecutive calls
  to \id{IDASolveF}, as this information is not captured in the checkpoint data.
}  

%%---------------------------------------------------------------------
\subsection{Backward problem initialization functions}
\label{sss:idainitb}
%%---------------------------------------------------------------------

The functions \id{IDACreateB} and \id{IDAInitB} (or \id{IDAInitBS}) must be 
called in the order listed. They instantiate an {\idas} solver object, provide problem 
and solution specifications, and allocate internal memory for the backward problem.
%%
%%
\ucfunctionf{IDACreateB}
{
  flag = IDACreateB(ida\_mem, \&which);
}
{
  The function \ID{IDACreateB} instantiates an {\idas} solver object for the
  backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    contains the identifier assigned by {\idas} for the newly created backward 
    problem. Any call to \id{IDA*B} functions requires such an identifier.
  \end{args}
}
{
   The return \id{flag} (of type \id{int}) is one of:
   \begin{args}[IDA\_MEM\_FAIL]
   \item[\Id{IDA\_SUCCESS}]
     The call to \id{IDACreateB} was successful.
   \item[\Id{IDA\_MEM\_NULL}]
     The \id{ida\_mem} was \id{NULL}.
   \item[\Id{IDA\_NO\_ADJ}]
     The function \id{IDAAdjInit} has not been previously called.
   \item[\Id{IDA\_MEM\_FAIL}]
     A memory allocation request has failed.
   \end{args}
}
{}

There are two initialization functions for the backward problem -- one for
the case when the backward problem does not depend on the forward
sensitivities, and one for the case when it does.  These two functions
are described next.

The function \id{IDAInitB} initializes the backward problem when it does not
depend on the forward sensitivities.  It is essentially wrapper for \id{IDAInit}
with some particularization for backward integration, as described below.

\ucfunctionf{IDAInitB}
{
  flag = IDAInitB(ida\_mem, which, resB, tB0, yB0, ypB0);
}
{
  The function \ID{IDAInitB} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[resB] (\Id{IDAResFnB})
    is the {\CC} function which computes $fB$, the residual of the 
    backward DAE problem. This function has the form 
    \id{resB(t, y, yp, yB, ypB, resvalB, user\_dataB)} (for full details see
    \S\ref{ss:DAEres_b}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the backward
    problem, normally equal to the endpoint of the forward integration.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution.
  \item[ypB0] (\id{N\_Vector})
    is the initial derivative value (at $t =$ \id{tB0}) of the backward solution.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAInitB} was successful.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or one
    of \id{yB0}, \id{ypB0}, \id{resB} was \id{NULL}.
  \end{args}
}
{
  The memory allocated by \id{IDAInitB} is deallocated by the function 
  \id{IDAAdjFree}.
}

For the case when backward problem also depends on the forward sensitivities, user
must call \id{IDAInitBS} instead of \id{IDAInitB}. Only the third argument of each
function differs between these functions.

\ucfunctionf{IDAInitBS}
{
  flag = IDAInitBS(ida\_mem, which, resBS, tB0, yB0, ypB0);
}
{
  The function \ID{IDAInitBS} provides problem specification, allocates internal memory, 
  and initializes the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[resBS] (\Id{IDAResFnBS})
    is the {\CC} function which computes $fB$, the residual or the 
    backward DAE problem. This function has the form 
    \id{resBS(t, y, yp, yS, ypS, yB, ypB, resvalB, user\_dataB)} 
    (for full details see \S\ref{ss:DAEres_bs}).
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution. 
  \item[ypB0] (\id{N\_Vector})
    is the initial derivative value (at $t =$ \id{tB0}) of the backward solution. 
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAInitB} was successful.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_BAD\_TB0}]
    The final time \id{tB0} was outside the interval over which the forward problem
    was solved.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or one
    of \id{yB0}, \id{ypB0}, \id{resB} was \id{NULL}, or sensitivities were not
    active during the forward integration.
  \end{args}
}
{
  The memory allocated by \id{IDAInitBS} is deallocated by the function 
  \id{IDAAdjFree}.
  
}

The function \id{IDAReInitB} reinitializes {\idas} for the solution of a series
of backward problems, each identified by a value of the parameter \id{which}.
\id{IDAReInitB} is essentially a wrapper for \id{IDAReInit}, and so all details
given for \id{IDAReInit} in \S\ref{sss:idareinit} apply here.\index{reinitialization}
Also, \id{IDAReInitB} can be called to reinitialize a backward problem even if it
has been initialized with the sensitivity-dependent version \id{IDAInitBS}.
Before calling \id{IDAReInitB} for a new backward problem, call any
desired solution extraction functions \id{IDAGet**} associated with the
previous backward problem.
The call to the \id{IDAReInitB} function has the form
%%
%%
\ucfunctionf{IDAReInitB}
{
  flag = IDAReInitB(ida\_mem, which, tB0, yB0, ypB0)
}
{
  The function \ID{IDAReInitB} reinitializes an {\idas} backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[tB0] (\id{realtype})
    specifies the endpoint $T$ where final conditions are provided for the 
    backward problem.
  \item[yB0] (\id{N\_Vector})
    is the initial value (at $t =$ \id{tB0}) of the backward solution. 
  \item[ypB0] (\id{N\_Vector})
    is the initial derivative value (at $t =$ \id{tB0}) of the backward solution. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAReInitB} was successful.
  \item[\Id{IDA\_NO\_MALLOC}]
    The function \id{IDAInit} has not been previously called.
  \item[\Id{IDA\_MEM\_NULL}] 
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_BAD\_TB0}]
    The final time \id{tB0} is outside the interval over which the forward problem
    was solved.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier, or one
    of \id{yB0}, \id{ypB0} was \id{NULL}.
  \end{args}
}
{}

%%
%%==============================================================================
\subsection{Tolerance specification functions for backward problem}
\label{sss:idatolerances_b}
%%==============================================================================
%%
One of the following two functions must be called to specify the integration 
tolerances for the backward problem. Note that this call must be made after the 
call to \id{IDAInitB} or \id{IDAInitBS}.
%%
\ucfunctionf{IDASStolerancesB}
{
  flag = IDASStolerances(ida\_mem, which, reltolB, abstolB);
}
{
  The function \ID{IDASStolerancesB} specifies scalar relative and absolute
  tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltolB] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstolB] (\id{realtype})
    is the scalar absolute error tolerance.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDASStolerancesB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    The allocation function \id{IDAInit} has not been called.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}] 
    One of the input tolerances was negative.
  \end{args}
}
{}
%%
%%
\ucfunctionf{IDASVtolerancesB}
{
  flag = IDASVtolerancesB(ida\_mem, which, reltolB, abstolB);
}
{
  The function \ID{IDASVtolerancesB} specifies scalar relative tolerance and
  vector absolute tolerances.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[reltol] (\id{realtype})
    is the scalar relative error tolerance.
  \item[abstol] (\id{N\_Vector})
    is the vector of absolute error tolerances.
  \end{args}
}
{
  The return \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDASVtolerancesB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    The {\idas} memory block was not initialized through a previous call to
    \id{IDACreate}.
  \item[\Id{IDA\_NO\_MALLOC}] 
    The allocation function \id{IDAInit} has not been called.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}] 
    The relative error tolerance was negative or the absolute tolerance
    had a negative component.
  \end{args}
}
{
  This choice of tolerances is important when the absolute error tolerance needs to
  be different for each component of the DAE state vector $y$.
}
%%

%%---------------------------------------------------------------------
\subsection{Linear solver initialization functions for backward problem}
\label{sss:lin_solv_b}
%%---------------------------------------------------------------------

\index{IDAS@{\idas} linear solvers!usage with adjoint module|(}
All {\idas} linear solver modules available for forward problems
are available for the backward problem.  They should be created as 
for the forward problem then attached to the memory structure for the backward
problem using the following function.

\index{IDAS@{\idas} linear solver interface!IDALS@{\idals}}
\ucfunctionf{IDASetLinearSolverB}
{
  flag = IDASetLinearSolverB(ida\_mem, which, LS, A);
}
{
  The function \ID{IDASetLinearSolverB} attaches a generic
  {\sunlinsol} object \id{LS} and corresponding template
  Jacobian {\sunmatrix} object \id{A} (if applicable) to {\idas},
  initializing the {\idals} linear solver interface for solution of
  the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    represents the identifier of the backward problem returned by \id{IDACreateB}.
  \item[LS] (\id{SUNLinearSolver})
    {\sunlinsol} object to use for solving linear systems for the backward problem. 
  \item[A] (\id{SUNMatrix})
    {\sunmatrix} object for used as a template for the Jacobian for the backward
    problem (or \id{NULL} if not applicable).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}
  \item[\Id{IDALS\_SUCCESS}] 
    The {\idals} initialization was successful.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The {\idals} interface is not compatible with the \id{LS} or
    \id{A} input objects or is incompatible with the current
    {\nvector} module.
  \item[\Id{IDALS\_MEM\_FAIL}]
    A memory allocation request failed.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  If \id{LS} is a matrix-based linear solver, then the template
  Jacobian matrix \id{A} will be used in the solve process, so if
  additional storage is required within the {\sunmatrix} object
  (e.g. for factorization of a banded matrix), ensure that the input
  object is allocated with sufficient size (see the documentation of
  the particular {\sunmatrix} type in Chapter \ref{s:sunmatrix} for
  further information).

  The previous routines \Id{IDADlsSetLinearSolverB} and
  \Id{IDASpilsSetLinearSolverB} are now wrappers for this routine, and may
  still be used for backward-compatibility.  However, these will be
  deprecated in future releases, so we recommend that users transition
  to the new routine name soon.
}
%%
%%

%%---------------------------------------------------------------------
\subsection{Initial condition calculation functions for backward problem}
\label{sss:idacalcicB}
%%---------------------------------------------------------------------

{\idas} provides support for calculation of consistent initial 
conditions for certain backward index-one problems of semi-implicit form through
the functions \Id{IDACalcICB} and \Id{IDACalcICBS}. Calling them is 
optional. It is only necessary when the initial conditions do not satisfy
the adjoint system. 

The above functions provide the same functionality for backward problems as 
\id{IDACalcIC} with parameter \id{icopt} =  \id{IDA\_YA\_YDP\_INIT} 
provides for forward problems (see \S\ref{ss:idacalcic}): compute the 
algebraic components of $yB$ and differential  components of $\dot{y}B$, given 
the differential components of $yB$.  They require that the \id{IDASetIdB}
was previously called to specify the differential and algebraic components.


Both functions require forward solutions at the final time \id{tB0}.
\id{IDACalcICBS} also needs forward sensitivities at the final time \id{tB0}.

\ucfunctionf{IDACalcICB}
{
  flag = IDACalcICB(ida\_mem, which, tBout1, N\_Vector yfin, N\_Vector ypfin);
}
{
  The function \ID{IDACalcICB} corrects the initial values \id{yB0} and \id{ypB0} at
  time \id{tB0} for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    is the identifier of the backward problem.
  \item[tBout1] (\id{realtype})
    is the first value of $t$ at which a solution will be requested (from
    \id{IDASolveB}). This value is needed here only to determine the direction of
    integration and rough scale in the independent variable $t$.   
  \item[yfin] (\id{N\_Vector})
    the forward solution at the final time \id{tB0}.
  \item[ypfin] (\id{N\_Vector})
    the forward solution derivative at the final time \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) can be any that is returned by 
  \id{IDACalcIC} (see \S\ref{ss:idacalcic}). However \id{IDACalcICB} can also 
  return one of the following:

  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_NO\_ADJ}]
    \id{IDAAdjInit} has not been previously called.
  \item[\id{IDA\_ILL\_INPUT}]
    Parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  All failure return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{IDACalcICB} failures.

  Note that \id{IDACalcICB} will correct the values of $yB(tB_0)$ and 
  $\dot{y}B(tB_0)$ which were specified in the previous call to \id{IDAInitB} 
  or \id{IDAReInitB}. To obtain the corrected values, call 
  \id{IDAGetconsistentICB} (see \S\ref{sss:optout_iccalcB}).
}

In the case where the backward problem also depends on the forward sensitivities, 
user must call the following function to correct the initial conditions:

\ucfunctionf{IDACalcICBS}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
  flag = IDACalcICBS(&ida\_mem, which, tBout1, N\_Vector yfin, N\_Vector ypfin, \\
                     &N\_Vector ySfin, N\_Vector ypSfin);
  \end{tabular}
}
{
  The function \ID{IDACalcICBS} corrects the initial values \id{yB0} and \id{ypB0} at
  time \id{tB0} for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    is the identifier of the backward problem.
  \item[tBout1] (\id{realtype})
    is the first value of $t$ at which a solution will be requested (from
    \id{IDASolveB}).This value is needed here only to determine the direction of
    integration and rough scale in the independent variable $t$.   
  \item[yfin] (\id{N\_Vector})
    the forward solution at the final time \id{tB0}.
  \item[ypfin] (\id{N\_Vector})
    the forward solution derivative at the final time \id{tB0}.
  \item[ySfin]  (\id{N\_Vector *})
    a pointer to an array of \id{Ns} vectors containing the sensitivities of
    the forward solution at the final time \id{tB0}.
  \item[ypSfin]  (\id{N\_Vector *})
    a pointer to an array of \id{Ns} vectors containing the derivatives of
    the forward solution sensitivities at the final time \id{tB0}.

  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) can be any that is returned by 
  \id{IDACalcIC} (see \S\ref{ss:idacalcic}). However \id{IDACalcICBS} can also 
  return one of the following:

  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_NO\_ADJ}]
    \id{IDAAdjInit} has not been previously called.
  \item[\id{IDA\_ILL\_INPUT}]
    Parameter \id{which} represented an invalid identifier, sensitivities were
    not active during forward integration, or \id{IDAInitBS} (or \id{IDAReInitBS})
    has not been previously called.
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag} $< 0$
  will trap all \id{IDACalcICBS} failures.

  Note that \id{IDACalcICBS} will correct the values of $yB(tB_0)$ and 
  $\dot{y}B(tB_0)$ which were specified in the previous call to \id{IDAInitBS} 
  or \id{IDAReInitBS}. To obtain the corrected values, call 
  \id{IDAGetConsistentICB} (see \S\ref{sss:optout_iccalcB}).
}



%%---------------------------------------------------------------------
\subsection{Backward integration function}
\label{sss:idasolveb}
%%---------------------------------------------------------------------

The function \ID{IDASolveB} performs the integration of the backward problem.
It is essentially a wrapper for the {\idas} main integration function 
\id{IDASolve} and, in the case in which checkpoints were needed, it evolves 
the solution of the backward problem through a sequence of forward-backward 
integration pairs between consecutive checkpoints. 
In each pair, the first run integrates the original IVP forward in time and
stores interpolation data; the second run integrates the backward problem 
backward in time and performs the required interpolation to provide
the solution of the IVP to the backward problem.

The function \id{IDASolveB} does not return the solution \id{yB}
itself.  To obtain that, call the function \id{IDAGetB}, which is
also described below.

The \id{IDASolveB} function does not support rootfinding, unlike
\id{IDASoveF}, which supports the finding of roots of functions of
$(t,y,\dot{y})$.  If rootfinding was performed by \id{IDASolveF}, then
for the sake of efficiency, it should be disabled for \id{IDASolveB}
by first calling \id{IDARootInit} with \id{nrtfn} = 0.

The call to \id{IDASolveB} has the form
%%
\ucfunctionf{IDASolveB}
{
  flag = IDASolveB(ida\_mem, tBout, itaskB);
}
{
  The function \ID{IDASolveB} integrates the backward DAE problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[tBout] (\id{realtype})
    the next time at which a computed solution is desired.
  \item[itaskB] (\id{int})
    \index{output mode}
    a flag indicating the job of the solver for the next step. 
    The \Id{IDA\_NORMAL} task is to have the solver take internal steps until   
    it has reached or just passed the user-specified value \id{tBout}.
    The solver then interpolates in order to   
    return an approximate value of $yB($\id{tBout}$)$. 
    The \Id{IDA\_ONE\_STEP} option tells the solver to take just one internal
    step in the direction of \id{tBout} and return. 
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  For more details see \S\ref{sss:idasolve}.
  \begin{args}[IDA\_TOO\_MUCH\_WORK]
  \item[\Id{IDA\_SUCCESS}]
    \id{IDASolveB} succeeded.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_NO\_BCK}]
    No backward problem has been added to the list of backward problems by
    a call to \id{IDACreateB}
  \item[\Id{IDA\_NO\_FWD}]
    The function \id{IDASolveF} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}]
    One of the inputs to \id{IDASolveB} is illegal.
  \item[\Id{IDA\_BAD\_ITASK}]
    The \id{itaskB} argument has an illegal value.
  \item[\Id{IDA\_TOO\_MUCH\_WORK}] 
    The solver took \id{mxstep} internal steps but could not reach \id{tBout}. 
  \item[\Id{IDA\_TOO\_MUCH\_ACC}] 
    The solver could not satisfy the accuracy demanded by the user for some 
    internal step.
  \item[\Id{IDA\_ERR\_FAILURE}]
    Error test failures occurred too many times during one internal time step.
  \item[\Id{IDA\_CONV\_FAILURE}] 
    Convergence test failures occurred too many times during one internal time step.
  \item[\Id{IDA\_LSETUP\_FAIL}] 
    The linear solver's setup function failed in an unrecoverable manner.
  \item[\Id{IDA\_SOLVE\_FAIL}] 
    The linear solver's solve function failed in an unrecoverable manner.
  \item[\Id{IDA\_BCKMEM\_NULL}]
    The {\idas} memory for the backward problem was not created with
    a call to \id{IDACreateB}.
  \item[\Id{IDA\_BAD\_TBOUT}]
    The desired output time \id{tBout} is outside the interval over which the 
    forward problem was solved.
  \item[\Id{IDA\_REIFWD\_FAIL}]
    Reinitialization of the forward problem failed at the first checkpoint
    (corresponding to the initial time of the forward problem).
  \item[\Id{IDA\_FWD\_FAIL}]
    An error occurred during the integration of the forward problem.
  \end{args} 
}
{
  All failure return values are negative and therefore a test \id{flag}$< 0$
  will trap all \id{IDASolveB} failures.

  In the case of multiple checkpoints and multiple backward problems, a given
  call to \id{IDASolveB} in \id{IDA\_ONE\_STEP} mode may not advance every problem
  one step, depending on the relative locations of the current times reached.
  But repeated calls will eventually advance all problems to \id{tBout}.
}
%%
%%
To obtain the solution \id{yB} to the backward problem, call the function
\id{IDAGetB} as follows:
%%
\ucfunctionf{IDAGetB}
{
  flag = IDAGetB(ida\_mem, which, \&tret, yB, ypB);
}
{
  The function \ID{IDAGetB} provides the solution \id{yB} of the backward DAE
  problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory returned by \id{IDACreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yB] (\id{N\_Vector})
    the backward solution at time \id{tret}.
  \item[ypB] (\id{N\_Vector})
    the backward solution derivative at time \id{tret}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following.
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    \id{IDAGetB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} is \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
   \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args} 
}
{
  {\warn}The user must allocate space for \id{yB} and \id{ypB}.

  To obtain the solution associated with a given backward problem at some
  other time within the last integration step, first obtain a pointer to the
  proper {\idas} memory structure by calling \id{IDAGetAdjIDABmem}
  and then use it to call \id{IDAGetDky}.
}


%%---------------------------------------------------------------------
\subsection{Optional input functions for the backward problem}
\label{ss:optional_input_b}
%%---------------------------------------------------------------------
%%
\subsubsection{Main solver optional input functions}
\index{optional input!backward solver|(}

The adjoint module in {\idas} provides wrappers for most of the optional 
input functions defined in \S\ref{sss:optin_main}. The only difference is 
that the user must specify the identifier \id{which} of the backward problem 
within the list managed by {\idas}. 

The optional input functions defined for the backward problem are:
\begin{verbatim}
  flag = IDASetNonlinearSolverB(ida_mem, which, NLSB);
  flag = IDASetUserDataB(ida_mem, which, user_dataB);
  flag = IDASetMaxOrdB(ida_mem, which, maxordB);
  flag = IDASetMaxNumStepsB(ida_mem, which, mxstepsB);
  flag = IDASetInitStepB(ida_mem, which, hinB)
  flag = IDASetMaxStepB(ida_mem, which, hmaxB);
  flag = IDASetSuppressAlgB(ida_mem, which, suppressalgB);
  flag = IDASetIdB(ida_mem, which, idB);
  flag = IDASetConstraintsB(ida_mem, which, constraintsB);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of their counterparts, but it can also be \Id{IDA\_NO\_ADJ} if \id{IDAAdjInit} 
has not been called, or \Id{IDA\_ILL\_INPUT} if \id{which} was an invalid identifier. 

\index{optional input!backward solver|)}

%%
%%
%%==================================================================================
%%
\subsubsection{Linear solver interface optional input functions}
\index{optional input!generic linear solver interface|(}
\index{IDALS@{\idals} linear solver interface!optional input|(}

\index{optional input!matrix-based linear solver|(}
When using matrix-based linear solver modules for the backward
problem, i.e., a non-\id{NULL} {\sunmatrix} object \id{A} was passed
to \id{IDASetLinearSolverB}, the {\idals} linear solver interface
needs a function to compute an approximation to the Jacobian matrix.
This can be attached through a call to either \id{IDASetJacFnB} or
\id{IDASetJacFnBS}, with the second used when the backward problem
depends on the forward sensitivities. 
%%
\index{Jacobian approximation function!user-supplied (backward)}
\ucfunctionf{IDASetJacFnB}
{
  flag = IDASetJacFnB(ida\_mem, which, jacB);
}
{
  The function \ID{IDASetJacFnB} specifies the Jacobian
  approximation function to be used for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacB] (\id{IDALsJacFnB})
    user-defined Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}
  \item[\Id{IDALS\_SUCCESS}] 
    \id{IDASetJacFnB} succeeded.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \\ \noindent
    \id{IDASetLinearSolverB}.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDALsJacFnB} is described in \S\ref{ss:jacFn_b}.

  The previous routine \Id{IDADlsSetJacFnB} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
\ucfunctionf{IDASetJacFnBS}
{
  flag = IDASetJacFnBS(ida\_mem, which, jacBS);
}
{
  The function \ID{IDASetJacFnBS} specifies the Jacobian
  approximation function to be used for the backward problem in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    represents the identifier of the backward problem.
  \item[jacBS] (\id{IDALJacFnBS})
    user-defined Jacobian approximation function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}
  \item[\Id{IDALS\_SUCCESS}] 
    \id{IDASetJacFnBS} succeeded.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The linear solver has not been initialized with a call to \\ \noindent
    \id{IDASetLinearSolverBS}.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function type \id{IDALsJacFnBS} is described in \S\ref{ss:jacFn_b}.

  The previous routine \Id{IDADlsSetJacFnBS} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%% 
\index{optional input!matrix-based linear solver|)}
%% 
%% 
\index{optional input!matrix-free linear solver|(}
When using a matrix-free linear solver module for the backward
problem, the {\idals} linear solver interface requires a function to
compute an approximation to the product between the Jacobian matrix
$J(t,y)$ and a vector $v$.  This may be performed internally using a
difference-quotient approximation, or it may be supplied by the user
by calling one of the following two functions:
%%
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
\ucfunctionf{IDASetJacTimesB}
{
  flag = IDASetJacTimesB(ida\_mem, which, jsetupB, jtimesB);
}
{
  The function \ID{IDASetJacTimesB} specifies the Jacobian-vector 
  setup and product functions to be used.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtsetupB] (\id{IDALsJacTimesSetupFnB})
    user-defined function to set up the Jacobian-vector product.
    Pass \id{NULL} if no setup is necessary.
  \item[jtimesB] (\id{IDALsJacTimesVecFnB})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The {\idals} linear solver has not been initialized.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{IDALsJacTimesVecFnB} and
  \id{IDALsJacTimesSetupFnB} are described in \S\ref{ss:jactimesvec_b}.

  The previous routine \Id{IDASpilsSetJacTimesB} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
\ucfunctionf{IDASetJacTimesBS}
{
  flag = IDASetJacTimesBS(ida\_mem, which, jsetupBS, jtimesBS);
}
{
  The function \ID{IDASetJacTimesBS} specifies the Jacobian-vector 
  product setup and evaluation functions to be used, in the case where the 
  backward problem depends on the forward sensitivities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[jtsetupBS] (\id{IDALsJacTimesSetupFnBS})
    user-defined function to set up the Jacobian-vector product.
    Pass \id{NULL} if no setup is necessary.
  \item[jtimesBS] (\id{IDALsJacTimesVecFnBS})
    user-defined Jacobian-vector product function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The {\idals} linear solver has not been initialized.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{IDALsJacTimesVecFnBS} and 
  \id{IDALsJacTimesSetupFnBS} are described in
  \S\ref{ss:jactimesvec_b}.

  The previous routine \Id{IDASpilsSetJacTimesBS} is now a wrapper for this
  routine, and may still be used for backward-compatibility.  However,
  this will be deprecated in future releases, so we recommend that
  users transition to the new routine name soon.
}
%%
%%
Alternately, when using the default difference-quotient approximation
to the Jacobian-vector product for the backward problem, the user may
specify the factor to use in setting increments for the
finite-difference approximation, via a call to \Id{IDASetIncrementFactorB}:
%%
\ucfunctionf{IDASetIncrementFactorB}
{
  flag = IDASetIncrementFactorB(ida\_mem, which, dqincfacB);
}
{
  The function \ID{IDASetIncrementFactorB} specifies the factor 
  in the increments used in the difference quotient approximations to matrix-vector
  products for the backward problem. 

  This routine can be used in both the cases wherethe backward problem
  does and does not depend on the forward sensitvities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[dqincfacB] (\id{realtype})
    difference quotient approximation factor.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The {\idals} linear solver has not been initialized.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The value of \id{eplifacB} is negative.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The default value is $1.0$.

  The previous routine \Id{IDASpilsSetIncrementFactorB} is now a
  wrapper for this routine, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new routine
  name soon. 
}
%%
\index{optional input!matrix-free linear solver|)}
%% 
%% 
\index{optional input!iterative linear solver|(}
%%
When using an iterative linear solver for the backward problem, the
user may supply a preconditioning operator to aid in solution of the
system, or she/he may adjust the convergence tolerance factor for the
iterative linear solver.  These may be accomplished through calling
the following functions:
%%
\index{preconditioning!user-supplied|(}
\ucfunctionf{IDASetPreconditionerB}
{
  flag = IDASetPreconditionerB(ida\_mem, which, psetupB, psolveB);
}
{
  The function \ID{IDASetPrecSolveFnB} specifies the preconditioner
  setup and solve functions for the backward integration.
}
{
  \begin{args}[psetupB]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupB] (\id{IDALsPrecSetupFnB})
    user-defined preconditioner setup function.
  \item[psolveB] (\id{IDALsPrecSolveFnB})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The {\idals} linear solver has not been initialized.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{IDALsPrecSolveFnB} and \id{IDALsPrecSetupFnB} are
  described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, respectively.
  The \id{psetupB} argument may be \id{NULL} if no setup operation is involved
  in the preconditioner.
   
  The previous routine \Id{IDASpilsSetPreconditionerB} is now a
  wrapper for this routine, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new routine
  name soon. 
}
%%
\ucfunctionf{IDASetPreconditionerBS}
{
  flag = IDASetPreconditionerBS(ida\_mem, which, psetupBS, psolveBS);
}
{
  The function \ID{IDASetPrecSolveFnBS} specifies the preconditioner
  setup and solve functions for the backward integration, in the case
  where the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[psetupBS]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[psetupBS] (\id{IDALsPrecSetupFnBS})
    user-defined preconditioner setup function.
  \item[psolveBS] (\id{IDALsPrecSolveFnBS})
    user-defined preconditioner solve function.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} memory block pointer was \id{NULL}.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The {\idals} linear solver has not been initialized.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The function types \id{IDALsPrecSolveFnBS} and \id{IDALsPrecSetupFnBS} are
  described in \S\ref{ss:psolve_b} and \S\ref{ss:psetup_b}, respectively.
  The \id{psetupBS} argument may be \id{NULL} if no setup operation is involved
  in the preconditioner.
  
  The previous routine \Id{IDASpilsSetPreconditionerBS} is now a
  wrapper for this routine, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new routine
  name soon. 
}
%%
\index{preconditioning!user-supplied|)}
%%
%%
\ucfunctionf{IDASetEpsLinB}
{
  flag = IDASetEpsLinB(ida\_mem, which, eplifacB);
}
{
  The function \ID{IDASetEpsLinB} specifies the factor by
  which the Krylov linear solver's convergence test constant is reduced
  from the nonlinear iteration test constant. (See \S\ref{ss:ivp_sol}).
  This routine can be used in both the cases wherethe backward problem
  does and does not depend on the forward sensitvities.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[eplifacB] (\id{realtype})
    linear convergence safety factor ($>= 0.0$).
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}] 
    The optional value has been successfully set.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDALS\_LMEM\_NULL}]
    The {\idals} linear solver has not been initialized.
  \item[\Id{IDALS\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The value of \id{eplifacB} is negative.
  \item[\Id{IDALS\_ILL\_INPUT}]
    The parameter \id{which} represented an invalid identifier.
  \end{args}
}
{
  The default value is $0.05$.

  Passing a value \id{eplifacB}$ = 0.0$ also indicates using the default value.

  The previous routine \Id{IDASpilsSetEpsLinB} is now a
  wrapper for this routine, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new routine
  name soon. 
}
%%
\index{optional input!iterative linear solver|)}
%% 
\index{optional input!generic linear solver interface|)}
\index{IDALS@{\idals} linear solver interface!optional input|)}
%%
%%
%%
%%
%---------------------------------------------------------------------------
\subsection{Optional output functions for the backward problem}
\label{ss:optional_output_b}
%---------------------------------------------------------------------------

\subsubsection{Main solver optional output functions}
\index{optional output!backward solver|(}

The user of the adjoint module in {\idas} has access to any of the
optional output functions described in \S\ref{ss:optional_output},
both for the main solver and for the linear solver modules. The first
argument of these \id{IDAGet*} and \id{IDA*Get*} functions is the
pointer to the {\idas} memory block for the backward problem. In order
to call any of these functions, the user must first call the following
function to obtain this pointer:
%%
\ucfunctionf{IDAGetAdjIDABmem}
{
  ida\_memB = IDAGetAdjIDABmem(ida\_mem, which);
}
{
  The function \ID{IDAGetAdjIDABmem} returns a pointer to the {\idas}
  memory block for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block created by \id{IDACreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \end{args}
}
{
  The return value, \id{ida\_memB} (of type \id{void *}), is a pointer to the
  {\idas} memory for the backward problem.
}
{
  {\warn}The user should not modify \id{ida\_memB} in any way.

  Optional output calls should pass \id{ida\_memB} as the first argument;
  thus, for example, to get the number of integration steps:
  \id{flag = IDAGetNumSteps(idas\_memB,\&nsteps)}.
}
\index{optional output!backward solver|)}


To get values of the {\it forward} solution during a backward integration,
use the following function.  The input value of \id{t} would typically be
equal to that at which the backward solution has just been obtained with
\id{IDAGetB}.  In any case, it must be within the last checkpoint interval
used by \id{IDASolveB}.

\ucfunctionf{IDAGetAdjY}
{
  flag = IDAGetAdjY(ida\_mem, t, y, yp);
}
{
  The function \ID{IDAGetAdjY} returns the interpolated value of the
 forward solution $y$ and its derivative during a backward integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block created by \id{IDACreate}.
  \item[t] (\id{realtype})
    value of the independent variable at which $y$ is desired (input).
  \item[y] (\id{N\_Vector}) forward solution $y(t)$.
  \item[yp] (\id{N\_Vector}) forward solution derivative $\dot{y}(t)$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
 \begin{args}[IDA\_GETY\_BADT]
  \item[\Id{IDA\_SUCCESS}] 
    \id{IDAGetAdjY} was successful. 
  \item[\Id{IDA\_MEM\_NULL}]
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_GETY\_BADT}]
    The value of \id{t} was outside the current checkpoint interval.
  \end{args}
}
{
  {\warn} The user must allocate space for \id{y} and \id{yp}.
}

\ucfunctionf{IDAGetAdjCheckPointsInfo}
{
  flag = IDAGetAdjCheckPointsInfo(ida\_mem, IDAadjCheckPointRec *ckpnt);
}
{
  The function \ID{IDAGetAdjCheckPointsInfo} loads an array of \id{ncheck+1}
  records of type \id{IDAadjCheckPointRec}.
  The user must allocate space for the array \id{ckpnt}.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block created by \id{IDACreate}.
  \item[ckpnt] (\id{IDAadjCheckPointRec *})
    array of \id{ncheck+1} checkpoint records, each of type \id{IDAadjCheckPointRec}.
  \end{args}
}
{  The return value is \id{IDA\_SUCCESS} if successful, or 
   \id{IDA\_MEM\_NULL} if \id{ida\_mem} is \id{NULL}, or
   \id{IDA\_NO\_ADJ} if ASA was not initialized.}
{  The members of each record \id{ckpnt[i]} are:
\begin{itemize}
 \item \id{ckpnt[i].my\_addr} (\id{void *}) address of current checkpoint
        in \id{ida\_mem->ida\_adj\_mem}
 \item \id{ckpnt[i].next\_addr} (\id{void *}) address of next checkpoint
 \item \id{ckpnt[i].t0} (\id{realtype}) start of checkpoint interval
 \item \id{ckpnt[i].t1} (\id{realtype}) end of checkpoint interval
 \item \id{ckpnt[i].nstep} (\id{long int}) step counter at ckeckpoint \id{t0}
 \item \id{ckpnt[i].order} (\id{int}) method order at checkpoint \id{t0}
 \item \id{ckpnt[i].step} (\id{realtype}) step size at checkpoint \id{t0}
\end{itemize}
}


%%
\subsubsection{Initial condition calculation optional output function}
\label{sss:optout_iccalcB}
\index{optional output!backward initial condition calculation|(}
%%

\ucfunctionf{IDAGetConsistentICB}
{
  flag = IDAGetConsistentICB(ida\_mem, which, yB0\_mod, ypB0\_mod);
}
{
  The function \ID{IDAGetConsistentICB} returns the corrected initial conditions
  for backward problem calculated by \id{IDACalcICB}.
}
{
  \begin{args}[ypB0\_mod]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which]
    is the identifier of the backward problem.
  \item[yB0\_mod] (\id{N\_Vector})
    consistent initial vector.
  \item[ypB0\_mod] (\id{N\_Vector})
    consistent initial derivative vector.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_ILL\_INPUT]
  \item[IDA\_SUCCESS] 
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_ILL\_INPUT}]
    Parameter \id{which} did not refer a valid backward problem identifier.
  \end{args}
}
{
  If the consistent solution vector or consistent derivative vector
  is not desired, pass \id{NULL} for the corresponding argument.

  {\warn} The user must allocate space for \id{yB0\_mod} and \id{ypB0\_mod}
  (if not \id{NULL}).
}
%%
\index{optional output!backward initial condition calculation|}

%%---------------------------------------------------------------------
\subsection{Backward integration of quadrature equations}
%%---------------------------------------------------------------------

Not only the backward problem but also the backward quadrature equations 
may or may not depend on the forward sensitivities. Accordingly, one of the 
\id{IDAQuadInitB} or \id{IDAQuadInitBS} should be used to allocate internal 
memory and to initialize backward quadratures.  For any other operation
(extraction, optional input/output, reinitialization, deallocation), the
same function is called regardless of whether or not the quadratures are
sensitivity-dependent.

\subsubsection{Backward quadrature initialization functions}
\label{sss:idaquadinitb}

The function \id{IDAQuadInitB} initializes and allocates memory for the backward
integration of quadrature equations that do not depende on forward sensititvities.
It has the following form:
%%
%%
\ucfunctionf{IDAQuadInitB}
{
flag = IDAQuadInitB(ida\_mem, which, rhsQB, yQB0);
}
{
  The function \ID{IDAQuadInitB} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQB] (\Id{IDAQuadRhsFnB})
    is the {\CC} function which computes $fQB$, the residual of the 
    backward quadrature equations. This function has the form 
    \id{rhsQB(t, y, yp, yB, ypB, rhsvalBQ, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_B}).
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAQuadInitB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}
%%
%%

The function \id{IDAQuadInitBS} initializes and allocates memory for the backward
integration of quadrature equations that depend on the forward sensitivities.
%%
%%
\ucfunctionf{IDAQuadInitBS}
{
flag = IDAQuadInitBS(ida\_mem, which, rhsQBS, yQBS0);
}
{
  The function \ID{IDAQuadInitBS} provides required problem specifications,
  allocates internal memory, and initializes backward quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[rhsQBS] (\Id{IDAQuadRhsFnBS})
    is the {\CC} function which computes $fQBS$, the residual of the 
    backward quadrature equations. This function has the form 
    \id{rhsQBS(t, y, yp, yS, ypS, yB, ypB, rhsvalBQS, user\_dataB)} 
    (see \S\ref{sss:rhs_quad_sens_B}).
  \item[yQBS0] (\id{N\_Vector})
    is the value of the sensitivity-dependent quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAQuadInitBS} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{}

The integration of quadrature equations during the backward phase can be
re-initialized by calling the following function.
Before calling \id{IDAQuadReInitB} for a new backward problem, call any
desired solution extraction functions \id{IDAGet**} associated with the
previous backward problem.

%%
%%
\ucfunctionf{IDAQuadReInitB}
{
  flag = IDAQuadReInitB(ida\_mem, which, yQB0);
}
{
  The function \ID{IDAQuadReInitB} re-initializes the backward quadrature integration.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[yQB0] (\id{N\_Vector})
    is the value of the quadrature variables at \id{tB0}.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) will be one of the following:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}]
    The call to \id{IDAQuadReInitB} was successful.
 \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} was \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[\Id{IDA\_MEM\_FAIL}] 
    A memory allocation request has failed.
  \item[\Id{IDA\_NO\_QUAD}] 
    Quadrature integration was not activated through a  previous 
    call to \id{IDAQuadInitB}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  \id{IDAQuadReInitB} can be used after a call to either \id{IDAQuadInitB}
  or \id{IDAQuadInitBS}.
}

\subsubsection{Backward quadrature extraction function}
\label{sss:quad_get_b}
To extract the values of the quadrature variables at the last return time
of \id{IDASolveB}, {\idas} provides a wrapper for the function \ID{IDAGetQuad}
(see \S\ref{ss:quad_get}). The call to this function has the form
%%
%%
\ucfunctionf{IDAGetQuadB}
{
  flag = IDAGetQuadB(ida\_mem, which, \&tret, yQB);
}
{
  The function \ID{IDAGetQuadB} returns the quadrature solution vector after
  a successful return from \id{IDASolveB}.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory.
  \item[tret] (\id{realtype})
    the time reached by the solver (output).
  \item[yQB] (\id{N\_Vector})
    the computed quadrature vector.
  \end{args}
}
{
  The return value \id{flag} of \id{IDAGetQuadB} is one of:
  \begin{args}[IDA\_ILL\_INPUT]
  \item[\Id{IDA\_SUCCESS}] 
    \id{IDAGetQuadB} was successful.
  \item[\Id{IDA\_MEM\_NULL}] 
    \id{ida\_mem} is \id{NULL}.
  \item[\Id{IDA\_NO\_ADJ}]
    The function \id{IDAAdjInit} has not been previously called.
  \item[IDA\_NO\_QUAD] 
    Quadrature integration was not initialized.
  \item[IDA\_BAD\_DKY] 
    \id{yQB} was \id{NULL}.
  \item[\Id{IDA\_ILL\_INPUT}]
    The parameter \id{which} is an invalid identifier.
  \end{args}
}
{
  {\warn}The user must allocate space for \id{yQB}.

  To obtain the quadratures associated with a given backward problem at some
  other time within the last integration step, first obtain a pointer to the
  proper {\idas} memory structure by calling \id{IDAGetAdjIDABmem}
  and then use it to call \id{IDAGetQuadDky}.
}
%%\subsubsection{Tolerance specification functions for backward quadrature integration}

\subsubsection{Optional input/output functions for backward quadrature integration}
\label{sss:quad_optional_input_B}
\index{optional input!quadrature integration}
\index{optional output!quadrature integration}
Optional values controlling the backward integration of quadrature equations can be 
changed from their default values through calls to one of the following functions 
which are wrappers for the corresponding optional input functions defined in 
\S\ref{ss:quad_optional_input}. The user must specify  the identifier \id{which} 
of the backward problem for which the optional values are specified.

\begin{verbatim}
  flag = IDASetQuadErrConB(ida_mem, which, errconQ);
  flag = IDAQuadSStolerancesB(ida_mem, which, reltolQ, abstolQ);
  flag = IDAQuadSVtolerancesB(ida_mem, which, reltolQ, abstolQ);
\end{verbatim}
Their return value \id{flag} (of type \id{int}) can have any of the return values 
of its counterparts, but it can also be \Id{IDA\_NO\_ADJ} if the function 
\id{IDAAdjInit} has not been previously called or \Id{IDA\_ILL\_INPUT} if the
parameter \id{which} was an invalid identifier.

Access to optional outputs related to backward quadrature integration
can be obtained by calling the corresponding \id{IDAGetQuad*}
functions (see \S\ref{ss:quad_optional_output}).  A pointer
\id{ida\_memB} to the {\idas} memory block for the backward problem,
required as the first argument of these functions, can be obtained
through a call to the functions \id{IDAGetAdjIDABmem} (see
\S\ref{ss:optional_output_b}).



%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
\section{User-supplied functions for adjoint sensitivity analysis}
\label{ss:user_fct_adj}
%%-------------------------------------------------------------------------------------
%%-------------------------------------------------------------------------------------
%%

In addition to the required DAE residual function and any optional functions
for the forward problem, when using the adjoint sensitivity module in {\idas},
the user must supply one function defining the backward problem DAE and, optionally,
functions to supply Jacobian-related information and one or two functions 
that define the preconditioner (if applicable for the choice of
{\sunlinsol} object) for the backward problem.
Type definitions for all these user-supplied functions are given below.

\subsection{DAE residual for the backward problem}\label{ss:DAEres_b}
\index{adjoint sensitivity analysis!residual evaluation}
\index{residual function!backward problem}

The user must provide a \id{resB} function of type \ID{IDAResFnB} defined as follows:
\usfunction{IDAResFnB}
{
  typedef int (*IDAResFnB)(&realtype t, N\_Vector y, N\_Vector yp, \\
                           &N\_Vector yB, N\_Vector ypB, \\
                           &N\_Vector resvalB, void *user\_dataB);
}
{
  This function evaluates the residual of the backward problem DAE system.
  This could be (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the output vector containing the residual for the backward DAE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAResFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if an unrecoverabl failure occurred (in which case the integration stops and
  \id{IDASolveB} returns \Id{IDA\_RESFUNC\_FAIL}).
}
{
  Allocation of memory for \id{resvalB} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{resvalB} arguments are all 
  of type \id{N\_Vector}, but \id{yB}, \id{ypB}, and \id{resvalB} typically have 
  different internal representations from \id{y} and \id{yp}.  It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{resB} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{resB} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the residual function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_RESFUNC\_FAIL}.
}

\subsection{DAE residual for the backward problem depending on the forward sensitivities}\label{ss:DAEres_bs}
\index{adjoint sensitivity analysis!residual evaluation}
\index{residual function!backward problem}

The user must provide a \id{resBS} function of type \ID{IDAResFnBS} defined as follows:
\usfunction{IDAResFnBS}
{
  typedef int (*IDAResFnBS)(&realtype t, N\_Vector y, N\_Vector yp, \\
                           &N\_Vector *yS, N\_Vector *ypS, \\
                           &N\_Vector yB, N\_Vector ypB, \\
                           &N\_Vector resvalB, void *user\_dataB);
}
{
  This function evaluates the residual of the backward problem DAE system.
  This could be (\ref{e:adj_eqns}) or (\ref{e:adj1_eqns}).
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the output vector containing the residual for the backward DAE problem.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAResFnBS} should return 0 if successful, a positive value if a
  recoverable error occurred (in which case {\idas} will attempt to correct),
  or a negative value if an unrecoverable error occurred (in which case the
  integration stops and \id{IDASolveB} returns \Id{IDA\_RESFUNC\_FAIL}).
}
{
  Allocation of memory for \id{resvalB} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{resvalB} arguments are all 
  of type \id{N\_Vector}, but \id{yB}, \id{ypB}, and \id{resvalB} typically have 
  different internal representations from \id{y} and \id{yp}. Likewise for each
  \id{yS[i]} and \id{ypS[i]}. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with respect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to 
  the user's \id{resBS} function every time it is called and can be the same as the 
  \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{resBS} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the residual function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_RESFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Quadrature right-hand side for the backward problem}
\index{residual function!quadrature backward problem}
\index{adjoint sensitivity analysis!quadrature evaluation}
\label{sss:rhs_quad_B}
The user must provide an \id{fQB} function of type \ID{IDAQuadRhsFnB} defined by
\usfunction{IDAQuadRhsFnB}
{
  typedef int (*IDAQuadRhsFnB)(&realtype t, N\_Vector y, N\_Vector yp, \\
                               &N\_Vector yB, N\_Vector ypB, \\
                               &N\_Vector rhsvalBQ, void *user\_dataB);
}
{
  This function computes the quadrature equation right-hand side for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[rhsvalBQ]
    is the output vector containing the residual for the backward quadrature
    equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAQuadRhsFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalBQ} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{rhsvalBQ} arguments are all 
  of type \id{N\_Vector}, but they typically all have 
  different internal representations. It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQB} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward problem.

  {\warn}Before calling the user's \id{fQB} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_QRHSFUNC\_FAIL}.
}

\subsection{Sensitivity-dependent quadrature right-hand side for the backward problem}
\index{residual function!sensitivity-dep. quadrature backward problem}
\index{adjoint sensitivity analysis!sensitivity-dependent quadrature evaluation}
\label{sss:rhs_quad_sens_B}
The user must provide an \id{fQBS} function of type \ID{IDAQuadRhsFnBS} defined by
\usfunction{IDAQuadRhsFnBS}
{
  typedef int (*IDAQuadRhsFnBS)(&realtype t, N\_Vector y, N\_Vector yp, \\
                                &N\_Vector *yS, N\_Vector *ypS, \\ 
                                &N\_Vector yB, N\_Vector ypB, \\
                                &N\_Vector rhsvalBQS, void *user\_dataB);
}
{
  This function computes the quadrature equation residual for the
  backward problem.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[rhsvalBQS]
    is the output vector containing the residual for the backward quadrature
    equations.
  \item[user\_dataB]
    is a pointer to user data, same as passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDAQuadRhsFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_QRHSFUNC\_FAIL}).
}
{
  Allocation of memory for \id{rhsvalBQS} is handled within {\idas}.

  The \id{y}, \id{yp}, \id{yB}, \id{ypB}, and \id{rhsvalBQS} arguments are all 
  of type \id{N\_Vector}, but they typically do not all have the same internal
  representations.  Likewise for each \id{yS[i]} and \id{ypS[i]}.  It is the user's 
  responsibility to access the vector data consistently (including the use of the 
  correct accessor macros from each {\nvector} implementation). For the sake of 
  computational efficiency, the vector functions in the two {\nvector} implementations 
  provided with {\idas} do not perform any consistency checks with repsect to their 
  \id{N\_Vector} arguments (see \S\ref{ss:nvec_ser} and \S\ref{ss:nvec_par}).

  The \id{user\_dataB} pointer is passed to the user's \id{fQBS} function every time 
  it is called and can be the same as the \id{user\_data} pointer used for the forward
  problem.

  {\warn}Before calling the user's \id{fQBS} function, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration.
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the quadrature right-hand side function which will halt the integration and
  \id{IDASolveB} will return \id{IDA\_QRHSFUNC\_FAIL}.
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian construction for the backward problem 
  (matrix-based linear solvers)}\label{ss:jacFn_b}

If a matrix-based linear solver module is is used for the backward problem (i.e., 
\Id{IDASetLinearSolverB} is called with non-\id{NULL} {\sunmatrix}
argument in the step described in \S\ref{ss:skeleton_adj}), the user may
provide a function of type \ID{IDALsJacFnB} or \ID{IDALsJacFnBS} 
(see \S\ref{ss:optional_input_b}), defined as follows:
%%
\index{Jacobian approximation function!user-supplied (backward)}
\usfunction{IDALsJacFnB}
{
  typedef int (*IDALsJacFnB)(&realtype tt, realtype cjB, \\
                             &N\_Vector yy, N\_Vector yp,\\
                             &N\_Vector yB, N\_Vector ypB,\\
                             &N\_Vector resvalB,\\
                             &SUNMatrix JacB, void *user\_dataB,\\
                             &N\_Vector tmp1B, N\_Vector tmp2B,\\
                             &N\_Vector tmp3B);
}
{
  This function computes the Jacobian of the backward problem (or an approximation
  to it). 
}
{
  \begin{args}[user\_dataB]
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated for variables of type \id{N\_Vector} 
    which can be used by the \id{IDALsJacFnB} function 
    as temporary storage or work space.
  \end{args}
}
{
  An \id{IDALsJacFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct, while {\idals} sets
  \id{last\_flag} to \Id{IDALS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{IDASolveB}
  returns \Id{IDA\_LSETUP\_FAIL} and {\idals} sets \id{last\_flag} to 
  \Id{IDALS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied Jacobian function must load the 
  matrix \id{JacB} with an approximation to the Jacobian matrix
  at the point (\id{tt},\id{yy},\id{yB}), where \id{yy} is the solution
  of the original IVP at time \id{tt}, and \id{yB} is the solution of the
  backward problem at the same time.
  Information regarding the structure of the specific {\sunmatrix}
  structure (e.g.~number of rows, upper/lower bandwidth, sparsity
  type) may be obtained through using the implementation-specific
  {\sunmatrix} interface functions (see Chapter \ref{s:sunmatrix} for
  details).

  With direct linear solvers (i.e., linear solvers with type
  \Id{SUNLINEARSOLVER\_DIRECT}), the Jacobian matrix $J(t,y)$ is zeroed out
  prior to calling the user-supplied Jacobian function so only nonzero elements
  need to be loaded into \id{JacB}.
  
  {\warn}Before calling the user's \id{IDALsJacFnB}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL} and {\idals} sets \id{last\_flag} to 
  \Id{IDALS\_JACFUNC\_UNRECVR}).

  The previous function type \Id{IDADlsJacFnB} is identical to
  \id{IDALsJacFnB}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

\usfunction{IDALsJacFnBS}
{
  typedef int (*IDALsJacFnBS)(&realtype tt, realtype cjB, \\
                              &N\_Vector yy, N\_Vector yp,\\
                              &N\_Vector *yS, N\_Vector *ypS,\\
                              &N\_Vector yB, N\_Vector ypB,\\
                              &N\_Vector resvalB,\\
                              &SUNMatrix JacB, void *user\_dataB,\\
                              &N\_Vector tmp1B, N\_Vector tmp2B,\\
                              &N\_Vector tmp3B);
}
{
  This function computes the Jacobian of the backward problem (or an
  approximation to it), in the case where the backward problem depends on the
  forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[tt]
    is the current value of the independent variable.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities
    of the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives
    of the forward solution sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[JacB]
    is the output approximate Jacobian matrix.
  \item[user\_dataB]
    is a pointer to user data --- the parameter passed to \id{IDASetUserDataB}. 
  \item[tmp1B]
  \item[tmp2B]
  \item[tmp3B]
    are pointers to memory allocated  for variables of type \id{N\_Vector} which 
    can be used by \id{IDALsJacFnBS} as temporary storage or work space.    
  \end{args}
}
{
  An \id{IDALsJacFnBS} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct, while {\idals} sets
  \id{last\_flag} to \Id{IDALS\_JACFUNC\_RECVR}), or a negative 
  value if it failed unrecoverably (in which case the integration is halted, \id{IDASolveB}
  returns \Id{IDA\_LSETUP\_FAIL} and {\idals} sets \id{last\_flag} to 
  \Id{IDALS\_JACFUNC\_UNRECVR}).
}
{
  A user-supplied dense Jacobian function must load the
  matrix \id{JacB} with an approximation to the Jacobian matrix
  at the point (\id{tt},\id{yy},\id{yS},\id{yB}), where \id{yy} is the solution
  of the original IVP at time \id{tt}, \id{yS} is the array of forward sensitivities
  at time \id{tt}, and \id{yB} is the solution of the backward problem at the same time.
  Information regarding the structure of the specific {\sunmatrix}
  structure (e.g.~number of rows, upper/lower bandwidth, sparsity
  type) may be obtained through using the implementation-specific
  {\sunmatrix} interface functions (see Chapter \ref{s:sunmatrix} for
  details).

  With direct linear solvers (i.e., linear solvers with type
  \Id{SUNLINEARSOLVER\_DIRECT}, the Jacobian matrix $J(t,y)$ is zeroed out prior
  to calling the user-supplied Jacobian function so only nonzero elements need
  to be loaded into \id{JacB}.

  {\warn}Before calling the user's \id{IDALsJacFnBS}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the Jacobian function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL} and {\idals} sets \id{last\_flag} to 
  \Id{IDALS\_JACFUNC\_UNRECVR}).


  The previous function type \Id{IDADlsJacFnBS} is identical to
  \id{IDALsJacFnBS}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%-------------------------------------------------------------------------------------
\subsection{Jacobian-vector product for the backward problem
   (matrix-free linear solvers)}\label{ss:jactimesvec_b}
\index{Jacobian approximation function!Jacobian-vector product!user-supplied (backward)}
If a matrix-free linear solver is selected for the backward problem
(i.e., \id{IDASetLinearSolverB} is called with \id{NULL}-valued
{\sunmatrix} argument in the steps described in \S\ref{ss:skeleton_adj}), the user may
provide a function of type \\ \noindent
\Id{IDALsJacTimesVecFnB} or 
\Id{IDALsJacTimesVecFnBS} in the following form,
to compute matrix-vector products $Jv$. If such a function is not supplied,
the default is a difference quotient approximation to these products.
%%
\usfunction{IDALsJacTimesVecFnB}
{
  typedef int (*IDALsJacTimesVecFnB)(&realtype t, \\
                                     &N\_Vector yy, N\_Vector yp, \\
                                     &N\_Vector yB, N\_Vector ypB, \\
                                     &N\_Vector resvalB, \\
                                     &N\_Vector vB, N\_Vector JvB, \\
                                     &realtype cjB, void *user\_dataB, \\
                                     &N\_Vector tmp1B, N\_Vector tmp2B);
}
{
  This function computes the action of the backward problem Jacobian \id{JB}
  on a given vector \id{vB}.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[vB]
    is the vector by which the Jacobian must be multiplied.
  \item[JvB]
      is the computed output vector, \id{JB*vB}.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
    are pointers to memory allocated for variables of type \id{N\_Vector} which
    can be used by \id{IDALsJacTimesVecFnB} as temporary storage or work space.
  \end{args}
}
{  
  The return value of a function of type \id{IDALsJtimesVecFnB} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the product of the Jacobian of the backward problem 
  at the point (\id{t}, \id{y}, \id{yB}) and the vector \id{vB}. 
  Here, \id{y} is the solution of the original IVP at time \id{t} and 
  \id{yB} is the solution of the backward problem at the same time.  
  The rest of the arguments are equivalent to those passed to a function of type
  \id{IDALsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).
  If the backward problem is the adjoint of ${\dot y} = f(t, y)$, then this 
  function is to compute $-(\dfdyI)^T v_B$.

  The previous function type \Id{IDASpilsJacTimesVecFnB} is identical to
  \\ \noindent \id{IDALsJacTimesVecFnB}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon. 
}
%%
\usfunction{IDALsJacTimesVecFnBS}
{
  typedef int (*IDALsJacTimesVecFnBS)(&realtype t, \\
                                      &N\_Vector yy, N\_Vector yp, \\
                                      &N\_Vector *yyS, N\_Vector *ypS, \\
                                      &N\_Vector yB, N\_Vector ypB, \\
                                      &N\_Vector resvalB, \\
                                      &N\_Vector vB, N\_Vector JvB, \\
                                      &realtype cjB, void *user\_dataB, \\
                                      &N\_Vector tmp1B, N\_Vector tmp2B);
}
{
  This function computes the action of the backward problem Jacobian \id{JB}
  on a given vector \id{vB}, in the case where the backward problem depends
  on the forward sensitivities.
}
{
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yyS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[vB]
    is the vector by which the Jacobian must be multiplied.
  \item[JvB]
      is the computed output vector, \id{JB*vB}.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.
  \item[tmp1B]
  \item[tmp2B]
    are pointers to memory allocated for variables of type \id{N\_Vector} which
    can be used by \id{IDALsJacTimesVecFnBS} as temporary storage or work space.
  \end{args}
}
{  
  The return value of a function of type \id{IDALsJtimesVecFnBS} should be
  $0$ if successful or nonzero if an error was encountered, in which case
  the integration is halted.
}
{
  A user-supplied Jacobian-vector product function must load the vector \id{JvB}
  with the product of the Jacobian of the backward problem 
  at the point (\id{t}, \id{y}, \id{yB}) and the vector \id{vB}. 
  Here, \id{y} is the solution of the original IVP at time \id{t} and 
  \id{yB} is the solution of the backward problem at the same time.  
  The rest of the arguments are equivalent to those passed to a function of type
  \id{IDALsJacTimesVecFn} (see \S\ref{ss:jtimesFn}).

  The previous function type \Id{IDASpilsJacTimesVecFnBS} is identical to
  \\ \noindent \id{IDALsJacTimesVecFnBS}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon. 
}


%%-------------------------------------------------------------------------------------
\subsection{Jacobian-vector product setup for the backward problem
   (matrix-free linear solvers)}\label{ss:jactimesvecsetup_b}
\index{Jacobian approximation function!Jacobian-vector setup!user-supplied (backward)}
If the user's Jacobian-times-vector requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied function of type \Id{IDALsJacTimesSetupFnB} or
\Id{IDALsJacTimesSetupFnBS}, defined as follows: 
%%
\usfunction{IDALsJacTimesSetupFnB}
{
  typedef int (*IDALsJacTimesSetupFnB)(&realtype tt, \\
                                       &N\_Vector yy, N\_Vector yp, \\
                                       &N\_Vector yB, N\_Vector ypB, \\
                                       &N\_Vector resvalB, \\
                                       &realtype cjB, void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian data needed
  by the Jacobian-times-vector routine for the backward problem.
}
{
  \begin{args}[user\_data]
  \item[tt]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  The value returned by the Jacobian-vector setup function
  should be $0$ if successful, positive for a recoverable error (in
  which case the step will be retried), or negative for an
  unrecoverable error (in which case the integration is halted). 
} 
{
  Each call to the Jacobian-vector setup function is preceded by a call to
  the backward problem residual user function with the same 
  \id{(t,y, yp, yB, ypB)} arguments.  
  Thus, the setup function can use any auxiliary data that is computed
  and saved during the evaluation of the DAE residual. 
  
  If the user's \id{IDALsJacTimesVecFnB} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{ida\_mem} 
  to \id{user\_dataB} and then use the \id{IDAGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  The previous function type \Id{IDASpilsJacTimesSetupFnB} is identical
  to \\ \noindent \id{IDALsJacTimesSetupFnB}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon.
}
%%
\usfunction{IDALsJacTimesSetupFnBS}
{
  typedef int (*IDALsJacTimesSetupFnBS)(&realtype tt, \\
                                        &N\_Vector yy, N\_Vector yp, \\
                                        &N\_Vector *yyS, N\_Vector *ypS, \\
                                        &N\_Vector yB, N\_Vector ypB, \\
                                        &N\_Vector resvalB, \\
                                        &realtype cjB, void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian data needed
  by the Jacobian-times-vector routine for the backward problem, in the case that
  the backward problem depends on the forward sensitivities.
}
{
  \begin{args}[user\_data]
  \item[tt]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the dependent variable vector, $y(t)$.
  \item[yp]
    is the current value of $\dot{y}(t)$.
  \item[yyS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  The value returned by the Jacobian-vector setup function
  should be $0$ if successful, positive for a recoverable error (in
  which case the step will be retried), or negative for an
  unrecoverable error (in which case the integration is halted). 
} 
{
  Each call to the Jacobian-vector setup function is preceded by a call to
  the backward problem residual user function with the same 
  \id{(t,y, yp, yyS, ypS, yB, ypB)} arguments.  
  Thus, the setup function can use any auxiliary data that is computed
  and saved during the evaluation of the DAE residual. 
  
  If the user's \id{IDALsJacTimesVecFnB} function uses difference quotient
  approximations, it may need to access quantities not in the call
  list. These include the current stepsize, the error weights, etc.
  To obtain these, the user will need to add a pointer to \id{ida\_mem} 
  to \id{user\_dataB} and then use the \id{IDAGet*} functions described in
  \S\ref{sss:optout_main}. The unit roundoff can be accessed as
  \id{UNIT\_ROUNDOFF} defined in \id{sundials\_types.h}.

  The previous function type \Id{IDASpilsJacTimesSetupFnBS} is identical
  to \\ \noindent \id{IDALsJacTimesSetupFnBS}, and may still be used for
  backward-compatibility.  However, this will be deprecated in future
  releases, so we recommend that users transition to the new function
  type name soon.
}
%%
%%
%%-------------------------------------------------------------------------------------
\subsection{Preconditioner solve for the backward problem
  (iterative linear solvers)}\label{ss:psolve_b}
\index{preconditioning!user-supplied}
\index{IDALS@{\idals} linear solver interface!preconditioner solve function (backward)}
If preconditioning is used during integration of the backward problem, 
then the user must provide a function to solve the linear system 
$Pz = r$, where $P$ is a left preconditioner matrix.
This function must have one of the following two forms:
%%
\usfunction{IDALsPrecSolveFnB}
{
  typedef int (*IDALsPrecSolveFnB)(&realtype t, \\
                                   &N\_Vector yy, N\_Vector yp, \\
                                   &N\_Vector yB, N\_Vector ypB, \\
                                   &N\_Vector resvalB, \\
                                   &N\_Vector rvecB, N\_Vector zvecB, \\
                                   &realtype cjB, realtype deltaB, \\
                                   &void *user\_dataB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem.
}
{  
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[deltaB]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to the function \id{IDASetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{IDASpilsPrecSolveFnB} is identical to
  \id{IDALsPrecSolveFnB}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
%%
\usfunction{IDALsPrecSolveFnBS}
{
  typedef int (*IDALsPrecSolveFnBS)(&realtype t, \\
                                    &N\_Vector yy, N\_Vector yp, \\
                                    &N\_Vector *yyS, N\_Vector *ypS, \\
                                    &N\_Vector yB, N\_Vector ypB, \\
                                    &N\_Vector resvalB, \\
                                    &N\_Vector rvecB, N\_Vector zvecB, \\
                                    &realtype cjB, realtype deltaB, \\
                                    &void *user\_dataB);
}
{
  This function solves the preconditioning system $Pz = r$ for the backward problem,
  for the case in which the backward problem depends on the forward sensitivities.
}
{  
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yyS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[rvecB]
    is the right-hand side vector $r$ of the linear system to be solved.
  \item[zvecB]
    is the computed output vector.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[deltaB]
    is an input tolerance to be used if an iterative method 
    is employed in the solution.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}      
    parameter passed to the function \id{IDASetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner solve function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried), or
  negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{IDASpilsPrecSolveFnBS} is identical to
  \id{IDALsPrecSolveFnBS}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%-------------------------------------------------------------------------------------
\subsection{Preconditioner setup for the backward problem
  (iterative linear solvers)}\label{ss:psetup_b}
\index{preconditioning!user-supplied}
\index{IDALS@{\idals} linear solver interface!preconditioner setup function (backward)}
If the user's preconditioner requires that any Jacobian-related data
be preprocessed or evaluated, then this needs to be done in a
user-supplied function of one of the following two types:
%%
\usfunction{IDALsPrecSetupFnB}
{
  typedef int (*IDALsPrecSetupFnB)(&realtype t, \\
                                   &N\_Vector yy, N\_Vector yp,  \\
                                   &N\_Vector yB, N\_Vector ypB, \\ 
                                   &N\_Vector resvalB, \\
                                   &realtype cjB, void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem.
}
{
  The arguments of an \id{IDALsPrecSetupFnB} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to the function \id{IDASetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  or negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{IDASpilsPrecSetupFnB} is identical to
  \id{IDALsPrecSetupFnB}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}
%%
\usfunction{IDALsPrecSetupFnBS}
{
  typedef int (*IDALsPrecSetupFnBS)(&realtype t, \\
                                    &N\_Vector yy, N\_Vector yp,  \\
                                    &N\_Vector *yyS, N\_Vector *ypS,  \\
                                    &N\_Vector yB, N\_Vector ypB, \\ 
                                    &N\_Vector resvalB, \\
                                    &realtype cjB, void *user\_dataB);
}
{
  This function preprocesses and/or evaluates Jacobian-related data needed
  by the preconditioner for the backward problem, in the case where the
  backward problem depends on the forward sensitivities.
}
{
  The arguments of an \id{IDALsPrecSetupFnBS} are as follows:
  \begin{args}[user\_dataB]
  \item[t]
    is the current value of the independent variable.
  \item[yy]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution vector.
  \item[yyS]
    a pointer to an array of \id{Ns} vectors containing the sensitivities of 
    the forward solution.
  \item[ypS]
    a pointer to an array of \id{Ns} vectors containing the derivatives of 
    the forward sensitivities.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[resvalB]
    is the current value of the residual for the backward problem.
  \item[cjB]
    is the scalar in the system Jacobian, proportional to the inverse of the
    step size ($\alpha$ in Eq. (\ref{e:DAE_Jacobian}) ).
  \item[user\_dataB]
    is a pointer to user data --- the same as the \id{user\_dataB}
    parameter passed to the function \id{IDASetUserDataB}.
  \end{args}
}
{
  The return value of a preconditioner setup function for the backward
  problem should be $0$ if successful, 
  positive for a recoverable error (in which case the step will be retried),     
  or negative for an unrecoverable error (in which case the integration is halted).
}
{
  The previous function type \Id{IDASpilsPrecSetupFnBS} is identical to
  \id{IDALsPrecSetupFnBS}, and may still be used for backward-compatibility.
  However, this will be deprecated in future releases, so we recommend
  that users transition to the new function type name soon.
}

%%
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
\section{Using the band-block-diagonal preconditioner for backward problems}
%%-------------------------------------------------------------------
%%-------------------------------------------------------------------
%%

As on the forward integration phase, the efficiency of Krylov iterative methods 
for the solution of linear systems can be greatly enhanced through preconditioning.
The band-block-diagonal preconditioner module {\idabbdpre},
provides interface functions through which it can be used on the backward integration phase.

\index{IDABBDPRE@{\idabbdpre} preconditioner!usage with adjoint module|(}
The adjoint module in {\idas} offers an interface to the band-block-diagonal
preconditioner module {\idabbdpre} described in section \S\ref{sss:idabbdpre}.
This generates a preconditioner that is a block-diagonal matrix with each
block being a band matrix and can be used with one of the Krylov linear solvers
and with the MPI-parallel vector module {\nvecp}.

In order to use the {\idabbdpre} module in the solution of the backward problem,
the user must define one or two additional functions, described at the end of this section. 

\subsection{Usage of IDABBDPRE for the backward problem}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-callable functions|(}
The {\idabbdpre} module is initialized by calling the following function,
{\em after} an iterative linear solver for the backward problem has
been attached to {\idas} by calling \Id{IDASetLinearSolverB} (see
\S\ref{sss:lin_solv_b}).  
%%
%%
\ucfunctionf{IDABBDPrecInitB}
{
  \begin{tabular}[t]{@{}r@{}l@{}}
    flag = IDABBDPrecInitB(&ida\_mem, which, NlocalB, mudqB, mldqB,\\
                           &mukeepB, mlkeepB, dqrelyB, GresB, GcommB);
  \end{tabular}
}
{
  The function \ID{IDABBDPrecInitB} initializes and allocates
  memory for the {\idabbdpre} preconditioner for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[NlocalB] (\id{sunindextype})
    local vector dimension for the backward problem.
  \item[mudqB] (\id{sunindextype})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{sunindextype})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mukeepB] (\id{sunindextype})
    upper half-bandwidth of the retained banded approximate Jacobian block.
  \item[mlkeepB] (\id{sunindextype})
    lower half-bandwidth of the retained banded approximate Jacobian block.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.  The default is \id{dqrelyB}$ = \sqrt{\text{unit roundoff}}$, which
    can be specified by passing \id{dqrely}$ = 0.0$.
  \item[GresB] (\id{IDABBDLocalFnB})
    the {\CC} function which computes $G_B(t,y,\dot y, y_B, \dot y_B)$, the
    function approximating the residual of the backward problem. 
  \item[GcommB] (\id{IDABBDCommFnB})
    the optional {\CC} function which performs all interprocess communication required for
    the computation of $G_B$.
  \end{args}
}
{
  If successful, \id{IDABBDPrecInitB} creates, allocates, and stores (internally
  in the {\idas} solver block) a pointer to the newly created 
  {\idabbdpre} memory block.
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}]
    The call to \id{IDABBDPrecInitB} was successful.
  \item[\Id{IDALS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} argument was \id{NULL}.
  \item[\Id{IDALS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{IDALS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
%%
%%
To reinitialize the {\idabbdpre} preconditioner module for the backward problem,
possibly with a change in \id{mudqB}, \id{mldqB}, or \id{dqrelyB}, call the
following function:
%%
\ucfunctionf{IDABBDPrecReInitB}
{
  flag = IDABBDPrecReInitB(ida\_mem, which, mudqB, mldqB, dqrelyB);
}
{
  The function \ID{IDABBDPrecReInitB} reinitializes the {\idabbdpre} preconditioner
  for the backward problem.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block returned by \id{IDACreate}.
  \item[which] (\id{int})
    the identifier of the backward problem.
  \item[mudqB] (\id{sunindextype})
    upper half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[mldqB] (\id{sunindextype})
    lower half-bandwidth to be used in the difference-quotient Jacobian approximation.
  \item[dqrelyB] (\id{realtype})
    the relative increment in components of \id{yB} used in the difference quotient
    approximations.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of:
  \begin{args}[IDALS\_ILL\_INPUT]
  \item[\Id{IDALS\_SUCCESS}]
    The call to \id{IDABBDPrecReInitB} was successful.
  \item[\Id{IDALS\_MEM\_FAIL}]
    A memory allocation request has failed.
  \item[\Id{IDALS\_MEM\_NULL}]
    The \id{ida\_mem} argument was \id{NULL}.
  \item[\Id{IDALS\_PMEM\_NULL}]
    The \id{IDABBDPrecInitB} has not been previously called.
  \item[\Id{IDALS\_LMEM\_NULL}]
    No linear solver has been attached.
  \item[\Id{IDALS\_ILL\_INPUT}]
    An invalid parameter has been passed.
  \end{args}
}
{}
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-callable functions|)}
%%
For more details on {\idabbdpre} see \S\ref{sss:idabbdpre}.

\subsection{User-supplied functions for IDABBDPRE}
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-supplied functions|(}
To use the {\idabbdpre} module, the user must supply one or two functions which the
module calls to construct the preconditioner: a required function \id{GresB}
(of type \id{IDABBDLocalFnB}) which approximates the residual of the backward
problem and which is computed locally, and an optional function \id{GcommB}
(of type \id{IDABBDCommFnB}) which performs all interprocess communication necessary 
to evaluate this approximate residual (see \S\ref{sss:idabbdpre}).
The prototypes for these two functions are described below.
%%
%%
\usfunction{IDABBDLocalFnB}
{
  typedef int (*IDABBDLocalFnB)(&sunindextype NlocalB, realtype t,  \\
                                &N\_Vector y, N\_Vector yp, \\
                                &N\_Vector yB, N\_Vector ypB, \\
                                &N\_Vector gB, void *user\_dataB);
}
{
  This \id{GresB} function loads the vector \id{gB}, an approximation to the
  residual of the backward problem, as a function of \id{t}, \id{y}, \id{yp}, 
  and \id{yB} and \id{ypB}.  
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length for the backward problem.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[gB]
    is the output vector, $G_B(t,y,\dot y, y_B, \dot y_B)$.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}      
    parameter passed to \id{IDASetUserDataB}.  
  \end{args}
}
{
  An \id{IDABBDLocalFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_LSETUP\_FAIL}). 
}
{
  This routine must assume that all interprocess communication of data needed to 
  calculate \id{gB} has already been done, and this data is accessible within
  \id{user\_dataB}.

  {\warn}Before calling the user's \id{IDABBDLocalFnB}, {\idas} needs to evaluate
  (through interpolation) the values of the states from the forward integration. 
  If an error occurs in the interpolation, {\idas} triggers an unrecoverable
  failure in the preconditioner setup function which will halt the integration
  (\id{IDASolveB} returns \id{IDA\_LSETUP\_FAIL}).
}
%%
%%
\usfunction{IDABBDCommFnB}
{
  typedef int (*IDABBDCommFnB)(&sunindextype NlocalB, realtype t,  \\
                           &N\_Vector y, N\_Vector yp, \\
                           &N\_Vector yB, N\_Vector ypB, \\
                           &void *user\_dataB);
}
{
  This \id{GcommB} function performs all interprocess communications necessary 
  for the execution of the \id{GresB} function above, using the input 
  vectors \id{y}, \id{yp}, \id{yB} and \id{ypB}.
}
{
  \begin{args}[user\_dataB]
  \item[NlocalB] 
    is the local vector length.
  \item[t]
    is the value of the independent variable.
  \item[y]
    is the current value of the forward solution vector.
  \item[yp]
    is the current value of the forward solution derivative vector.
  \item[yB]
    is the current value of the backward dependent variable vector.
  \item[ypB]
    is the current value of the backward dependent derivative vector.
  \item[user\_dataB]
    is a pointer to user data --- the same as the \Id{user\_dataB}
    parameter passed to \id{IDASetUserDataB}.
  \end{args}
}
{
  An \id{IDABBDCommFnB} should return 0 if successful, a positive value if a recoverable
  error occurred (in which case {\idas} will attempt to correct), or a negative 
  value if it failed unrecoverably (in which case the integration is halted and
  \id{IDASolveB} returns \Id{IDA\_LSETUP\_FAIL}). 
}
{
  The \id{GcommB} function is expected to save communicated data in space defined within the
  structure \id{user\_dataB}. 

  Each call to the \id{GcommB} function is preceded by a call to the function that 
  evaluates the residual of the backward problem with the same \id{t}, \id{y}, \id{yp}, 
  \id{yB} and \id{ypB} arguments. If there is no additional communication needed, then 
  pass \id{GcommB} $=$ \id{NULL} to \id{IDABBDPrecInitB}.
}
\index{IDABBDPRE@{\idabbdpre} preconditioner!user-supplied functions|)}
%%
%%
\index{IDABBDPRE@{\idabbdpre} preconditioner!usage with adjoint module|)}
