%===================================================================================
\chapter{Description of the SUNNonlinearSolver module}\label{c:sunnonlinsol}
%===================================================================================
\index{SUNNonlinearSolver@\texttt{SUNNonlinearSolver} module}
\input{sunnonlinsol_generic}

%---------------------------------------------------------------------------
\section{IDAS SUNNonlinearSolver interface}
\label{s:sunnonlinsol_interface}
%---------------------------------------------------------------------------

As discussed in Chapter \ref{s:math} each integration step requires the
(approximate) solution of the nonlinear system
\begin{equation}
  G(y_n) = F\left(t_n, y_n, h_{n}^{-1}\sum_{i=0}^{q}\alpha_{n,i}y_{n-i}\right) = 0.
\end{equation}
Rather than solving this system for the new state $y_n$ {\ida} reformulates the
system to solve for the correction $y_{cor}$ to the predicted new state $y_{pred}$
and its derivative $\dot{y}_{pred}$ so that $y_n = y_{pred} + y_{cor}$ and
$\dot{y}_n = \dot{y}_{pred} + h_{n}^{-1} \alpha_{n,0} y_{cor}$. The nonlinear
system rewritten in terms of $y_{cor}$ is
\begin{equation}
  G(y_{cor}) = F\left(t_n, y_{pred}+y_{cor},
  \dot{y}_{pred} + \alpha y_{cor}\right) = 0.
\end{equation}
where $\alpha = h_{n}^{-1} \alpha_{n,0}$.
Similarly in the forward sensitivity analysis case the nonlinear system is also
reformulated in terms of the correction to the predicted sensitivities.

The nonlinear system function provided by {\ida} to the nonlinear solver module
internally updates the current value of the new state and its derivative based
on the current corretion passed to the function (as well as the sensitivities).
These values are used when calling the DAE residual function and when setting up
linear solves (e.g., for updating the Jacobian or preconditioner).

{\idas} provides several advanced functions that will not be needed by most users,
but might be useful for users who choose to provide their own implementation of
the \id{SUNNonlinearSolver} API. For example, such a user might need access to
the current $y$ and $\dot{y}$ vectors to compute Jacobian data.

\ucfunction{IDAGetCurrentCj}
{
  flag = IDAGetCurrentCj(ida\_mem, \&cj);
}
{
  The function \ID{IDAGetCurrentCj} returns the scalar $c_j$
  which is proportional to the inverse of the step size ($\alpha$ in
  Eq. (\ref{e:DAE_Jacobian}).
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\ida} memory block.
  \item[cj] (\id{realtype})
    the value of $c_j$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAGetCurrentY}
{
  flag = IDAGetCurrentY(ida\_mem, \&y);
}
{
  The function \ID{IDAGetCurrentY} returns the current $y$ vector.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\ida} memory block.
  \item[y] (\id{N\_Vector *})
    the current $y$ vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAGetCurrentYp}
{
  flag = IDAGetCurrentYp(ida\_mem, \&yp);
}
{
  The function \ID{IDAGetCurrentYp} returns the current $\dot{y}$ vector.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\ida} memory block.
  \item[yp] (\id{N\_Vector *})
    the current $\dot{y}$ vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAGetCurrentYSens}
{
  flag = IDAGetCurrentYSens(ida\_mem, \&yyS);
}
{
  The function \ID{IDAGetCurrentYSens} returns the current sensitivity
  vector array.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\ida} memory block.
  \item[yyS] (\id{N\_Vector **})
    pointer to the vector array that is set to the array of sensitivity vectors
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAGetCurrentYpSens}
{
  flag = IDAGetCurrentYpSens(ida\_mem, \&ypS);
}
{
  The function \ID{IDAGetCurrentYpSens} returns the derivative the current
  sensitivity vector array.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\ida} memory block.
  \item[ypS] (\id{N\_Vector **})
    pointer to the vector array that is set to the array of sensitivity
    vector derivatives
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAComputeY}
{
  flag = IDAComputeY(ida\_mem, ycor, y);
}
{
  The function computes the current $y$ vector based on the given correction
  vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item \id{ida\_mem} - (\id{void *}) pointer to the {\ida} memory block
    \item \id{ycor} - (\id{N\_Vector}) the correction
    \item \id{y} - (\id{N\_Vector}) the output vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAComputeYp}
{
  flag = IDAComputeYp(ida\_mem, ycor, yp);
}
{
  The function computes $\dot{y}$ based on the given correction
  vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item \id{ida\_mem} - (\id{void *}) pointer to the {\ida} memory block
    \item \id{ycor} - (\id{N\_Vector}) the correction
    \item \id{yp} - (\id{N\_Vector}) the output vector array
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAComputeYSens}
{
  flag = IDAComputeYSens(ida\_mem, ycorS, yys);
}
{
  The function computes the sensitivities based on the given correction
  vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item \id{ida\_mem} - (\id{void *}) pointer to the {\ida} memory block
    \item \id{ycorS} - (\id{N\_Vector} *) the correction
    \item \id{yyS} - (\id{N\_Vector} *) the output vector array
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunction{IDAComputeYpSens}
{
  flag = IDAComputeYpSens(ida\_mem, ycorS, ypS);
}
{
  The function computes the sensitivity derivatives based on the
  given correction vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item \id{ida\_mem} - (\id{void *}) pointer to the {\ida} memory block
    \item \id{ycorS} - (\id{N\_Vector *}) the correction
    \item \id{ypS} - (\id{N\_Vector *}) the output vector array
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

%---------------------------------------------------------------------------
% sunnonlinsol module sections
%---------------------------------------------------------------------------

\input{sunnonlinsol_newton}
\input{sunnonlinsol_petscsnes}
