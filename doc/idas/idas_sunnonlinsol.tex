%===============================================================================
\chapter{Description of the SUNNonlinearSolver module}\label{c:sunnonlinsol}
%===============================================================================
\index{SUNNonlinearSolver@\texttt{SUNNonlinearSolver} module}
\input{sunnonlinsol_generic}

%---------------------------------------------------------------------------
\section{IDAS SUNNonlinearSolver interface}
\label{s:sunnonlinsol_interface}
%---------------------------------------------------------------------------

As discussed in Chapter \ref{s:math} each integration step requires the
(approximate) solution of the nonlinear system
\begin{equation}
  G(y_n) = F\left(t_n, y_n, h_{n}^{-1}\sum_{i=0}^{q}\alpha_{n,i}y_{n-i}\right) = 0.
\end{equation}
Rather than solving this system for the new state $y_n$ {\idas} reformulates the
system to solve for the correction $y_{cor}$ to the predicted new state $y_{pred}$
and its derivative $\dot{y}_{pred}$ so that $y_n = y_{pred} + y_{cor}$ and
$\dot{y}_n = \dot{y}_{pred} + h_{n}^{-1} \alpha_{n,0} y_{cor}$. The nonlinear
system rewritten in terms of $y_{cor}$ is
\begin{equation} \label{eq:res_corrector}
  G(y_{cor}) = F\left(t_n, y_{pred}+y_{cor},
  \dot{y}_{pred} + \alpha y_{cor}\right) = 0.
\end{equation}
where $\alpha = h_{n}^{-1} \alpha_{n,0}$.
Similarly in the forward sensitivity analysis case the nonlinear system is also
reformulated in terms of the correction to the predicted sensitivities.

The nonlinear system function provided by {\idas} to the nonlinear solver module
internally updates the current value of the new state and its derivative based
on the current corretion passed to the function (as well as the sensitivities).
These values are used when calling the DAE residual function and when setting up
linear solves (e.g., for updating the Jacobian or preconditioner).

{\idas} provides several advanced functions that will not be needed by most users,
but might be useful for users who choose to provide their own implementation of
the \id{SUNNonlinearSolver} API. For example, such a user might need access to
the current $y$ and $\dot{y}$ vectors to compute Jacobian data.

\ucfunctionf{IDAGetCurrentCj}
{
  flag = IDAGetCurrentCj(ida\_mem, \&cj);
}
{
  The function \ID{IDAGetCurrentCj} returns the scalar $c_j$
  which is proportional to the inverse of the step size ($\alpha$ in
  Eq. \ref{e:DAE_Jacobian}).
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[cj] (\id{realtype})
    the value of $c_j$.
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAGetCurrentY}
{
  flag = IDAGetCurrentY(ida\_mem, \&y);
}
{
  The function \ID{IDAGetCurrentY} returns the current $y$ vector.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[y] (\id{N\_Vector *})
    the current $y$ vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAGetCurrentYp}
{
  flag = IDAGetCurrentYp(ida\_mem, \&yp);
}
{
  The function \ID{IDAGetCurrentYp} returns the current $\dot{y}$ vector.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[yp] (\id{N\_Vector *})
    the current $\dot{y}$ vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAGetCurrentYSens}
{
  flag = IDAGetCurrentYSens(ida\_mem, \&yyS);
}
{
  The function \ID{IDAGetCurrentYSens} returns the current sensitivity
  vector array.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[yyS] (\id{N\_Vector **})
    pointer to the vector array that is set to the array of sensitivity vectors
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAGetCurrentYpSens}
{
  flag = IDAGetCurrentYpSens(ida\_mem, \&ypS);
}
{
  The function \ID{IDAGetCurrentYpSens} returns the derivative the current
  sensitivity vector array.
}
{
  \begin{args}[ida\_mem]
  \item[ida\_mem] (\id{void *})
    pointer to the {\idas} memory block.
  \item[ypS] (\id{N\_Vector **})
    pointer to the vector array that is set to the array of sensitivity
    vector derivatives
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAGetNonlinearSystemData}
{
  flag = IDAGetNonlinearSystemData(&ida\_mem, \&tcur, \&yypred, \&yppred, \\
                                   &\&yyn, \&ypn, \&res, \&cj, user\_data);
}
{
  The function \ID{IDAGetNonlinearSystemData} returns all internal
  data required to construct the current nonlinear system
  \eqref{eq:res_corrector}.
}
{
  \begin{args}[user\_data]
  \item[ida\_mem] (\id{void *}) pointer to the {\idas} memory block.
  \item[tcur] (\id{realtype*}) current value of the independent variable $t_n$.
  \item[yypred] (\id{N\_Vector*}) predicted value of $y_{pred}$ at $t_n$.
  \item[yppred] (\id{N\_Vector*}) predicted value of $\dot{y}_{pred}$ at $t_n$.
  \item[yyn] (\id{N\_Vector*}) the vector $y_n$. This vector may be not current
    and may need to be filled (see the note below).
  \item[ypn] (\id{N\_Vector*}) the vector $\dot{y}_n$. This vector may be not
    current and may need to be filled (see the note below).
  \item[res] (\id{N\_Vector*}) the resiudal function evaluated at the current
    time and state, $F(t_n, y_n, \dot{y}_n)$. This vector may be not current and
    may need to be filled (see the note below).
  \item[cj] (\id{realtype*}) the scalar $c_j$ which is proportional to the
  inverse of the step size ($\alpha$ in \eqref{eq:res_corrector}).
  \item[user\_data] (\id{void**}) pointer to the user-defined data structures
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output values have been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  This routine is intended for users who wish to attach a custom
  \id{SUNNonlinSolSysFn} (see \S\ref{ss:sunnonlinsol_sunsuppliedfn}) to an
  existing \id{SUNNonlinearSolver} object (through a call to
  \id{SUNNonlinSolSetSysFn}) or who need access to nonlinear system data to
  compute the nonlinear system fucntion as part of a custom
  \id{SUNNonlinearSolver} object.

  When supplying a custom \id{SUNNonlinSolSysFn} to an existing
  \id{SUNNonlinearSolver} object, the user should call
  \id{IDAGetNonlinearSystemData} \textbf{inside} the nonlinear system
  function to access the requisite data for evaluting the nonlinear system
  function of their choosing. Additionlly, if the \id{SUNNonlinearSolver} object
  (existing or custom) leverages the \id{SUNNonlinSolLSetupFn} and/or
  \id{SUNNonlinSolLSolveFn} functions supplied by {\idas} (through calls to
  \id{SUNNonlinSolSetLSetupFn} and \id{SUNNonlinSolSetLSolveFn} respectively)
  the vectors \id{yyn}, \id{ypn}, and \id{res} \textbf{must be filled} in by the
  user's \id{SUNNonlinSolSysFn} with the current state and corresponding
  evaluation of the right-hand side function respectively i.e.,
  \begin{align*}
    yyn &= y_{pred} + y_{cor}, \\
    ypn &= \dot{y}_{pred} + \alpha \dot{y}_{cor}, \\
    res &= F\left(t_{n}, y_n, \dot{y}_n\right),
  \end{align*}
  where $y_{cor}$ was the first argument supplied to the \id{SUNNonlinSolSysFn}.

  If this function is called as part of a custom linear solver (i.e., the
  default \id{SUNNonlinSolSysFn} is used) then the vectors \id{yyn}, \id{ypn},
  and \id{res} are only current when \id{IDAGetNonlinearSystemData} is called
  after an evaluation of the nonlinear system function.
}

\ucfunctionf{IDAGetNonlinearSystemDataSens}
{
  flag = IDAGetNonlinearSystemDataSens(&ida\_mem, \&tcur, \&yySpred, \&ypSpred,\\
                                       &\&yySn, \&ypSn, \&cj, user\_data);
}
{
  The function \ID{IDAGetNonlinearSystemDataSens} returns all internal
  sensitivity data required to construct the current nonlinear system
  \eqref{eq:res_corrector}.
}
{
  \begin{args}[user\_data]
  \item[ida\_mem] (\id{void *}) pointer to the {\idas} memory block.
  \item[tcur] (\id{realtype*}) current value of the independent variable $t_n$.
  \item[yySpred] (\id{N\_Vector**}) predicted value of $yS_{i,pred}$ at $t_n$
    for $i = 0 \dots N_s - 1$.
  \item[ypSpred] (\id{N\_Vector**}) predicted value of $\dot{y}S_{i,pred}$ at
    $t_n$ for $i = 0 \dots N_s - 1$.
  \item[yySn] (\id{N\_Vector**}) the vectors $yS_{i,n}$. These vectors may be
    not current (see the note below).
  \item[ypSn] (\id{N\_Vector**}) the vectors $\dot{y}S_{i,n}$. These vectors may
    be not current (see the note below).
  \item[cj] (\id{realtype*}) the scalar $c_j$ which is proportional to the
  inverse of the step size ($\alpha$ in \eqref{eq:res_corrector}).
  \item[user\_data] (\id{void**}) pointer to the user-defined data structures
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output values have been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{
  This routine is intended for users who wish to attach a custom
  \id{SUNNonlinSolSysFn} (see \S\ref{ss:sunnonlinsol_sunsuppliedfn}) to an
  existing \id{SUNNonlinearSolver} object (through a call to
  \id{SUNNonlinSolSetSysFn}) or who need access to nonlinear system data to
  compute the nonlinear system fucntion as part of a custom
  \id{SUNNonlinearSolver} object.

  When supplying a custom \id{SUNNonlinSolSysFn} to an existing
  \id{SUNNonlinearSolver} object, the user should call
  \id{IDAGetNonlinearSystemDataSens} \textbf{inside} the nonlinear system
  function to access the requisite data for evaluting the nonlinear system
  function of their choosing. Additionlly, if the the vectors \id{yySn} and
  \id{ypSn} are provided as additional workspace and do not need to be filled in
  by the user's \id{SUNNonlinSolSysFn}.

  If this function is called as part of a custom linear solver (i.e., the
  default \id{SUNNonlinSolSysFn} is used) then the vectors \id{yySn} and
  \id{ypSn} are only current when \id{IDAGetNonlinearSystemDataSens} is
  called after an evaluation of the nonlinear system function.
}

\ucfunctionf{IDAComputeY}
{
  flag = IDAComputeY(ida\_mem, ycor, y);
}
{
  The function computes the current $y(t)$ vector based on the given correction
  vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item[ida\_mem] (\id{void *}) pointer to the {\idas} memory block
    \item[ycor] (\id{N\_Vector}) the correction
    \item[y] (\id{N\_Vector}) the output vector
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[\Id{IDA\_MEM\_NULL}]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAComputeYp}
{
  flag = IDAComputeYp(ida\_mem, ycor, yp);
}
{
  The function computes $\dot{y}(t)$ based on the given correction
  vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item[ida\_mem] (\id{void *}) pointer to the {\idas} memory block
    \item[ycor] (\id{N\_Vector}) the correction
    \item[yp] (\id{N\_Vector}) the output vector array
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAComputeYSens}
{
  flag = IDAComputeYSens(ida\_mem, ycorS, yys);
}
{
  The function computes the sensitivities based on the given correction
  vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item[ida\_mem] (\id{void *}) pointer to the {\idas} memory block
    \item[ycorS] (\id{N\_Vector} *) the correction
    \item[yyS] (\id{N\_Vector} *) the output vector array
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

\ucfunctionf{IDAComputeYpSens}
{
  flag = IDAComputeYpSens(ida\_mem, ycorS, ypS);
}
{
  The function computes the sensitivity derivatives based on the
  given correction vector from the nonlinear solver.
}
{
  \begin{args}[ida\_mem]
    \item[ida\_mem] (\id{void *}) pointer to the {\idas} memory block
    \item[ycorS] (\id{N\_Vector *}) the correction
    \item[ypS] (\id{N\_Vector *}) the output vector array
  \end{args}
}
{
  The return value \id{flag} (of type \id{int}) is one of
  \begin{args}[IDA\_MEM\_NULL]
  \item[IDA\_SUCCESS]
    The optional output value has been successfully set.
  \item[IDA\_MEM\_NULL]
    The \id{ida\_mem} pointer is \id{NULL}.
  \end{args}
}
{}

%---------------------------------------------------------------------------
% sunnonlinsol module sections
%---------------------------------------------------------------------------

\input{sunnonlinsol_newton}
\input{sunnonlinsol_petscsnes}
