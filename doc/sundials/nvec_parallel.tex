% This is a shared SUNDIALS TEX file with description of
% the MPI parallel nvector implementation
%
\section{The NVECTOR\_PARALLEL implementation}\label{ss:nvec_par}

The {\nvecp} implementation of the {\nvector} module provided with
{\sundials} is based on {\mpi}.  It defines the {\em content}
field of \id{N\_Vector} to be a structure containing the global and local lengths
of the vector, a pointer to the beginning of a contiguous local data array,
an {\mpi} communicator, and a boolean flag {\em own\_data} indicating ownership of
the data array {\em data}.
%%
\begin{verbatim}
struct _N_VectorContent_Parallel {
  sunindextype local_length;
  sunindextype global_length;
  booleantype own_data;
  realtype *data;
  MPI_Comm comm;
};
\end{verbatim}
%%
%%--------------------------------------------

The header file to include when using this module is \id{nvector\_parallel.h}.
The installed module library to link to is
\id{libsundials\_nvecparallel.\textit{lib}}
where \id{\em.lib} is typically \id{.so} for shared libraries and \id{.a}
for static libraries.


% ====================================================================
\subsection{NVECTOR\_PARALLEL accessor macros}
\label{ss:nvec_par_macros}
% ====================================================================

The following macros are provided to access the content of a {\nvecp}
vector. The suffix \id{\_P} in the names denotes the distributed memory
parallel version.
\begin{itemize}

\item
  \ID{NV\_CONTENT\_P}

  This macro gives access to the contents of the parallel
  vector \id{N\_Vector}.

  The assignment \id{v\_cont = NV\_CONTENT\_P(v)} sets
  \id{v\_cont} to be a pointer to the \id{N\_Vector} content
  structure of type \id{struct \_N\_VectorContent\_Parallel}.

  Implementation:

  \verb|#define NV_CONTENT_P(v) ( (N_VectorContent_Parallel)(v->content) )|

\item
  \ID{NV\_OWN\_DATA\_P}, \ID{NV\_DATA\_P},
  \ID{NV\_LOCLENGTH\_P}, \ID{NV\_GLOBLENGTH\_P}

  These macros give individual access to the parts of
  the content of a parallel \id{N\_Vector}.

  The assignment \id{v\_data = NV\_DATA\_P(v)} sets \id{v\_data} to be
  a pointer to the first component of the local data for the \id{N\_Vector} \id{v}.
  The assignment \id{NV\_DATA\_P(v) = v\_data} sets the component array of
  \id{v} to be \id{v\_data} by storing the pointer \id{v\_data}.

  The assignment \id{v\_llen = NV\_LOCLENGTH\_P(v)} sets \id{v\_llen} to be
  the length of the local part of \id{v}.
  The call \id{NV\_LENGTH\_P(v) = llen\_v} sets
  the local length of \id{v} to be \id{llen\_v}.

  The assignment \id{v\_glen = NV\_GLOBLENGTH\_P(v)} sets \id{v\_glen} to
  be the global length of the vector \id{v}.
  The call \id{NV\_GLOBLENGTH\_P(v) = glen\_v} sets the global
  length of \id{v} to be \id{glen\_v}.

  Implementation:

  \verb|#define NV_OWN_DATA_P(v)   ( NV_CONTENT_P(v)->own_data )|

  \verb|#define NV_DATA_P(v)       ( NV_CONTENT_P(v)->data )|

  \verb|#define NV_LOCLENGTH_P(v)  ( NV_CONTENT_P(v)->local_length )|

  \verb|#define NV_GLOBLENGTH_P(v) ( NV_CONTENT_P(v)->global_length )|

\item \ID{NV\_COMM\_P}

  This macro provides access to the {\mpi} communicator used by the {\nvecp}
  vectors.

  Implementation:

  \verb|#define NV_COMM_P(v) ( NV_CONTENT_P(v)->comm )|

\item \ID{NV\_Ith\_P}

  This macro gives access to the individual components of the local data
  array of an \id{N\_Vector}.

  The assignment \id{r = NV\_Ith\_P(v,i)} sets \id{r} to be the value of
  the \id{i}-th component of the local part of \id{v}.
  The assignment \id{NV\_Ith\_P(v,i) = r}
  sets the value of the \id{i}-th component of the local part of \id{v}
  to be \id{r}.

  Here $i$ ranges from $0$ to $n-1$, where $n$ is the local length.

  Implementation:

  \verb|#define NV_Ith_P(v,i) ( NV_DATA_P(v)[i] )|

\end{itemize}


% ====================================================================
\subsection{NVECTOR\_PARALLEL functions}
\label{ss:nvec_par_functions}
% ====================================================================

The {\nvecp} module defines parallel implementations of all vector operations listed
in Tables \ref{ss:nvecops}, \ref{ss:nvecfusedops}, \ref{ss:nvecarrayops},
and \ref{ss:nveclocalops}. Their names
are obtained from those in these tables by appending the suffix \id{\_Parallel}
(e.g. \id{N\_VDestroy\_Parallel}).
The module {\nvecp} provides the following additional
user-callable routines:
%%--------------------------------------
\sunmodfunf{N\_VNew\_Parallel}
{
  This function creates and allocates memory for a parallel vector.
}
{
  N\_Vector N\_VNew\_Parallel(MPI\_Comm comm, sunindextype
  local\_length,
  \newlinefill{N\_Vector N\_VNew\_Parallel}
  sunindextype global\_length);
}
%%--------------------------------------
\sunmodfunf{N\_VNewEmpty\_Parallel}
{
  This function creates a new parallel \id{N\_Vector} with an empty
  (\id{NULL}) data array.
}
{
  N\_Vector N\_VNewEmpty\_Parallel(MPI\_Comm comm, sunindextype
  local\_length,
  \newlinefill{N\_Vector N\_VNewEmpty\_Parallel}
  sunindextype global\_length);
}
%%--------------------------------------
\sunmodfunf{N\_VMake\_Parallel}
{
  This function creates and allocates memory for a parallel vector
  with user-provided data array. This function does {\em not} allocate memory
  for \id{v\_data} itself.
}
{
  N\_Vector N\_VMake\_Parallel(MPI\_Comm comm,
  sunindextype local\_length,
  \newlinefill{N\_Vector N\_VMake\_Parallel}
  sunindextype global\_length,
  realtype *v\_data);
}
%%--------------------------------------
\sunmodfunf{N\_VCloneVectorArray\_Parallel}
{
  This function creates (by cloning) an array of \id{count} parallel vectors.
}
{
  N\_Vector *N\_VCloneVectorArray\_Parallel(int count, N\_Vector w);
}
%%--------------------------------------
\sunmodfunf{N\_VCloneVectorArrayEmpty\_Parallel}
{
  This function creates (by cloning) an array of \id{count} parallel vectors,
  each with an empty (\id{NULL}) data array.
}
{
  N\_Vector *N\_VCloneVectorArrayEmpty\_Parallel(int count, N\_Vector w);
}
%%--------------------------------------
\sunmodfunf{N\_VDestroyVectorArray\_Parallel}
{
  This function frees memory allocated for the array of \id{count}  variables of
  type \id{N\_Vector} created with \id{N\_VCloneVectorArray\_Parallel} or with \\
  \id{N\_VCloneVectorArrayEmpty\_Parallel}.
}
{
  void N\_VDestroyVectorArray\_Parallel(N\_Vector *vs, int count);
}
%%--------------------------------------
\sunmodfunf{N\_VGetLocalLength\_Parallel}
{
  This function returns the local vector length.
}
{
  sunindextype N\_VGetLocalLength\_Parallel(N\_Vector v);
}
%%--------------------------------------
\sunmodfunf{N\_VPrint\_Parallel}
{
  This function prints the local content of a parallel vector to \id{stdout}.
}
{
  void N\_VPrint\_Parallel(N\_Vector v);
}
%%--------------------------------------
\sunmodfunf{N\_VPrintFile\_Parallel}
{
  This function prints the local content of a parallel vector to \id{outfile}.
}
{
  void N\_VPrintFile\_Parallel(N\_Vector v, FILE *outfile);
}
%%--------------------------------------
By default all fused and vector array operations are disabled in the {\nvecp}
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with \id{N\_VNew\_Parallel}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using \id{N\_VClone} with that vector. This guarantees the new vectors will
have the same operations enabled/disabled as cloned vectors inherit the same
enable/disable options as the vector they are cloned from while vectors created with
\id{N\_VNew\_Parallel} will have the default settings for the {\nvecp} module.
%%--------------------------------------
\sunmodfunf{N\_VEnableFusedOps\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) all fused and
  vector array operations in the parallel vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableFusedOps\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableLinearCombination\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the linear
  combination fused operation in the parallel vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableLinearCombination\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableScaleAddMulti\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the scale and
  add a vector to multiple vectors fused operation in the parallel vector. The
  return value is \id{0} for success and \id{-1} if the input vector or its
  \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableScaleAddMulti\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableDotProdMulti\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the multiple
  dot products fused operation in the parallel vector. The return value is \id{0}
  for success and \id{-1} if the input vector or its \id{ops} structure are
  \id{NULL}.
}
{
  int N\_VEnableDotProdMulti\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableLinearSumVectorArray\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the linear sum
  operation for vector arrays in the parallel vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableLinearSumVectorArray\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableScaleVectorArray\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the scale
  operation for vector arrays in the parallel vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableScaleVectorArray\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableConstVectorArray\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the const
  operation for vector arrays in the parallel vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableConstVectorArray\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableWrmsNormVectorArray\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the WRMS norm
  operation for vector arrays in the parallel vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableWrmsNormVectorArray\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfunf{N\_VEnableWrmsNormMaskVectorArray\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the masked WRMS
  norm operation for vector arrays in the parallel vector. The return value is
  \id{0} for success and \id{-1} if the input vector or its \id{ops} structure are
  \id{NULL}.
}
{
  int N\_VEnableWrmsNormMaskVectorArray\_Parallel(N\_Vector v, booleantype tf);
}
%%--------------------------------------
\sunmodfun{N\_VEnableScaleAddMultiVectorArray\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the scale and
  add a vector array to multiple vector arrays operation in the parallel vector. The
  return value is \id{0} for success and \id{-1} if the input vector or its
  \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableScaleAddMultiVectorArray\_Parallel(N\_Vector v,
  \newlinefill{int N\_VEnableScaleAddMultiVectorArray\_Parallel}
  booleantype tf);
}
%%--------------------------------------
\sunmodfun{N\_VEnableLinearCombinationVectorArray\_Parallel}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the linear
  combination operation for vector arrays in the parallel vector. The return value
  is \id{0} for success and \id{-1} if the input vector or its \id{ops} structure
  are \id{NULL}.
}
{
  int N\_VEnableLinearCombinationVectorArray\_Parallel(N\_Vector v,
  \newlinefill{int N\_VEnableLinearCombinationVectorArray\_Parallel}
  booleantype tf);
}
%%
%%------------------------------------
%%
\paragraph{\bf Notes}

\begin{itemize}

\item
  When looping over the components of an \id{N\_Vector} \id{v}, it is
  more efficient to first obtain the local component array via
  \id{v\_data = NV\_DATA\_P(v)} and then access \id{v\_data[i]} within the
  loop than it is to use \id{NV\_Ith\_P(v,i)} within the loop.

\item
  {\warn}\id{N\_VNewEmpty\_Parallel}, \id{N\_VMake\_Parallel},
  and \id{N\_VCloneVectorArrayEmpty\_Parallel} set the field
  {\em own\_data} $=$ \id{SUNFALSE}.
  \id{N\_VDestroy\_Parallel} and \id{N\_VDestroyVectorArray\_Parallel}
  will not attempt to free the pointer {\em data} for any \id{N\_Vector} with
  {\em own\_data} set to \id{SUNFALSE}. In such a case, it is the user's responsibility to
  deallocate the {\em data} pointer.

\item
  {\warn}To maximize efficiency, vector operations in the {\nvecp} implementation
  that have more than one \id{N\_Vector} argument do not check for
  consistent internal representation of these vectors. It is the user's
  responsibility to ensure that such routines are called with \id{N\_Vector}
  arguments that were all created with the same internal representations.

\end{itemize}


% ====================================================================
\subsection{NVECTOR\_PARALLEL Fortran interfaces}
\label{ss:nvec_par_fortran}
% ====================================================================

For solvers that include a {\F} 77 interface module, the {\nvecp} module
also includes a {\F}-callable function
\id{FNVINITP(COMM, code, NLOCAL, NGLOBAL, IER)},
to initialize this {\nvecp} module.  Here \id{COMM} is the MPI communicator,
\id{code} is an input solver id (1 for {\cvode}, 2 for {\ida}, 3 for {\kinsol},
4 for {\arkode}); \id{NLOCAL} and \id{NGLOBAL} are the local and global
vector sizes, respectively (declared so as to match C type \id{long int});
and IER is an error return flag equal 0 for success and -1 for failure.
{\warn}NOTE: If the header file \id{sundials\_config.h} defines
\id{SUNDIALS\_MPI\_COMM\_F2C} to be $1$ (meaning the {\mpi}
implementation used to build {\sundials} includes the
\id{MPI\_Comm\_f2c} function), then \id{COMM} can be any valid
{\mpi} communicator. Otherwise, \id{MPI\_COMM\_WORLD} will be used, so
just pass an integer value as a placeholder.
