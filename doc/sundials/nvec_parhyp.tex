% This is a shared SUNDIALS TEX file with description of
% the MPI parallel ParHyp hypre nvector implementation
%
\section{The NVECTOR\_PARHYP implementation}\label{ss:nvec_parhyp}

The {\nvecph} implementation of the {\nvector} module provided with
{\sundials} is a wrapper around {\hypre}'s ParVector class. 
Most of the vector kernels simply call {\hypre} vector operations. 
The implementation defines the {\em content} field of \id{N\_Vector} to 
be a structure containing the global and local lengths of the vector, a 
pointer to an object of type \id{HYPRE\_ParVector}, an {\mpi} communicator, 
and a boolean flag {\em own\_parvector} indicating ownership of the
{\hypre} parallel vector object {\em x}.
%%
%%
\begin{verbatim}
struct _N_VectorContent_ParHyp {
  sunindextype local_length;
  sunindextype global_length;
  booleantype own_parvector;
  MPI_Comm comm;
  HYPRE_ParVector x;
};
\end{verbatim}
%%
%%--------------------------------------------
The header file to include when using this module is \id{nvector\_parhyp.h}.
The installed module library to link to is
\id{libsundials\_nvecparhyp.\textit{lib}}
where \id{\em.lib} is typically \id{.so} for shared libraries and \id{.a}
for static libraries.

Unlike native {\sundials} vector types, {\nvecph} does not provide macros 
to access its member variables.
Note that {\nvecph} requires {\sundials} to be built with {\mpi} support.


% ====================================================================
\subsection{NVECTOR\_PARHYP functions}
\label{ss:nvec_parhyp_functions}
% ====================================================================

The {\nvecph} module defines implementations of all vector operations 
listed in Tables \ref{ss:nvecops}, \ref{ss:nvecfusedops},
\ref{ss:nvecarrayops}, and \ref{ss:nveclocalops}, except
for \id{N\_VSetArrayPointer} and \id{N\_VGetArrayPointer}, because accessing raw vector
data is handled by low-level {\hypre} functions.
As such, this vector is not available for use with {\sundials} Fortran interfaces.
When access to raw vector data is needed, one
should extract the {\hypre} vector first, and then use {\hypre}
methods to access the data. Usage examples of {\nvecph} are provided in
the \id{cvAdvDiff\_non\_ph.c} example program for {\cvode} \cite{cvode_ex}
and the \id{ark\_diurnal\_kry\_ph.c} example program for {\arkode} \cite{arkode_ex}.

The names of parhyp methods are obtained from those in Tables \ref{ss:nvecops},
\ref{ss:nvecfusedops}, \ref{ss:nvecarrayops}, and \ref{ss:nveclocalops}
by appending the suffix \id{\_ParHyp} (e.g. \id{N\_VDestroy\_ParHyp}).
The module {\nvecph} provides the following additional user-callable routines:
%%--------------------------------------
\sunmodfun{N\_VNewEmpty\_ParHyp}
{
  This function creates a new parhyp \id{N\_Vector} with the pointer to the {\hypre} 
  vector set to \id{NULL}.
}
{
  N\_Vector N\_VNewEmpty\_ParHyp(MPI\_Comm comm, sunindextype local\_length,
  \newlinefill{N\_Vector N\_VNewEmpty\_ParHyp}
  sunindextype global\_length)
}
%%--------------------------------------
\sunmodfun{N\_VMake\_ParHyp}
{  
  This function creates an \id{N\_Vector} wrapper around an existing
  {\hypre} parallel vector. It does {\em not} allocate memory for \id{x} 
  itself.  
}
{
  N\_Vector N\_VMake\_ParHyp(HYPRE\_ParVector x)
}
%%--------------------------------------
\sunmodfun{N\_VGetVector\_ParHyp}
{  
  This function returns the underlying {\hypre} vector.
}
{
  HYPRE\_ParVector N\_VGetVector\_ParHyp(N\_Vector v)
}
%%--------------------------------------
\sunmodfun{N\_VCloneVectorArray\_ParHyp}
{ 
  This function creates (by cloning) an array of \id{count} parallel vectors.
}
{
  N\_Vector *N\_VCloneVectorArray\_ParHyp(int count, N\_Vector w)
}
%%--------------------------------------
\sunmodfun{N\_VCloneVectorArrayEmpty\_ParHyp}
{
  This function creates (by cloning) an array of \id{count} parallel vectors,
  each with an empty (\id{NULL}) data array.
}
{
  N\_Vector *N\_VCloneVectorArrayEmpty\_ParHyp(int count, N\_Vector w)
}
%%--------------------------------------
\sunmodfun{N\_VDestroyVectorArray\_ParHyp}
{ 
  This function frees memory allocated for the array of \id{count}  variables of
  type \id{N\_Vector} created with \id{N\_VCloneVectorArray\_ParHyp} or with
  \id{N\_VCloneVectorArrayEmpty\_ParHyp}.
}
{
  void N\_VDestroyVectorArray\_ParHyp(N\_Vector *vs, int count)
}
%%--------------------------------------
\sunmodfun{N\_VPrint\_ParHyp}
{  
  This function prints the local content of a parhyp vector to \id{stdout}.
}
{   
  void N\_VPrint\_ParHyp(N\_Vector v)
}
%%--------------------------------------
\sunmodfun{N\_VPrintFile\_ParHyp}
{  
  This function prints the local content of a parhyp vector to \id{outfile}.
}
{   
  void N\_VPrintFile\_ParHyp(N\_Vector v, FILE *outfile)
}

By default all fused and vector array operations are disabled in the {\nvecph}
module. The following additional user-callable routines are provided to
enable or disable fused and vector array operations for a specific vector. To
ensure consistency across vectors it is recommended to first create a vector
with \id{N\_VMake\_ParHyp}, enable/disable the desired operations for that vector
with the functions below, and create any additional vectors from that vector
using \id{N\_VClone}. This guarantees the new vectors will have the same
operations enabled/disabled as cloned vectors inherit the same enable/disable
options as the vector they are cloned from while vectors created with
\id{N\_VMake\_ParHyp} will have the default settings for the {\nvecph} module.
%%--------------------------------------
\sunmodfun{N\_VEnableFusedOps\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) all fused and
  vector array operations in the parhyp vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableFusedOps\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableLinearCombination\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the linear
  combination fused operation in the parhyp vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableLinearCombination\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableScaleAddMulti\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the scale and
  add a vector to multiple vectors fused operation in the parhyp vector. The
  return value is \id{0} for success and \id{-1} if the input vector or its
  \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableScaleAddMulti\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableDotProdMulti\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the multiple
  dot products fused operation in the parhyp vector. The return value is \id{0}
  for success and \id{-1} if the input vector or its \id{ops} structure are
  \id{NULL}.
}
{
  int N\_VEnableDotProdMulti\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableLinearSumVectorArray\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the linear sum
  operation for vector arrays in the parhyp vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableLinearSumVectorArray\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableScaleVectorArray\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the scale
  operation for vector arrays in the parhyp vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableScaleVectorArray\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableConstVectorArray\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the const
  operation for vector arrays in the parhyp vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableConstVectorArray\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableWrmsNormVectorArray\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the WRMS norm
  operation for vector arrays in the parhyp vector. The return value is \id{0} for
  success and \id{-1} if the input vector or its \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableWrmsNormVectorArray\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableWrmsNormMaskVectorArray\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the masked WRMS
  norm operation for vector arrays in the parhyp vector. The return value is
  \id{0} for success and \id{-1} if the input vector or its \id{ops} structure are
  \id{NULL}.
}
{
  int N\_VEnableWrmsNormMaskVectorArray\_ParHyp(N\_Vector v, booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableScaleAddMultiVectorArray\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the scale and
  add a vector array to multiple vector arrays operation in the parhyp vector. The
  return value is \id{0} for success and \id{-1} if the input vector or its
  \id{ops} structure are \id{NULL}.
}
{
  int N\_VEnableScaleAddMultiVectorArray\_ParHyp(N\_Vector v,
  \newlinefill{int N\_VEnableScaleAddMultiVectorArray\_ParHyp}
  booleantype tf)
}
%%--------------------------------------
\sunmodfun{N\_VEnableLinearCombinationVectorArray\_ParHyp}
{
  This function enables (\id{SUNTRUE}) or disables (\id{SUNFALSE}) the linear
  combination operation for vector arrays in the parhyp vector. The return value
  is \id{0} for success and \id{-1} if the input vector or its \id{ops} structure
  are \id{NULL}.
}
{
  int N\_VEnableLinearCombinationVectorArray\_ParHyp(N\_Vector v,
  \newlinefill{int N\_VEnableLinearCombinationVectorArray\_ParHyp}
  booleantype tf)
}
%%
%%------------------------------------
%%
\paragraph{\bf Notes} 
           
\begin{itemize}
                                        
\item
  When there is a need to access components of an \id{N\_Vector\_ParHyp}, \id{v}, 
  it is recommended to extract the {\hypre} vector via       
  \id{x\_vec = N\_VGetVector\_ParHyp(v)} and then access components using 
  appropriate {\hypre} functions.        
                                                               
\item
  {\warn}\id{N\_VNewEmpty\_ParHyp}, \id{N\_VMake\_ParHyp}, 
  and \id{N\_VCloneVectorArrayEmpty\_ParHyp} set the field 
  {\em own\_parvector} to \id{SUNFALSE}. 
  \id{N\_VDestroy\_ParHyp} and \id{N\_VDestroyVectorArray\_ParHyp}
  will not attempt to delete an underlying {\hypre} vector for any \id{N\_Vector} 
  with {\em own\_parvector} set to \id{SUNFALSE}. In such a case, it is the 
  user's responsibility to delete the underlying vector.

\item
  {\warn}To maximize efficiency, vector operations in the {\nvecph} implementation
  that have more than one \id{N\_Vector} argument do not check for
  consistent internal representations of these vectors. It is the user's 
  responsibility to ensure that such routines are called with \id{N\_Vector}
  arguments that were all created with the same internal representations.

\end{itemize}
