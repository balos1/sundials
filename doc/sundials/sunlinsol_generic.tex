% This is a shared SUNDIALS TEX file with description of
% the generic sunlinsol abstraction
%
For problems that involve the solution of linear systems of equations,
the {\sundials} packages operate using generic linear solver modules
defined through the {\sunlinsol} API.  This allows {\sundials}
packages to utilize any valid {\sunlinsol} implementation that provides
a set of required functions.  These functions can be divided into
three categories.  The first are the core linear solver functions.  The
second group consists of ``set'' routines to supply the linear solver object
with functions provided by the {\sundials} package, or for modification
of solver parameters.  The last group consists of ``get'' routines for
retrieving artifacts (statistics, residual vectors, etc.) from the
linear solver.  All of these functions are defined in the header file
\Id{sundials/sundials\_linearsolver.h}.

The implementations provided with {\sundials} work in coordination
with the {\sundials} generic {\nvector} and {\sunmatrix} modules to
provide a set of compatible data structures and solvers for the
solution of linear systems using direct or iterative (matrix-based or matrix-free)
methods.  Moreover, advanced users can provide a customized
\Id{SUNLinearSolver} implementation to any {\sundials} package,
particularly in cases where they provide their own {\nvector} and/or
{\sunmatrix} modules.

Historically, the {\sundials} packages have been designed to specifically
leverage the use of either \emph{direct linear solvers} or matrix-free,
\emph{scaled, preconditioned, iterative linear solvers}.  However, user-supplied
implementations for matrix-based iterative linear solvers and linear solvers
with `embedded' matrices are also supported.

The iterative linear solvers packaged with {\sundials} leverage
scaling and preconditioning, as applicable, to balance error between
solution components and to accelerate convergence of the linear
solver.  To this end, instead of solving the  linear system $Ax = b$
directly, these apply the underlying iterative algorithm to the
transformed system
\begin{equation}
  \label{eq:transformed_linear_system}
  \tilde{A} \tilde{x} = \tilde{b}
\end{equation}
where
\begin{align}
  \notag
  \tilde{A} &= S_1 P_1^{-1} A P_2^{-1} S_2^{-1},\\
  \label{eq:transformed_linear_system_components}
  \tilde{b} &= S_1 P_1^{-1} b,\\
  \notag
  \tilde{x} &= S_2 P_2 x,
\end{align}
and where
\begin{itemize}
\item $P_1$ is the left preconditioner,
\item $P_2$ is the right preconditioner,
\item $S_1$ is a diagonal matrix of scale factors for $P_1^{-1} b$,
\item $S_2$ is a diagonal matrix of scale factors for $P_2 x$.
\end{itemize}
The scaling matrices are chosen so that $S_1 P_1^{-1} b$ and $S_2 P_2 x$
have dimensionless components. If preconditioning is done on the left only
($P_2 = I$), by a  matrix $P$, then $S_2$ must be a scaling for $x$, while $S_1$
is a scaling for $P^{-1} b$, and so may also be taken as a scaling for $x$.
Similarly, if preconditioning is done on the right only ($P_1 = I$ and
$P_2 = P$), then $S_1$ must be a scaling for $b$, while $S_2$ is a scaling for
$P x$, and may also be taken as a scaling for $b$.

{\sundials} packages request that iterative linear solvers stop
based on the 2-norm of the scaled preconditioned residual meeting a
prescribed tolerance
\[
  \left\| \tilde{b} - \tilde{A} \tilde{x} \right\|_2  <  \text{tol}.
\]

When provided an iterative {\sunlinsol} implementation that does not
support the scaling matrices $S_1$ and $S_2$, {\sundials}'
packages will adjust the value of $\text{tol}$ accordingly
(see \S\ref{ss:sunlinsol_iterative_tolerance} for more details). In
this case, they instead request that iterative linear solvers stop
based on the criteria
\[
   \left\| P_1^{-1} b - P_1^{-1} A x \right\|_2  <  \text{tol}.
\]
We note that the corresponding adjustments to $\text{tol}$ in
this case are non-optimal, in that they cannot balance error between
specific entries of the solution $x$, only the aggregate error
in the overall solution vector.

We further note that not all of the {\sundials}-provided iterative
linear solvers support the full range of the above options (e.g.,
separate left/right preconditioning), and that some of the {\sundials}
packages only utilize a subset of these options.  Further details on
these exceptions are described in the documentation for each
{\sunlinsol} implementation, or for each {\sundials} package.

For users interested in providing their own {\sunlinsol} module, the
following section presents the {\sunlinsol} API and its implementation
beginning with the definition of {\sunlinsol} functions in sections
\ref{ss:sunlinsol_CoreFn} -- \ref{ss:sunlinsol_GetFn}. This is followed by
the definition of functions supplied to a linear solver implementation in
section \ref{ss:sunlinsol_SUNSuppliedFn}. A table of linear solver return
codes is given in section \ref{ss:sunlinsol_ErrorCodes}. The
\id{SUNLinearSolver} type and the generic {\sunlinsol} module are defined
in section \ref{ss:sunlinsol_Generic}.  The section
\ref{ss:sunlinsol_compatibility} discusses compatibility between the
{\sundials}-provided {\sunlinsol} modules and {\sunmatrix} modules.
Section \ref{ss:sunlinsol_custom} lists the requirements for supplying a custom
{\sunlinsol} module and discusses some intended use cases. Users wishing to
supply their own {\sunlinsol} module are encouraged to use the {\sunlinsol}
implementations provided with {\sundials} as a template for supplying custom
linear solver modules. The {\sunlinsol} functions required by this {\sundials}
package as well as other package specific details are given in
section \ref{s:sunlinsol_interface}. The remaining sections of this chapter
present the {\sunlinsol} modules provided with {\sundials}.

% ====================================================================
\section{The SUNLinearSolver API}
\label{s:sunlinsol_api}
% ====================================================================

The {\sunlinsol} API defines several linear solver operations that enable
{\sundials} packages to utilize any {\sunlinsol} implementation that
provides the required functions. These functions can be divided into three
categories. The first are the core linear solver functions. The second group
of functions consists of set routines to supply the linear solver with
functions provided by the {\sundials} time integrators and to modify solver
parameters. The final group consists of get routines for retrieving linear
solver statistics. All of these functions are defined in the header file
\id{sundials/sundials\_linearsolver.h}.



%---------------------------------------------------------------------------
\subsection{\id{SUNLinearSolver} core functions}\label{ss:sunlinsol_CoreFn}

The core linear solver functions consist of two required functions to get the
linear solver type \\ \noindent (\Id{SUNLinSolGetType}) and solve the linear
system $Ax=b$ (\Id{SUNLinSolSolve}). The remaining functions are for getting the
solver ID (\Id{SUNLinSolGetID}), initializing the linear solver object once all
solver-specific options have been set (\Id{SUNLinSolInitialize}), setting up the
linear solver object to utilize an updated matrix $A$ (\Id{SUNLinSolSetup}), and
for destroying the linear solver object (\Id{SUNLinSolFree}) are optional.

% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolGetType}
{
  type = SUNLinSolGetType(LS);
}
{
  The \textit{required} function \Id{SUNLinSolGetType} returns the
  type identifier for the linear solver \id{LS}. It is used to
  determine the solver type (direct, iterative, or matrix-iterative) from
  the abstract \id{SUNLinearSolver} interface.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  The return value \id{type} (of type \id{int}) will be one of the
  following:
  \begin{itemize}
  \item \Id{SUNLINEARSOLVER\_DIRECT} -- \id{0}, the {\sunlinsol} module requires
  a matrix, and computes an `exact' solution to the linear system defined by
  that matrix.
  \item \Id{SUNLINEARSOLVER\_ITERATIVE} -- \id{1}, the {\sunlinsol} module does
  not require a matrix (though one may be provided), and computes an inexact
  solution to the linear system using a matrix-free iterative algorithm. That is
  it solves the linear system defined by the package-supplied \id{ATimes}
  routine (see \Id{SUNLinSolSetATimes} below), even if that linear
  system differs from the one encoded in the matrix object (if one is
  provided). As the solver computes the solution only inexactly (or may
  diverge), the linear solver should check for solution convergence/accuracy as
  appropriate.
  \item \Id{SUNLINEARSOLVER\_MATRIX\_ITERATIVE} -- \id{2}, the {\sunlinsol}
  module requires a matrix, and computes an inexact solution to the linear
  system defined by that matrix using an iterative algorithm. That is it solves
  the linear system defined by the matrix object even if that linear system
  differs from that encoded by the package-supplied \id{ATimes} routine. As the
  solver computes the solution only inexactly (or may diverge), the linear
  solver should check for solution convergence/accuracy as appropriate.
  \item \Id{SUNLINEARSOLVER\_MATRIX\_EMBEDDED} -- \id{3}, the {\sunlinsol} module sets up
  and solves the specified linear system at each linear solve call.  Any
  matrix-related data structures are held internally to the linear solver itself,
  and are not provided by the {\sundials} package.
  \end{itemize}
}
{
 See section \ref{ss:sunlinsol_intended} for more information on intended use
 cases corresponding to the linear solver type.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolGetID}
{
  id = SUNLinSolGetID(LS);
}
{
  The \textit{optional} function \Id{SUNLinSolGetID} returns the
  identifier for the linear solver \id{LS}.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  The return value \id{id} (of type \id{int}) will be a non-negative value
  defined by the enumeration \id{SUNLinearSolver\_ID}.  The possible enumeration
  values are specified in the \id{sundials\_linearsolver.h} header file.
}
{
  It is recommended that a user-supplied \id{SUNLinearSolver} return the\\
  \noindent \id{SUNLINEARSOLVER\_CUSTOM} identifier.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolInitialize}
{
  retval = SUNLinSolInitialize(LS);
}
{
  The \textit{optional} function \Id{SUNLinSolInitialize} performs
  linear solver initialization (assuming that all solver-specific
  options have been set).
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  This should return zero for a
  successful call, and a negative value for a failure, ideally
  returning one of the generic error codes listed in Table
  \ref{t:sunlinsolerr}.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolSetup}
{
  retval = SUNLinSolSetup(LS, A);
}
{
  The \textit{optional} function \Id{SUNLinSolSetup} performs
  any linear solver setup needed, based on an updated system
  {\sunmatrix} \id{A}.  This may be called frequently (e.g., with a full
  Newton method) or infrequently (for a modified Newton method), based
  on the type of integrator and/or nonlinear solver requesting the
  solves.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \item[A] (\id{SUNMatrix})
    a {\sunmatrix} object.
  \end{args}
}
{
  This should return zero for a successful call, a positive
  value for a recoverable failure and a negative value for an
  unrecoverable failure, ideally returning one of the generic error
  codes listed in Table \ref{t:sunlinsolerr}.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolSolve}
{
  retval = SUNLinSolSolve(LS, A, x, b, tol);
}
{
  The \textit{required} function \Id{SUNLinSolSolve} solves a linear system $Ax = b$.
}
{
  \begin{args}[tol]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \item[A] (\id{SUNMatrix})
    a {\sunmatrix} object.
  \item[x] (\id{N\_Vector})
    a {\nvector} object containing the initial guess for the solution of the
    linear system, and the solution to the linear system upon return.
  \item[b] (\id{N\_Vector})
    a {\nvector} object containing the linear system right-hand side.
  \item[tol] (\id{realtype})
    the desired linear solver tolerance.
  \end{args}
}
{
  This should return zero for
  a successful call, a positive value for a recoverable failure and a
  negative value for an unrecoverable failure, ideally returning one
  of the generic error codes listed in Table \ref{t:sunlinsolerr}.
}
{
  {\bf Direct solvers:} can ignore the \id{tol} argument.

  {\bf Matrix-free solvers:} (those that identify as
  \id{SUNLINEARSOLVER\_ITERATIVE}) can ignore the {\sunmatrix} input
  \id{A}, and should instead rely on the matrix-vector product
  function supplied through the routine \Id{SUNLinSolSetATimes}.

  {\bf Iterative solvers:} (those that identify as
  \id{SUNLINEARSOLVER\_ITERATIVE} or \newline
  \id{SUNLINEARSOLVER\_MATRIX\_ITERATIVE})
  should attempt to solve to the specified tolerance \id{tol} in a weighted
  2-norm. If the solver does not support scaling then it should just use a
  2-norm.

  {\bf Matrix-embedded solvers:} should ignore the {\sunmatrix} input \id{A}
  as this will be \id{NULL}.  It is assumed that within this call, the solver
  will call interface routines from the relevant {\sundials} package to
  directly form the relevant linear system matrix $A$, and then solve the system
  before returning with the solution $x$.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolFree}
{
  retval = SUNLinSolFree(LS);
}
{
  The \textit{optional} function \Id{SUNLinSolFree} frees memory allocated by the linear solver.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  This should return zero for a successful call and a negative value
  for a failure.
}
{}
% --------------------------------------------------------------------


%---------------------------------------------------------------------------
\subsection{\id{SUNLinearSolver} set functions}\label{ss:sunlinsol_SetFn}

The following set functions are used to supply linear solver modules with
functions defined by the {\sundials} packages and to modify solver
parameters.  Only the routine for setting the matrix-vector product
routine is required, and even then is only required for matrix-free linear
solver modules.  Otherwise, all other set functions are optional.  {\sunlinsol}
implementations that do not provide the functionality for any optional
routine should leave the corresponding function pointer \id{NULL}
instead of supplying a dummy routine.

% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolSetATimes}
{
  retval = SUNLinSolSetATimes(LS, A\_data, ATimes);
}
{
  The function \Id{SUNLinSolSetATimes} is \textit{required for matrix-free
  linear solvers}; otherwise it is optional.

  This routine provides an \id{ATimesFn} function pointer, as well as
  a \id{void*} pointer to a data structure used by this routine, to a
  linear solver object.  {\sundials} packages will call this function
  to set the matrix-vector product function to either a
  solver-provided difference-quotient via vector operations or a
  user-supplied solver-specific routine.

}
{
  \begin{args}[ATimes]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \item[A\_data] (\id{void*})
    data structure passed to \id{ATimes}.
  \item[ATimes] (\id{ATimesFn})
    function pointer implementing the matrix-vector product routine.
  \end{args}
}
{
  This routine should return zero for a successful call, and a
  negative value for a failure, ideally returning one of the generic
  error codes listed in Table \ref{t:sunlinsolerr}.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolSetPreconditioner}
{
  retval = SUNLinSolSetPreconditioner(LS, Pdata, Pset, Psol);
}
{
  The \emph{optional} function \Id{SUNLinSolSetPreconditioner}
  provides \id{PSetupFn} and \id{PSolveFn} function pointers that
  implement the preconditioner solves $P_1^{-1}$ and $P_2^{-1}$ from
  equations
  \eqref{eq:transformed_linear_system}-\eqref{eq:transformed_linear_system_components}.
  This routine will be called by a {\sundials} package, which will
  provide translation between the generic \id{Pset} and \id{Psol}
  calls and the package- or user-supplied routines.
}
{
  \begin{args}[Pdata]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \item[Pdata] (\id{void*})
    data structure passed to both \id{Pset} and \id{Psol}.
  \item[Pset] (\id{PSetupFn})
    function pointer implementing the preconditioner setup.
  \item[Psol] (\id{PSolveFn})
    function pointer implementing the preconditioner solve.
  \end{args}
}
{
  This routine should return zero for a successful call, and a
  negative value for a failure, ideally returning one of the generic
  error codes listed in Table \ref{t:sunlinsolerr}.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolSetScalingVectors}
{
  retval = SUNLinSolSetScalingVectors(LS, s1, s2);
}
{
  The \emph{optional} function \Id{SUNLinSolSetScalingVectors}
  provides left/right scaling vectors for the linear system
  solve.  Here, \id{s1} and \id{s2} are {\nvector} of positive scale factors
  containing the diagonal of the matrices $S_1$ and $S_2$ from
  equations
  \eqref{eq:transformed_linear_system}-\eqref{eq:transformed_linear_system_components},
  respectively.
  Neither of these vectors need to be tested for positivity, and a \id{NULL}
  argument for either indicates that the corresponding scaling matrix
  is the identity.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \item[s1] (\id{N\_Vector})
    diagonal of the matrix $S_1$
  \item[s2] (\id{N\_Vector})
    diagonal of the matrix $S_2$
  \end{args}
}
{
  This routine should return zero for a successful call, and a
  negative value for a failure, ideally returning one of the generic
  error codes listed in Table \ref{t:sunlinsolerr}.
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolSetZeroGuess}
{
  retval = SUNLinSolSetZeroGuess(LS, onoff);
}
{
  The \emph{optional} function \Id{SUNLinSolSetZeroGuess} indicates if the
  next call to \id{SUNLinSolSolve} will be made with a zero initial guess.
}
{
  \begin{args}[onoff]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \item[onoff] (\id{booleantype})
    a flag indicating if the initial guess to linear solver is zero
    (\id{SUNTRUE}) or non-zero (\id{SUNFALSE}).
  \end{args}
}
{
  This routine should return zero for a successful call, and a
  negative value for a failure, ideally returning one of the generic
  error codes listed in Table \ref{t:sunlinsolerr}.
}
{
  Is is assumed that the initial guess status is not retained across calls to
  \id{SUNLinSolSolve}. As such, the linear solver interfaces in each of the
  {\sundials} packages call \id{SUNLinSolSetZeroGuess} prior to each call to
  \id{SUNLinSolSolve}.
}
% --------------------------------------------------------------------


%---------------------------------------------------------------------------
\subsection{\id{SUNLinearSolver} get functions}\label{ss:sunlinsol_GetFn}

The following get functions allow {\sundials} packages to retrieve
results from a linear solve.  All routines are optional.

% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolNumIters}
{
  its = SUNLinSolNumIters(LS);
}
{
  The \emph{optional} function \Id{SUNLinSolNumIters}
  should return the number of linear iterations performed in
  the last `solve' call.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  \id{int} containing the number of iterations
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolResNorm}
{
  rnorm = SUNLinSolResNorm(LS);
}
{
  The \emph{optional} function \Id{SUNLinSolResNorm}
  should return the final residual norm from the last
  `solve' call.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  \id{realtype} containing the final residual norm
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolResid}
{
  rvec = SUNLinSolResid(LS);
}
{
   If an iterative method computes the preconditioned initial residual
   and returns with a successful solve without performing any
   iterations (i.e., either the initial guess or the preconditioner is
   sufficiently accurate), then this \emph{optional} routine may be
   called by the {\sundials} package.  This routine should return the
   {\nvector} containing the preconditioned initial residual vector.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  \id{N\_Vector} containing the final residual vector
}
{
  Since \id{N\_Vector} is actually a pointer, and the results
  are not modified, this routine should \emph{not} require additional
  memory allocation.  If the {\sunlinsol} object does not retain a
  vector for this purpose, then this function pointer should be set to
  \id{NULL} in the implementation.
}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolLastFlag}
{
  lflag = SUNLinSolLastFlag(LS);
}
{
  The \emph{optional} function \Id{SUNLinSolLastFlag}
  should return the last error flag encountered within the
  linear solver. This is not called by the {\sundials} packages
  directly; it allows the user to investigate linear solver issues
  after a failed solve.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \end{args}
}
{
  \id{sunindextype} containing the most recent error flag
}
{}
% --------------------------------------------------------------------
\ucfunctionf{SUNLinSolSpace}
{
  retval = SUNLinSolSpace(LS, \&lrw, \&liw);
}
{
  The \emph{optional} function \Id{SUNLinSolSpace}
  should return the storage requirements for the linear
  solver \id{LS}.
}
{
  \begin{args}[lrw]
  \item[LS] (\id{SUNLinearSolver})
    a {\sunlinsol} object.
  \item[lrw] (\id{long int*})
    the number of realtype words stored by the linear solver.
  \item[liw] (\id{long int*})
    the number of integer words stored by the linear solver.
  \end{args}
}
{
  This should return zero for a successful call, and a negative value
  for a failure, ideally returning one of the generic error codes
  listed in Table \ref{t:sunlinsolerr}.
}
{
  This function is advisory only, for use in determining a user's
  total space requirements.
}
% --------------------------------------------------------------------



%---------------------------------------------------------------------------
\subsection{Functions provided by {\sundials} packages}\label{ss:sunlinsol_SUNSuppliedFn}

To interface with the {\sunlinsol} modules, the {\sundials} packages
supply a variety of routines for evaluating the matrix-vector product,
and setting up and applying the preconditioner.  These
package-provided routines translate between the user-supplied ODE, DAE,
or nonlinear systems and the generic interfaces to the linear systems
of equations that result in their solution.  The types for functions
provided to a {\sunlinsol} module are defined in the header
file \id{sundials/sundials\_iterative.h}, and are described below.



% --------------------------------------------------------------------
\usfunction{ATimesFn}
{
  typedef int (*ATimesFn)(void *A\_data, N\_Vector v, N\_Vector z);
}
{
  These functions compute the action of a matrix on a vector,
  performing the operation $z = Av$.  Memory for \id{z} should already be
  allocted prior to calling this function.  The vector \id{v} should
  be left unchanged.
}
{
  \begin{args}[A\_data]
  \item[A\_data]
    is a pointer to client data, the same as that supplied to \id{SUNLinSolSetATimes}.
  \item[v]
    is the input vector to multiply.
  \item[z]
    is the output vector computed.
  \end{args}
}
{
  This routine should return 0 if successful and a
  non-zero value if unsuccessful.
}
{}
% --------------------------------------------------------------------
\usfunction{PSetupFn}
{
  typedef int (*PSetupFn)(void *P\_data)
}
{
  These functions set up any requisite problem data in preparation
  for calls to the corresponding \id{PSolveFn}.
}
{
  \begin{args}[P\_data]
  \item[P\_data]
    is a pointer to client data, the same pointer as that supplied to the routine
    \id{SUNLinSolSetPreconditioner}.
  \end{args}
}
{
  This routine should return 0 if successful and a non-zero value if unsuccessful.
}
{}
% --------------------------------------------------------------------
\usfunction{PSolveFn}
{
  typedef int (*PSolveFn)(&void *P\_data, N\_Vector r, N\_Vector z, \\
                          &realtype tol, int lr)
}
{
  These functions solve the preconditioner equation $Pz = r$
  for the vector $z$.  Memory for \id{z} should already be
  allocted prior to calling this function.  The
  parameter \id{P\_data} is a pointer to any information about $P$
  which the function needs in order to do its job (set up by the
  corresponding \id{PSetupFn}). The parameter \id{lr} is input, and
  indicates whether $P$ is to be taken as the left preconditioner or
  the right preconditioner: \id{lr} = 1 for left and \id{lr} = 2 for
  right.  If preconditioning is on one side only, \id{lr} can be
  ignored.  If the preconditioner is iterative, then it should strive
  to solve the preconditioner equation so that
  \[
      \| Pz - r \|_{\text{wrms}} < tol
  \]
  where the weight vector for the WRMS norm may be accessed from the
  main package memory structure.  The vector \id{r} should not be
  modified by the \id{PSolveFn}.
}
{
  \begin{args}[P\_data]
  \item[P\_data]
    is a pointer to client data, the same pointer as that supplied to the routine \id{SUNLinSolSetPreconditioner}.
  \item[r]
    is the right-hand side vector for the preconditioner system.
  \item[z]
    is the solution vector for the preconditioner system.
  \item[tol]
    is the desired tolerance for an iterative preconditioner.
  \item[lr]
    is flag indicating whether the routine should perform left (1) or
    right (2) preconditioning.
  \end{args}
}
{
  This routine should return 0 if successful and a non-zero value if
  unsuccessful.  On a failure, a negative return value indicates an
  unrecoverable condition, while a positive value indicates a
  recoverable one, in which the calling routine may reattempt the
  solution after updating preconditioner data.
}
{}
% --------------------------------------------------------------------



%---------------------------------------------------------------------------
\subsection{\id{SUNLinearSolver} return codes}\label{ss:sunlinsol_ErrorCodes}


The functions provided to {\sunlinsol} modules by each {\sundials}
package, and functions within the {\sundials}-provided {\sunlinsol}
implementations utilize a common set of return codes, shown in
Table \ref{t:sunlinsolerr}.  These adhere to a
common pattern: 0 indicates success, a postitive value corresponds to
a recoverable failure, and a negative value indicates a
non-recoverable failure.  Aside from this pattern, the actual values
of each error code are primarily to provide additional information to
the user in case of a linear solver failure.

\newlength{\ColumnOne}
\settowidth{\ColumnOne}{\id{SUNLS\_PACKAGE\_FAIL\_UNREC}}
\newlength{\ColumnTwo}
\settowidth{\ColumnTwo}{\id{Value}}
\newlength{\ColumnThree}
\setlength{\ColumnThree}{\textwidth}
\addtolength{\ColumnThree}{-0.5in}
\addtolength{\ColumnThree}{-\ColumnOne}
\addtolength{\ColumnThree}{-\ColumnTwo}

\tablecaption{Description of the \id{SUNLinearSolver} error codes}\label{t:sunlinsolerr}
\tablehead{\hline {\rule{0mm}{5mm}}{\bf Name} & {\bf Value} & {\bf Description} \\[3mm] \hline\hline}
\tabletail{\hline \multicolumn{3}{|r|}{\small\slshape continued on next page} \\ \hline}
\begin{xtabular}{|p{\ColumnOne}|p{\ColumnTwo}|p{\ColumnThree}|}
%%
\id{SUNLS\_SUCCESS} & \id{0} & successful call or converged solve
\\[1mm]
%%
\id{SUNLS\_MEM\_NULL} & \id{-801} & the memory argument to the function is \id{NULL}
\\[1mm]
%%
\id{SUNLS\_ILL\_INPUT} & \id{-802} & an illegal input has been provided to the function
\\[1mm]
%%
\id{SUNLS\_MEM\_FAIL} & \id{-803} & failed memory access or allocation
\\[1mm]
%%
\id{SUNLS\_ATIMES\_NULL} & \id{-804} & the Atimes function is \id{NULL}
\\[1mm]
%%
\id{SUNLS\_ATIMES\_FAIL\_UNREC} & \id{-805} & an unrecoverable failure
  occurred in the \id{ATimes} routine
\\[1mm]
%%
\id{SUNLS\_PSET\_FAIL\_UNREC} & \id{-806} & an unrecoverable failure
  occurred in the \id{Pset} routine
\\[1mm]
%%
\id{SUNLS\_PSOLVE\_NULL} & \id{-807} & the preconditioner solve function is \id{NULL}
\\[1mm]
%%
\id{SUNLS\_PSOLVE\_FAIL\_UNREC} & \id{-808} & an unrecoverable failure
  occurred in the \id{Psolve} routine
\\[1mm]
%%
\id{SUNLS\_PACKAGE\_FAIL\_UNREC} & \id{-809} & an unrecoverable failure
  occurred in an external linear solver package
\\[1mm]
%%
\id{SUNLS\_GS\_FAIL} & \id{-810} & a failure occurred during
  Gram-Schmidt orthogonalization ({\sunlinsolspgmr}/{\sunlinsolspfgmr})
\\[1mm]
%%
\id{SUNLS\_QRSOL\_FAIL} & \id{-811} & a singular $R$ matrix was
  encountered in a QR factorization ({\sunlinsolspgmr}/{\sunlinsolspfgmr})
\\[1mm]
%%
\id{SUNLS\_VECTOROP\_ERR} & \id{-812} & a vector operation error occurred
\\[1mm]
%%
\id{SUNLS\_RES\_REDUCED} & \id{801} &  an iterative solver reduced the
  residual, but did not converge to the desired tolerance
\\[1mm]
%%
\id{SUNLS\_CONV\_FAIL} & \id{802} &  an iterative solver did not
converge (and the residual was not reduced)
\\[1mm]
%%
\id{SUNLS\_ATIMES\_FAIL\_REC} & \id{803} & a recoverable failure occurred
  in the \id{ATimes} routine
\\[1mm]
%%
\id{SUNLS\_PSET\_FAIL\_REC} & \id{804} & a recoverable failure occurred
  in the \id{Pset} routine
\\[1mm]
%%
\id{SUNLS\_PSOLVE\_FAIL\_REC} & \id{805} & a recoverable failure occurred
  in the \id{Psolve} routine
\\[1mm]
%%
\id{SUNLS\_PACKAGE\_FAIL\_REC} & \id{806} &  a recoverable failure
  occurred in an external linear solver package
\\[1mm]
%%
\id{SUNLS\_QRFACT\_FAIL} & \id{807} & a singular matrix was encountered
  during a QR factorization ({\sunlinsolspgmr}/{\sunlinsolspfgmr})
\\[1mm]
%%
\id{SUNLS\_LUFACT\_FAIL} & \id{808} & a singular matrix was encountered
  during a LU factorization ({\sunlinsoldense}/{\sunlinsolband})
\\
\hline
\end{xtabular}
\bigskip


%---------------------------------------------------------------------------
\subsection{The generic \id{SUNLinearSolver} module}\label{ss:sunlinsol_Generic}

{\sundials} packages interact with specific {\sunlinsol} implementations
through the generic {\sunlinsol} module on which all other {\sunlinsol}
iplementations are built.  The \id{SUNLinearSolver} type is a pointer
to a structure containing an implementation-dependent \emph{content} field,
and an \emph{ops} field.  The type \Id{SUNLinearSolver} is defined as
%%
%%
\begin{verbatim}
typedef struct _generic_SUNLinearSolver *SUNLinearSolver;

struct _generic_SUNLinearSolver {
  void *content;
  struct _generic_SUNLinearSolver_Ops *ops;
};
\end{verbatim}
%%
%%
where the \id{\_generic\_SUNLinearSolver\_Ops} structure is a list of
pointers to the various actual linear solver operations provided by a
specific implementation.  The \id{\_generic\_SUNLinearSolver\_Ops}
structure is defined as
%%
\begin{verbatim}
struct _generic_SUNLinearSolver_Ops {
  SUNLinearSolver_Type (*gettype)(SUNLinearSolver);
  SUNLinearSolver_ID   (*getid)(SUNLinearSolver);
  int                  (*setatimes)(SUNLinearSolver, void*, ATimesFn);
  int                  (*setpreconditioner)(SUNLinearSolver, void*,
                                            PSetupFn, PSolveFn);
  int                  (*setscalingvectors)(SUNLinearSolver,
                                            N_Vector, N_Vector);
  int                  (*setzeroguess)(SUNLinearSolver, booleantype);
  int                  (*initialize)(SUNLinearSolver);
  int                  (*setup)(SUNLinearSolver, SUNMatrix);
  int                  (*solve)(SUNLinearSolver, SUNMatrix, N_Vector,
                                N_Vector, realtype);
  int                  (*numiters)(SUNLinearSolver);
  realtype             (*resnorm)(SUNLinearSolver);
  sunindxetype         (*lastflag)(SUNLinearSolver);
  int                  (*space)(SUNLinearSolver, long int*, long int*);
  N_Vector             (*resid)(SUNLinearSolver);
  int                  (*free)(SUNLinearSolver);
};
\end{verbatim}

The generic {\sunlinsol} module defines and implements the linear
solver operations defined in Sections
\ref{ss:sunlinsol_CoreFn}-\ref{ss:sunlinsol_GetFn}.  These routines
are in fact only wrappers to the linear solver operations
defined by a particular {\sunlinsol} implementation, which are
accessed through the {\em ops} field of the \id{SUNLinearSolver}
structure. To illustrate this point we show below the implementation
of a typical linear solver operation from the generic {\sunlinsol}
module, namely \id{SUNLinSolInitialize}, which initializes a
{\sunlinsol} object for use after it has been created and configured,
and returns a flag denoting a successful/failed operation:
%%
%%
\begin{verbatim}
int SUNLinSolInitialize(SUNLinearSolver S)
{
  return ((int) S->ops->initialize(S));
}
\end{verbatim}

The Fortran 2003 interface provides a \id{bind(C)} derived-type for the
\id{\_generic\_SUNLinearSolver} and the \id{\_generic\_SUNLinearSolver\_Ops} structures.
Their definition is given below.
%%
%%
\begin{verbatim}
 type, bind(C), public :: SUNLinearSolver
  type(C_PTR), public :: content
  type(C_PTR), public :: ops
 end type SUNLinearSolver

 type, bind(C), public :: SUNLinearSolver_Ops
  type(C_FUNPTR), public :: gettype
  type(C_FUNPTR), public :: setatimes
  type(C_FUNPTR), public :: setpreconditioner
  type(C_FUNPTR), public :: setscalingvectors
  type(C_FUNPTR), public :: setzeroguess
  type(C_FUNPTR), public :: initialize
  type(C_FUNPTR), public :: setup
  type(C_FUNPTR), public :: solve
  type(C_FUNPTR), public :: numiters
  type(C_FUNPTR), public :: resnorm
  type(C_FUNPTR), public :: lastflag
  type(C_FUNPTR), public :: space
  type(C_FUNPTR), public :: resid
  type(C_FUNPTR), public :: free
 end type SUNLinearSolver_Ops
\end{verbatim}


\section{Compatibility of \id{SUNLinearSolver} modules}\label{ss:sunlinsol_compatibility}

We note that not all {\sunlinsol} types are compatible with all
{\sunmatrix} and {\nvector} types provided with {\sundials}.  In Table
\ref{t:linsol-matrix} we show the matrix-based linear solvers
available as {\sunlinsol} modules, and the compatible matrix
implementations.  Recall that Table \ref{t:solver-vector} shows the
compatibility between all {\sunlinsol} modules and vector
implementations.

\tablecaption{{\sundials} matrix-based linear solvers and matrix
              implementations that can be used for each.}\label{t:linsol-matrix}
\tablehead{\hline \multicolumn{1}{|p{2cm}|}{{Linear Solver Interface}} &
                  \multicolumn{1}{p{1.3cm}|}{{Dense Matrix}} &
                  \multicolumn{1}{p{1.3cm}|}{{Banded Matrix}} &
                  \multicolumn{1}{p{1.4cm}|}{{Sparse Matrix}} &
                  \multicolumn{1}{p{1.4cm}|}{{SLUNRloc Matrix}} &
                  \multicolumn{1}{p{1.4cm}|}{{User Supplied}} \\ \hline}
\tabletail{\hline \multicolumn{6}{|r|}{\small\slshape continued on next page} \\ \hline}
\begin{center}
\begin{xtabular}{|l|c|c|c|c|c|}
  %   Linear Solver &  Dense   & Banded & Sparse & SLUNRloc & User     \\
  %   Interface     &          &        &        &          & Supplied \\
      Dense         &  \cm     &        &        &          & \cm      \\ \hline
      Band          &          & \cm    &        &          & \cm      \\ \hline
      LapackDense   &  \cm     &        &        &          & \cm      \\ \hline
      LapackBand    &          & \cm    &        &          & \cm      \\ \hline
      \klu          &          &        &  \cm   &          & \cm      \\ \hline
      \superludist  &          &        &        & \cm      & \cm      \\ \hline
      \superlumt    &          &        &  \cm   &          & \cm      \\ \hline
      User supplied &  \cm     & \cm    &  \cm   & \cm      & \cm      \\ \hline
\end{xtabular}
\end{center}
\bigskip



\section{Implementing a custom \id{SUNLinearSolver} module}\label{ss:sunlinsol_custom}

A particular implementation of the {\sunlinsol} module must:
\begin{itemize}
\item Specify the {\em content} field of the \id{SUNLinearSolver} object.
\item Define and implement a minimal subset of the linear solver
  operations. See the section \ref{s:sunlinsol_interface} to determine which
  {\sunlinsol} operations are required for this {\sundials} package.

  Note that the names of these routines should be unique to that
  implementation in order to permit using more than one {\sunlinsol}
  module (each with different \id{SUNLinearSolver} internal data
  representations) in the same code.
\item Define and implement user-callable constructor and destructor
  routines to create and free a \id{SUNLinearSolver} with
  the new {\em content} field and with {\em ops} pointing to the
  new linear solver operations.
\end{itemize}

We note that the function pointers for all unsupported optional
routines should be set to \id{NULL} in the \emph{ops} structure.  This
allows the {\sundials} package that is using the {\sunlinsol} object
to know that the associated functionality is not supported.

To aid in the creation of custom {\sunlinsol} modules the generic {\sunlinsol}
module provides the utility functions \id{SUNLinSolNewEmpty} and \id{SUNLinSolFreeEmpty}.
When used in custom {\sunlinsol} constructors the function \id{SUNLinSolNewEmpty} will
ease the introduction of any new optional linear solver operations to the {\sunlinsol}
API by ensuring only required operations need to be set.
%
% --------------------------------------------------------------------
%
\ucfunctionf{SUNLinSolNewEmpty}
{
  LS = SUNLinSolNewEmpty();
}
{
  The function \Id{SUNLinSolNewEmpty} allocates a new generic {\sunlinsol}
  object and initializes its content pointer and the function pointers in the
  operations structure to \id{NULL}.
}
{}
{
  This function returns a \id{SUNLinearSolver} object. If an error occurs when
  allocating the object, then this routine will return \id{NULL}.
}
{}
%
% --------------------------------------------------------------------
%
\ucfunctionf{SUNLinSolFreeEmpty}
{
  SUNLinSolFreeEmpty(LS);
}
{
  This routine frees the generic \id{SUNLinSolFreeEmpty} object, under the assumption that any
  implementation-specific data that was allocated within the underlying content structure
  has already been freed. It will additionally test whether the ops pointer is \id{NULL},
  and, if it is not, it will free it as well.
}
{
  \begin{args}[LS]
  \item[LS] (\id{SUNLinearSolver})
  \end{args}
}
{}
{}


Additionally, a {\sunlinsol} implementation \emph{may} do the
following:
\begin{itemize}
\item Define and implement additional user-callable ``set'' routines
  acting on the \id{SUNLinearSolver}, e.g., for setting various
  configuration options to tune the linear solver to a
  particular problem.
\item Provide additional user-callable ``get'' routines acting on the
  \id{SUNLinearSolver} object, e.g., for returning various solve
  statistics.
\end{itemize}

\subsection{Intended use cases}\label{ss:sunlinsol_intended}

The {\sunlinsol} (and {\sunmatrix}) APIs are designed to require a minimal set
of routines to ease interfacing with custom or third-party linear solver
libraries. External solvers provide similar routines with
the necessary functionality and thus will require minimal effort to wrap within
custom {\sunmatrix} and {\sunlinsol} implementations. Sections
\ref{s:sunmat_usage} and \ref{s:sunlinsol_interface} include a list of the required set
of routines that compatible {\sunmatrix} and {\sunlinsol} implementations must
provide. As {\sundials} packages utilize generic {\sunlinsol} modules allowing
for user-supplied \id{SUNLinearSolver} implementations, there exists a wide
range of possible linear solver combinations. Some intended use cases for both
the {\sundials}-provided and user-supplied {\sunlinsol} modules are discussd in
the following sections.

\subsubsection*{Direct linear solvers}

Direct linear solver modules require a matrix and compute an `exact' solution to
the linear system \textit{defined by the matrix}. Multiple matrix formats and
associated direct linear solvers are supplied with {\sundials} through different
{\sunmatrix} and {\sunlinsol} implementations. {\sundials} packages strive to
amortize the high cost of matrix construction by reusing matrix information for
multiple nonlinear iterations. As a result, each package's linear solver
interface recomputes Jacobian information as infrequently as possible.

Alternative matrix storage formats and compatible linear solvers that are not
currently provided by, or interfaced with, {\sundials} can leverage this
infrastructure with minimal effort. To do so, a user must implement custom
{\sunmatrix} and {\sunlinsol} wrappers for the desired matrix format
and/or linear solver following the APIs described in Chapters
\ref{s:sunmatrix} and \ref{s:sunlinsol}. \emph{This user-supplied
{\sunlinsol} module must then self-identify as having
\Id{SUNLINEARSOLVER\_DIRECT} type.}

\subsubsection*{Matrix-free iterative linear solvers}

Matrix-free iterative linear solver modules do not require a matrix and compute
an inexact solution to the linear system \textit{defined by the package-supplied
\id{ATimes} routine}. {\sundials} supplies multiple scaled, preconditioned
iterative linear solver (spils) {\sunlinsol} modules that support scaling to
allow users to handle non-dimensionalization (as best as possible) within each
{\sundials} package and retain variables and define equations as desired in
their applications. For linear solvers that do not support left/right scaling,
the tolerance supplied to the linear solver is adjusted to compensate (see
section \ref{ss:sunlinsol_iterative_tolerance} for more details); however, this
use case may be non-optimal and cannot handle situations where the magnitudes of
different solution components or equations vary dramatically within a single
problem.

To utilize alternative linear solvers that are not currently provided by, or
interfaced with, {\sundials} a user must implement a custom {\sunlinsol} wrapper
for the linear solver following the API described in Chapter \ref{s:sunlinsol}.
\emph{This user-supplied {\sunlinsol} module must then self-identify as having
\Id{SUNLINEARSOLVER\_ITERATIVE} type.}

\subsubsection*{Matrix-based iterative linear solvers (reusing $A$)}

Matrix-based iterative linear solver modules require a matrix and compute an
inexact solution to the linear system \textit{defined by the matrix}.
This matrix will be updated infrequently and resued across multiple
solves to amortize cost of matrix construction. As in the direct
linear solver case, only wrappers for the matrix and linear solver in
{\sunmatrix} and {\sunlinsol} implementations need to be created to
utilize a new linear solver. \emph{This user-supplied {\sunlinsol}
module must then self-identify as having
\Id{SUNLINEARSOLVER\_MATRIX\_ITERATIVE} type.}

At present, {\sundials} has one example problem that uses this approach for
wrapping a structured-grid matrix, linear solver, and preconditioner from the
{\hypre} library that may be used as a template for other customized
implementations
(see \texttt{examples/arkode/CXX\_parhyp/ark\_heat2D\_hypre.cpp}).

\subsubsection*{Matrix-based iterative linear solvers (current $A$)}

For users who wish to utilize a matrix-based iterative linear solver module
where the matrix is \textit{purely for preconditioning} and the linear system is
\textit{defined by the package-supplied \id{ATimes} routine}, we envision two
current possibilities.

The preferred approach is for users to employ one of the {\sundials}
spils {\sunlinsol} implementations ({\sunlinsolspgmr}, {\sunlinsolspfgmr},
{\sunlinsolspbcgs}, {\sunlinsolsptfqmr}, or {\sunlinsolpcg}) as the outer
solver. The creation and storage of the preconditioner matrix, and interfacing
with the corresponding linear solver, can be handled through a package's
preconditioner `setup' and `solve' functionality (see \S\ref{sss:optin_ls})
without creating {\sunmatrix} and {\sunlinsol} implementations. This usage mode
is recommended primarily because the {\sundials}-provided spils modules support
the scaling as described above.

A second approach supported by the linear solver APIs is as follows. If the
{\sunlinsol} implementation is matrix-based, \textit{self-identifies
as having \Id{SUNLINEARSOLVER\_ITERATIVE} type}, and \emph{also provides a
non-\id{NULL} \Id{SUNLinSolSetATimes} routine}, then each {\sundials} package
will call that routine to attach its package-specific matrix-vector product
routine to the {\sunlinsol} object. The {\sundials} package will then call the
{\sunlinsol}-provided \Id{SUNLinSolSetup} routine (infrequently) to update
matrix information, but will provide current matrix-vector products to the
{\sunlinsol} implementation through the package-supplied \id{ATimesFn} routine.

\subsubsection*{Application-specific linear solvers with embedded matrix structure}

Many applications can exploit additional linear system structure due to the
implicit couplings in their model equations.  In certain circumstances,
the linear solve $Ax=b$ may be performed without the need for a global
system matrix $A$, as the unformed $A$ may be block diagonal or block triangular,
and thus the overall linear solve may be performed through a sequence of smaller
linear solves.  In other circumstances, a linear system solve may be accomplished
via specialized fast solvers, such as the fast Fourier transform, fast multipole
method, or treecode, in which case no matrix structure may be explicitly necessary.
Furthermore, in many of these situations construction and preprocessing of the
linear system matrix $A$ may be inexpensive, and thus increased performance
may be possible if the current linear system information is used within every solve
(instead of being lagged, as occurs with matrix-based solvers that reuse $A$).

To support such application-specific situations, {\sundials} supports user-provided
linear solvers with the \Id{SUNLINEARSOLVER\_MATRIX\_EMBEDDED} type.  For an
application to leverage this support, it should define a custom {\sunlinsol}
implementation having this type.  For this implementation, only the required
\Id{SUNLinSolGetType} and \Id{SUNLinSolSolve} operations should be needed.  Within
\Id{SUNLinSolSolve}, the linear solver implementation should call package-specific
interface routines (e.g., \Id{ARKStepGetNonlinearSystemData},
\Id{CVodeGetNonlinearSystemData}, \Id{IDAGetNonlinearSystemData},
\Id{ARKStepGetCurrentGamma}, \Id{CVodeGetCurrentGamma}, \Id{IDAGetCurrentCj} or
\Id{MRIStepGetCurrentGamma}) to construct the relevant system matrix $A$ (or
portions thereof), solve the linear system $Ax=b$, and return the solution vector $x$.

We note that when attaching this custom {\sunlinsol} object with the relevant
{\sundials} package \id{SetLinearSolver} routine, the input {\sunmatrix} \id{A}
should be set to \id{NULL}.
