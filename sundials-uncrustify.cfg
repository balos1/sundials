# ------------------------------------------------------------------------------
# Programmer(s): David J. Gardner @ LLNL
# ------------------------------------------------------------------------------
# SUNDIALS Copyright Start
# Copyright (c) 2002-2020, Lawrence Livermore National Security
# and Southern Methodist University.
# All rights reserved.
#
# See the top-level LICENSE and NOTICE files for details.
#
# SPDX-License-Identifier: BSD-3-Clause
# SUNDIALS Copyright End
# ------------------------------------------------------------------------------
# This format is based on the GNU configuration supplied with uncrustify.
# ------------------------------------------------------------------------------
#
# Terminology:
#   Types of parenthesis:
#     sparen - parenthesis found with if/for/switch/while statements.
#     fparen - parenthesis found with function prototypes, calls and
#              implementations.
#     paren  - everything else, such as parenthesis those found with
#              arithmetic ops.
#
#   A 'span' is the maximum number of lines that a aligning feature will be
#   considered. This is done to limit the scope of the aligning. So, if a span
#   is set to 3 and more than 3 lines do not contain the item that is to be
#   aligned, then the aligning set is closed.
#
#   A 'gap' is the minimum spacing for aligned items. So, if it is set to 3 for
#   typedefs, then there are a minimum of three spaces between the type and the
#   typedef name.
#
#   A 'threshold' is the maximum number of columns that a aligning feature will
#   be considered.  This is done to limit the scope of the aligning. This
#   prevents really longs lines from being aligned with short lines.
#
# Meaning of the settings:
#   Ignore - do not do any changes
#   Add    - makes sure there is 1 or more space/brace/newline/etc
#   Force  - makes sure there is exactly 1 space/brace/newline/etc, behaves like
#            Add in some contexts
#   Remove - removes space/brace/newline/etc
#
# Settings that are unchanged from the default value include (default) in the
# description. These are included in the configuration file to note the style
# used in the source.
#
# To get a list of all available options and the default values:
#
#   $ uncrustify --show-config > default.cfg
#
# To apply the formatting defined in my-format.cfg:
#
#   $ uncrustify -c my-format.cfg -f <input-file> -o <output-file>
#
# ------------------------------------------------------------------------------

# ---------------
# General options
# ---------------

# Use Unix lf line endings
newlines = lf

# ---------------
# Spacing options
# ---------------

# One space around non-assignment symbolic operators ('+', '/', '%', '<<', etc.)
sp_arith = force

# One space around addignment operators ('=', '+=', '-=', etc.)
sp_assign = force

# One space around boolean operators '&&' and '||'.
# "a&&b" => "a && b"
sp_bool = force

# At least one space around comparison operators '<', '>', '==', etc.
# Allows for multiple spaces in long 'if' conditions e.g., CheckNVector
# "a<b" => "a < b"
sp_compare = add

# No spaces inside '(' and ')'.
# "( int )" => "(int)"
sp_inside_paren = remove

# No spaces between '((' and '))'
# "( (a == b) && (b != c) )" => "((a == b) && (b != c))"
sp_paren_paren = remove

# Add or remove space before pointer star '*'.
#sp_before_ptr_star              = ignore   # ignore/add/remove/force

# Add or remove space before pointer star '*' that isn't followed by a
# variable name. If set to ignore, sp_before_ptr_star is used instead.
#sp_before_unnamed_ptr_star      = ignore   # ignore/add/remove/force

# Add or remove space between pointer stars '*'.
#sp_between_ptr_star             = ignore   # ignore/add/remove/force

# Add or remove space after pointer star '*', if followed by a word.
#
# Overrides sp_type_func.
#sp_after_ptr_star               = ignore   # ignore/add/remove/force

# Add or remove space after pointer star '*', if followed by a qualifier.
#sp_after_ptr_star_qualifier     = ignore   # ignore/add/remove/force

# Add or remove space after a pointer star '*', if followed by a function
# prototype or function definition.
#
# Overrides sp_after_ptr_star and sp_type_func.
#sp_after_ptr_star_func          = ignore   # ignore/add/remove/force

# Add or remove space after a pointer star '*', if followed by an open
# parenthesis, as in 'void* (*)().
#sp_ptr_star_paren               = ignore   # ignore/add/remove/force

# One space before '(' of control statements ('if', 'for', 'switch', etc.)
# "if(" => "if ("
sp_before_sparen = force

# Remove space inside '(' and ')' of control statements
# "if ( a == b )" => "if (a == b)"
sp_inside_sparen = remove

# One space after ')' of control statements
# "if (){" => "if () {"
sp_after_sparen = force

# Remove space before ';' (default)
# "a = b + c ;" => "a = b + c;"
sp_before_semi = remove

# One space after ','
# "a,b" => "a, b"
sp_after_comma = force

# Remove space between 'sizeof' and '('
# "sizeof(int)" => "sizeof (int)"
sp_sizeof_paren = remove

# Remove space after cast
# "(int) a" => "(int)a"
sp_after_cast = remove

# One space inside enum '{' and '}'
# "enum {1}" => "enum { 1 }"
sp_inside_braces_enum = force

# One space inside struct/union '{' and '}'
# "struct {1}" => "struct { 1 }"
sp_inside_braces_struct = force

# One space inside '{' and '}'
# "{1}" => "{ 1 }"
sp_inside_braces = force

# One space between return type and function name
# "int   foo" => "int foo"
sp_type_func = force

# No remove space between function name and '(' with a typedef specifier
# "int foo();" => "int foo ();"
sp_func_proto_paren = remove

# No space between alias name and '(' of a non-pointer function type typedef
# "int foo() {" => "int foo () {"
sp_func_def_paren = remove

# No space inside function '(' and ')'.
# "foo( int a )" => "foo(int a)"
sp_inside_fparen = remove

# No space between function name and '(' on function calls
# "foo(" => "foo ("
sp_func_call_paren = remove

# Add space between 'return' and '(' to match clang-format
# "return(0);" => "return (0);"
sp_return_paren = add

# Add or remove space after the opening of a C++ comment,
# "//A" => "// A"
sp_cmt_cpp_start = add

# -----------------
# Indenting options
# -----------------

# Indent two columns per level
indent_columns = 2

# Always indent with spaces
indent_with_tabs = 0

# Indent strings broken by '\' to they line up
indent_align_string = true

# Do not indent braces (default)
indent_brace = 0

# Do not indent the body of a 'namespace' (default)
indent_namespace = false

# Do note indent the body of inside 'extern "C"' (default)
indent_extern = false

# Whether to indent trailing single line ('//') comments relative to the code
# instead of trying to keep the same absolute column.
#indent_relative_single_line_comments = false    # true/false

# Indent 'case' two spaces from 'switch' (same as indent_colums)
indent_switch_case = indent_columns

# Align a close parenthesis after a newline under the open parenthesis
#indent_paren_close = 1

# Align continued statements at the '=' (default)
indent_align_assign = true

# Align continued statements at the '(' (default)
indent_align_paren = true

# How to indent the continuation of ternary operator.
#
# 0: Off (default)
# 1: When the `if_false` is a continuation, indent it under `if_false`
# 2: When the `:` is a continuation, indent it under `?`
#indent_ternary_operator = 0        # unsigned number

# -----------------------------------
# Newline adding and removing options
# -----------------------------------

# Don't split one-line function definitions (might modify nl_func_type_name)
# "int foo() { return 0; }" is valid
nl_func_leave_one_liners = true

# Split one-line if/else statements
# "if(...) b++;" => "if (...) \n { \n b++; \n }
nl_if_leave_one_liners = false

# Newline between a function call's close paren and open bracket
# "foo() {" => "foo()\n{"
nl_fcall_brace = force

# No newline between 'enum' and open bracket
# "enum {" => "enum \n {" vs
nl_enum_brace = remove # <<< CHANGE? >>>

# No newline between 'struct' and open bracket
# "struct {" => "struct \n {"
nl_struct_brace = remove # <<< CHANGE? >>>

# Newline between 'if' and open bracket
# "if () {" => "if () \n {"
nl_if_brace = force

# Newline between 'else' and open bracket
# "else {" => "else \n {"
nl_brace_else = force

# Newline between 'else' and open bracket
# "else {" => "else \n {"
nl_else_brace = force

# Newline between 'for' and open bracket
# "for () {" => "for () \n {"
nl_for_brace = force

# Newline between 'while' and open bracket
# "while () {" => "while () \n {"
nl_while_brace = force

# Newline between 'do' and open bracket
# "do {" => "do \n {"
nl_do_brace = force

# Newline newline between '}' and 'while' of 'do' statement.
# "} while" => "} \n while"
nl_brace_while = force

# Newline between 'switch' and open bracket
# "switch () {" => "switch () \n {"
nl_switch_brace = force

# Newline before 'case', and a blank line before a 'case' statement that follows
# a ';' or '}'.
nl_before_case = true

# Newline between function signature and open bracket
# "int foo() {" => "int foo()\n{"
nl_fdef_brace = force

# Newline after semicolons (except in 'for' statements)
# "foo(...); bar(...)" => "foo(...); \n bar(...)"
nl_after_semicolon = true

# Remove blanks after '#ifxx' and '#elxx', or before '#elxx' and '#endif'. Does
# not affect top-level #ifdefs.
nl_squeeze_ifdef = true

# Blank line before 'return' statements, unless after an open brace.
#nl_before_return = true

# Blank line after 'return' statements, unless followed by a close brace.
#nl_after_return = true

# Two empty lines between multi-line functions (3 = 2 blank lines)
nl_after_func_body = 3

# One blank line after a variable definitions at the top of a function body.
nl_func_var_def_blk = 1

# ------------------
# Blank line options
# ------------------

# Remove blank lines after open brace
eat_blanks_after_open_brace = true

# Remove blank lines before close brace
eat_blanks_before_close_brace = true

# -------------------
# Positioning options
# -------------------

# The position of arithmetic operators in wrapped expressions.
# ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force
#pos_arith = ignore

# ----------------------
# Line splitting options
# ----------------------

# Try to limit code width to N columns.
code_width = 80

# Split long function prototypes/calls at commas. The option ls_code_width has
# priority over the option ls_func_split_full.
ls_func_split_full = true

# Split lines as close to code_width as possible and ignore some groupings. The
# option ls_code_width has priority over the option ls_func_split_full.
ls_code_width = true

# ----------------------------------------------------
# Code alignment options (not left column spaces/tabs)
# ----------------------------------------------------

# Align consecutive variable definitions
align_var_def_span = 1

# How to consider (or treat) the '*' in the alignment of variable definitions.
#
# 0: Part of the type     'void *   foo;' (default)
# 1: Part of the variable 'void     *foo;'
# 2: Dangling             'void    *foo;'
# Dangling: the '*' will not be taken into account when aligning.
#align_var_def_star_style = 0

# How to consider (or treat) the '&' in the alignment of variable definitions.
#
# 0: Part of the type     'long &   foo;' (default)
# 1: Part of the variable 'long     &foo;'
# 2: Dangling             'long    &foo;'
# Dangling: the '&' will not be taken into account when aligning.
#align_var_def_amp_style = 0

# Align consecutive assignments (span for for aligning on '=' in assignments).
align_assign_span = 1


# The span for aligning comments that end lines.
#
# 0: Don't align (default).
#align_right_cmt_span            = 0        # unsigned number

# The span for aligning struct/union member definitions.
#
# 0: Don't align (default).
#align_var_struct_span           = 0        # unsigned number

# How to consider (or treat) the '*' in the alignment of typedefs.
#
# 0: Part of the typedef type, 'typedef int * pint;' (default)
# 1: Part of type name:        'typedef int   *pint;'
# 2: Dangling:                 'typedef int  *pint;'
# Dangling: the '*' will not be taken into account when aligning.
#align_typedef_star_style        = 0        # unsigned number

# How to consider (or treat) the '&' in the alignment of typedefs.
#
# 0: Part of the typedef type, 'typedef int & intref;' (default)
# 1: Part of type name:        'typedef int   &intref;'
# 2: Dangling:                 'typedef int  &intref;'
# Dangling: the '&' will not be taken into account when aligning.
#align_typedef_amp_style         = 0        # unsigned number

# The span for aligning comments that end lines.
#
# 0: Don't align (default).
#align_right_cmt_span            = 0        # unsigned number

# This will align trailing \ on macro defines
align_nl_cont = true

# Whether to align macro functions and variables together.
#align_pp_define_together        = false    # true/false

# The span for aligning on '#define' bodies.
#
# =0: Don't align (default)
# >0: Number of lines (including comments) between blocks
#align_pp_define_span            = 0        # unsigned number

# ----------------------------
# Comment modification options
# ----------------------------

# Whether to apply changes to multi-line comments, including cmt_width,
# keyword substitution and leading chars.
#
# Default: true
cmt_indent_multi = true

# Whether to put a star on subsequent comment lines.
cmt_star_cont = true

# Convert all tabs to spaces in comments.
cmt_convert_tab_to_spaces = true

# Try to wrap comments at N columns (same as code width)
cmt_width = code_width

# For multi-line comments with a '*' lead, remove leading spaces if the first
# and last lines of the comment are the same length.
#
# Default: true
cmt_multi_check_last = false

# Path to a file that contains text to insert at the beginning of a file if
# the file doesn't start with a C/C++ comment. If the inserted text contains
# '$(filename)', that will be replaced with the current file's name.
#cmt_insert_file_header          = ""         # string

# ---------------------------------------
# Code modifying options (non-whitespace)
# ---------------------------------------

# Add braces on a single-line 'do' statement.
# "do a--; while ();" => "do { a--; } while ();"
mod_full_brace_do = add

# Add braces on a single-line 'for' statement.
# "for () a--;" => "for () { a--; }"
mod_full_brace_for = add

# Add braces on a single-line 'if' statement. Braces will not be removed if the
# braced statement contains an 'else'.
# "if (a) a--;" => "if (a) { a--; }"
mod_full_brace_if = add

# Whether to enforce that all blocks of an 'if'/'else if'/'else' chain either
# have, or do not have, braces. If true, braces will be added if any block
# needs braces, and will only be removed if they can be removed from all
# blocks.
#
# Overrides mod_full_brace_if.
#mod_full_brace_if_chain         = false    # true/false

# Whether to add braces to all blocks of an 'if'/'else if'/'else' chain.
# If true, mod_full_brace_if_chain will only remove braces from an 'if' that
# does not have an 'else if' or 'else'.
#mod_full_brace_if_chain_only    = false    # true/false

# Add braces on a single-line 'while' statement.
# "while (a) a--;" => "while (a) { a--; }"
mod_full_brace_while = add

# Whether to prevent removal of braces from 'if'/'for'/'while'/etc. blocks
# which span multiple lines.
#
# Affects:
#   mod_full_brace_for
#   mod_full_brace_if
#   mod_full_brace_if_chain
#   mod_full_brace_if_chain_only
#   mod_full_brace_while
#   mod_full_brace_using
#
# Does not affect:
#   mod_full_brace_do
#   mod_full_brace_function
#mod_full_brace_nl_block_rem_mlcond = false    # true/false

# Add (unnecessary) parenthesis on 'return' statement (match existing style)
# "return 1;" => "return (1);"
mod_paren_on_return = add

# Fully parenthesize Boolean expressions in 'while' and 'if' statement
# "if (a && b > c)" => "if (a && (b > c))".
mod_full_paren_if_bool = true

# If a function body exceeds the specified number of newlines and doesn't have
# a comment after the close brace, a comment will be added.
#mod_add_long_function_closebrace_comment = 0        # unsigned number

# If a namespace body exceeds the specified number of newlines and doesn't
# have a comment after the close brace, a comment will be added.
#mod_add_long_namespace_closebrace_comment = 0        # unsigned number

# Whether to sort consecutive single-line '#include' statements (C/C++) and
# '#import' statements (Objective-C). Be aware that this has the potential to
# break your code if your includes/imports have ordering dependencies.
#mod_sort_include                = false    # true/false

# Whether to prioritize '#include' and '#import' statements that contain
# filename without extension when sorting is enabled.
#mod_sort_incl_import_prioritize_filename = false    # true/false

# Whether to prioritize '#include' and '#import' statements that does not
# contain extensions when sorting is enabled.
#mod_sort_incl_import_prioritize_extensionless = false    # true/false

# Whether to prioritize '#include' and '#import' statements that contain
# angle over quotes when sorting is enabled.
#mod_sort_incl_import_prioritize_angle_over_quotes = false    # true/false

# Whether to group '#include' and '#import' statements when sorting is enabled.
#mod_sort_incl_import_grouping_enabled = false    # true/false

# Whether to move a 'break' that appears after a fully braced 'case' before
# the close brace, as in 'case X: { ... } break;' => 'case X: { ... break; }'.
#mod_move_case_break             = false    # true/false

# Add or remove braces around a fully braced case statement. Will only remove
# braces if there are no variable declarations in the block.
#mod_case_brace                  = ignore   # ignore/add/remove/force

# Add or remove the comma after the last value of an enumeration.
#mod_enum_last_comma             = ignore   # ignore/add/remove/force

# --------------------
# Preprocessor options
# --------------------

# ---------------------
# Sort includes options
# ---------------------

# The regex for include category with priority 0.
include_category_0 = '^(<|"(gtest|gmock|isl|json)/)'

# The regex for include category with priority 1.
include_category_1 = '.*'

# The regex for include category with priority 2.
include_category_2 = ""

# -------------------------
# Use or Do not Use options
# -------------------------

# -----------------------------------------------------
# Warn levels - 1: error, 2: warning (default), 3: note
# -----------------------------------------------------
