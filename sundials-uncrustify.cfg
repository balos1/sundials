# ------------------------------------------------------------------------------
# Programmer(s): David J. Gardner @ LLNL
# ------------------------------------------------------------------------------
# SUNDIALS Copyright Start
# Copyright (c) 2002-2020, Lawrence Livermore National Security
# and Southern Methodist University.
# All rights reserved.
#
# See the top-level LICENSE and NOTICE files for details.
#
# SPDX-License-Identifier: BSD-3-Clause
# SUNDIALS Copyright End
# ------------------------------------------------------------------------------
# This format is based on the GNU configuration supplied with uncrustify.
# ------------------------------------------------------------------------------
# Meaning of the settings:
#   Ignore - do not do any changes
#   Add    - makes sure there is 1 or more space/brace/newline/etc
#   Force  - makes sure there is exactly 1 space/brace/newline/etc,
#            behaves like Add in some contexts
#   Remove - removes space/brace/newline/etc
#
# Settings that are unchanged from the default value include (default) in the
# description. These are included in the configuration file to note the style
# used in the source.
#
# To get a list of all available options and the default values:
#
#   $ uncrustify --show-config > default.cfg
#
# To apply the formatting defined in my-format.cfg:
#
#   $ uncrustify -c my-format.cfg -f <input-file> -o <output-file>
#
# ------------------------------------------------------------------------------

# ---------------
# General options
# ---------------

# Use Unix lf line endings
newlines = lf

# ---------------
# Spacing options
# ---------------

# One space around non-assignment symbolic operators ('+', '/', '%', '<<', etc.)
sp_arith = force

# One space around addignment operators ('=', '+=', '-=', etc.)
sp_assign = force

# One space around boolean operators '&&' and '||'.
# "a && b" vs "a&&b"
sp_bool = force

# At least one space around comparison operators '<', '>', '==', etc.
# Allows for multiple spaces in long 'if' conditions e.g., CheckNVector
# "a < b" vs "a<b"
sp_compare = add

# No spaces inside '(' and ')'.
# "(int)" vs "( int )"
sp_inside_paren = remove

# No spaces between '((' and '))'
# "((a == b) && (b != c))" vs "( (a == b) && (b != c) )"
sp_paren_paren = remove

# One space before '(' of control statements ('if', 'for', 'switch', etc.)
# "if (" vs "if("
sp_before_sparen = force

# Remove space inside '(' and ')' of control statements
# "if (a == b)" vs "if ( a == b )"
sp_inside_sparen = remove

# One space after ')' of control statements
# "if () {" vs "if (){"
sp_after_sparen = force

# Remove space before ';' (default)
# "a = b + c;" vs "a = b + c ;"
sp_before_semi = remove

# One space after ','
# "a, b" vs "a,b"
sp_after_comma = force

# Remove space between 'sizeof' and '('
# "sizeof (int)" vs "sizeof(int)"
sp_sizeof_paren = remove

# Remove space after cast
# "(int)a" vs. "(int) a"
sp_after_cast = remove

# One space inside enum '{' and '}'
# "enum { 1 }" vs "enum {1}"
sp_inside_braces_enum = force

# One space inside struct/union '{' and '}'
# "struct { 1 }" vs "struct {1}"
sp_inside_braces_struct = force

# One space inside '{' and '}'
# "{ 1 }" vs "{1}"
sp_inside_braces = force

# One space between return type and function name
# "int foo" vs "int   foo"
sp_type_func = force

# No remove space between function name and '(' with a typedef specifier
# "int foo ();" vs "int foo();"
sp_func_proto_paren = remove

# No space between alias name and '(' of a non-pointer function type typedef
# "int foo () {" vs "int foo() {"
sp_func_def_paren = remove

# No space inside function '(' and ')'.
# "foo(int a)" vs "foo( int a )"
sp_inside_fparen = remove

# No space between function name and '(' on function calls
# "foo (" vs "foo("
sp_func_call_paren = remove

# Add space between 'return' and '(' to match clang-format
# "return (0);" vs "return(0);"
sp_return_paren = add

# Add or remove space after the opening of a C++ comment,
# i.e. '// A' vs. '//A'.
sp_cmt_cpp_start = add

# -----------------
# Indenting options
# -----------------

# Indent two columns per level
indent_columns = 2

# Always indent with spaces
indent_with_tabs = 0

# Indent strings broken by '\' to they line up
indent_align_string = true

# Do not indent braces (default)
indent_brace = 0

# Do not indent the body of a 'namespace' (default)
indent_namespace = false

# Do note indent the body of inside 'extern "C"' (default)
indent_extern = false

# Whether to indent trailing single line ('//') comments relative to the code
# instead of trying to keep the same absolute column.
#indent_relative_single_line_comments = false    # true/false

# Indent 'case' two spaces from 'switch' (same as indent_colums)
indent_switch_case = 2

# Align a close parenthesis after a newline under the open parenthesis
#indent_paren_close = 1

# Align continued statements at the '=' (default)
indent_align_assign = true

# Align continued statements at the '(' (default)
indent_align_paren = true

# How to indent the continuation of ternary operator.
#
# 0: Off (default)
# 1: When the `if_false` is a continuation, indent it under `if_false`
# 2: When the `:` is a continuation, indent it under `?`
#indent_ternary_operator = 0        # unsigned number

# -----------------------------------
# Newline adding and removing options
# -----------------------------------

# Don't split one-line function definitions, as in 'int foo() { return 0; }'.
# might modify nl_func_type_name
nl_func_leave_one_liners = true

# Don't split one-line if/else statements, as in 'if(...) b++;'.
nl_if_leave_one_liners = false

# Whether to add a newline after semicolons, except in 'for' statements.
nl_after_semicolon = true

# The number of newlines after '}' of a multi-line function body (3 = 2 blank lines).
nl_after_func_body = 3

nl_enum_brace       = remove        # "enum {" vs "enum \n {"
nl_union_brace      = remove        # "union {" vs "union \n {"
nl_struct_brace     = remove        # "struct {" vs "struct \n {"
nl_do_brace         = add           # "do {" vs "do \n {"
nl_if_brace         = add           # "if () {" vs "if () \n {"
nl_for_brace        = add           # "for () {" vs "for () \n {"
nl_else_brace       = add           # "else {" vs "else \n {"
nl_while_brace      = add           # "while () {" vs "while () \n {"
nl_switch_brace     = add           # "switch () {" vs "switch () \n {"
nl_func_var_def_blk = 1
nl_before_case      = 1
nl_fcall_brace      = add           # "foo() {" vs "foo()\n{"
nl_fdef_brace       = add           # "int foo() {" vs "int foo()\n{"
# nl_after_return    = TRUE
nl_brace_while      = add
nl_brace_else       = add
nl_squeeze_ifdef    = TRUE

# ------------------
# Blank line options
# ------------------

eat_blanks_before_close_brace = true
eat_blanks_after_open_brace   = true

# -------------------
# Positioning options
# -------------------

# The position of arithmetic operators in wrapped expressions.
#pos_arith = ignore   # ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force

# ----------------------
# Line splitting options
# ----------------------

# Try to limit code width to N columns.
code_width = 80

# Whether to fully split long function prototypes/calls at commas.
# The option ls_code_width has priority over the option ls_func_split_full.
ls_func_split_full = true

# Whether to split lines as close to code_width as possible and ignore some
# groupings.
# The option ls_code_width has priority over the option ls_func_split_full.
ls_code_width = true

# ----------------------------------------------------
# Code alignment options (not left column spaces/tabs)
# ----------------------------------------------------

# align assignments
# The span for aligning on '=' in assignments.
#
# 0: Don't align (default).
align_assign_span = 1

# This will align trailing \ on macro defines
align_nl_cont = true

# align_with_tabs               = FALSE                 # use tabs to align
# align_on_tabstop              = FALSE                 # align on tabstops
# align_enum_equ_span           = 4
# align_nl_cont                 = TRUE
# align_var_def_span            = 2
# align_var_def_inline          = TRUE
# align_var_def_star            = TRUE
# align_var_def_colon           = TRUE
# align_assign_span             = 1
# align_struct_init_span        = 3
# align_var_struct_span         = 3
# align_right_cmt_span          = 3
# align_pp_define_span          = 3
# align_pp_define_gap           = 4
# align_number_left             = TRUE
# align_typedef_span            = 5
# align_typedef_gap             = 3

# ----------------------------
# Comment modification options
# ----------------------------

# Whether to apply changes to multi-line comments, including cmt_width,
# keyword substitution and leading chars.
#
# Default: true
cmt_indent_multi = true

# Whether to put a star on subsequent comment lines.
cmt_star_cont = true

# Convert all tabs to spaces in comments.
cmt_convert_tab_to_spaces = true

# Try to wrap comments at N columns.
cmt_width = 80

# For multi-line comments with a '*' lead, remove leading spaces if the first
# and last lines of the comment are the same length.
#
# Default: true
cmt_multi_check_last = false

# Path to a file that contains text to insert at the beginning of a file if
# the file doesn't start with a C/C++ comment. If the inserted text contains
# '$(filename)', that will be replaced with the current file's name.
#cmt_insert_file_header          = ""         # string

# ---------------------------------------
# Code modifying options (non-whitespace)
# ---------------------------------------

# Add or remove unnecessary parenthesis on 'return' statement.
mod_paren_on_return = add

# # Add or remove braces on a single-line 'if' statement. Braces will not be
# # removed if the braced statement contains an 'else'.
mod_full_brace_if               = add     # ignore/add/remove/force

# Add or remove braces on a single-line 'for' statement.
mod_full_brace_for = add # "for () a--;" vs "for () { a--; }"

# mod_paren_on_return           = ignore        # "return 1;" vs "return (1);"
# mod_full_brace_if             = ignore        # "if (a) a--;" vs "if (a) { a--; }"
# mod_full_brace_for            = ignore        # "for () a--;" vs "for () { a--; }"
# mod_full_brace_do             = ignore        # "do a--; while ();" vs "do { a--; } while ();"
# mod_full_brace_while          = ignore        # "while (a) a--;" vs "while (a) { a--; }"

# --------------------
# Preprocessor options
# --------------------

# ---------------------
# Sort includes options
# ---------------------

# The regex for include category with priority 0.
include_category_0 = '^(<|"(gtest|gmock|isl|json)/)'         # string

# The regex for include category with priority 1.
include_category_1 = '.*'         # string

# The regex for include category with priority 2.
include_category_2 = ""         # string

# -------------------------
# Use or Do not Use options
# -------------------------

# -----------------------------------------------------
# Warn levels - 1: error, 2: warning (default), 3: note
# -----------------------------------------------------
